{"version":3,"file":"TickingFlameChartHelpers.js","sourceRoot":"","sources":["../../../../../../front_end/panels/media/TickingFlameChartHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport function formatMillisecondsToSeconds(ms: number, decimalPlaces: number): string {\n  const roundPower = Math.pow(10, 3 - decimalPlaces);\n  const denominatorPower = Math.pow(10, Math.max(0, decimalPlaces));\n  return `${Math.round(ms / roundPower) / denominatorPower} s`;\n}\n\n/**\n * Manage the bounding box properties for the ticking flame chart.\n * kept in a separate file for unit testing.\n */\nexport class Bounds {\n  #min: number;\n  #max: number;\n  #low: number;\n  #high: number;\n  private readonly maxRange: number;\n  private readonly minRange: number;\n  constructor(initialLow: number, initialHigh: number, maxRange: number, minRange: number) {\n    this.#min = initialLow;\n    this.#max = initialHigh;\n    this.#low = this.#min;\n    this.#high = this.#max;\n    this.maxRange = maxRange;\n    this.minRange = minRange;\n  }\n\n  get low(): number {\n    return this.#low;\n  }\n\n  get high(): number {\n    return this.#high;\n  }\n\n  get min(): number {\n    return this.#min;\n  }\n\n  get max(): number {\n    return this.#max;\n  }\n\n  get range(): number {\n    return this.#high - this.#low;\n  }\n\n  private reassertBounds(): void {\n    let needsAdjustment = true;\n    while (needsAdjustment) {\n      needsAdjustment = false;\n      if (this.range < this.minRange) {\n        needsAdjustment = true;\n        const delta = (this.minRange - this.range) / 2;\n        this.#high += delta;\n        this.#low -= delta;\n      }\n\n      if (this.#low < this.#min) {\n        needsAdjustment = true;\n        this.#low = this.#min;\n      }\n\n      if (this.#high > this.#max) {\n        needsAdjustment = true;\n        this.#high = this.#max;\n      }\n    }\n  }\n\n  /**\n   * zoom out |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomOut(amount: number, position: number): void {\n    const range = this.#high - this.#low;\n    const growSize = range * Math.pow(1.1, amount) - range;\n    const lowEnd = growSize * position;\n    const highEnd = growSize - lowEnd;\n    this.#low -= lowEnd;\n    this.#high += highEnd;\n    this.reassertBounds();\n  }\n\n  /**\n   * zoom in |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomIn(amount: number, position: number): void {\n    const range = this.#high - this.#low;\n    if (this.range <= this.minRange) {\n      return;\n    }\n\n    const shrinkSize = range - range / Math.pow(1.1, amount);\n    const lowEnd = shrinkSize * position;\n    const highEnd = shrinkSize - lowEnd;\n    this.#low += lowEnd;\n    this.#high -= highEnd;\n    this.reassertBounds();\n  }\n\n  /**\n   * Add Xms to the max value, and scroll the timeline forward if the end is in sight.\n   */\n  addMax(amount: number): void {\n    const range = this.#high - this.#low;\n    const isAtHighEnd = this.#high === this.#max;\n    const isZoomedOut = this.#low === this.#min || range >= this.maxRange;\n\n    this.#max += amount;\n    if (isAtHighEnd && isZoomedOut) {\n      this.#high = this.#max;\n    }\n    this.reassertBounds();\n  }\n\n  /**\n   * Attempt to push the maximum time up to |time| ms.\n   */\n  pushMaxAtLeastTo(time: number): boolean {\n    if (this.#max < time) {\n      this.addMax(time - this.#max);\n      return true;\n    }\n    return false;\n  }\n}\n"]}