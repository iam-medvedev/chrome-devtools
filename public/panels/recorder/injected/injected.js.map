{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/recorder/injected/Logger.ts", "../../../../../../../front_end/panels/recorder/injected/MonotonicArray.ts", "../../../../../../../front_end/panels/recorder/injected/selectors/ARIASelector.ts", "../../../../../../../front_end/panels/recorder/injected/selectors/Selector.ts", "../../../../../../../front_end/panels/recorder/injected/selectors/CSSSelector.ts", "../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/PierceQuerySelector.js", "../../../../../../../front_end/panels/recorder/injected/selectors/PierceSelector.ts", "../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextContent.js", "../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextQuerySelector.js", "../../../../../../../front_end/panels/recorder/injected/selectors/TextSelector.ts", "../../../../../../../front_end/panels/recorder/injected/selectors/XPath.ts", "../../../../../../../front_end/panels/recorder/injected/SelectorComputer.ts", "../../../../../../../front_end/panels/recorder/injected/util.ts", "../../../../../../../front_end/panels/recorder/injected/RecordingClient.ts", "../../../../../../../front_end/panels/recorder/injected/SelectorPicker.ts", "injected.prebundle.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst noop = () => void 0;\n\nexport class Logger {\n  #log: (...args: unknown[]) => void;\n  #time: (label: string) => void;\n  #timeEnd: (label: string) => void;\n\n  constructor(level?: 'silent'|'debug') {\n    switch (level) {\n      case 'silent':\n        this.#log = noop;\n        this.#time = noop;\n        this.#timeEnd = noop;\n        break;\n      default:\n        // eslint-disable-next-line no-console\n        this.#log = console.log;\n        this.#time = console.time;\n        this.#timeEnd = console.timeEnd;\n        break;\n    }\n  }\n\n  log(...args: unknown[]): void {\n    this.#log(...args);\n  }\n\n  timed<T>(label: string, action: () => T): T {\n    this.#time(label);\n    const value = action();\n    this.#timeEnd(label);\n    return value;\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport class MonotonicArray<T extends object> {\n  #values = new WeakMap<T, number>();\n  #nextId = 1;\n\n  getOrInsert = (node: T): number => {\n    const value = this.#values.get(node);\n    if (value !== undefined) {\n      return value;\n    }\n    this.#values.set(node, this.#nextId);\n    this.#nextId++;\n    return this.#nextId - 1;\n  };\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {DeepSelector, Selector} from './Selector.js';\n\nexport interface AccessibilityBindings {\n  getAccessibleName(node: Node): string;\n  getAccessibleRole(node: Node): string;\n}\n\nclass ARIASelectorComputer {\n  #bindings: AccessibilityBindings;\n\n  constructor(bindings: AccessibilityBindings) {\n    this.#bindings = bindings;\n  }\n\n  // Takes a path consisting of element names and roles and makes sure that\n  // every element resolves to a single result. If it does, the selector is added\n  // to the chain of selectors.\n  #computeUniqueARIASelectorForElements = (\n      elements: Array<{name: string, role: string}>,\n      queryByRoleOnly: boolean,\n      ): DeepSelector|undefined => {\n    const selectors: string[] = [];\n    let parent: Element|Document = document;\n    for (const element of elements) {\n      let result = this.#queryA11yTreeOneByName(parent, element.name);\n      if (result) {\n        selectors.push(element.name);\n        parent = result;\n        continue;\n      }\n      if (queryByRoleOnly) {\n        result = this.#queryA11yTreeOneByRole(parent, element.role);\n        if (result) {\n          selectors.push(`[role=\"${element.role}\"]`);\n          parent = result;\n          continue;\n        }\n      }\n      result = this.#queryA11yTreeOneByNameAndRole(\n          parent,\n          element.name,\n          element.role,\n      );\n      if (result) {\n        selectors.push(`${element.name}[role=\"${element.role}\"]`);\n        parent = result;\n        continue;\n      }\n      return;\n    }\n    return selectors;\n  };\n\n  #queryA11yTreeOneByName = (\n      parent: Element|Document,\n      name?: string,\n      ): Element|null => {\n    if (!name) {\n      return null;\n    }\n    const maxResults = 2;\n    const result = this.#queryA11yTree(parent, name, undefined, maxResults);\n    if (result.length !== 1) {\n      return null;\n    }\n    return result[0];\n  };\n\n  #queryA11yTreeOneByRole = (\n      parent: Element|Document,\n      role?: string,\n      ): Element|null => {\n    if (!role) {\n      return null;\n    }\n    const maxResults = 2;\n    const result = this.#queryA11yTree(parent, undefined, role, maxResults);\n    if (result.length !== 1) {\n      return null;\n    }\n    return result[0];\n  };\n\n  #queryA11yTreeOneByNameAndRole = (\n      parent: Element|Document,\n      name?: string,\n      role?: string,\n      ): Element|null => {\n    if (!role || !name) {\n      return null;\n    }\n    const maxResults = 2;\n    const result = this.#queryA11yTree(parent, name, role, maxResults);\n    if (result.length !== 1) {\n      return null;\n    }\n    return result[0];\n  };\n\n  // Queries the DOM tree for elements with matching accessibility name and role.\n  // It attempts to mimic https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-queryAXTree.\n  #queryA11yTree = (\n      parent: Element|Document,\n      name?: string,\n      role?: string,\n      maxResults = 0,\n      ): Element[] => {\n    const result: Element[] = [];\n    if (!name && !role) {\n      throw new Error('Both role and name are empty');\n    }\n    const shouldMatchName = Boolean(name);\n    const shouldMatchRole = Boolean(role);\n    const collect = (root: Element|ShadowRoot): void => {\n      const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n      do {\n        const currentNode = iter.currentNode as HTMLElement;\n        if (currentNode.shadowRoot) {\n          collect(currentNode.shadowRoot);\n        }\n        if (currentNode instanceof ShadowRoot) {\n          continue;\n        }\n        if (shouldMatchName && this.#bindings.getAccessibleName(currentNode) !== name) {\n          continue;\n        }\n        if (shouldMatchRole && this.#bindings.getAccessibleRole(currentNode) !== role) {\n          continue;\n        }\n        result.push(currentNode);\n        if (maxResults && result.length >= maxResults) {\n          return;\n        }\n      } while (iter.nextNode());\n    };\n    collect(parent instanceof Document ? document.documentElement : parent);\n    return result;\n  };\n\n  compute = (node: Node): Selector|undefined => {\n    let selector: Selector|undefined;\n    let current: Node|null = node;\n    const elements: Array<{name: string, role: string}> = [];\n    while (current) {\n      const role = this.#bindings.getAccessibleRole(current);\n      const name = this.#bindings.getAccessibleName(current);\n      if (!role && !name) {\n        if (current === node) {\n          break;\n        }\n      } else {\n        elements.unshift({name, role});\n        selector = this.#computeUniqueARIASelectorForElements(\n            elements,\n            current !== node,\n        );\n        if (selector) {\n          break;\n        }\n        if (current !== node) {\n          elements.shift();\n        }\n      }\n      current = current.parentNode;\n      if (current instanceof ShadowRoot) {\n        current = current.host;\n      }\n    }\n    return selector;\n  };\n}\n\n/**\n * Computes the ARIA selector for a node.\n *\n * @internal\n * @param node The node to compute.\n * @returns The computed CSS selector.\n *\n */\nexport const computeARIASelector = (\n    node: Node,\n    bindings: AccessibilityBindings,\n    ): Selector|undefined => {\n  return new ARIASelectorComputer(bindings).compute(node);\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Represents a selector that pierces shadow roots. Each selector before the\n * last one is matches a shadow root for which we pierce through.\n */\nexport type DeepSelector = string[];\n\n/**\n * Represents a selector.\n */\nexport type Selector = string|DeepSelector;\n\nexport class SelectorPart {\n  value: string;\n  optimized: boolean;\n  constructor(value: string, optimized: boolean) {\n    this.value = value;\n    this.optimized = optimized || false;\n  }\n\n  toString(): string {\n    return this.value;\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {type Selector, SelectorPart} from './Selector.js';\n\nexport interface QueryableNode extends Node {\n  querySelectorAll(selectors: string): NodeListOf<Element>;\n}\n\nconst idSelector = (id: string): string => {\n  return `#${CSS.escape(id)}`;\n};\n\nconst attributeSelector = (name: string, value: string): string => {\n  return `[${name}='${CSS.escape(value)}']`;\n};\n\nconst classSelector = (selector: string, className: string): string => {\n  return `${selector}.${CSS.escape(className)}`;\n};\n\nconst nthTypeSelector = (selector: string, index: number): string => {\n  return `${selector}:nth-of-type(${index + 1})`;\n};\n\nconst typeSelector = (selector: string, type: string): string => {\n  return `${selector}${attributeSelector('type', type)}`;\n};\n\nconst hasUniqueId = (node: Element): boolean => {\n  return (Boolean(node.id) && (node.getRootNode() as QueryableNode).querySelectorAll(idSelector(node.id)).length === 1);\n};\n\nconst isUniqueAmongTagNames = (\n    node: Element,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child.tagName === node.tagName) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isUniqueAmongInputTypes = (\n    node: HTMLInputElement,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child instanceof HTMLInputElement && child.type === node.type) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getUniqueClassName = (\n    node: Element,\n    children: Iterable<Element>,\n    ): string|undefined => {\n  const classNames = new Set(node.classList);\n  for (const child of children) {\n    if (child !== node) {\n      for (const className of child.classList) {\n        classNames.delete(className);\n      }\n      if (classNames.size === 0) {\n        break;\n      }\n    }\n  }\n  if (classNames.size > 0) {\n    return classNames.values().next().value;\n  }\n  return undefined;\n};\n\nconst getTypeIndex = (node: Element, children: Iterable<Element>): number => {\n  let nthTypeIndex = 0;\n  for (const child of children) {\n    if (child === node) {\n      return nthTypeIndex;\n    }\n    if (child.tagName === node.tagName) {\n      ++nthTypeIndex;\n    }\n  }\n  throw new Error('Node not found in children');\n};\n\nexport const getSelectorPart = (\n    node: Node,\n    attributes: string[] = [],\n    ): SelectorPart|undefined => {\n  if (!(node instanceof Element)) {\n    return;\n  }\n\n  // Declared attributes have the greatest priority.\n  for (const attribute of attributes) {\n    const value = node.getAttribute(attribute);\n    if (value) {\n      return new SelectorPart(attributeSelector(attribute, value), true);\n    }\n  }\n\n  // IDs are supposed to be globally unique, so this has second priority.\n  if (hasUniqueId(node)) {\n    return new SelectorPart(idSelector(node.id), true);\n  }\n\n  // All selectors will be prefixed with the tag name starting here.\n  const selector = node.tagName.toLowerCase();\n\n  // These can only appear once in the entire document, so handle this fast.\n  switch (node.tagName) {\n    case 'BODY':\n    case 'HEAD':\n    case 'HTML':\n      return new SelectorPart(selector, true);\n  }\n\n  const parent = node.parentNode;\n  // If the node has no parent, then the node must be detached. We handle this\n  // gracefully.\n  if (!parent) {\n    return new SelectorPart(selector, true);\n  }\n\n  const children = parent.children;\n\n  // Determine if the child has a unique node name among all children.\n  if (isUniqueAmongTagNames(node, children)) {\n    return new SelectorPart(selector, true);\n  }\n\n  // If it's an input, check uniqueness among types.\n  if (node instanceof HTMLInputElement && isUniqueAmongInputTypes(node, children)) {\n    return new SelectorPart(typeSelector(selector, node.type), true);\n  }\n\n  // Determine if the child has a unique class name.\n  const className = getUniqueClassName(node, children);\n  if (className !== undefined) {\n    return new SelectorPart(classSelector(selector, className), true);\n  }\n\n  // Last resort. Just use the nth-type index. A priori, this will always exists.\n  return new SelectorPart(\n      nthTypeSelector(selector, getTypeIndex(node, children)),\n      false,\n  );\n};\n\n/**\n * This interface represents operations on an ordered range of indices of type\n * `I`. Implementations must have the following assumptions:\n *\n *  1. `self(self(i)) = self(i)`, i.e. `self` must be idempotent.\n *  2. `inc(i) > i`.\n *  3. `j >= i` implies `gte(valueOf(j), i)`, i.e. `gte` preserves the order of\n *     the range.\n *\n */\nexport interface RangeOps<I, V> {\n  // Returns a suitable version of an index (e.g. ShadowRoot.host instead of\n  // ShadowRoot).\n  self?(index: I): I;\n\n  // Increments the given index by 1.\n  inc(index: I): I;\n\n  // Gets the value at the given index.\n  valueOf(index: I): V;\n\n  // Must preserve `j >= i` if `value === valueOf(j)`.\n  gte(value: V, index: I): boolean;\n}\n\n/**\n * The goal of this function is to find the smallest index `i` that makes\n * `gte(valueOf(i), j)` true for all `j` in `[min, max)`. We do not use binary\n * search because\n *\n *  1. We expect the min-max to be concentrated towards the minimum (< 10\n *     iterations).\n *  2. We expect `valueOf` to be `O(n)`, so together with (1), the average will\n *     be around `O(n)` which is significantly faster than binary search in this\n *     case.\n */\nexport const findMinMax = <I, V>(\n    [min, max]: [I, I],\n    fns: RangeOps<I, V>,\n    ): V => {\n  fns.self ??= (i): I => i;\n\n  let index = fns.inc(min);\n  let value: V;\n  let isMax: boolean;\n  do {\n    value = fns.valueOf(min);\n    isMax = true;\n    while (index !== max) {\n      min = fns.self(index);\n      index = fns.inc(min);\n      if (!fns.gte(value, index)) {\n        isMax = false;\n        break;\n      }\n    }\n  } while (!isMax);\n  return value;\n};\n\nexport class SelectorRangeOps implements RangeOps<QueryableNode, string> {\n  // Close chains (using `>`) are stored in inner arrays.\n  #buffer: SelectorPart[][] = [[]];\n  #attributes: string[];\n  #depth = 0;\n\n  constructor(attributes: string[] = []) {\n    this.#attributes = attributes;\n  }\n\n  inc(node: Node): QueryableNode {\n    return node.parentNode ?? (node.getRootNode() as QueryableNode);\n  }\n  valueOf(node: Node): string {\n    const part = getSelectorPart(node, this.#attributes);\n    if (!part) {\n      throw new Error('Node is not an element');\n    }\n    if (this.#depth > 1) {\n      // Implies this selector is for a distant ancestor.\n      this.#buffer.unshift([part]);\n    } else {\n      // Implies this selector is for a parent.\n      this.#buffer[0].unshift(part);\n    }\n    this.#depth = 0;\n    return this.#buffer.map(parts => parts.join(' > ')).join(' ');\n  }\n  gte(selector: string, node: QueryableNode): boolean {\n    ++this.#depth;\n    return node.querySelectorAll(selector).length === 1;\n  }\n}\n\n/**\n * Computes the CSS selector for a node.\n *\n * @internal\n * @param node The node to compute.\n * @returns The computed CSS selector.\n *\n */\nexport const computeCSSSelector = (\n    node: Node,\n    attributes?: string[],\n    ): Selector|undefined => {\n  const selectors = [];\n\n  // We want to find the minimal selector that is unique within a document. We\n  // are slightly restricted since selectors cannot cross ShadowRoot borders, so\n  // the actual goal is to find the minimal selector that is unique within a\n  // root node. We then need to repeat this for each shadow root.\n  try {\n    let root: Document|ShadowRoot;\n    while (node instanceof Element) {\n      root = node.getRootNode() as Document | ShadowRoot;\n      selectors.unshift(\n          findMinMax(\n              [node as QueryableNode, root],\n              new SelectorRangeOps(attributes),\n              ),\n      );\n      node = root instanceof ShadowRoot ? root.host : root;\n    }\n  } catch {\n    return undefined;\n  }\n\n  return selectors;\n};\n\nexport const queryCSSSelectorAll = (selectors: Selector): Element[] => {\n  if (typeof selectors === 'string') {\n    selectors = [selectors];\n  } else if (selectors.length === 0) {\n    return [];\n  }\n  let lists: Array<NodeListOf<Element>> = [\n    [document.documentElement] as unknown as NodeListOf<Element>,\n  ];\n  do {\n    const selector = selectors.shift() as string;\n    const roots: Array<NodeListOf<Element>> = [];\n    for (const nodes of lists) {\n      for (const node of nodes) {\n        const list = (node.shadowRoot ?? node).querySelectorAll(selector);\n        if (list.length > 0) {\n          roots.push(list);\n        }\n      }\n    }\n    lists = roots;\n  } while (selectors.length > 0 && lists.length > 0);\n  return lists.flatMap(list => [...list]);\n};\n", "/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @internal\n */\nexport const pierceQuerySelector = (root, selector) => {\n    let found = null;\n    const search = (root) => {\n        const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n        do {\n            const currentNode = iter.currentNode;\n            if (currentNode.shadowRoot) {\n                search(currentNode.shadowRoot);\n            }\n            if (currentNode instanceof ShadowRoot) {\n                continue;\n            }\n            if (currentNode !== root && !found && currentNode.matches(selector)) {\n                found = currentNode;\n            }\n        } while (!found && iter.nextNode());\n    };\n    if (root instanceof Document) {\n        root = root.documentElement;\n    }\n    search(root);\n    return found;\n};\n/**\n * @internal\n */\nexport const pierceQuerySelectorAll = (element, selector) => {\n    const result = [];\n    const collect = (root) => {\n        const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n        do {\n            const currentNode = iter.currentNode;\n            if (currentNode.shadowRoot) {\n                collect(currentNode.shadowRoot);\n            }\n            if (currentNode instanceof ShadowRoot) {\n                continue;\n            }\n            if (currentNode !== root && currentNode.matches(selector)) {\n                result.push(currentNode);\n            }\n        } while (iter.nextNode());\n    };\n    if (element instanceof Document) {\n        element = element.documentElement;\n    }\n    collect(element);\n    return result;\n};\n//# sourceMappingURL=PierceQuerySelector.js.map", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  pierceQuerySelectorAll,\n} from '../../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/PierceQuerySelector.js';\n\nimport {\n  findMinMax,\n  type QueryableNode,\n  type RangeOps,\n  SelectorRangeOps,\n} from './CSSSelector.js';\nimport type {Selector} from './Selector.js';\n\nclass PierceSelectorRangeOpts implements RangeOps<QueryableNode, string[][]> {\n  #selector: string[][] = [[]];\n  #attributes: string[];\n  #depth = 0;\n\n  constructor(attributes: string[] = []) {\n    this.#attributes = attributes;\n  }\n\n  inc(node: Node): Document|ShadowRoot {\n    return node.getRootNode() as Document | ShadowRoot;\n  }\n  self(node: Document|ShadowRoot): QueryableNode {\n    return node instanceof ShadowRoot ? node.host : node;\n  }\n  valueOf(node: QueryableNode): string[][] {\n    const selector = findMinMax(\n        [node, node.getRootNode()],\n        new SelectorRangeOps(this.#attributes),\n    );\n    if (this.#depth > 1) {\n      this.#selector.unshift([selector]);\n    } else {\n      this.#selector[0].unshift(selector);\n    }\n    this.#depth = 0;\n    return this.#selector;\n  }\n  gte(selector: string[][], node: Node): boolean {\n    ++this.#depth;\n    // Note we use some insider logic here. `valueOf(node)` will always\n    // correspond to `selector.flat().slice(1)`, so it suffices to check\n    // uniqueness for `selector.flat()[0]`.\n    return pierceQuerySelectorAll(node, selector[0][0]).length === 1;\n  }\n}\n\n/**\n * Computes the pierce CSS selector for a node.\n *\n * @internal\n * @param node The node to compute.\n * @returns The computed pierce CSS selector.\n *\n */\nexport const computePierceSelector = (\n    node: Node,\n    attributes?: string[],\n    ): string[]|undefined => {\n  try {\n    const ops = new PierceSelectorRangeOpts(attributes);\n    return findMinMax([node, document], ops).flat();\n  } catch {\n    return undefined;\n  }\n};\n\nexport const queryPierceSelectorAll = (selectors: Selector): Element[] => {\n  if (typeof selectors === 'string') {\n    selectors = [selectors];\n  } else if (selectors.length === 0) {\n    return [];\n  }\n  let lists: Element[][] = [[document.documentElement]];\n  do {\n    const selector = selectors.shift() as string;\n    const roots: Element[][] = [];\n    for (const nodes of lists) {\n      for (const node of nodes) {\n        const list = pierceQuerySelectorAll(node.shadowRoot ?? node, selector);\n        if (list.length > 0) {\n          roots.push(list);\n        }\n      }\n    }\n    lists = roots;\n  } while (selectors.length > 0 && lists.length > 0);\n  return lists.flatMap(list => [...list]);\n};\n", "/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nconst TRIVIAL_VALUE_INPUT_TYPES = new Set(['checkbox', 'image', 'radio']);\n/**\n * Determines if the node has a non-trivial value property.\n *\n * @internal\n */\nconst isNonTrivialValueNode = (node) => {\n    if (node instanceof HTMLSelectElement) {\n        return true;\n    }\n    if (node instanceof HTMLTextAreaElement) {\n        return true;\n    }\n    if (node instanceof HTMLInputElement &&\n        !TRIVIAL_VALUE_INPUT_TYPES.has(node.type)) {\n        return true;\n    }\n    return false;\n};\nconst UNSUITABLE_NODE_NAMES = new Set(['SCRIPT', 'STYLE']);\n/**\n * Determines whether a given node is suitable for text matching.\n *\n * @internal\n */\nexport const isSuitableNodeForTextMatching = (node) => {\n    return (!UNSUITABLE_NODE_NAMES.has(node.nodeName) && !document.head?.contains(node));\n};\n/**\n * Maps {@link Node}s to their computed {@link TextContent}.\n */\nconst textContentCache = new WeakMap();\nconst eraseFromCache = (node) => {\n    while (node) {\n        textContentCache.delete(node);\n        if (node instanceof ShadowRoot) {\n            node = node.host;\n        }\n        else {\n            node = node.parentNode;\n        }\n    }\n};\n/**\n * Erases the cache when the tree has mutated text.\n */\nconst observedNodes = new WeakSet();\nconst textChangeObserver = new MutationObserver(mutations => {\n    for (const mutation of mutations) {\n        eraseFromCache(mutation.target);\n    }\n});\n/**\n * Builds the text content of a node using some custom logic.\n *\n * @remarks\n * The primary reason this function exists is due to {@link ShadowRoot}s not having\n * text content.\n *\n * @internal\n */\nexport const createTextContent = (root) => {\n    let value = textContentCache.get(root);\n    if (value) {\n        return value;\n    }\n    value = { full: '', immediate: [] };\n    if (!isSuitableNodeForTextMatching(root)) {\n        return value;\n    }\n    let currentImmediate = '';\n    if (isNonTrivialValueNode(root)) {\n        value.full = root.value;\n        value.immediate.push(root.value);\n        root.addEventListener('input', event => {\n            eraseFromCache(event.target);\n        }, { once: true, capture: true });\n    }\n    else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                value.full += child.nodeValue ?? '';\n                currentImmediate += child.nodeValue ?? '';\n                continue;\n            }\n            if (currentImmediate) {\n                value.immediate.push(currentImmediate);\n            }\n            currentImmediate = '';\n            if (child.nodeType === Node.ELEMENT_NODE) {\n                value.full += createTextContent(child).full;\n            }\n        }\n        if (currentImmediate) {\n            value.immediate.push(currentImmediate);\n        }\n        if (root instanceof Element && root.shadowRoot) {\n            value.full += createTextContent(root.shadowRoot).full;\n        }\n        if (!observedNodes.has(root)) {\n            textChangeObserver.observe(root, {\n                childList: true,\n                characterData: true,\n                subtree: true,\n            });\n            observedNodes.add(root);\n        }\n    }\n    textContentCache.set(root, value);\n    return value;\n};\n//# sourceMappingURL=TextContent.js.map", "/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createTextContent, isSuitableNodeForTextMatching, } from './TextContent.js';\n/**\n * Queries the given node for all nodes matching the given text selector.\n *\n * @internal\n */\nexport const textQuerySelectorAll = function* (root, selector) {\n    let yielded = false;\n    for (const node of root.childNodes) {\n        if (node instanceof Element && isSuitableNodeForTextMatching(node)) {\n            let matches;\n            if (!node.shadowRoot) {\n                matches = textQuerySelectorAll(node, selector);\n            }\n            else {\n                matches = textQuerySelectorAll(node.shadowRoot, selector);\n            }\n            for (const match of matches) {\n                yield match;\n                yielded = true;\n            }\n        }\n    }\n    if (yielded) {\n        return;\n    }\n    if (root instanceof Element && isSuitableNodeForTextMatching(root)) {\n        const textContent = createTextContent(root);\n        if (textContent.full.includes(selector)) {\n            yield root;\n        }\n    }\n};\n//# sourceMappingURL=TextQuerySelector.js.map", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  createTextContent,\n} from '../../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextContent.js';\nimport {\n  textQuerySelectorAll,\n} from '../../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextQuerySelector.js';\n\nimport type {Selector} from './Selector.js';\n\nconst MINIMUM_TEXT_LENGTH = 12;\nconst MAXIMUM_TEXT_LENGTH = 64;\n\nconst collect = <T>(iter: Iterable<T>, max = Infinity): T[] => {\n  const results = [];\n  for (const value of iter) {\n    if (max <= 0) {\n      break;\n    }\n    results.push(value);\n    --max;\n  }\n  return results;\n};\n\n/**\n * Computes the text selector for a node.\n *\n * @internal\n * @param node The node to compute.\n * @returns The computed text selector.\n *\n */\nexport const computeTextSelector = (node: Node): Selector|undefined => {\n  const content = createTextContent(node).full.trim();\n  if (!content) {\n    return;\n  }\n\n  // If it's short, just return it.\n  if (content.length <= MINIMUM_TEXT_LENGTH) {\n    const elements = collect(textQuerySelectorAll(document, content), 2);\n    if (elements.length !== 1 || elements[0] !== node) {\n      return;\n    }\n    return [content];\n  }\n\n  // If it's too long, it's probably irrelevant.\n  if (content.length > MAXIMUM_TEXT_LENGTH) {\n    return;\n  }\n\n  // We do a binary search for the optimal length of a substring starting at 0.\n  let left = MINIMUM_TEXT_LENGTH;\n  let right = content.length;\n  while (left <= right) {\n    const center = left + ((right - left) >> 2);\n    const elements = collect(\n        textQuerySelectorAll(document, content.slice(0, center)),\n        2,\n    );\n    if (elements.length !== 1 || elements[0] !== node) {\n      left = center + 1;\n    } else {\n      right = center - 1;\n    }\n  }\n\n  // Never matched.\n  if (right === content.length) {\n    return;\n  }\n\n  // We attempt to round the word in the event we are in the middle of a word.\n  const length = right + 1;\n  const remainder = content.slice(length, length + MAXIMUM_TEXT_LENGTH);\n  return [content.slice(0, length + remainder.search(/ |$/))];\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {SelectorPart, type Selector} from './Selector.js';\n\nconst attributeSelector = (name: string, value: string): string => {\n  return `//*[@${name}=${JSON.stringify(value)}]`;\n};\n\nconst getSelectorPart = (\n    node: Node,\n    optimized?: boolean,\n    attributes: string[] = [],\n    ): SelectorPart|undefined => {\n  let value: string;\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      if (!(node instanceof Element)) {\n        return;\n      }\n      if (optimized) {\n        for (const attribute of attributes) {\n          value = node.getAttribute(attribute) ?? '';\n          if (value) {\n            return new SelectorPart(attributeSelector(attribute, value), true);\n          }\n        }\n      }\n      if (node.id) {\n        return new SelectorPart(attributeSelector('id', node.id), true);\n      }\n      value = node.localName;\n      break;\n    case Node.ATTRIBUTE_NODE:\n      value = '@' + node.nodeName;\n      break;\n    case Node.TEXT_NODE:\n    case Node.CDATA_SECTION_NODE:\n      value = 'text()';\n      break;\n    case Node.PROCESSING_INSTRUCTION_NODE:\n      value = 'processing-instruction()';\n      break;\n    case Node.COMMENT_NODE:\n      value = 'comment()';\n      break;\n    case Node.DOCUMENT_NODE:\n      value = '';\n      break;\n    default:\n      value = '';\n      break;\n  }\n\n  const index = getXPathIndexInParent(node);\n  if (index > 0) {\n    value += `[${index}]`;\n  }\n\n  return new SelectorPart(value, node.nodeType === Node.DOCUMENT_NODE);\n};\n\nconst getXPathIndexInParent = (node: Node): number => {\n  /**\n   * @returns -1 in case of error, 0 if no siblings matching the same expression,\n   * XPath index among the same expression-matching sibling nodes otherwise.\n   */\n  function areNodesSimilar(left: Node, right: Node): boolean {\n    if (left === right) {\n      return true;\n    }\n\n    if (left instanceof Element && right instanceof Element) {\n      return left.localName === right.localName;\n    }\n\n    if (left.nodeType === right.nodeType) {\n      return true;\n    }\n\n    // XPath treats CDATA as text nodes.\n    const leftType = left.nodeType === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : left.nodeType;\n    const rightType = right.nodeType === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : right.nodeType;\n    return leftType === rightType;\n  }\n\n  const children = node.parentNode ? node.parentNode.children : null;\n  if (!children) {\n    return 0;\n  }\n  let hasSameNamedElements;\n  for (let i = 0; i < children.length; ++i) {\n    if (areNodesSimilar(node, children[i]) && children[i] !== node) {\n      hasSameNamedElements = true;\n      break;\n    }\n  }\n  if (!hasSameNamedElements) {\n    return 0;\n  }\n  let ownIndex = 1;  // XPath indices start with 1.\n  for (let i = 0; i < children.length; ++i) {\n    if (areNodesSimilar(node, children[i])) {\n      if (children[i] === node) {\n        return ownIndex;\n      }\n      ++ownIndex;\n    }\n  }\n\n  throw new Error(\n      'This is impossible; a child must be the child of the parent',\n  );\n};\n\n/**\n * Computes the XPath for a node.\n *\n * @internal\n * @param node The node to compute.\n * @param optimized Whether to optimize the XPath for the node. Does not imply\n * the XPath is shorter; implies the XPath will be highly-scoped to the node.\n * @returns The computed XPath.\n *\n */\nexport const computeXPath = (\n    node: Node,\n    optimized?: boolean,\n    attributes?: string[],\n    ): Selector|undefined => {\n  if (node.nodeType === Node.DOCUMENT_NODE) {\n    return '/';\n  }\n\n  const selectors = [];\n\n  const buffer = [];\n  let contextNode: Node|null = node;\n  while (contextNode !== document && contextNode) {\n    const part = getSelectorPart(contextNode, optimized, attributes);\n    if (!part) {\n      return;\n    }\n    buffer.unshift(part);\n    if (part.optimized) {\n      contextNode = contextNode.getRootNode();\n    } else {\n      contextNode = contextNode.parentNode;\n    }\n    if (contextNode instanceof ShadowRoot) {\n      selectors.unshift((buffer[0].optimized ? '' : '/') + buffer.join('/'));\n      buffer.splice(0, buffer.length);\n      contextNode = contextNode.host;\n    }\n  }\n\n  if (buffer.length) {\n    selectors.unshift((buffer[0].optimized ? '' : '/') + buffer.join('/'));\n  }\n\n  if (!selectors.length || selectors.length > 1) {\n    // XPath evaluation does not work on shadowRoot.\n    return;\n  }\n\n  return selectors;\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {SelectorType} from '../../../third_party/puppeteer-replay/puppeteer-replay.js';\n\nimport type {Logger} from './Logger.js';\nimport {MonotonicArray} from './MonotonicArray.js';\nimport {\n  type AccessibilityBindings,\n  computeARIASelector,\n} from './selectors/ARIASelector.js';\nimport {computeCSSSelector} from './selectors/CSSSelector.js';\nimport {computePierceSelector} from './selectors/PierceSelector.js';\nimport type {Selector} from './selectors/Selector.js';\nimport {computeTextSelector} from './selectors/TextSelector.js';\nimport {computeXPath} from './selectors/XPath.js';\n\nconst prefixSelector = (\n    selector: Selector|undefined,\n    prefix: string,\n    ): Selector|undefined => {\n  if (selector === undefined) {\n    return;\n  }\n  if (typeof selector === 'string') {\n    return `${prefix}/${selector}`;\n  }\n  return selector.map(selector => `${prefix}/${selector}`);\n};\n\nexport class SelectorComputer {\n  #customAttributes = [\n    // Most common attributes first.\n    'data-testid',\n    'data-test',\n    'data-qa',\n    'data-cy',\n    'data-test-id',\n    'data-qa-id',\n    'data-testing',\n  ];\n\n  #bindings: AccessibilityBindings;\n  #logger: Logger;\n  #nodes = new MonotonicArray<Node>();\n  #selectorFunctionsInOrder: Array<(node: Node) => Selector | undefined>;\n\n  constructor(\n      bindings: AccessibilityBindings,\n      logger: Logger,\n      customAttribute = '',\n      selectorTypesToRecord?: SelectorType[],\n  ) {\n    this.#bindings = bindings;\n    this.#logger = logger;\n\n    let selectorOrder = [\n      'aria',\n      'css',\n      'xpath',\n      'pierce',\n      'text',\n    ] as SelectorType[];\n    if (customAttribute) {\n      // Custom DOM attributes indicate a preference for CSS/XPath selectors.\n      this.#customAttributes.unshift(customAttribute);\n      selectorOrder = [\n        'css',\n        'xpath',\n        'pierce',\n        'aria',\n        'text',\n      ] as SelectorType[];\n    }\n\n    this.#selectorFunctionsInOrder = selectorOrder\n                                         .filter(type => {\n                                           if (selectorTypesToRecord) {\n                                             return selectorTypesToRecord.includes(type);\n                                           }\n                                           return true;\n                                         })\n                                         .map(selectorType => {\n                                           switch (selectorType) {\n                                             case 'css':\n                                               return this.getCSSSelector.bind(this);\n                                             case 'xpath':\n                                               return this.getXPathSelector.bind(this);\n                                             case 'pierce':\n                                               return this.getPierceSelector.bind(this);\n                                             case 'aria':\n                                               return this.getARIASelector.bind(this);\n                                             case 'text':\n                                               return this.getTextSelector.bind(this);\n                                             default:\n                                               throw new Error('Unknown selector type: ' + selectorType);\n                                           }\n                                         });\n  }\n\n  getSelectors(node: Node): Selector[] {\n    const selectors: Selector[] = [];\n    for (const getSelector of this.#selectorFunctionsInOrder) {\n      const selector = getSelector(node);\n      if (selector) {\n        selectors.push(selector);\n      }\n    }\n    return selectors;\n  }\n\n  getCSSSelector(node: Node): Selector|undefined {\n    return this.#logger.timed(`getCSSSelector: ${this.#nodes.getOrInsert(node)} ${node.nodeName}`, () => {\n      return computeCSSSelector(node, this.#customAttributes);\n    });\n  }\n\n  getTextSelector(node: Node): Selector|undefined {\n    return this.#logger.timed(`getTextSelector: ${this.#nodes.getOrInsert(node)} ${node.nodeName}`, () => {\n      return prefixSelector(computeTextSelector(node), 'text');\n    });\n  }\n\n  getXPathSelector(node: Node): Selector|undefined {\n    return this.#logger.timed(`getXPathSelector: ${this.#nodes.getOrInsert(node)} ${node.nodeName}`, () => {\n      return prefixSelector(\n          computeXPath(node, true, this.#customAttributes),\n          'xpath',\n      );\n    });\n  }\n\n  getPierceSelector(node: Node): Selector|undefined {\n    return this.#logger.timed(`getPierceSelector: ${this.#nodes.getOrInsert(node)} ${node.nodeName}`, () => {\n      return prefixSelector(\n          computePierceSelector(node, this.#customAttributes),\n          'pierce',\n      );\n    });\n  }\n\n  getARIASelector(node: Node): Selector|undefined {\n    return this.#logger.timed(`getARIASelector: ${this.#nodes.getOrInsert(node)} ${node.nodeName}`, () => {\n      return prefixSelector(computeARIASelector(node, this.#bindings), 'aria');\n    });\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Schema} from '../../../third_party/puppeteer-replay/puppeteer-replay.js';\n\nexport function assert<Condition>(condition: Condition): asserts condition {\n  if (!condition) {\n    throw new Error('Assertion failed!');\n  }\n}\n\nexport const haultImmediateEvent = (event: Event): void => {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n};\n\nexport const getMouseEventOffsets = (event: MouseEvent, target: Element): {offsetX: number, offsetY: number} => {\n  const rect = target.getBoundingClientRect();\n  return {offsetX: event.clientX - rect.x, offsetY: event.clientY - rect.y};\n};\n\n/**\n * @returns the element that emitted the event.\n */\nexport const getClickableTargetFromEvent = (event: Event): Element => {\n  for (const element of event.composedPath()) {\n    if (!(element instanceof Element)) {\n      continue;\n    }\n    // If an element has no width or height, we skip this target.\n    const rect = element.getBoundingClientRect();\n    if (rect.width === 0 || rect.height === 0) {\n      continue;\n    }\n    return element;\n  }\n  throw new Error(`No target is found in event of type ${event.type}`);\n};\n\nexport const createClickAttributes = (event: MouseEvent, target: Element): Schema.ClickAttributes|undefined => {\n  let deviceType: 'pen'|'touch'|undefined;\n  if (event instanceof PointerEvent) {\n    switch (event.pointerType) {\n      case 'mouse':\n        // Default device.\n        break;\n      case 'pen':\n      case 'touch':\n        deviceType = event.pointerType;\n        break;\n      default:\n        // Unsupported device type.\n        return;\n    }\n  }\n  const {offsetX, offsetY} = getMouseEventOffsets(event, target);\n  if (offsetX < 0 || offsetY < 0) {\n    // Event comes from outside the viewport. Can happen as a result of a\n    // simulated click (through a keyboard event e.g.).\n    return;\n  }\n  return {\n    button: (['auxiliary', 'secondary', 'back', 'forward'] as const)[event.button - 1],\n    deviceType,\n    offsetX,\n    offsetY,\n  };\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Schema, SelectorType, StepType} from '../../../third_party/puppeteer-replay/puppeteer-replay.js';\n\nimport {Logger} from './Logger.js';\nimport {SelectorComputer} from './SelectorComputer.js';\nimport type {AccessibilityBindings} from './selectors/ARIASelector.js';\nimport {queryCSSSelectorAll} from './selectors/CSSSelector.js';\nimport type {Selector} from './selectors/Selector.js';\nimport type {Step} from './Step.js';\nimport {\n  assert,\n  createClickAttributes,\n  getClickableTargetFromEvent,\n  haultImmediateEvent,\n} from './util.js';\n\ndeclare global {\n  interface Window {\n    stopShortcut(payload: string): void;\n    addStep(step: string): void;\n  }\n}\n\ninterface Shortcut {\n  meta: boolean;\n  ctrl: boolean;\n  shift: boolean;\n  alt: boolean;\n  keyCode: number;\n}\n\nexport interface RecordingClientOptions {\n  debug: boolean;\n  allowUntrustedEvents: boolean;\n  selectorAttribute?: string;\n  selectorTypesToRecord: SelectorType[];\n  stopShortcuts?: Shortcut[];\n}\n\n/**\n * Determines whether an element is ignorable as an input.\n *\n * This is only called on input-like elements (elements that emit the `input`\n * event).\n *\n * With every `if` statement, please write a comment above explaining your\n * reasoning for ignoring the event.\n */\nconst isIgnorableInputElement = (element: Element): boolean => {\n  if (element instanceof HTMLInputElement) {\n    switch (element.type) {\n      // Checkboxes are always changed as a consequence of another type of action\n      // such as the keyboard or mouse. As such, we can safely ignore these\n      // elements.\n      case 'checkbox':\n        return true;\n        // Radios are always changed as a consequence of another type of action\n        // such as the keyboard or mouse. As such, we can safely ignore these\n        // elements.\n      case 'radio':\n        return true;\n    }\n  }\n  return false;\n};\n\nconst getShortcutLength = (shortcut: Shortcut): string => {\n  return Object.values(shortcut).filter(key => !!key).length.toString();\n};\n\nclass RecordingClient {\n  static readonly defaultSetupOptions: Readonly<RecordingClientOptions> = Object.freeze({\n    debug: false,\n    allowUntrustedEvents: false,\n    selectorTypesToRecord:\n                             [\n                               'aria',\n                               'css',\n                               'text',\n                               'xpath',\n                               'pierce',\n                             ] as SelectorType[],\n  });\n\n  #computer: SelectorComputer;\n\n  #isTrustedEvent = (event: Event): boolean => event.isTrusted;\n  #stopShortcuts: Shortcut[] = [];\n  #logger: Logger;\n\n  constructor(\n      bindings: AccessibilityBindings,\n      options = RecordingClient.defaultSetupOptions,\n  ) {\n    this.#logger = new Logger(options.debug ? 'debug' : 'silent');\n    this.#logger.log('creating a RecordingClient');\n    this.#computer = new SelectorComputer(\n        bindings,\n        this.#logger,\n        options.selectorAttribute,\n        options.selectorTypesToRecord,\n    );\n\n    if (options.allowUntrustedEvents) {\n      this.#isTrustedEvent = (): boolean => true;\n    }\n\n    this.#stopShortcuts = options.stopShortcuts ?? [];\n  }\n\n  start = (): void => {\n    this.#logger.log('Setting up recording listeners');\n\n    window.addEventListener('keydown', this.#onKeyDown, true);\n    window.addEventListener('beforeinput', this.#onBeforeInput, true);\n    window.addEventListener('input', this.#onInput, true);\n    window.addEventListener('keyup', this.#onKeyUp, true);\n\n    window.addEventListener('pointerdown', this.#onPointerDown, true);\n    window.addEventListener('click', this.#onClick, true);\n    window.addEventListener('auxclick', this.#onClick, true);\n\n    window.addEventListener('beforeunload', this.#onBeforeUnload, true);\n  };\n\n  stop = (): void => {\n    this.#logger.log('Tearing down client listeners');\n\n    window.removeEventListener('keydown', this.#onKeyDown, true);\n    window.removeEventListener('beforeinput', this.#onBeforeInput, true);\n    window.removeEventListener('input', this.#onInput, true);\n    window.removeEventListener('keyup', this.#onKeyUp, true);\n\n    window.removeEventListener('pointerdown', this.#onPointerDown, true);\n    window.removeEventListener('click', this.#onClick, true);\n    window.removeEventListener('auxclick', this.#onClick, true);\n\n    window.removeEventListener('beforeunload', this.#onBeforeUnload, true);\n  };\n\n  getSelectors = (node: Node): Selector[] => {\n    return this.#computer.getSelectors(node);\n  };\n\n  getCSSSelector = (node: Node): Selector|undefined => {\n    return this.#computer.getCSSSelector(node);\n  };\n\n  getTextSelector = (node: Node): Selector|undefined => {\n    return this.#computer.getTextSelector(node);\n  };\n\n  queryCSSSelectorAllForTesting = (selector: Selector): Element[] => {\n    return queryCSSSelectorAll(selector);\n  };\n\n  #wasStopShortcutPress = (event: KeyboardEvent): boolean => {\n    for (const shortcut of this.#stopShortcuts ?? []) {\n      if (event.shiftKey === shortcut.shift && event.ctrlKey === shortcut.ctrl && event.metaKey === shortcut.meta &&\n          event.keyCode === shortcut.keyCode) {\n        this.stop();\n        haultImmediateEvent(event);\n        window.stopShortcut(getShortcutLength(shortcut));\n        return true;\n      }\n    }\n    return false;\n  };\n\n  #initialInputTarget: {element: Element, selectors: Selector[]} = {element: document.documentElement, selectors: []};\n\n  /**\n   * Sets the current input target and computes the selector.\n   *\n   * This needs to be called before any input-related events (keydown, keyup,\n   * input, change, etc) occur so the precise selector is known. Since we\n   * capture on the `Window`, it suffices to call this on the first event in any\n   * given input sequence. This will always be either `keydown`, `beforeinput`,\n   * or `input`.\n   */\n  #setInitialInputTarget = (event: Event): void => {\n    const element = event.composedPath()[0];\n    assert(element instanceof Element);\n    if (this.#initialInputTarget.element === element) {\n      return;\n    }\n    this.#initialInputTarget = {element, selectors: this.getSelectors(element)};\n  };\n\n  #onKeyDown = (event: KeyboardEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    if (this.#wasStopShortcutPress(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n    this.#addStep({\n      type: 'keyDown' as StepType.KeyDown,\n      key: event.key as Schema.Key,\n    });\n  };\n\n  #onBeforeInput = (event: Event): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n  };\n\n  #onInput = (event: Event): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n    if (isIgnorableInputElement(this.#initialInputTarget.element)) {\n      return;\n    }\n    const {element, selectors} = this.#initialInputTarget;\n    this.#addStep({\n      type: 'change' as StepType.Change,\n      selectors,\n      value: 'value' in element ? element.value as string : element.textContent as string,\n    });\n  };\n\n  #onKeyUp = (event: KeyboardEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#addStep({\n      type: 'keyUp' as StepType.KeyUp,\n      key: event.key as Schema.Key,\n    });\n  };\n\n  #initialPointerTarget: {element: Element, selectors: Selector[]} = {\n    element: document.documentElement,\n    selectors: [],\n  };\n  #setInitialPointerTarget = (event: Event): void => {\n    const element = getClickableTargetFromEvent(event);\n    if (this.#initialPointerTarget.element === element) {\n      return;\n    }\n    this.#initialPointerTarget = {\n      element,\n      selectors: this.#computer.getSelectors(element),\n    };\n  };\n\n  #pointerDownTimestamp = 0;\n  #onPointerDown = (event: MouseEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#pointerDownTimestamp = event.timeStamp;\n    this.#setInitialPointerTarget(event);\n  };\n\n  #onClick = (event: MouseEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialPointerTarget(event);\n    const attributes = createClickAttributes(event, this.#initialPointerTarget.element);\n    if (!attributes) {\n      return;\n    }\n    const duration = event.timeStamp - this.#pointerDownTimestamp;\n    this.#addStep({\n      type: event.detail === 2 ? 'doubleClick' as StepType.DoubleClick : 'click' as StepType.Click,\n      selectors: this.#initialPointerTarget.selectors,\n      duration: duration > 350 ? duration : undefined,\n      ...attributes,\n    });\n  };\n\n  #onBeforeUnload = (event: Event): void => {\n    this.#logger.log('Unloading');\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#addStep({type: 'beforeUnload'});\n  };\n\n  #addStep = (step: Step): void => {\n    const payload = JSON.stringify(step);\n    this.#logger.log(`Adding step: ${payload}`);\n    window.addStep(payload);\n  };\n}\n\nexport {RecordingClient};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {Logger} from './Logger.js';\nimport {SelectorComputer} from './SelectorComputer.js';\nimport type {AccessibilityBindings} from './selectors/ARIASelector.js';\nimport {getClickableTargetFromEvent, getMouseEventOffsets, haultImmediateEvent} from './util.js';\n\ndeclare global {\n  interface Window {\n    captureSelectors(data: string): void;\n  }\n}\n\nclass SelectorPicker {\n  #logger: Logger;\n  #computer: SelectorComputer;\n\n  constructor(\n      bindings: AccessibilityBindings,\n      customAttribute = '',\n      debug = true,\n  ) {\n    this.#logger = new Logger(debug ? 'debug' : 'silent');\n    this.#logger.log('Creating a SelectorPicker');\n    this.#computer = new SelectorComputer(\n        bindings,\n        this.#logger,\n        customAttribute,\n    );\n  }\n\n  #handleClickEvent = (event: MouseEvent): void => {\n    haultImmediateEvent(event);\n\n    const target = getClickableTargetFromEvent(event);\n    window.captureSelectors(\n        JSON.stringify({\n          selectors: this.#computer.getSelectors(target),\n          ...getMouseEventOffsets(event, target),\n        }),\n    );\n  };\n\n  start = (): void => {\n    this.#logger.log('Setting up selector listeners');\n\n    window.addEventListener('click', this.#handleClickEvent, true);\n    window.addEventListener('mousedown', haultImmediateEvent, true);\n    window.addEventListener('mouseup', haultImmediateEvent, true);\n  };\n\n  stop = (): void => {\n    this.#logger.log('Tearing down selector listeners');\n\n    window.removeEventListener('click', this.#handleClickEvent, true);\n    window.removeEventListener('mousedown', haultImmediateEvent, true);\n    window.removeEventListener('mouseup', haultImmediateEvent, true);\n  };\n}\n\nexport {SelectorPicker};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as RecordingClient from './RecordingClient.js';\nimport * as SelectorPicker from './SelectorPicker.js';\nimport type {AccessibilityBindings} from './selectors/ARIASelector.js';\nimport type * as Step from './Step.js';\n\ndeclare global {\n  interface Window {\n    stopShortcut(payload: string): void;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DevToolsRecorder: DevToolsRecorder;\n  }\n}\n\nclass DevToolsRecorder {\n  #recordingClient?: RecordingClient.RecordingClient;\n  startRecording(\n      bindings: AccessibilityBindings,\n      options?: RecordingClient.RecordingClientOptions,\n      ): void {\n    if (this.#recordingClient) {\n      throw new Error('Recording client already started.');\n    }\n    if (this.#selectorPicker) {\n      throw new Error('Selector picker is active.');\n    }\n    this.#recordingClient = new RecordingClient.RecordingClient(\n        bindings,\n        options,\n    );\n    this.#recordingClient.start();\n  }\n  stopRecording(): void {\n    if (!this.#recordingClient) {\n      throw new Error('Recording client was not started.');\n    }\n    this.#recordingClient.stop();\n    this.#recordingClient = undefined;\n  }\n\n  get recordingClientForTesting(): RecordingClient.RecordingClient {\n    if (!this.#recordingClient) {\n      throw new Error('Recording client was not started.');\n    }\n    return this.#recordingClient;\n  }\n\n  #selectorPicker?: SelectorPicker.SelectorPicker;\n  startSelectorPicker(\n      bindings: AccessibilityBindings,\n      customAttribute?: string,\n      debug?: boolean,\n      ): void {\n    if (this.#selectorPicker) {\n      throw new Error('Selector picker already started.');\n    }\n    if (this.#recordingClient) {\n      this.#recordingClient.stop();\n    }\n    this.#selectorPicker = new SelectorPicker.SelectorPicker(\n        bindings,\n        customAttribute,\n        debug,\n    );\n    this.#selectorPicker.start();\n  }\n  stopSelectorPicker(): void {\n    if (!this.#selectorPicker) {\n      throw new Error('Selector picker was not started.');\n    }\n    this.#selectorPicker.stop();\n    this.#selectorPicker = undefined;\n    if (this.#recordingClient) {\n      this.#recordingClient.start();\n    }\n  }\n}\n\nif (!window.DevToolsRecorder) {\n  window.DevToolsRecorder = new DevToolsRecorder();\n}\n\nexport {\n  type DevToolsRecorder,\n  type RecordingClient,\n  type SelectorPicker,\n  type Step,\n};\n"],
  "mappings": "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",
  "names": ["collect", "collect", "attributeSelector", "getSelectorPart", "selector"]
}
