{"version":3,"file":"AgentProject.js","sourceRoot":"","sources":["../../../../../../front_end/panels/ai_assistance/AgentProject.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Persistence from '../../models/persistence/persistence.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport type * as Workspace from '../../models/workspace/workspace.js';\nimport * as Diff from '../../third_party/diff/diff.js';\n\nimport {debugLog} from './debug.js';\n\n/**\n * AgentProject wraps around a Workspace.Workspace.Project and\n * implements AI Assistance-specific logic for accessing workspace files\n * including additional checks and restrictions.\n */\nexport class AgentProject {\n  #project: Workspace.Workspace.Project;\n  #ignoredFolderNames = new Set(['node_modules']);\n  #filesChanged = new Set<string>();\n  #linesChanged = 0;\n\n  readonly #maxFilesChanged: number;\n  readonly #maxLinesChanged: number;\n\n  constructor(project: Workspace.Workspace.Project, options: {\n    maxFilesChanged: number,\n    maxLinesChanged: number,\n  } = {\n    maxFilesChanged: 5,\n    maxLinesChanged: 200,\n  }) {\n    this.#project = project;\n    this.#maxFilesChanged = options.maxFilesChanged;\n    this.#maxLinesChanged = options.maxLinesChanged;\n  }\n\n  /**\n   * Provides file names in the project to the agent.\n   */\n  getFiles(): string[] {\n    return this.#indexFiles().files;\n  }\n\n  /**\n   * Provides access to the file content in the working copy\n   * of the matching UiSourceCode.\n   */\n  readFile(filepath: string): string|undefined {\n    const {map} = this.#indexFiles();\n    const uiSourceCode = map.get(filepath);\n    if (!uiSourceCode) {\n      return;\n    }\n    // TODO: needs additional handling for binary files.\n    return uiSourceCode.workingCopyContentData().text;\n  }\n\n  /**\n   * This method updates the file content in the working copy of the\n   * UiSourceCode identified by the filepath.\n   */\n  writeFile(filepath: string, content: string): void {\n    const {map} = this.#indexFiles();\n    const uiSourceCode = map.get(filepath);\n    if (!uiSourceCode) {\n      throw new Error(`UISourceCode ${filepath} not found`);\n    }\n    const currentContent = this.readFile(filepath);\n    const lineEndRe = /\\r\\n?|\\n/;\n    let linesChanged = 0;\n    if (currentContent) {\n      const diff = Diff.Diff.DiffWrapper.lineDiff(currentContent.split(lineEndRe), content.split(lineEndRe));\n      for (const item of diff) {\n        if (item[0] !== Diff.Diff.Operation.Equal) {\n          linesChanged++;\n        }\n      }\n    } else {\n      linesChanged += content.split(lineEndRe).length;\n    }\n\n    if (this.#linesChanged + linesChanged > this.#maxLinesChanged) {\n      throw new Error('Too many lines changed');\n    }\n\n    this.#filesChanged.add(filepath);\n    if (this.#filesChanged.size > this.#maxFilesChanged) {\n      this.#filesChanged.delete(filepath);\n      throw new Error('Too many files changed');\n    }\n    this.#linesChanged += linesChanged;\n    uiSourceCode.setWorkingCopy(content);\n  }\n\n  /**\n   * This method searches in files for the agent and provides the\n   * matches to the agent.\n   */\n  async searchFiles(query: string, caseSensitive?: boolean, isRegex?: boolean): Promise<Array<{\n    filepath: string,\n    lineNumber: number,\n    columnNumber: number,\n    matchLength: number,\n  }>> {\n    const {map} = this.#indexFiles();\n    const matches = [];\n    for (const [filepath, file] of map.entries()) {\n      await file.requestContentData();\n      debugLog('searching in', filepath, 'for', query);\n      const content = file.isDirty() ? file.workingCopyContentData() : await file.requestContentData();\n      const results =\n          TextUtils.TextUtils.performSearchInContentData(content, query, caseSensitive ?? true, isRegex ?? false);\n      for (const result of results) {\n        debugLog('matches in', filepath);\n        matches.push({\n          filepath,\n          lineNumber: result.lineNumber,\n          columnNumber: result.columnNumber,\n          matchLength: result.matchLength\n        });\n      }\n    }\n    return matches;\n  }\n\n  #shouldSkipPath(pathParts: string[]): boolean {\n    for (const part of pathParts) {\n      if (this.#ignoredFolderNames.has(part)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  #indexFiles(): {files: string[], map: Map<string, Workspace.UISourceCode.UISourceCode>} {\n    const files = [];\n    const map = new Map();\n    // TODO: this could be optimized and cached.\n    for (const uiSourceCode of this.#project.uiSourceCodes()) {\n      const pathParths = Persistence.FileSystemWorkspaceBinding.FileSystemWorkspaceBinding.relativePath(uiSourceCode);\n      if (this.#shouldSkipPath(pathParths)) {\n        continue;\n      }\n      const path = pathParths.join('/');\n      files.push(path);\n      map.set(path, uiSourceCode);\n    }\n    return {files, map};\n  }\n}\n"]}