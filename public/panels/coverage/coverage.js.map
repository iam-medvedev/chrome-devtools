{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/coverage/CoverageModel.ts", "../../../../../../front_end/panels/coverage/CoverageListView.ts", "coverageListView.css.js", "../../../../../../front_end/panels/coverage/CoverageView.ts", "../../../../../../front_end/panels/coverage/CoverageDecorationManager.ts", "coverageView.css.js"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport type * as Bindings from '../../models/bindings/bindings.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\n\nexport const enum CoverageType {\n  CSS = (1 << 0),\n  JAVA_SCRIPT = (1 << 1),\n  JAVA_SCRIPT_PER_FUNCTION = (1 << 2),\n}\n\nexport const enum SuspensionState {\n  ACTIVE = 'Active',\n  SUSPENDING = 'Suspending',\n  SUSPENDED = 'Suspended',\n}\n\nexport enum Events {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  CoverageUpdated = 'CoverageUpdated',\n  CoverageReset = 'CoverageReset',\n  SourceMapResolved = 'SourceMapResolved',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface EventTypes {\n  [Events.CoverageUpdated]: CoverageInfo[];\n  [Events.CoverageReset]: void;\n  [Events.SourceMapResolved]: void;\n}\n\nconst COVERAGE_POLLING_PERIOD_MS = 200;\nconst RESOLVE_SOURCEMAP_TIMEOUT = 500;\n\ninterface BacklogItem<T> {\n  rawCoverageData: T[];\n  stamp: number;\n}\n\nexport class CoverageModel extends SDK.SDKModel.SDKModel<EventTypes> {\n  private cpuProfilerModel: SDK.CPUProfilerModel.CPUProfilerModel|null;\n  private cssModel: SDK.CSSModel.CSSModel|null;\n  private debuggerModel: SDK.DebuggerModel.DebuggerModel|null;\n  private coverageByURL: Map<Platform.DevToolsPath.UrlString, URLCoverageInfo>;\n  private coverageByContentProvider: Map<TextUtils.ContentProvider.ContentProvider, CoverageInfo>;\n  private coverageUpdateTimes: Set<number>;\n  private suspensionState: SuspensionState;\n  private pollTimer: number|null;\n  private currentPollPromise: Promise<void>|null;\n  private shouldResumePollingOnResume: boolean|null;\n  private jsBacklog: Array<BacklogItem<Protocol.Profiler.ScriptCoverage>>;\n  private cssBacklog: Array<BacklogItem<Protocol.CSS.RuleUsage>>;\n  private performanceTraceRecording: boolean|null;\n  private sourceMapManager: SDK.SourceMapManager.SourceMapManager<SDK.Script.Script>|null;\n  private willResolveSourceMaps: boolean;\n  private processSourceMapBacklog: SourceMapObject[];\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.cpuProfilerModel = target.model(SDK.CPUProfilerModel.CPUProfilerModel);\n    this.cssModel = target.model(SDK.CSSModel.CSSModel);\n    this.debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n    this.sourceMapManager = this.debuggerModel?.sourceMapManager() || null;\n    this.sourceMapManager?.addEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.sourceMapAttached, this);\n\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n\n    // We keep track of the update times, because the other data-structures don't change if an\n    // update doesn't change the coverage. Some visualizations want to convey to the user that\n    // an update was received at a certain time, but did not result in a coverage change.\n    this.coverageUpdateTimes = new Set();\n\n    this.suspensionState = SuspensionState.ACTIVE;\n    this.pollTimer = null;\n    this.currentPollPromise = null;\n    this.shouldResumePollingOnResume = false;\n    this.jsBacklog = [];\n    this.cssBacklog = [];\n    this.performanceTraceRecording = false;\n    this.willResolveSourceMaps = false;\n    this.processSourceMapBacklog = [];\n  }\n\n  async start(jsCoveragePerBlock: boolean): Promise<boolean> {\n    if (this.suspensionState !== SuspensionState.ACTIVE) {\n      throw new Error('Cannot start CoverageModel while it is not active.');\n    }\n    const promises = [];\n    if (this.cssModel) {\n      // Note there's no JS coverage since JS won't ever return\n      // coverage twice, even after it's restarted.\n      this.clearCSS();\n\n      this.cssModel.addEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n      promises.push(this.cssModel.startCoverage());\n    }\n    if (this.cpuProfilerModel) {\n      promises.push(\n          this.cpuProfilerModel.startPreciseCoverage(jsCoveragePerBlock, this.preciseCoverageDeltaUpdate.bind(this)));\n    }\n\n    await Promise.all(promises);\n    return Boolean(this.cssModel || this.cpuProfilerModel);\n  }\n\n  private async sourceMapAttached(\n      event: Common.EventTarget.EventTargetEvent<{client: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap}>):\n      Promise<void> {\n    const script = event.data.client;\n    const sourceMap = event.data.sourceMap;\n\n    this.processSourceMapBacklog.push({script, sourceMap});\n    if (!this.willResolveSourceMaps) {\n      this.willResolveSourceMaps = true;\n      setTimeout(this.resolveSourceMapsAndUpdate.bind(this), RESOLVE_SOURCEMAP_TIMEOUT);\n    }\n  }\n\n  private async resolveSourceMapsAndUpdate(): Promise<void> {\n    this.willResolveSourceMaps = false;\n    // reset the backlog once we start processing it\n    const currentBacklog = this.processSourceMapBacklog;\n    this.processSourceMapBacklog = [];\n    await Promise.all(currentBacklog.map(({script, sourceMap}) => this.resolveSourceMap(script, sourceMap)));\n    this.dispatchEventToListeners(Events.SourceMapResolved);\n  }\n\n  private async resolveSourceMap(script: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap): Promise<void> {\n    const url = script.sourceURL;\n    const urlCoverage = this.coverageByURL.get(url);\n    if (!urlCoverage) {\n      // The urlCoverage has not been created yet, so no need to update it.\n      return;\n    }\n    // If the urlCoverage is there, but no sourceURLCoverageInfo have been added,\n    // it means the source map is attached after the URLCoverage is created.\n    // So now we need to create the sourceURLCoverageInfo and add it to the urlCoverage.\n    if (urlCoverage.sourcesURLCoverageInfo.size === 0) {\n      const generatedContent = TextUtils.ContentData.ContentData.contentDataOrEmpty(await script.requestContentData());\n      const [sourceSizeMap, sourceSegments] =\n          this.calculateSizeForSources(sourceMap, generatedContent.textObj, script.contentLength);\n      urlCoverage.setSourceSegments(sourceSegments);\n      for (const sourceURL of sourceMap.sourceURLs()) {\n        this.addCoverageForSource(sourceURL, sourceSizeMap.get(sourceURL) || 0, urlCoverage.type(), urlCoverage);\n      }\n    }\n  }\n\n  async preciseCoverageDeltaUpdate(timestamp: number, coverageData: Protocol.Profiler.ScriptCoverage[]): Promise<void> {\n    this.coverageUpdateTimes.add(timestamp);\n    const result = await this.backlogOrProcessJSCoverage(coverageData, timestamp);\n    if (result.length) {\n      this.dispatchEventToListeners(Events.CoverageUpdated, result);\n    }\n  }\n\n  async stop(): Promise<void> {\n    await this.stopPolling();\n    const promises = [];\n    if (this.cpuProfilerModel) {\n      promises.push(this.cpuProfilerModel.stopPreciseCoverage());\n    }\n    if (this.cssModel) {\n      promises.push(this.cssModel.stopCoverage());\n      this.cssModel.removeEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n    }\n    await Promise.all(promises);\n  }\n\n  reset(): void {\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n    this.coverageUpdateTimes = new Set();\n    this.dispatchEventToListeners(Events.CoverageReset);\n  }\n\n  async startPolling(): Promise<void> {\n    if (this.currentPollPromise || this.suspensionState !== SuspensionState.ACTIVE) {\n      return;\n    }\n    await this.pollLoop();\n  }\n\n  private async pollLoop(): Promise<void> {\n    this.clearTimer();\n    this.currentPollPromise = this.pollAndCallback();\n    await this.currentPollPromise;\n    if (this.suspensionState === SuspensionState.ACTIVE || this.performanceTraceRecording) {\n      this.pollTimer = window.setTimeout(() => this.pollLoop(), COVERAGE_POLLING_PERIOD_MS);\n    }\n  }\n\n  async stopPolling(): Promise<void> {\n    this.clearTimer();\n    await this.currentPollPromise;\n    this.currentPollPromise = null;\n    // Do one last poll to get the final data.\n    await this.pollAndCallback();\n  }\n\n  private async pollAndCallback(): Promise<void> {\n    if (this.suspensionState === SuspensionState.SUSPENDED && !this.performanceTraceRecording) {\n      return;\n    }\n    const updates = await this.takeAllCoverage();\n    // This conditional should never trigger, as all intended ways to stop\n    // polling are awaiting the `_currentPollPromise` before suspending.\n    console.assert(\n        this.suspensionState !== SuspensionState.SUSPENDED || Boolean(this.performanceTraceRecording),\n        'CoverageModel was suspended while polling.');\n    if (updates.length) {\n      this.dispatchEventToListeners(Events.CoverageUpdated, updates);\n    }\n  }\n\n  private clearTimer(): void {\n    if (this.pollTimer) {\n      clearTimeout(this.pollTimer);\n      this.pollTimer = null;\n    }\n  }\n\n  /**\n   * Stops polling as preparation for suspension. This function is idempotent\n   * due because it changes the state to suspending.\n   */\n  override async preSuspendModel(reason?: string): Promise<void> {\n    if (this.suspensionState !== SuspensionState.ACTIVE) {\n      return;\n    }\n    this.suspensionState = SuspensionState.SUSPENDING;\n    if (reason === 'performance-timeline') {\n      this.performanceTraceRecording = true;\n      // Keep polling to the backlog if a performance trace is recorded.\n      return;\n    }\n    if (this.currentPollPromise) {\n      await this.stopPolling();\n      this.shouldResumePollingOnResume = true;\n    }\n  }\n\n  override async suspendModel(_reason?: string): Promise<void> {\n    this.suspensionState = SuspensionState.SUSPENDED;\n  }\n\n  override async resumeModel(): Promise<void> {\n  }\n\n  /**\n   * Restarts polling after suspension. Note that the function is idempotent\n   * because starting polling is idempotent.\n   */\n  override async postResumeModel(): Promise<void> {\n    this.suspensionState = SuspensionState.ACTIVE;\n    this.performanceTraceRecording = false;\n    if (this.shouldResumePollingOnResume) {\n      this.shouldResumePollingOnResume = false;\n      await this.startPolling();\n    }\n  }\n\n  entries(): URLCoverageInfo[] {\n    return Array.from(this.coverageByURL.values());\n  }\n\n  getCoverageForUrl(url: Platform.DevToolsPath.UrlString): URLCoverageInfo|null {\n    return this.coverageByURL.get(url) || null;\n  }\n\n  usageForRange(contentProvider: TextUtils.ContentProvider.ContentProvider, startOffset: number, endOffset: number):\n      boolean|undefined {\n    const coverageInfo = this.coverageByContentProvider.get(contentProvider);\n    return coverageInfo?.usageForRange(startOffset, endOffset);\n  }\n\n  private clearCSS(): void {\n    for (const entry of this.coverageByContentProvider.values()) {\n      if (entry.type() !== CoverageType.CSS) {\n        continue;\n      }\n      const contentProvider = entry.getContentProvider() as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      this.coverageByContentProvider.delete(contentProvider);\n      const urlEntry = this.coverageByURL.get(entry.url());\n      if (!urlEntry) {\n        continue;\n      }\n      const key = `${contentProvider.startLine}:${contentProvider.startColumn}`;\n      urlEntry.removeCoverageEntry(key, entry);\n      if (urlEntry.numberOfEntries() === 0) {\n        this.coverageByURL.delete(entry.url());\n      }\n    }\n\n    if (this.cssModel) {\n      for (const styleSheetHeader of this.cssModel.getAllStyleSheetHeaders()) {\n        this.addStyleSheetToCSSCoverage(styleSheetHeader);\n      }\n    }\n  }\n\n  private async takeAllCoverage(): Promise<CoverageInfo[]> {\n    const [updatesCSS, updatesJS] = await Promise.all([this.takeCSSCoverage(), this.takeJSCoverage()]);\n    return [...updatesCSS, ...updatesJS];\n  }\n\n  private async takeJSCoverage(): Promise<CoverageInfo[]> {\n    if (!this.cpuProfilerModel) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cpuProfilerModel.takePreciseCoverage();\n    this.coverageUpdateTimes.add(timestamp);\n    return await this.backlogOrProcessJSCoverage(coverage, timestamp);\n  }\n\n  private async backlogOrProcessJSCoverage(\n      freshRawCoverageData: Protocol.Profiler.ScriptCoverage[], freshTimestamp: number): Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.jsBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.ACTIVE) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.jsBacklog.sort(ascendingByTimestamp)) {\n      results.push(await this.processJSCoverage(rawCoverageData, stamp));\n    }\n    this.jsBacklog = [];\n    return results.flat();\n  }\n\n  async processJSBacklog(): Promise<void> {\n    void this.backlogOrProcessJSCoverage([], 0);\n  }\n\n  private async processJSCoverage(scriptsCoverage: Protocol.Profiler.ScriptCoverage[], stamp: number):\n      Promise<CoverageInfo[]> {\n    if (!this.debuggerModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    for (const entry of scriptsCoverage) {\n      const script = this.debuggerModel.scriptForId(entry.scriptId);\n      if (!script) {\n        continue;\n      }\n\n      const ranges = [];\n      let type = CoverageType.JAVA_SCRIPT;\n      for (const func of entry.functions) {\n        // Do not coerce undefined to false, i.e. only consider blockLevel to be false\n        // if back-end explicitly provides blockLevel field, otherwise presume blockLevel\n        // coverage is not available. Also, ignore non-block level functions that weren't\n        // ever called.\n        if (func.isBlockCoverage === false && !(func.ranges.length === 1 && !func.ranges[0].count)) {\n          type |= CoverageType.JAVA_SCRIPT_PER_FUNCTION;\n        }\n        for (const range of func.ranges) {\n          ranges.push(range);\n        }\n      }\n      const subentry = await this.addCoverage(\n          script, script.contentLength, script.lineOffset, script.columnOffset, ranges, type, stamp);\n      if (subentry) {\n        updatedEntries.push(...subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private handleStyleSheetAdded(\n      event: Common.EventTarget.EventTargetEvent<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader>): void {\n    this.addStyleSheetToCSSCoverage(event.data);\n  }\n\n  private async takeCSSCoverage(): Promise<CoverageInfo[]> {\n    // Don't poll if we have no model, or are suspended.\n    if (!this.cssModel || this.suspensionState !== SuspensionState.ACTIVE) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cssModel.takeCoverageDelta();\n    this.coverageUpdateTimes.add(timestamp);\n    return await this.backlogOrProcessCSSCoverage(coverage, timestamp);\n  }\n\n  private async backlogOrProcessCSSCoverage(freshRawCoverageData: Protocol.CSS.RuleUsage[], freshTimestamp: number):\n      Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.cssBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.ACTIVE) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.cssBacklog.sort(ascendingByTimestamp)) {\n      results.push(await this.processCSSCoverage(rawCoverageData, stamp));\n    }\n    this.cssBacklog = [];\n    return results.flat();\n  }\n\n  private async processCSSCoverage(ruleUsageList: Protocol.CSS.RuleUsage[], stamp: number): Promise<CoverageInfo[]> {\n    if (!this.cssModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    const rulesByStyleSheet = new Map<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader, RangeUseCount[]>();\n    for (const rule of ruleUsageList) {\n      const styleSheetHeader = this.cssModel.styleSheetHeaderForId(rule.styleSheetId);\n      if (!styleSheetHeader) {\n        continue;\n      }\n      let ranges = rulesByStyleSheet.get(styleSheetHeader);\n      if (!ranges) {\n        ranges = [];\n        rulesByStyleSheet.set(styleSheetHeader, ranges);\n      }\n      ranges.push({startOffset: rule.startOffset, endOffset: rule.endOffset, count: Number(rule.used)});\n    }\n    for (const entry of rulesByStyleSheet) {\n      const styleSheetHeader = entry[0];\n      const ranges = entry[1];\n      const subentry = await this.addCoverage(\n          styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn,\n          ranges, CoverageType.CSS, stamp);\n      if (subentry) {\n        updatedEntries.push(...subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private static convertToDisjointSegments(ranges: RangeUseCount[], stamp: number): CoverageSegment[] {\n    ranges.sort((a, b) => a.startOffset - b.startOffset);\n\n    const result: CoverageSegment[] = [];\n    const stack = [];\n    for (const entry of ranges) {\n      let top: RangeUseCount = stack[stack.length - 1];\n      while (top && top.endOffset <= entry.startOffset) {\n        append(top.endOffset, top.count);\n        stack.pop();\n        top = stack[stack.length - 1];\n      }\n      append(entry.startOffset, top ? top.count : 0);\n      stack.push(entry);\n    }\n\n    for (let top = stack.pop(); top; top = stack.pop()) {\n      append(top.endOffset, top.count);\n    }\n\n    function append(end: number, count: number): void {\n      const last = result[result.length - 1];\n      if (last) {\n        if (last.end === end) {\n          return;\n        }\n        if (last.count === count) {\n          last.end = end;\n          return;\n        }\n      }\n      result.push({end, count, stamp});\n    }\n\n    return result;\n  }\n\n  private addStyleSheetToCSSCoverage(styleSheetHeader: SDK.CSSStyleSheetHeader.CSSStyleSheetHeader): void {\n    void this.addCoverage(\n        styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, [],\n        CoverageType.CSS, Date.now());\n  }\n\n  private calculateSizeForSources(sourceMap: SDK.SourceMap.SourceMap, text: TextUtils.Text.Text, contentLength: number):\n      [\n        Map<Platform.DevToolsPath.UrlString, number>,\n        SourceSegment[],\n      ] {\n    // Map shows the size of source files contributed to the size in the generated file. For example:\n    // Map(3)Â {url1 => 593, url2 => 232, url3 => 52}\n    // This means in there are 593 bytes in the generated file are contributed by url1, and so on.\n    const sourceSizeMap = new Map<Platform.DevToolsPath.UrlString, number>();\n    // Continuous segments shows that which source file contribute to the generated file segment. For example:\n    // [{end: 84, sourceUrl: ''}, {end: 593, sourceUrl: url1}, {end: 781, sourceUrl: url2}, {end: 833, sourceUrl: url3}, {end: 881, sourceUrl: url1}]\n    // This means that the first 84 bytes in the generated file are not contributed by any source file, the next 593 bytes are contributed by url1, and so on.\n    const sourceSegments: SourceSegment[] = [];\n\n    const calculateSize = function(startLine: number, startCol: number, endLine: number, endCol: number): number {\n      if (startLine === endLine) {\n        return endCol - startCol;\n      }\n      if (text) {\n        // If we hit the line break, we need to use offset to calculate size\n        const startOffset = text.offsetFromPosition(startLine, startCol);\n        const endOffset = text.offsetFromPosition(endLine, endCol);\n        return endOffset - startOffset;\n      }\n      // If for some reason we don't have the text, we can only use col number to calculate size\n      return endCol;\n    };\n\n    const mappings = sourceMap.mappings();\n    if (mappings.length === 0) {\n      return [sourceSizeMap, sourceSegments];\n    }\n\n    // calculate the segment before the first entry\n    let lastEntry = mappings[0];\n    let totalSegmentSize = 0;\n    if (text) {\n      totalSegmentSize += text.offsetFromPosition(lastEntry.lineNumber, lastEntry.columnNumber);\n    } else {\n      totalSegmentSize += calculateSize(0, 0, lastEntry.lineNumber, lastEntry.columnNumber);\n    }\n    sourceSegments.push({end: totalSegmentSize, sourceUrl: '' as Platform.DevToolsPath.UrlString});\n\n    for (let i = 0; i < mappings.length; i++) {\n      const curEntry = mappings[i];\n      const entryRange = sourceMap.findEntryRanges(curEntry.lineNumber, curEntry.columnNumber);\n      if (entryRange) {\n        // calculate the size\n        const range = entryRange.range;\n        const sourceURL = entryRange.sourceURL;\n        const oldSize = sourceSizeMap.get(sourceURL) || 0;\n        let size = 0;\n        if (i === mappings.length - 1) {\n          const startOffset = text.offsetFromPosition(range.startLine, range.startColumn);\n          size = contentLength - startOffset;\n        } else {\n          size = calculateSize(range.startLine, range.startColumn, range.endLine, range.endColumn);\n        }\n        sourceSizeMap.set(sourceURL, oldSize + size);\n      }\n\n      // calculate the segment\n      const segmentSize =\n          calculateSize(lastEntry.lineNumber, lastEntry.columnNumber, curEntry.lineNumber, curEntry.columnNumber);\n      totalSegmentSize += segmentSize;\n      if (curEntry.sourceURL !== lastEntry.sourceURL) {\n        if (text) {\n          const endOffsetForLastEntry = text.offsetFromPosition(curEntry.lineNumber, curEntry.columnNumber);\n          sourceSegments.push(\n              {end: endOffsetForLastEntry, sourceUrl: lastEntry.sourceURL || '' as Platform.DevToolsPath.UrlString});\n        } else {\n          sourceSegments.push(\n              {end: totalSegmentSize, sourceUrl: lastEntry.sourceURL || '' as Platform.DevToolsPath.UrlString});\n        }\n      }\n      lastEntry = curEntry;\n      // add the last segment if we are at the last entry\n      if (i === mappings.length - 1) {\n        sourceSegments.push(\n            {end: contentLength, sourceUrl: curEntry.sourceURL || '' as Platform.DevToolsPath.UrlString});\n      }\n    }\n\n    return [sourceSizeMap, sourceSegments];\n  }\n\n  private async addCoverage(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, startLine: number,\n      startColumn: number, ranges: RangeUseCount[], type: CoverageType, stamp: number): Promise<CoverageInfo[]|null> {\n    const coverageInfoArray: CoverageInfo[] = [];\n    const url = contentProvider.contentURL();\n    if (!url) {\n      return null;\n    }\n    let urlCoverage = this.coverageByURL.get(url);\n    let isNewUrlCoverage = false;\n    if (!urlCoverage) {\n      isNewUrlCoverage = true;\n      urlCoverage = new URLCoverageInfo(url);\n      this.coverageByURL.set(url, urlCoverage);\n      // If the script has source map, we need to create the sourceURLCoverageInfo for each source file.\n      const sourceMap = await this.sourceMapManager?.sourceMapForClientPromise(contentProvider as SDK.Script.Script);\n      if (sourceMap) {\n        const generatedContent =\n            TextUtils.ContentData.ContentData.contentDataOrEmpty(await contentProvider.requestContentData());\n        const [sourceSizeMap, sourceSegments] =\n            this.calculateSizeForSources(sourceMap, generatedContent.textObj, contentLength);\n        urlCoverage.setSourceSegments(sourceSegments);\n        for (const sourceURL of sourceMap.sourceURLs()) {\n          const subentry = this.addCoverageForSource(sourceURL, sourceSizeMap.get(sourceURL) || 0, type, urlCoverage);\n          if (subentry) {\n            coverageInfoArray.push(subentry);\n          }\n        }\n      }\n    }\n\n    const coverageInfo = urlCoverage.ensureEntry(contentProvider, contentLength, startLine, startColumn, type);\n    this.coverageByContentProvider.set(contentProvider, coverageInfo);\n    const segments = CoverageModel.convertToDisjointSegments(ranges, stamp);\n    const last = segments[segments.length - 1];\n    if (last && last.end < contentLength) {\n      segments.push({end: contentLength, stamp, count: 0});\n    }\n    const usedSizeDelta = coverageInfo.mergeCoverage(segments);\n    if (!isNewUrlCoverage && usedSizeDelta === 0) {\n      return null;\n    }\n    urlCoverage.addToSizes(usedSizeDelta, 0);\n    // go through the sources that have size changes.\n    for (const [sourceUrl, sizeDelta] of coverageInfo.sourceDeltaMap) {\n      const sourceURLCoverageInfo = urlCoverage.sourcesURLCoverageInfo.get(sourceUrl);\n      if (sourceURLCoverageInfo) {\n        sourceURLCoverageInfo.addToSizes(sizeDelta, 0);\n        sourceURLCoverageInfo.lastSourceUsedRange = coverageInfo.sourceUsedRangeMap.get(sourceUrl) || [];\n      }\n    }\n\n    coverageInfoArray.push(coverageInfo);\n    return coverageInfoArray;\n  }\n\n  private addCoverageForSource(\n      url: Platform.DevToolsPath.UrlString, size: number, type: CoverageType,\n      generatedUrlCoverage: URLCoverageInfo): CoverageInfo|null {\n    const uiSourceCode = Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url);\n    const contentProvider = uiSourceCode as TextUtils.ContentProvider.ContentProvider;\n    const urlCoverage = new SourceURLCoverageInfo(url, generatedUrlCoverage);\n    const coverageInfo = urlCoverage.ensureEntry(contentProvider, size, 0, 0, type);\n\n    generatedUrlCoverage.sourcesURLCoverageInfo.set(url, urlCoverage);\n\n    return coverageInfo;\n  }\n\n  async exportReport(fos: Bindings.FileUtils.FileOutputStream): Promise<void> {\n    const result: Array<{url: string, ranges: Array<{start: number, end: number}>, text: string | null}> = [];\n    const coverageByUrlKeys = Array.from(this.coverageByURL.keys()).sort();\n    for (const urlInfoKey of coverageByUrlKeys) {\n      const urlInfo = this.coverageByURL.get(urlInfoKey);\n      if (!urlInfo) {\n        continue;\n      }\n      const url = urlInfo.url();\n      if (url.startsWith('extensions::') || Common.ParsedURL.schemeIs(url, 'chrome-extension:')) {\n        continue;\n      }\n      result.push(...await urlInfo.entriesForExport());\n    }\n    await fos.write(JSON.stringify(result, undefined, 2));\n    void fos.close();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(CoverageModel, {capabilities: SDK.Target.Capability.NONE, autostart: false});\n\nexport interface EntryForExport {\n  url: Platform.DevToolsPath.UrlString;\n  ranges: Array<{start: number, end: number}>;\n  text: string|null;\n}\n\nfunction locationCompare(a: string, b: string): number {\n  const [aLine, aPos] = a.split(':');\n  const [bLine, bPos] = b.split(':');\n  return Number.parseInt(aLine, 10) - Number.parseInt(bLine, 10) ||\n      Number.parseInt(aPos, 10) - Number.parseInt(bPos, 10);\n}\n\nexport class URLCoverageInfo extends Common.ObjectWrapper.ObjectWrapper<URLCoverageInfo.EventTypes> {\n  readonly #url: Platform.DevToolsPath.UrlString;\n  private coverageInfoByLocation: Map<string, CoverageInfo>;\n  #size: number;\n  #usedSize: number;\n  #type!: CoverageType;\n  #isContentScript: boolean;\n  sourcesURLCoverageInfo = new Map<Platform.DevToolsPath.UrlString, SourceURLCoverageInfo>();\n  sourceSegments: SourceSegment[]|undefined;\n\n  constructor(url: Platform.DevToolsPath.UrlString) {\n    super();\n\n    this.#url = url;\n    this.coverageInfoByLocation = new Map();\n    this.#size = 0;\n    this.#usedSize = 0;\n    this.#isContentScript = false;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.#url;\n  }\n\n  type(): CoverageType {\n    return this.#type;\n  }\n\n  size(): number {\n    return this.#size;\n  }\n\n  usedSize(): number {\n    return this.#usedSize;\n  }\n\n  unusedSize(): number {\n    return this.#size - this.#usedSize;\n  }\n\n  usedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.#size === 0) {\n      return 0;\n    }\n    if (!this.unusedSize() || !this.size()) {\n      return 0;\n    }\n    return this.usedSize() / this.size();\n  }\n\n  unusedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.#size === 0) {\n      return 1;\n    }\n    return this.unusedSize() / this.size();\n  }\n\n  isContentScript(): boolean {\n    return this.#isContentScript;\n  }\n\n  entries(): IterableIterator<CoverageInfo> {\n    return this.coverageInfoByLocation.values();\n  }\n\n  numberOfEntries(): number {\n    return this.coverageInfoByLocation.size;\n  }\n\n  removeCoverageEntry(key: string, entry: CoverageInfo): void {\n    if (!this.coverageInfoByLocation.delete(key)) {\n      return;\n    }\n    this.addToSizes(-entry.getUsedSize(), -entry.getSize());\n  }\n\n  addToSizes(usedSize: number, size: number): void {\n    this.#usedSize += usedSize;\n    this.#size += size;\n\n    if (usedSize !== 0 || size !== 0) {\n      this.dispatchEventToListeners(URLCoverageInfo.Events.SizesChanged);\n    }\n  }\n\n  setSourceSegments(segments: SourceSegment[]): void {\n    this.sourceSegments = segments;\n  }\n\n  ensureEntry(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, lineOffset: number,\n      columnOffset: number, type: CoverageType): CoverageInfo {\n    const key = `${lineOffset}:${columnOffset}`;\n    let entry = this.coverageInfoByLocation.get(key);\n\n    if ((type & CoverageType.JAVA_SCRIPT) && !this.coverageInfoByLocation.size &&\n        contentProvider instanceof SDK.Script.Script) {\n      this.#isContentScript = (contentProvider).isContentScript();\n    }\n    this.#type |= type;\n\n    if (entry) {\n      entry.addCoverageType(type);\n      return entry;\n    }\n\n    if ((type & CoverageType.JAVA_SCRIPT) && !this.coverageInfoByLocation.size &&\n        contentProvider instanceof SDK.Script.Script) {\n      this.#isContentScript = (contentProvider).isContentScript();\n    }\n\n    entry = new CoverageInfo(contentProvider, contentLength, lineOffset, columnOffset, type, this);\n    this.coverageInfoByLocation.set(key, entry);\n    this.addToSizes(0, contentLength);\n\n    return entry;\n  }\n\n  async getFullText(): Promise<TextUtils.Text.Text|null> {\n    // For .html resources, multiple scripts share URL, but have different offsets.\n    let useFullText = false;\n    const url = this.url();\n    for (const info of this.coverageInfoByLocation.values()) {\n      const {lineOffset, columnOffset} = info.getOffsets();\n      if (lineOffset || columnOffset) {\n        useFullText = Boolean(url);\n        break;\n      }\n    }\n\n    if (!useFullText) {\n      return null;\n    }\n    const resource = SDK.ResourceTreeModel.ResourceTreeModel.resourceForURL(url);\n    if (!resource) {\n      return null;\n    }\n    const content = TextUtils.ContentData.ContentData.contentDataOrEmpty(await resource.requestContentData());\n    return content.textObj;\n  }\n\n  entriesForExportBasedOnFullText(fullText: TextUtils.Text.Text): EntryForExport {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const entry: EntryForExport = {url: this.url(), ranges: [], text: fullText.value()};\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const {lineOffset, columnOffset} = info.getOffsets();\n      const offset = fullText ? fullText.offsetFromPosition(lineOffset, columnOffset) : 0;\n      entry.ranges.push(...info.rangesForExport(offset));\n    }\n    return entry;\n  }\n\n  async entriesForExportBasedOnContent(): Promise<EntryForExport[]> {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const result = [];\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const entry: EntryForExport = {\n        url: this.url(),\n        ranges: info.rangesForExport(),\n        text: TextUtils.ContentData.ContentData.textOr(await info.getContentProvider().requestContentData(), null),\n      };\n      result.push(entry);\n    }\n    return result;\n  }\n\n  async entriesForExport(): Promise<EntryForExport[]> {\n    const fullText = await this.getFullText();\n\n    // We have full text for this resource, resolve the offsets using the text line endings.\n    if (fullText) {\n      return [await this.entriesForExportBasedOnFullText(fullText)];\n    }\n\n    // Fall back to the per-script operation.\n    return await this.entriesForExportBasedOnContent();\n  }\n}\n\nexport class SourceURLCoverageInfo extends URLCoverageInfo {\n  generatedURLCoverageInfo: URLCoverageInfo;\n  lastSourceUsedRange: RangeOffset[] = [];\n  constructor(sourceUrl: Platform.DevToolsPath.UrlString, generatedUrlCoverage: URLCoverageInfo) {\n    super(sourceUrl);\n    this.generatedURLCoverageInfo = generatedUrlCoverage;\n  }\n}\n\nexport namespace URLCoverageInfo {\n  export enum Events {\n    /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n    SizesChanged = 'SizesChanged',\n    /* eslint-enable @typescript-eslint/naming-convention */\n  }\n\n  export interface EventTypes {\n    [Events.SizesChanged]: void;\n  }\n}\n\nexport const mergeSegments = (segmentsA: CoverageSegment[], segmentsB: CoverageSegment[]): CoverageSegment[] => {\n  const result: CoverageSegment[] = [];\n\n  let indexA = 0;\n  let indexB = 0;\n  while (indexA < segmentsA.length && indexB < segmentsB.length) {\n    const a = segmentsA[indexA];\n    const b = segmentsB[indexB];\n    const count = (a.count || 0) + (b.count || 0);\n    const end = Math.min(a.end, b.end);\n    const last = result[result.length - 1];\n    const stamp = Math.min(a.stamp, b.stamp);\n    if (!last || last.count !== count || last.stamp !== stamp) {\n      result.push({end, count, stamp});\n    } else {\n      last.end = end;\n    }\n    if (a.end <= b.end) {\n      indexA++;\n    }\n    if (a.end >= b.end) {\n      indexB++;\n    }\n  }\n\n  for (; indexA < segmentsA.length; indexA++) {\n    result.push(segmentsA[indexA]);\n  }\n  for (; indexB < segmentsB.length; indexB++) {\n    result.push(segmentsB[indexB]);\n  }\n  return result;\n};\n\nexport class CoverageInfo {\n  private contentProvider: TextUtils.ContentProvider.ContentProvider;\n  private size: number;\n  private usedSize: number;\n  private statsByTimestamp: Map<number, number>;\n  private lineOffset: number;\n  private columnOffset: number;\n  private coverageType: CoverageType;\n  private segments: CoverageSegment[];\n  private generatedUrlCoverageInfo: URLCoverageInfo;\n  sourceUsedSizeMap = new Map<Platform.DevToolsPath.UrlString, number>();\n  sourceDeltaMap = new Map<Platform.DevToolsPath.UrlString, number>();\n  sourceUsedRangeMap = new Map<Platform.DevToolsPath.UrlString, RangeOffset[]>();\n\n  constructor(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, size: number, lineOffset: number,\n      columnOffset: number, type: CoverageType, generatedUrlCoverageInfo: URLCoverageInfo) {\n    this.contentProvider = contentProvider;\n    this.size = size;\n    this.usedSize = 0;\n    this.statsByTimestamp = new Map();\n    this.lineOffset = lineOffset;\n    this.columnOffset = columnOffset;\n    this.coverageType = type;\n    this.generatedUrlCoverageInfo = generatedUrlCoverageInfo;\n\n    this.segments = [];\n  }\n\n  getContentProvider(): TextUtils.ContentProvider.ContentProvider {\n    return this.contentProvider;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.contentProvider.contentURL();\n  }\n\n  type(): CoverageType {\n    return this.coverageType;\n  }\n\n  addCoverageType(type: CoverageType): void {\n    this.coverageType |= type;\n  }\n\n  getOffsets(): {lineOffset: number, columnOffset: number} {\n    return {lineOffset: this.lineOffset, columnOffset: this.columnOffset};\n  }\n\n  /**\n   * Returns the delta by which usedSize increased.\n   */\n  mergeCoverage(segments: CoverageSegment[]): number {\n    const oldUsedSize = this.usedSize;\n    this.segments = mergeSegments(this.segments, segments);\n    this.updateStats();\n    if (this.generatedUrlCoverageInfo.sourceSegments && this.generatedUrlCoverageInfo.sourceSegments.length > 0) {\n      this.updateSourceCoverage();\n    }\n    return this.usedSize - oldUsedSize;\n  }\n\n  getSize(): number {\n    return this.size;\n  }\n\n  getUsedSize(): number {\n    return this.usedSize;\n  }\n\n  usageForRange(start: number, end: number): boolean {\n    let index = Platform.ArrayUtilities.upperBound(this.segments, start, (position, segment) => position - segment.end);\n    for (; index < this.segments.length && this.segments[index].end < end; ++index) {\n      if (this.segments[index].count) {\n        return true;\n      }\n    }\n    return index < this.segments.length && Boolean(this.segments[index].count);\n  }\n\n  private updateStats(): void {\n    this.statsByTimestamp = new Map();\n    this.usedSize = 0;\n\n    let last = 0;\n    for (const segment of this.segments) {\n      let previousCount = this.statsByTimestamp.get(segment.stamp);\n      if (previousCount === undefined) {\n        previousCount = 0;\n      }\n\n      if (segment.count) {\n        const used = segment.end - last;\n        this.usedSize += used;\n        this.statsByTimestamp.set(segment.stamp, previousCount + used);\n      }\n      last = segment.end;\n    }\n  }\n\n  private updateSourceCoverage(): void {\n    const sourceCoverage = new Map();\n    this.sourceDeltaMap = new Map();\n    this.sourceUsedRangeMap = new Map();\n    const ranges = this.generatedUrlCoverageInfo.sourceSegments || [];\n    let segmentStart = 0;\n    let lastFoundRange = 0;\n    for (const segment of this.segments) {\n      const segmentEnd = segment.end;\n      if (segment.count) {\n        for (let i = lastFoundRange; i < ranges.length; i++) {\n          // Calculate the start point of the current range.\n          // If it's the first range, the start point is 0,\n          // otherwise, it's one more than the end point of the previous range.\n          const rangeStart = i === 0 ? 0 : ranges[i - 1].end + 1;\n          const rangeEnd = ranges[i].end;\n          // Calculate the start and end points of the overlap between the current segment and range\n          const overlapStart = Math.max(segmentStart, rangeStart);\n          const overlapEnd = Math.min(segmentEnd, rangeEnd);\n\n          // If there's an overlap (start point is less than or equal to end point)\n          if (overlapStart <= overlapEnd) {\n            const overlapSize = overlapEnd - overlapStart + 1;\n            const overlapRange = {start: overlapStart, end: overlapEnd};\n            if (!sourceCoverage.has(ranges[i].sourceUrl)) {\n              sourceCoverage.set(ranges[i].sourceUrl, overlapSize);\n            } else {\n              sourceCoverage.set(ranges[i].sourceUrl, sourceCoverage.get(ranges[i].sourceUrl) + overlapSize);\n            }\n            if (!this.sourceUsedRangeMap.has(ranges[i].sourceUrl)) {\n              this.sourceUsedRangeMap.set(ranges[i].sourceUrl, [overlapRange]);\n            } else {\n              this.sourceUsedRangeMap.get(ranges[i].sourceUrl)?.push(overlapRange);\n            }\n            // The next overlap will start at or after the end of the current range\n            lastFoundRange = i;\n          }\n          // The segment end is before the end of the current range, so we can stop looking for overlaps\n          if (segmentEnd < rangeEnd) {\n            break;\n          }\n        }\n      }\n      segmentStart = segmentEnd + 1;\n    }\n\n    for (const [url, size] of sourceCoverage) {\n      const oldSize = this.sourceUsedSizeMap.get(url) || 0;\n      if (oldSize !== size) {\n        this.sourceUsedSizeMap.set(url, size);         // update the map tracking the old used size\n        this.sourceDeltaMap.set(url, size - oldSize);  // update the map tracking the delta\n      }\n    }\n  }\n\n  rangesForExport(offset = 0): Array<{start: number, end: number}> {\n    const ranges = [];\n    let start = 0;\n    for (const segment of this.segments) {\n      if (segment.count) {\n        const last = ranges.length > 0 ? ranges[ranges.length - 1] : null;\n        if (last && last.end === start + offset) {\n          // We can extend the last segment.\n          last.end = segment.end + offset;\n        } else {\n          // There was a gap, add a new segment.\n          ranges.push({start: start + offset, end: segment.end + offset});\n        }\n      }\n      start = segment.end;\n    }\n    return ranges;\n  }\n}\nexport interface RangeUseCount {\n  startOffset: number;\n  endOffset: number;\n  count: number;\n}\nexport interface CoverageSegment {\n  end: number;\n  count: number;\n  stamp: number;\n}\n\nexport interface SourceSegment {\n  end: number;\n  sourceUrl: Platform.DevToolsPath.UrlString;\n}\n\nexport interface EntryRange {\n  range: TextUtils.TextRange.TextRange;\n  sourceRange: TextUtils.TextRange.TextRange;\n  sourceURL: Platform.DevToolsPath.UrlString;\n}\n\nexport interface RangeOffset {\n  start: number;\n  end: number;\n}\n\nexport interface SourceMapObject {\n  script: SDK.Script.Script;\n  sourceMap: SDK.SourceMap.SourceMap;\n}\n", "// Copyright 2017 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nimport * as DataGrid from '../../ui/legacy/components/data_grid/data_grid.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport {Directives, html, nothing, render} from '../../ui/lit/lit.js';\n\nimport coverageListViewStyles from './coverageListView.css.js';\nimport {CoverageType} from './CoverageModel.js';\n\nexport interface CoverageListItem {\n  url: Platform.DevToolsPath.UrlString;\n  type: CoverageType;\n  size: number;\n  usedSize: number;\n  unusedSize: number;\n  usedPercentage: number;\n  unusedPercentage: number;\n  sources: CoverageListItem[];\n  isContentScript: boolean;\n  generatedUrl?: Platform.DevToolsPath.UrlString;\n}\n\nconst UIStrings = {\n  /**\n   * @description Text that appears on a button for the css resource type filter.\n   */\n  css: 'CSS',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  jsPerFunction: 'JS (per function)',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  jsPerBlock: 'JS (per block)',\n  /**\n   * @description Text for web URLs\n   */\n  url: 'URL',\n  /**\n   * @description Text that refers to some types\n   */\n  type: 'Type',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  totalBytes: 'Total Bytes',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  unusedBytes: 'Unused Bytes',\n  /**\n   * @description Text in the Coverage List View of the Coverage Tab\n   */\n  usageVisualization: 'Usage Visualization',\n  /**\n   * @description Data grid name for Coverage data grids\n   */\n  codeCoverage: 'Code Coverage',\n  /**\n   * @description Cell title in Coverage List View of the Coverage tab. The coverage tool tells\n   *developers which functions (logical groups of lines of code) were actually run/executed. If a\n   *function does get run, then it is marked in the UI to indicate that it was covered.\n   */\n  jsCoverageWithPerFunction:\n      'JS coverage with per function granularity: Once a function was executed, the whole function is marked as covered.',\n  /**\n   * @description Cell title in Coverage List View of the Coverage tab. The coverage tool tells\n   *developers which blocks (logical groups of lines of code, smaller than a function) were actually\n   *run/executed. If a block does get run, then it is marked in the UI to indicate that it was\n   *covered.\n   */\n  jsCoverageWithPerBlock:\n      'JS coverage with per block granularity: Once a block of JavaScript was executed, that block is marked as covered.',\n  /**\n   * @description Accessible text for the value in bytes in memory allocation or coverage view.\n   */\n  sBytes: '{n, plural, =1 {# byte} other {# bytes}}',\n  /**\n   * @description Accessible text for the unused bytes column in the coverage tool that describes the total unused bytes and percentage of the file unused.\n   * @example {88%} percentage\n   */\n  sBytesS: '{n, plural, =1 {# byte, {percentage}} other {# bytes, {percentage}}}',\n  /**\n   * @description Tooltip text for the bar in the coverage list view of the coverage tool that illustrates the relation between used and unused bytes.\n   * @example {1000} PH1\n   * @example {12.34} PH2\n   */\n  sBytesSBelongToFunctionsThatHave: '{PH1} bytes ({PH2}) belong to functions that have not (yet) been executed.',\n  /**\n   * @description Tooltip text for the bar in the coverage list view of the coverage tool that illustrates the relation between used and unused bytes.\n   * @example {1000} PH1\n   * @example {12.34} PH2\n   */\n  sBytesSBelongToBlocksOf: '{PH1} bytes ({PH2}) belong to blocks of JavaScript that have not (yet) been executed.',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   * @example {1000} PH1\n   * @example {12.34} PH2\n   */\n  sBytesSBelongToFunctionsThatHaveExecuted: '{PH1} bytes ({PH2}) belong to functions that have executed at least once.',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   * @example {1000} PH1\n   * @example {12.34} PH2\n   */\n  sBytesSBelongToBlocksOfJavascript:\n      '{PH1} bytes ({PH2}) belong to blocks of JavaScript that have executed at least once.',\n  /**\n   * @description Accessible text for the visualization column of coverage tool. Contains percentage of unused bytes to used bytes.\n   * @example {12.3} PH1\n   * @example {12.3} PH2\n   */\n  sOfFileUnusedSOfFileUsed: '{PH1} % of file unused, {PH2} % of file used',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/coverage/CoverageListView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst {styleMap} = Directives;\n\nexport function coverageTypeToString(type: CoverageType): string {\n  const types = [];\n  if (type & CoverageType.CSS) {\n    types.push(i18nString(UIStrings.css));\n  }\n  if (type & CoverageType.JAVA_SCRIPT_PER_FUNCTION) {\n    types.push(i18nString(UIStrings.jsPerFunction));\n  } else if (type & CoverageType.JAVA_SCRIPT) {\n    types.push(i18nString(UIStrings.jsPerBlock));\n  }\n  return types.join('+');\n}\n\nexport class CoverageListView extends UI.Widget.VBox {\n  private readonly nodeForUrl: Map<Platform.DevToolsPath.UrlString, GridNode>;\n  private highlightRegExp: RegExp|null;\n  private dataGrid: DataGrid.SortableDataGrid.SortableDataGrid<GridNode>;\n\n  constructor() {\n    super({useShadowDom: true});\n    this.registerRequiredCSS(coverageListViewStyles);\n    this.nodeForUrl = new Map();\n    this.highlightRegExp = null;\n\n    const columns = [\n      {\n        id: 'url',\n        title: i18nString(UIStrings.url),\n        width: '250px',\n        weight: 3,\n        fixedWidth: false,\n        sortable: true,\n        disclosure: true,\n      },\n      {id: 'type', title: i18nString(UIStrings.type), width: '45px', weight: 1, fixedWidth: true, sortable: true},\n      {\n        id: 'size',\n        title: i18nString(UIStrings.totalBytes),\n        width: '60px',\n        fixedWidth: true,\n        sortable: true,\n        align: DataGrid.DataGrid.Align.RIGHT,\n        weight: 1,\n      },\n      {\n        id: 'unused-size',\n        title: i18nString(UIStrings.unusedBytes),\n        width: '100px',\n        fixedWidth: true,\n        sortable: true,\n        align: DataGrid.DataGrid.Align.RIGHT,\n        sort: DataGrid.DataGrid.Order.Descending,\n        weight: 1,\n      },\n      {\n        id: 'bars',\n        title: i18nString(UIStrings.usageVisualization),\n        width: '250px',\n        fixedWidth: false,\n        sortable: true,\n        weight: 1,\n      },\n    ] as DataGrid.DataGrid.ColumnDescriptor[];\n    this.dataGrid =\n        DataGrid.SortableDataGrid.SortableDataGrid.create(['dummy'], [], i18nString(UIStrings.codeCoverage)) as\n        DataGrid.SortableDataGrid.SortableDataGrid<GridNode>;\n    this.dataGrid.removeColumn('dummy');\n    for (const column of columns) {\n      this.dataGrid.addColumn(column);\n    }\n    this.dataGrid.setColumnsVisibility(new Set(columns.map(column => column.id)));\n    this.dataGrid.setResizeMethod(DataGrid.DataGrid.ResizeMethod.LAST);\n    this.dataGrid.setStriped(true);\n    this.dataGrid.element.classList.add('flex-auto');\n    this.dataGrid.addEventListener(DataGrid.DataGrid.Events.OPENED_NODE, this.onOpenedNode, this);\n\n    const dataGridWidget = this.dataGrid.asWidget();\n    dataGridWidget.show(this.contentElement);\n    this.setDefaultFocusedChild(dataGridWidget);\n  }\n\n  update(coverageInfo: CoverageListItem[], highlightRegExp: RegExp|null): void {\n    this.highlightRegExp = highlightRegExp;\n    const maxSize = coverageInfo.reduce((acc, entry) => Math.max(acc, entry.size), 0);\n\n    const coverageUrls = new Set(coverageInfo.map(info => info.url));\n    for (const [url, node] of this.nodeForUrl.entries()) {\n      if (!coverageUrls.has(url)) {\n        node.remove();\n        this.nodeForUrl.delete(url);\n      }\n    }\n\n    let hadUpdates = false;\n    for (const entry of coverageInfo) {\n      let node = this.nodeForUrl.get(entry.url);\n      if (node) {\n        hadUpdates = node.refreshIfNeeded(maxSize, entry) || hadUpdates;\n        if (entry.sources.length > 0) {\n          this.updateSourceNodes(entry.sources, maxSize, node);\n        }\n        node.setHighlight(this.highlightRegExp);\n        continue;\n      }\n      node = new GridNode(entry, maxSize);\n      this.nodeForUrl.set(entry.url, node);\n      this.appendNodeByType(node);\n      if (entry.sources.length > 0) {\n        this.updateSourceNodes(entry.sources, maxSize, node);\n      }\n      node.setHighlight(this.highlightRegExp);\n      hadUpdates = true;\n    }\n    if (hadUpdates) {\n      this.dataGrid.dispatchEventToListeners(DataGrid.DataGrid.Events.SORTING_CHANGED);\n    }\n  }\n\n  updateSourceNodes(sources: CoverageListItem[], maxSize: number, node: GridNode): void {\n    for (const coverageInfo of sources) {\n      const sourceNode = this.nodeForUrl.get(coverageInfo.url);\n      if (sourceNode) {\n        sourceNode.refreshIfNeeded(maxSize, coverageInfo);\n      } else {\n        const sourceNode = new GridNode(coverageInfo, maxSize);\n        node.appendChild(sourceNode);\n        this.nodeForUrl.set(coverageInfo.url, sourceNode);\n      }\n    }\n  }\n\n  reset(): void {\n    this.nodeForUrl.clear();\n    this.dataGrid.rootNode().removeChildren();\n  }\n\n  private appendNodeByType(node: GridNode): void {\n    if (node.coverageInfo.generatedUrl) {\n      const parentNode = this.nodeForUrl.get(node.coverageInfo.generatedUrl);\n      parentNode?.appendChild(node);\n    } else {\n      this.dataGrid.rootNode().appendChild(node);\n    }\n  }\n\n  selectByUrl(url: string): void {\n    const node = this.nodeForUrl.get(url as Platform.DevToolsPath.UrlString);\n    if (node) {\n      node.revealAndSelect();\n    }\n  }\n\n  private onOpenedNode(): void {\n    void this.revealSourceForSelectedNode();\n  }\n\n  private async revealSourceForSelectedNode(): Promise<void> {\n    const node = this.dataGrid.selectedNode;\n    if (!node) {\n      return;\n    }\n    const coverageInfo = (node as GridNode).coverageInfo;\n    const sourceCode = Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(coverageInfo.url);\n    if (!sourceCode) {\n      return;\n    }\n\n    if (this.dataGrid.selectedNode !== node) {\n      return;\n    }\n    void Common.Revealer.reveal(sourceCode);\n  }\n}\n\nlet percentageFormatter: Intl.NumberFormat|null = null;\n\nfunction getPercentageFormatter(): Intl.NumberFormat {\n  if (!percentageFormatter) {\n    percentageFormatter = new Intl.NumberFormat(i18n.DevToolsLocale.DevToolsLocale.instance().locale, {\n      style: 'percent',\n      maximumFractionDigits: 1,\n    });\n  }\n  return percentageFormatter;\n}\n\nlet bytesFormatter: Intl.NumberFormat|null = null;\n\nfunction getBytesFormatter(): Intl.NumberFormat {\n  if (!bytesFormatter) {\n    bytesFormatter = new Intl.NumberFormat(i18n.DevToolsLocale.DevToolsLocale.instance().locale);\n  }\n  return bytesFormatter;\n}\n\nexport class GridNode extends DataGrid.SortableDataGrid.SortableDataGridNode<GridNode> {\n  coverageInfo: CoverageListItem;\n  private lastUsedSize!: number|undefined;\n  private url: Platform.DevToolsPath.UrlString;\n  private maxSize: number;\n  private highlightRegExp: RegExp|null;\n\n  constructor(coverageInfo: CoverageListItem, maxSize: number) {\n    super();\n    this.coverageInfo = coverageInfo;\n    this.url = coverageInfo.url;\n    this.maxSize = maxSize;\n    this.highlightRegExp = null;\n    this.#updateData(coverageInfo);\n  }\n\n  #updateData(coverageInfo: CoverageListItem): void {\n    this.data['url'] = this.url;\n    this.data['type'] = coverageTypeToString(coverageInfo.type);\n    this.data['size'] = coverageInfo.size;\n    this.data['unused-size'] = coverageInfo.unusedSize;\n    this.data['bars'] = coverageInfo.unusedSize;\n    this.coverageInfo = coverageInfo;\n  }\n\n  setHighlight(highlightRegExp: RegExp|null): void {\n    if (this.highlightRegExp === highlightRegExp) {\n      return;\n    }\n    this.highlightRegExp = highlightRegExp;\n    for (const child of this.children) {\n      (child as GridNode).setHighlight(this.highlightRegExp);\n    }\n    this.refresh();\n  }\n\n  refreshIfNeeded(maxSize: number, coverageInfo: CoverageListItem): boolean {\n    if (this.lastUsedSize === coverageInfo.usedSize && maxSize === this.maxSize) {\n      return false;\n    }\n    this.lastUsedSize = coverageInfo.usedSize;\n    this.maxSize = maxSize;\n    this.refresh();\n    this.#updateData(coverageInfo);\n    return true;\n  }\n\n  override createCell(columnId: string): HTMLElement {\n    const cell = this.createTD(columnId);\n    const info = this.coverageInfo;\n    const formatBytes = (value: number|undefined): string => {\n      return getBytesFormatter().format(value ?? 0);\n    };\n    const formatPercent = (value: number|undefined): string => {\n      return getPercentageFormatter().format(value ?? 0);\n    };\n    switch (columnId) {\n      case 'url': {\n        UI.Tooltip.Tooltip.install(cell, this.url);\n        this.setCellAccessibleName(this.url, cell, columnId);\n        const splitURL = /^(.*)(\\/[^/]*)$/.exec(this.url);\n        render(\n            html`\n          <div class=\"url-outer\">\n            <div class=\"url-prefix\">${splitURL ? splitURL[1] : this.url}</div>\n            <div class=\"url-suffix\">${splitURL ? splitURL[2] : ''}</div>\n          </div>`,\n            cell);\n        if (this.highlightRegExp) {\n          this.highlight(cell, this.url);\n        }\n        break;\n      }\n      case 'type': {\n        UI.Tooltip.Tooltip.install(\n            cell,\n            info.type & CoverageType.JAVA_SCRIPT_PER_FUNCTION ? i18nString(UIStrings.jsCoverageWithPerFunction) :\n                info.type & CoverageType.JAVA_SCRIPT          ? i18nString(UIStrings.jsCoverageWithPerBlock) :\n                                                                '');\n        render(coverageTypeToString(this.coverageInfo.type), cell);\n        break;\n      }\n      case 'size': {\n        this.setCellAccessibleName(i18nString(UIStrings.sBytes, {n: info.size || 0}), cell, columnId);\n        render(html`<span>${formatBytes(info.size)}</span>`, cell);\n        break;\n      }\n      case 'unused-size': {\n        this.setCellAccessibleName(\n            i18nString(UIStrings.sBytesS, {n: info.unusedSize, percentage: formatPercent(info.unusedPercentage)}), cell,\n            columnId);\n        // clang-format off\n        render(html`\n          <span>${formatBytes(info.unusedSize)}</span>\n          <span class=\"percent-value\">\n            ${formatPercent(info.unusedPercentage)}\n          </span>`, cell);\n        // clang-format on\n        break;\n      }\n      case 'bars': {\n        this.setCellAccessibleName(\n            i18nString(\n                UIStrings.sOfFileUnusedSOfFileUsed,\n                {PH1: formatPercent(info.unusedPercentage), PH2: formatPercent(info.usedPercentage)}),\n            cell, columnId);\n        // clang-format off\n        render(html`\n          <div class=\"bar-container\">\n            ${info.unusedSize > 0 ? html`\n              <div class=\"bar bar-unused-size\"\n                  title=${\n                    info.type & CoverageType.JAVA_SCRIPT_PER_FUNCTION ? i18nString(UIStrings.sBytesSBelongToFunctionsThatHave, {PH1: info.unusedSize, PH2: formatPercent(info.unusedPercentage)}) :\n                    info.type & CoverageType.JAVA_SCRIPT              ? i18nString(UIStrings.sBytesSBelongToBlocksOf, {PH1: info.unusedSize, PH2: formatPercent(info.unusedPercentage)}) :\n                                                                          ''}\n                  style=${styleMap({width: ((info.unusedSize / this.maxSize) * 100 || 0) + '%'})}>\n              </div>` : nothing}\n            ${info.usedSize > 0 ? html`\n            <div class=\"bar bar-used-size\"\n                  title=${\n                    info.type & CoverageType.JAVA_SCRIPT_PER_FUNCTION ? i18nString(UIStrings.sBytesSBelongToFunctionsThatHaveExecuted, {PH1: info.usedSize, PH2: formatPercent(info.usedPercentage)}) :\n                    info.type & CoverageType.JAVA_SCRIPT              ? i18nString(UIStrings.sBytesSBelongToBlocksOfJavascript, {PH1: info.usedSize, PH2: formatPercent(info.usedPercentage)}) :\n                                                                          ''}\n                  { PH1: info.usedSize, PH2: formatPercent(info.usedPercentage) })}\n                style=${styleMap({width:((info.usedSize / this.maxSize) * 100 || 0) + '%'})}>\n            </div>` : nothing}\n          </div>`, cell);\n        // clang-format on\n      }\n    }\n    return cell;\n  }\n\n  private highlight(element: Element, textContent: string): void {\n    if (!this.highlightRegExp) {\n      return;\n    }\n    const matches = this.highlightRegExp.exec(textContent);\n    if (!matches?.length) {\n      return;\n    }\n    const range = new TextUtils.TextRange.SourceRange(matches.index, matches[0].length);\n    UI.UIUtils.highlightRangesWithStyleClass(element, [range], 'filter-highlight');\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2021 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.data-grid {\n  border: none;\n}\n\n.data-grid td .url-outer {\n  width: 100%;\n  display: inline-flex;\n  justify-content: flex-start;\n}\n\n.data-grid td .url-outer .filter-highlight {\n  font-weight: bold;\n}\n\n.data-grid td .url-prefix {\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.data-grid td .url-suffix {\n  flex: none;\n}\n\n.data-grid td .bar {\n  display: inline-block;\n  height: 8px;\n  border: 1px solid transparent;\n}\n\n.data-grid td .bar-unused-size {\n  background-color: var(--app-color-coverage-unused);\n}\n\n.data-grid td .bar-used-size {\n  background-color: var(--app-color-coverage-used);\n}\n\n.data-grid td .percent-value {\n  width: 7ex;\n  display: inline-block;\n  color: var(--sys-color-on-surface-subtle);\n}\n\n@media (forced-colors: active) {\n  .data-grid td .bar-container {\n    forced-color-adjust: none;\n  }\n\n  .data-grid td .bar-unused-size {\n    background-color: ButtonText;\n  }\n\n  .data-grid td .bar-used-size {\n    background-color: ButtonFace;\n  }\n\n  .data-grid td .bar {\n    border-color: ButtonText;\n  }\n\n  .data-grid .selected td .bar {\n    border-top-color: HighlightText;\n    border-bottom-color: HighlightText;\n  }\n\n  .data-grid .selected td .bar:last-child {\n    border-right-color: HighlightText;\n  }\n\n  .data-grid .selected td .bar:first-child {\n    border-left-color: HighlightText;\n  }\n\n  .data-grid:focus tr.selected span.percent-value {\n    color: HighlightText;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./coverageListView.css')} */`;", "// Copyright 2016 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport '../../ui/legacy/legacy.js';\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nimport * as Buttons from '../../ui/components/buttons/buttons.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as VisualLogging from '../../ui/visual_logging/visual_logging.js';\n\nimport {CoverageDecorationManager} from './CoverageDecorationManager.js';\nimport {type CoverageListItem, CoverageListView} from './CoverageListView.js';\nimport {\n  type CoverageInfo,\n  CoverageModel,\n  CoverageType,\n  Events,\n  SourceURLCoverageInfo,\n  type URLCoverageInfo,\n} from './CoverageModel.js';\nimport coverageViewStyles from './coverageView.css.js';\n\nconst UIStrings = {\n  /**\n   * @description Tooltip in Coverage List View of the Coverage tab for selecting JavaScript coverage mode\n   */\n  chooseCoverageGranularityPer:\n      'Choose coverage granularity: Per function has low overhead, per block has significant overhead.',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  perFunction: 'Per function',\n  /**\n   * @description Text in Coverage List View of the Coverage tab\n   */\n  perBlock: 'Per block',\n  /**\n   * @description Text in Coverage View of the Coverage tab\n   */\n  filterByUrl: 'Filter by URL',\n  /**\n   * @description Label for the type filter in the Coverage Panel\n   */\n  filterCoverageByType: 'Filter coverage by type',\n  /**\n   * @description Text for everything\n   */\n  all: 'All',\n  /**\n   * @description Text that appears on a button for the css resource type filter.\n   */\n  css: 'CSS',\n  /**\n   * @description Text in Timeline Tree View of the Performance panel\n   */\n  javascript: 'JavaScript',\n  /**\n   * @description Tooltip text that appears on the setting when hovering over it in Coverage View of the Coverage tab\n   */\n  includeExtensionContentScripts: 'Include extension content scripts',\n  /**\n   * @description Title for a type of source files\n   */\n  contentScripts: 'Content scripts',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   */\n  noCoverageData: 'No coverage data',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   */\n  reloadPage: 'Reload page',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   */\n  startRecording: 'Start recording',\n\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   * @example {Reload page} PH1\n   */\n  clickTheReloadButtonSToReloadAnd: 'Click the \"{PH1}\" button to reload and start capturing coverage.',\n  /**\n   * @description Message in Coverage View of the Coverage tab\n   * @example {Start recording} PH1\n   */\n  clickTheRecordButtonSToStart: 'Click the \"{PH1}\" button to start capturing coverage.',\n  /**\n   * @description Message in the Coverage View explaining that DevTools could not capture coverage.\n   */\n  bfcacheNoCapture: 'Could not capture coverage info because the page was served from the back/forward cache.',\n  /**\n   * @description  Message in the Coverage View explaining that DevTools could not capture coverage.\n   */\n  activationNoCapture: 'Could not capture coverage info because the page was prerendered in the background.',\n  /**\n   * @description  Message in the Coverage View prompting the user to reload the page.\n   * @example {reload button icon} PH1\n   */\n  reloadPrompt: 'Click the reload button {PH1} to reload and get coverage.',\n\n  /**\n   * @description Footer message in Coverage View of the Coverage tab\n   * @example {300k used, 600k unused} PH1\n   * @example {500k used, 800k unused} PH2\n   */\n  filteredSTotalS: 'Filtered: {PH1}  Total: {PH2}',\n  /**\n   * @description Footer message in Coverage View of the Coverage tab\n   * @example {1.5 MB} PH1\n   * @example {2.1 MB} PH2\n   * @example {71%} PH3\n   * @example {29%} PH4\n   */\n  sOfSSUsedSoFarSUnused: '{PH1} of {PH2} ({PH3}%) used so far, {PH4} unused.',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/coverage/CoverageView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nlet coverageViewInstance: CoverageView|undefined;\n\nexport class CoverageView extends UI.Widget.VBox {\n  private model: CoverageModel|null;\n  private decorationManager: CoverageDecorationManager|null;\n  private readonly coverageTypeComboBox: UI.Toolbar.ToolbarComboBox;\n  private readonly coverageTypeComboBoxSetting: Common.Settings.Setting<number>;\n  private toggleRecordAction: UI.ActionRegistration.Action;\n  private readonly toggleRecordButton: UI.Toolbar.ToolbarButton;\n  private inlineReloadButton: Element|null;\n  private readonly startWithReloadButton: UI.Toolbar.ToolbarButton|undefined;\n  private readonly clearAction: UI.ActionRegistration.Action;\n  private readonly exportAction: UI.ActionRegistration.Action;\n  private textFilterRegExp: RegExp|null;\n  private readonly filterInput: UI.Toolbar.ToolbarInput;\n  private typeFilterValue: number|null;\n  private readonly filterByTypeComboBox: UI.Toolbar.ToolbarComboBox;\n  private showContentScriptsSetting: Common.Settings.Setting<boolean>;\n  private readonly contentScriptsCheckbox: UI.Toolbar.ToolbarSettingCheckbox;\n  private readonly coverageResultsElement: HTMLElement;\n  private readonly landingPage: UI.Widget.VBox;\n  private readonly bfcacheReloadPromptPage: UI.Widget.VBox;\n  private readonly activationReloadPromptPage: UI.Widget.VBox;\n  private listView: CoverageListView;\n  private readonly statusToolbarElement: HTMLElement;\n  private statusMessageElement: HTMLElement;\n\n  constructor() {\n    super({\n      jslog: `${VisualLogging.panel('coverage').track({resize: true})}`,\n      useShadowDom: true,\n    });\n    this.registerRequiredCSS(coverageViewStyles);\n\n    this.model = null;\n    this.decorationManager = null;\n\n    const toolbarContainer = this.contentElement.createChild('div', 'coverage-toolbar-container');\n    toolbarContainer.setAttribute('jslog', `${VisualLogging.toolbar()}`);\n    toolbarContainer.role = 'toolbar';\n    const toolbar = toolbarContainer.createChild('devtools-toolbar', 'coverage-toolbar');\n    toolbar.role = 'presentation';\n    toolbar.wrappable = true;\n\n    this.coverageTypeComboBox = new UI.Toolbar.ToolbarComboBox(\n        this.onCoverageTypeComboBoxSelectionChanged.bind(this), i18nString(UIStrings.chooseCoverageGranularityPer),\n        undefined, 'coverage-type');\n    const coverageTypes = [\n      {\n        label: i18nString(UIStrings.perFunction),\n        value: CoverageType.JAVA_SCRIPT | CoverageType.JAVA_SCRIPT_PER_FUNCTION,\n      },\n      {\n        label: i18nString(UIStrings.perBlock),\n        value: CoverageType.JAVA_SCRIPT,\n      },\n    ];\n    for (const type of coverageTypes) {\n      this.coverageTypeComboBox.addOption(this.coverageTypeComboBox.createOption(type.label, `${type.value}`));\n    }\n    this.coverageTypeComboBoxSetting =\n        Common.Settings.Settings.instance().createSetting('coverage-view-coverage-type', 0);\n    this.coverageTypeComboBox.setSelectedIndex(this.coverageTypeComboBoxSetting.get());\n    this.coverageTypeComboBox.setEnabled(true);\n    toolbar.appendToolbarItem(this.coverageTypeComboBox);\n    this.toggleRecordAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.toggle-recording');\n    this.toggleRecordButton = UI.Toolbar.Toolbar.createActionButton(this.toggleRecordAction);\n    toolbar.appendToolbarItem(this.toggleRecordButton);\n\n    const mainTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n    const mainTargetSupportsRecordOnReload = mainTarget?.model(SDK.ResourceTreeModel.ResourceTreeModel);\n    this.inlineReloadButton = null;\n    if (mainTargetSupportsRecordOnReload) {\n      this.startWithReloadButton = UI.Toolbar.Toolbar.createActionButton('coverage.start-with-reload');\n      toolbar.appendToolbarItem(this.startWithReloadButton);\n      this.toggleRecordButton.setEnabled(false);\n      this.toggleRecordButton.setVisible(false);\n    }\n    this.clearAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.clear');\n    this.clearAction.setEnabled(false);\n    toolbar.appendToolbarItem(UI.Toolbar.Toolbar.createActionButton(this.clearAction));\n\n    toolbar.appendSeparator();\n    this.exportAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.export');\n    this.exportAction.setEnabled(false);\n    toolbar.appendToolbarItem(UI.Toolbar.Toolbar.createActionButton(this.exportAction));\n\n    this.textFilterRegExp = null;\n    toolbar.appendSeparator();\n    this.filterInput = new UI.Toolbar.ToolbarFilter(i18nString(UIStrings.filterByUrl), 1, 1);\n    this.filterInput.setEnabled(false);\n    this.filterInput.addEventListener(UI.Toolbar.ToolbarInput.Event.TEXT_CHANGED, this.onFilterChanged, this);\n    toolbar.appendToolbarItem(this.filterInput);\n\n    toolbar.appendSeparator();\n\n    this.typeFilterValue = null;\n    this.filterByTypeComboBox = new UI.Toolbar.ToolbarComboBox(\n        this.onFilterByTypeChanged.bind(this), i18nString(UIStrings.filterCoverageByType), undefined,\n        'coverage-by-type');\n    const options = [\n      {\n        label: i18nString(UIStrings.all),\n        value: '',\n      },\n      {\n        label: i18nString(UIStrings.css),\n        value: CoverageType.CSS,\n      },\n      {\n        label: i18nString(UIStrings.javascript),\n        value: CoverageType.JAVA_SCRIPT | CoverageType.JAVA_SCRIPT_PER_FUNCTION,\n      },\n    ];\n    for (const option of options) {\n      this.filterByTypeComboBox.addOption(this.filterByTypeComboBox.createOption(option.label, `${option.value}`));\n    }\n\n    this.filterByTypeComboBox.setSelectedIndex(0);\n    this.filterByTypeComboBox.setEnabled(false);\n    toolbar.appendToolbarItem(this.filterByTypeComboBox);\n\n    toolbar.appendSeparator();\n    this.showContentScriptsSetting = Common.Settings.Settings.instance().createSetting('show-content-scripts', false);\n    this.showContentScriptsSetting.addChangeListener(this.onFilterChanged, this);\n    this.contentScriptsCheckbox = new UI.Toolbar.ToolbarSettingCheckbox(\n        this.showContentScriptsSetting, i18nString(UIStrings.includeExtensionContentScripts),\n        i18nString(UIStrings.contentScripts));\n    this.contentScriptsCheckbox.setEnabled(false);\n    toolbar.appendToolbarItem(this.contentScriptsCheckbox);\n\n    this.coverageResultsElement = this.contentElement.createChild('div', 'coverage-results');\n    this.landingPage = this.buildLandingPage();\n    this.bfcacheReloadPromptPage = this.buildReloadPromptPage(i18nString(UIStrings.bfcacheNoCapture), 'bfcache-page');\n    this.activationReloadPromptPage =\n        this.buildReloadPromptPage(i18nString(UIStrings.activationNoCapture), 'prerender-page');\n    this.listView = new CoverageListView();\n\n    this.statusToolbarElement = this.contentElement.createChild('div', 'coverage-toolbar-summary');\n    this.statusMessageElement = this.statusToolbarElement.createChild('div', 'coverage-message');\n    this.landingPage.show(this.coverageResultsElement);\n  }\n\n  static instance(): CoverageView {\n    if (!coverageViewInstance) {\n      coverageViewInstance = new CoverageView();\n    }\n    return coverageViewInstance;\n  }\n\n  static removeInstance(): void {\n    coverageViewInstance = undefined;\n  }\n\n  private buildLandingPage(): UI.Widget.VBox {\n    const widget = new UI.EmptyWidget.EmptyWidget(i18nString(UIStrings.noCoverageData), '');\n    widget.link = 'https://developer.chrome.com/docs/devtools/coverage' as Platform.DevToolsPath.UrlString;\n    if (this.startWithReloadButton) {\n      const action = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.start-with-reload');\n      if (action) {\n        widget.text = i18nString(UIStrings.clickTheReloadButtonSToReloadAnd, {PH1: i18nString(UIStrings.reloadPage)});\n        const button = UI.UIUtils.createTextButton(\n            i18nString(UIStrings.reloadPage), () => action.execute(),\n            {jslogContext: action.id(), variant: Buttons.Button.Variant.TONAL});\n        widget.contentElement.append(button);\n      }\n    } else {\n      widget.text = i18nString(UIStrings.clickTheRecordButtonSToStart, {PH1: i18nString(UIStrings.startRecording)});\n      const button = UI.UIUtils.createTextButton(\n          i18nString(UIStrings.startRecording), () => this.toggleRecordAction.execute(),\n          {jslogContext: this.toggleRecordAction.id(), variant: Buttons.Button.Variant.TONAL});\n      widget.contentElement.append(button);\n    }\n    return widget;\n  }\n\n  private buildReloadPromptPage(message: Common.UIString.LocalizedString, className: string): UI.Widget.VBox {\n    const widget = new UI.Widget.VBox();\n    const reasonDiv = document.createElement('div');\n    reasonDiv.classList.add('message');\n    reasonDiv.textContent = message;\n    widget.contentElement.appendChild(reasonDiv);\n    this.inlineReloadButton =\n        UI.UIUtils.createInlineButton(UI.Toolbar.Toolbar.createActionButton('inspector-main.reload'));\n    const messageElement =\n        i18n.i18n.getFormatLocalizedString(str_, UIStrings.reloadPrompt, {PH1: this.inlineReloadButton});\n    messageElement.classList.add('message');\n    widget.contentElement.appendChild(messageElement);\n    widget.element.classList.add(className);\n    return widget;\n  }\n\n  clear(): void {\n    if (this.model) {\n      this.model.reset();\n    }\n    this.reset();\n  }\n\n  private reset(): void {\n    if (this.decorationManager) {\n      this.decorationManager.dispose();\n      this.decorationManager = null;\n    }\n    this.listView.reset();\n    this.listView.detach();\n    this.landingPage.show(this.coverageResultsElement);\n    this.statusMessageElement.textContent = '';\n    this.filterInput.setEnabled(false);\n    this.filterByTypeComboBox.setEnabled(false);\n    this.contentScriptsCheckbox.setEnabled(false);\n    this.exportAction.setEnabled(false);\n  }\n\n  toggleRecording(): void {\n    const enable = !this.toggleRecordAction.toggled();\n\n    if (enable) {\n      void this.startRecording({reload: false, jsCoveragePerBlock: this.isBlockCoverageSelected()});\n    } else {\n      void this.stopRecording();\n    }\n  }\n\n  isBlockCoverageSelected(): boolean {\n    const option = this.coverageTypeComboBox.selectedOption();\n    const coverageType = Number(option ? option.value : Number.NaN);\n    // Check that Coverage.CoverageType.JavaScriptPerFunction is not present.\n    return coverageType === CoverageType.JAVA_SCRIPT;\n  }\n\n  private selectCoverageType(jsCoveragePerBlock: boolean): void {\n    const selectedIndex = jsCoveragePerBlock ? 1 : 0;\n    this.coverageTypeComboBox.setSelectedIndex(selectedIndex);\n  }\n\n  private onCoverageTypeComboBoxSelectionChanged(): void {\n    this.coverageTypeComboBoxSetting.set(this.coverageTypeComboBox.selectedIndex());\n  }\n\n  async startRecording(options: {reload: (boolean|undefined), jsCoveragePerBlock: (boolean|undefined)}|null):\n      Promise<void> {\n    let hadFocus, reloadButtonFocused;\n    if ((this.startWithReloadButton?.element.hasFocus()) || (this.inlineReloadButton?.hasFocus())) {\n      reloadButtonFocused = true;\n    } else if (this.hasFocus()) {\n      hadFocus = true;\n    }\n\n    this.reset();\n    const mainTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n    if (!mainTarget) {\n      return;\n    }\n\n    const {reload, jsCoveragePerBlock} = {reload: false, jsCoveragePerBlock: false, ...options};\n\n    if (!this.model || reload) {\n      this.model = mainTarget.model(CoverageModel);\n    }\n    if (!this.model) {\n      return;\n    }\n    Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageStarted);\n    if (jsCoveragePerBlock) {\n      Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageStartedPerBlock);\n    }\n    const success = await this.model.start(Boolean(jsCoveragePerBlock));\n    if (!success) {\n      return;\n    }\n    this.selectCoverageType(Boolean(jsCoveragePerBlock));\n    this.model.addEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n    this.model.addEventListener(Events.SourceMapResolved, this.updateListView, this);\n    const resourceTreeModel = mainTarget.model(SDK.ResourceTreeModel.ResourceTreeModel);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.PrimaryPageChanged,\n        this.onPrimaryPageChanged, this);\n    this.decorationManager = new CoverageDecorationManager(\n        this.model, Workspace.Workspace.WorkspaceImpl.instance(),\n        Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance(),\n        Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance());\n    this.toggleRecordAction.setToggled(true);\n    this.clearAction.setEnabled(false);\n    if (this.startWithReloadButton) {\n      this.startWithReloadButton.setEnabled(false);\n      this.startWithReloadButton.setVisible(false);\n      this.toggleRecordButton.setEnabled(true);\n      this.toggleRecordButton.setVisible(true);\n      if (reloadButtonFocused) {\n        this.toggleRecordButton.focus();\n      }\n    }\n    this.coverageTypeComboBox.setEnabled(false);\n    this.filterInput.setEnabled(true);\n    this.filterByTypeComboBox.setEnabled(true);\n    this.contentScriptsCheckbox.setEnabled(true);\n    if (this.landingPage.isShowing()) {\n      this.landingPage.detach();\n    }\n    this.listView.show(this.coverageResultsElement);\n    if (hadFocus && !reloadButtonFocused) {\n      this.listView.focus();\n    }\n    if (reload && resourceTreeModel) {\n      resourceTreeModel.reloadPage();\n    } else {\n      void this.model.startPolling();\n    }\n  }\n\n  private onCoverageDataReceived(event: Common.EventTarget.EventTargetEvent<CoverageInfo[]>): void {\n    const data = event.data;\n    this.updateViews(data);\n  }\n\n  private updateListView(): void {\n    const entries =\n        (this.model?.entries() || [])\n            .map(entry => this.toCoverageListItem(entry))\n            .filter(info => this.isVisible(info))\n            .map(\n                (entry: CoverageListItem) =>\n                    ({...entry, sources: entry.sources.filter((entry: CoverageListItem) => this.isVisible(entry))}));\n    this.listView.update(entries, this.textFilterRegExp);\n  }\n\n  private toCoverageListItem(info: URLCoverageInfo): CoverageListItem {\n    return {\n      url: info.url(),\n      type: info.type(),\n      size: info.size(),\n      usedSize: info.usedSize(),\n      unusedSize: info.unusedSize(),\n      usedPercentage: info.usedPercentage(),\n      unusedPercentage: info.unusedPercentage(),\n      sources: [...info.sourcesURLCoverageInfo.values()].map(this.toCoverageListItem, this),\n      isContentScript: info.isContentScript(),\n      generatedUrl: info instanceof SourceURLCoverageInfo ? info.generatedURLCoverageInfo.url() : undefined,\n    };\n  }\n\n  async stopRecording(): Promise<void> {\n    SDK.TargetManager.TargetManager.instance().removeModelListener(\n        SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.PrimaryPageChanged,\n        this.onPrimaryPageChanged, this);\n    if (this.hasFocus()) {\n      this.listView.focus();\n    }\n    // Stopping the model triggers one last poll to get the final data.\n    if (this.model) {\n      await this.model.stop();\n      this.model.removeEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n    }\n    this.toggleRecordAction.setToggled(false);\n    this.coverageTypeComboBox.setEnabled(true);\n    if (this.startWithReloadButton) {\n      this.startWithReloadButton.setEnabled(true);\n      this.startWithReloadButton.setVisible(true);\n      this.toggleRecordButton.setEnabled(false);\n      this.toggleRecordButton.setVisible(false);\n    }\n    this.clearAction.setEnabled(true);\n  }\n\n  private async onPrimaryPageChanged(\n      event: Common.EventTarget.EventTargetEvent<\n          {frame: SDK.ResourceTreeModel.ResourceTreeFrame, type: SDK.ResourceTreeModel.PrimaryPageChangeType}>):\n      Promise<void> {\n    const frame = event.data.frame;\n    const coverageModel = frame.resourceTreeModel().target().model(CoverageModel);\n    if (!coverageModel) {\n      return;\n    }\n    // If the primary page target has changed (due to MPArch activation), switch to new CoverageModel.\n    if (this.model !== coverageModel) {\n      if (this.model) {\n        await this.model.stop();\n        this.model.removeEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n      }\n      this.model = coverageModel;\n      const success = await this.model.start(this.isBlockCoverageSelected());\n      if (!success) {\n        return;\n      }\n\n      this.model.addEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n      this.decorationManager = new CoverageDecorationManager(\n          this.model, Workspace.Workspace.WorkspaceImpl.instance(),\n          Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance(),\n          Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance());\n    }\n\n    if (this.bfcacheReloadPromptPage.isShowing()) {\n      this.bfcacheReloadPromptPage.detach();\n      this.listView.show(this.coverageResultsElement);\n    }\n    if (this.activationReloadPromptPage.isShowing()) {\n      this.activationReloadPromptPage.detach();\n      this.listView.show(this.coverageResultsElement);\n    }\n    if (frame.backForwardCacheDetails.restoredFromCache) {\n      this.listView.detach();\n      this.bfcacheReloadPromptPage.show(this.coverageResultsElement);\n    }\n    if (event.data.type === SDK.ResourceTreeModel.PrimaryPageChangeType.ACTIVATION) {\n      this.listView.detach();\n      this.activationReloadPromptPage.show(this.coverageResultsElement);\n    }\n\n    this.model.reset();\n    this.decorationManager?.reset();\n    this.listView.reset();\n    void this.model.startPolling();\n  }\n\n  private updateViews(updatedEntries: CoverageInfo[]): void {\n    this.updateStats();\n    this.updateListView();\n    this.exportAction.setEnabled(this.model !== null && this.model.entries().length > 0);\n    this.decorationManager?.update(updatedEntries);\n  }\n\n  private updateStats(): void {\n    const all = {total: 0, unused: 0};\n    const filtered = {total: 0, unused: 0};\n    const filterApplied = this.textFilterRegExp !== null;\n    if (this.model) {\n      for (const info of this.model.entries()) {\n        all.total += info.size();\n        all.unused += info.unusedSize();\n        const listItem = this.toCoverageListItem(info);\n        if (this.isVisible(listItem)) {\n          if (this.textFilterRegExp?.test(info.url())) {\n            filtered.total += info.size();\n            filtered.unused += info.unusedSize();\n          } else {\n            // If it doesn't match the filter, calculate the stats from visible children if there are any\n            for (const childInfo of info.sourcesURLCoverageInfo.values()) {\n              if (this.isVisible(this.toCoverageListItem(childInfo))) {\n                filtered.total += childInfo.size();\n                filtered.unused += childInfo.unusedSize();\n              }\n            }\n          }\n        }\n      }\n    }\n    this.statusMessageElement.textContent = filterApplied ?\n        i18nString(UIStrings.filteredSTotalS, {PH1: formatStat(filtered), PH2: formatStat(all)}) :\n        formatStat(all);\n\n    function formatStat({total, unused}: {total: number, unused: number}): string {\n      const used = total - unused;\n      const percentUsed = total ? Math.round(100 * used / total) : 0;\n      return i18nString(UIStrings.sOfSSUsedSoFarSUnused, {\n        PH1: i18n.ByteUtilities.bytesToString(used),\n        PH2: i18n.ByteUtilities.bytesToString(total),\n        PH3: percentUsed,\n        PH4: i18n.ByteUtilities.bytesToString(unused),\n      });\n    }\n  }\n\n  private onFilterChanged(): void {\n    if (!this.listView) {\n      return;\n    }\n    const text = this.filterInput.value();\n    this.textFilterRegExp = text ? Platform.StringUtilities.createPlainTextSearchRegex(text, 'i') : null;\n    this.updateListView();\n    this.updateStats();\n  }\n\n  private onFilterByTypeChanged(): void {\n    if (!this.listView) {\n      return;\n    }\n\n    Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageReportFiltered);\n\n    const option = this.filterByTypeComboBox.selectedOption();\n    const type = option?.value;\n    this.typeFilterValue = parseInt(type || '', 10) || null;\n    this.updateListView();\n    this.updateStats();\n  }\n\n  private isVisible(coverageInfo: CoverageListItem): boolean {\n    const url = coverageInfo.url;\n    if (url.startsWith(CoverageView.EXTENSION_BINDINGS_URL_PREFIX)) {\n      return false;\n    }\n    if (coverageInfo.isContentScript && !this.showContentScriptsSetting.get()) {\n      return false;\n    }\n    if (this.typeFilterValue && !(coverageInfo.type & this.typeFilterValue)) {\n      return false;\n    }\n    // If it's a parent, check if any children are visible\n    if (coverageInfo.sources.length > 0) {\n      for (const sourceURLCoverageInfo of coverageInfo.sources) {\n        if (this.isVisible(sourceURLCoverageInfo)) {\n          return true;\n        }\n      }\n    }\n\n    return !this.textFilterRegExp || this.textFilterRegExp.test(url);\n  }\n\n  async exportReport(): Promise<void> {\n    const fos = new Bindings.FileUtils.FileOutputStream();\n    const fileName =\n        `Coverage-${Platform.DateUtilities.toISO8601Compact(new Date())}.json` as Platform.DevToolsPath.RawPathString;\n    const accepted = await fos.open(fileName);\n    if (!accepted) {\n      return;\n    }\n    this.model && await this.model.exportReport(fos);\n  }\n\n  selectCoverageItemByUrl(url: string): void {\n    this.listView.selectByUrl(url as Platform.DevToolsPath.UrlString);\n  }\n\n  static readonly EXTENSION_BINDINGS_URL_PREFIX = 'extensions::';\n\n  override wasShown(): void {\n    UI.Context.Context.instance().setFlavor(CoverageView, this);\n    super.wasShown();\n  }\n\n  override willHide(): void {\n    super.willHide();\n    UI.Context.Context.instance().setFlavor(CoverageView, null);\n  }\n}\n\nexport class ActionDelegate implements UI.ActionRegistration.ActionDelegate {\n  handleAction(_context: UI.Context.Context, actionId: string): boolean {\n    const coverageViewId = 'coverage';\n    void UI.ViewManager.ViewManager.instance()\n        .showView(coverageViewId, /** userGesture= */ false, /** omitFocus= */ true)\n        .then(() => {\n          const view = UI.ViewManager.ViewManager.instance().view(coverageViewId);\n          return view?.widget();\n        })\n        .then(widget => this.#handleAction(widget as CoverageView, actionId));\n\n    return true;\n  }\n\n  #handleAction(coverageView: CoverageView, actionId: string): void {\n    switch (actionId) {\n      case 'coverage.toggle-recording':\n        coverageView.toggleRecording();\n        break;\n      case 'coverage.start-with-reload':\n        void coverageView.startRecording({reload: true, jsCoveragePerBlock: coverageView.isBlockCoverageSelected()});\n        break;\n      case 'coverage.clear':\n        coverageView.clear();\n        break;\n      case 'coverage.export':\n        void coverageView.exportReport();\n        break;\n      default:\n        console.assert(false, `Unknown action: ${actionId}`);\n    }\n  }\n}\n", "// Copyright 2017 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as Bindings from '../../models/bindings/bindings.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\n\nimport type {CoverageInfo, CoverageModel} from './CoverageModel.js';\n\nexport const decoratorType = 'coverage';\n\nexport class CoverageDecorationManager {\n  private coverageModel: CoverageModel;\n  private readonly textByProvider: Map<TextUtils.ContentProvider.ContentProvider, TextUtils.Text.Text|null>;\n  private readonly uiSourceCodeByContentProvider:\n      Platform.MapUtilities.Multimap<TextUtils.ContentProvider.ContentProvider, Workspace.UISourceCode.UISourceCode>;\n\n  readonly #workspace: Workspace.Workspace.WorkspaceImpl;\n  readonly #debuggerBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding;\n  readonly #cssBinding: Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding;\n\n  constructor(\n      coverageModel: CoverageModel, workspace: Workspace.Workspace.WorkspaceImpl,\n      debuggerBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding,\n      cssBinding: Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding) {\n    this.coverageModel = coverageModel;\n    this.#workspace = workspace;\n    this.#debuggerBinding = debuggerBinding;\n    this.#cssBinding = cssBinding;\n\n    this.textByProvider = new Map();\n    this.uiSourceCodeByContentProvider = new Platform.MapUtilities.Multimap();\n\n    for (const uiSourceCode of this.#workspace.uiSourceCodes()) {\n      uiSourceCode.setDecorationData(decoratorType, this);\n    }\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.onUISourceCodeAdded, this);\n  }\n\n  reset(): void {\n    for (const uiSourceCode of this.#workspace.uiSourceCodes()) {\n      uiSourceCode.setDecorationData(decoratorType, undefined);\n    }\n  }\n\n  dispose(): void {\n    this.reset();\n    this.#workspace.removeEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.onUISourceCodeAdded, this);\n  }\n\n  update(updatedEntries: CoverageInfo[]): void {\n    for (const entry of updatedEntries) {\n      for (const uiSourceCode of this.uiSourceCodeByContentProvider.get(entry.getContentProvider())) {\n        uiSourceCode.setDecorationData(decoratorType, this);\n      }\n    }\n  }\n\n  /**\n   * Returns the coverage per line of the provided uiSourceCode. The resulting array has the same length\n   * as the provided `lines` array.\n   *\n   * @param uiSourceCode The UISourceCode for which to get the coverage info.\n   * @param lineMappings The caller might have applied formatting to the UISourceCode. Each entry\n   *                     in this array represents one line and the range specifies where it's found in\n   *                     the original content.\n   */\n  async usageByLine(uiSourceCode: Workspace.UISourceCode.UISourceCode, lineMappings: TextUtils.TextRange.TextRange[]):\n      Promise<Array<boolean|undefined>> {\n    const result = [];\n    await this.updateTexts(uiSourceCode, lineMappings);\n\n    for (const {startLine, startColumn, endLine, endColumn} of lineMappings) {\n      const startLocationsPromise = this.rawLocationsForSourceLocation(uiSourceCode, startLine, startColumn);\n      const endLocationsPromise = this.rawLocationsForSourceLocation(uiSourceCode, endLine, endColumn);\n      const [startLocations, endLocations] = await Promise.all([startLocationsPromise, endLocationsPromise]);\n      let used: (boolean|undefined)|undefined = undefined;\n      for (let startIndex = 0, endIndex = 0; startIndex < startLocations.length; ++startIndex) {\n        const start = startLocations[startIndex];\n        while (endIndex < endLocations.length &&\n               CoverageDecorationManager.compareLocations(start, endLocations[endIndex]) >= 0) {\n          ++endIndex;\n        }\n        if (endIndex >= endLocations.length || endLocations[endIndex].id !== start.id) {\n          continue;\n        }\n        const end = endLocations[endIndex++];\n        const text = this.textByProvider.get(end.contentProvider);\n        if (!text) {\n          continue;\n        }\n        const textValue = text.value();\n        let startOffset = Math.min(text.offsetFromPosition(start.line, start.column), textValue.length - 1);\n        let endOffset = Math.min(text.offsetFromPosition(end.line, end.column), textValue.length - 1);\n        while (startOffset <= endOffset && /\\s/.test(textValue[startOffset])) {\n          ++startOffset;\n        }\n        while (startOffset <= endOffset && /\\s/.test(textValue[endOffset])) {\n          --endOffset;\n        }\n        if (startOffset <= endOffset) {\n          used = this.coverageModel.usageForRange(end.contentProvider, startOffset, endOffset);\n        }\n        if (used) {\n          break;\n        }\n      }\n      result.push(used);\n    }\n    return result;\n  }\n\n  private async updateTexts(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineMappings: TextUtils.TextRange.TextRange[]): Promise<void> {\n    const promises = [];\n    for (const range of lineMappings) {\n      for (const entry of await this.rawLocationsForSourceLocation(uiSourceCode, range.startLine, 0)) {\n        if (this.textByProvider.has(entry.contentProvider)) {\n          continue;\n        }\n        this.textByProvider.set(entry.contentProvider, null);\n        this.uiSourceCodeByContentProvider.set(entry.contentProvider, uiSourceCode);\n        promises.push(this.updateTextForProvider(entry.contentProvider));\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  private async updateTextForProvider(contentProvider: TextUtils.ContentProvider.ContentProvider): Promise<void> {\n    const contentData =\n        TextUtils.ContentData.ContentData.contentDataOrEmpty(await contentProvider.requestContentData());\n    this.textByProvider.set(contentProvider, contentData.textObj);\n  }\n\n  private async rawLocationsForSourceLocation(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, line: number, column: number): Promise<RawLocation[]> {\n    const result: RawLocation[] = [];\n    const contentType = uiSourceCode.contentType();\n    if (contentType.hasScripts()) {\n      let locations = await this.#debuggerBinding.uiLocationToRawLocations(uiSourceCode, line, column);\n      locations = locations.filter(location => !!location.script());\n      for (const location of locations) {\n        const script = location.script();\n        if (!script) {\n          continue;\n        }\n        if (script.isInlineScript() && contentType.isDocument()) {\n          location.lineNumber -= script.lineOffset;\n          if (!location.lineNumber) {\n            location.columnNumber -= script.columnOffset;\n          }\n        }\n        result.push({\n          id: `js:${location.scriptId}`,\n          contentProvider: script,\n          line: location.lineNumber,\n          column: location.columnNumber,\n        });\n      }\n    }\n    if (contentType.isStyleSheet() || contentType.isDocument()) {\n      const rawStyleLocations =\n          this.#cssBinding.uiLocationToRawLocations(new Workspace.UISourceCode.UILocation(uiSourceCode, line, column));\n      for (const location of rawStyleLocations) {\n        const header = location.header();\n        if (!header) {\n          continue;\n        }\n        if (header.isInline && contentType.isDocument()) {\n          location.lineNumber -= header.startLine;\n          if (!location.lineNumber) {\n            location.columnNumber -= header.startColumn;\n          }\n        }\n        result.push({\n          id: `css:${location.styleSheetId}`,\n          contentProvider: header,\n          line: location.lineNumber,\n          column: location.columnNumber,\n        });\n      }\n    }\n    return result.sort(CoverageDecorationManager.compareLocations);\n  }\n\n  private static compareLocations(a: RawLocation, b: RawLocation): number {\n    return a.id.localeCompare(b.id) || a.line - b.line || a.column - b.column;\n  }\n\n  private onUISourceCodeAdded(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    uiSourceCode.setDecorationData(decoratorType, this);\n  }\n}\nexport interface RawLocation {\n  id: string;\n  contentProvider: TextUtils.ContentProvider.ContentProvider;\n  line: number;\n  column: number;\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2016 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  overflow: hidden;\n}\n\n.coverage-toolbar-container {\n  display: flex;\n  border-bottom: 1px solid var(--sys-color-divider);\n  flex: 0 0 auto;\n}\n\n.coverage-toolbar {\n  flex: auto;\n}\n\n.coverage-toolbar-summary {\n  background-color: var(--sys-color-cdt-base-container);\n  border-top: 1px solid var(--sys-color-divider);\n  padding-left: 5px;\n  flex: 0 0 19px;\n  display: flex;\n  padding-right: 5px;\n}\n\n.coverage-toolbar-summary .coverage-message {\n  padding-top: 2px;\n  padding-left: 1ex;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n.coverage-results {\n  overflow-y: auto;\n  display: flex;\n  flex: auto;\n}\n\n.bfcache-page,\n.prerender-page {\n  justify-content: center;\n  align-items: center;\n  padding: 20px;\n}\n\n.bfcache-page .message,\n.prerender-page .message {\n  white-space: pre-line;\n  text-align: center;\n}\n\n/*# sourceURL=${import.meta.resolve('./coverageView.css')} */`;"],
  "mappings": "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",
  "names": ["Events", "URLCoverageInfo", "Common", "TextUtils", "Workspace", "sourceNode", "Common", "i18n", "Platform", "SDK", "Workspace", "UI", "Platform", "TextUtils", "Workspace", "UIStrings", "str_", "i18nString", "toolbar", "entry"]
}
