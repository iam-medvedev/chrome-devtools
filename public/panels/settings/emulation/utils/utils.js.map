{
  "version": 3,
  "sources": ["../../../../../../../../front_end/panels/settings/emulation/utils/StructuredHeaders.ts", "../../../../../../../../front_end/panels/settings/emulation/utils/UserAgentMetadata.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// This provides parsing and serialization for HTTP structured headers as specified in:\n// https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19\n// (the ABNF fragments are quoted from the spec, unless otherwise specified,\n//  and the code pretty much just follows the algorithms given there).\n//\n// parseList, parseItem, serializeList, and serializeItem are the main entry points.\n//\n// Currently dictionary handling is not implemented (but would likely be easy\n// to add).  Serialization of decimals and byte sequences is also not\n// implemented.\n\nexport const enum ResultKind {\n  ERROR = 0,\n  PARAM_NAME = 1,\n  PARAMETER = 2,\n  PARAMETERS = 3,\n  ITEM = 4,\n  INTEGER = 5,\n  DECIMAL = 6,\n  STRING = 7,\n  TOKEN = 8,\n  BINARY = 9,\n  BOOLEAN = 10,\n  LIST = 11,\n  INNER_LIST = 12,\n  SERIALIZATION_RESULT = 13,\n}\n\nexport interface Error {\n  kind: ResultKind.ERROR;\n}\n\nexport interface Integer {\n  kind: ResultKind.INTEGER;\n  value: number;\n}\n\nexport interface Decimal {\n  kind: ResultKind.DECIMAL;\n  value: number;\n}\n\nexport interface String {\n  kind: ResultKind.STRING;\n  value: string;\n}\n\nexport interface Token {\n  kind: ResultKind.TOKEN;\n  value: string;\n}\n\nexport interface Binary {\n  kind: ResultKind.BINARY;\n  // This is undecoded base64\n  value: string;\n}\n\nexport interface Boolean {\n  kind: ResultKind.BOOLEAN;\n  value: boolean;\n}\n\n/**\n * bare-item = sf-integer / sf-decimal / sf-string / sf-token\n * / sf-binary / sf-boolean\n **/\nexport type BareItem = Integer|Decimal|String|Token|Binary|Boolean;\n\nexport interface ParamName {\n  kind: ResultKind.PARAM_NAME;\n  value: string;\n}\n\n/**\n * parameter     = param-name [ \"=\" param-value ]\n * param-value   = bare-item\n **/\nexport interface Parameter {\n  kind: ResultKind.PARAMETER;\n  name: ParamName;\n  value: BareItem;\n}\n\n/** parameters  = *( \";\" *SP parameter ) **/\nexport interface Parameters {\n  kind: ResultKind.PARAMETERS;\n  items: Parameter[];\n}\n\n/** sf-item   = bare-item parameters **/\nexport interface Item {\n  kind: ResultKind.ITEM;\n  value: BareItem;\n  parameters: Parameters;\n}\n\n/**\n * inner-list    = \"(\" *SP [ sf-item *( 1*SP sf-item ) *SP ] \")\"\n * parameters\n **/\nexport interface InnerList {\n  kind: ResultKind.INNER_LIST;\n  items: Item[];\n  parameters: Parameters;\n}\n\n/** list-member = sf-item / inner-list **/\nexport type ListMember = Item|InnerList;\n\n/** sf-list = list-member *( OWS \",\" OWS list-member ) **/\nexport interface List {\n  kind: ResultKind.LIST;\n  items: ListMember[];\n}\n\nexport interface SerializationResult {\n  kind: ResultKind.SERIALIZATION_RESULT;\n  value: string;\n}\n\nconst CHAR_MINUS: number = '-'.charCodeAt(0);\nconst CHAR_0: number = '0'.charCodeAt(0);\nconst CHAR_9: number = '9'.charCodeAt(0);\nconst CHAR_A: number = 'A'.charCodeAt(0);\nconst CHAR_Z: number = 'Z'.charCodeAt(0);\nconst CHAR_LOWER_A: number = 'a'.charCodeAt(0);\nconst CHAR_LOWER_Z: number = 'z'.charCodeAt(0);\nconst CHAR_DQUOTE: number = '\"'.charCodeAt(0);\nconst CHAR_COLON: number = ':'.charCodeAt(0);\nconst CHAR_QUESTION_MARK: number = '?'.charCodeAt(0);\nconst CHAR_STAR: number = '*'.charCodeAt(0);\nconst CHAR_UNDERSCORE: number = '_'.charCodeAt(0);\nconst CHAR_DOT: number = '.'.charCodeAt(0);\nconst CHAR_BACKSLASH: number = '\\\\'.charCodeAt(0);\nconst CHAR_SLASH: number = '/'.charCodeAt(0);\nconst CHAR_PLUS: number = '+'.charCodeAt(0);\nconst CHAR_EQUALS: number = '='.charCodeAt(0);\nconst CHAR_EXCLAMATION: number = '!'.charCodeAt(0);\nconst CHAR_HASH: number = '#'.charCodeAt(0);\nconst CHAR_DOLLAR: number = '$'.charCodeAt(0);\nconst CHAR_PERCENT: number = '%'.charCodeAt(0);\nconst CHAR_AND: number = '&'.charCodeAt(0);\nconst CHAR_SQUOTE: number = '\\''.charCodeAt(0);\nconst CHAR_HAT: number = '^'.charCodeAt(0);\nconst CHAR_BACKTICK: number = '`'.charCodeAt(0);\nconst CHAR_PIPE: number = '|'.charCodeAt(0);\nconst CHAR_TILDE: number = '~'.charCodeAt(0);\n\n// ASCII printable range.\nconst CHAR_MIN_ASCII_PRINTABLE = 0x20;\nconst CHAR_MAX_ASCII_PRINTABLE = 0x7e;\n\n/**\n * Note: structured headers operates over ASCII, not unicode, so these are\n * all indeed supposed to return false on things outside 32-127 range regardless\n * of them being other kinds of digits or letters.\n **/\nfunction isDigit(charCode: number|undefined): boolean {\n  // DIGIT = %x30-39 ; 0-9 (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return charCode >= CHAR_0 && charCode <= CHAR_9;\n}\n\nfunction isAlpha(charCode: number|undefined): boolean {\n  // ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_A && charCode <= CHAR_Z) || (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isLcAlpha(charCode: number|undefined): boolean {\n  // lcalpha = %x61-7A ; a-z\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isTChar(charCode: number|undefined): boolean {\n  if (charCode === undefined) {\n    return false;\n  }\n\n  // tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n  // \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA (from RFC 7230)\n  if (isDigit(charCode) || isAlpha(charCode)) {\n    return true;\n  }\n  switch (charCode) {\n    case CHAR_EXCLAMATION:\n    case CHAR_HASH:\n    case CHAR_DOLLAR:\n    case CHAR_PERCENT:\n    case CHAR_AND:\n    case CHAR_SQUOTE:\n    case CHAR_STAR:\n    case CHAR_PLUS:\n    case CHAR_MINUS:\n    case CHAR_DOT:\n    case CHAR_HAT:\n    case CHAR_UNDERSCORE:\n    case CHAR_BACKTICK:\n    case CHAR_PIPE:\n    case CHAR_TILDE:\n      return true;\n    default:\n      return false;\n  }\n}\n\nclass Input {\n  private readonly data: string;\n  private pos: number;\n\n  constructor(input: string) {\n    this.data = input;\n    this.pos = 0;\n    // 4.2 step 2 is to discard any leading SP characters.\n    this.skipSP();\n  }\n\n  peek(): string|undefined {\n    return this.data[this.pos];\n  }\n\n  peekCharCode(): number|undefined {\n    return (this.pos < this.data.length ? this.data.charCodeAt(this.pos) : undefined);\n  }\n\n  eat(): void {\n    ++this.pos;\n  }\n\n  // Matches SP*.\n  // SP = %x20, from RFC 5234\n  skipSP(): void {\n    while (this.data[this.pos] === ' ') {\n      ++this.pos;\n    }\n  }\n\n  // Matches OWS\n  // OWS = *( SP / HTAB ) , from RFC 7230\n  skipOWS(): void {\n    while (this.data[this.pos] === ' ' || this.data[this.pos] === '\\t') {\n      ++this.pos;\n    }\n  }\n\n  atEnd(): boolean {\n    return (this.pos === this.data.length);\n  }\n\n  // 4.2 steps 6,7 --- checks for trailing characters.\n  allParsed(): boolean {\n    this.skipSP();\n    return (this.pos === this.data.length);\n  }\n}\n\nfunction makeError(): Error {\n  return {kind: ResultKind.ERROR};\n}\n\n/** 4.2.1. Parsing a list **/\nfunction parseListInternal(input: Input): List|Error {\n  const result: List = {kind: ResultKind.LIST, items: []};\n\n  while (!input.atEnd()) {\n    const piece: ListMember|Error = parseItemOrInnerList(input);\n    if (piece.kind === ResultKind.ERROR) {\n      return piece;\n    }\n    result.items.push(piece);\n    input.skipOWS();\n    if (input.atEnd()) {\n      return result;\n    }\n\n    if (input.peek() !== ',') {\n      return makeError();\n    }\n    input.eat();\n    input.skipOWS();\n\n    // \"If input_string is empty, there is a trailing comma; fail parsing.\"\n    if (input.atEnd()) {\n      return makeError();\n    }\n  }\n  return result;  // this case corresponds to an empty list.\n}\n\n/** 4.2.1.1.  Parsing an Item or Inner List **/\nfunction parseItemOrInnerList(input: Input): ListMember|Error {\n  if (input.peek() === '(') {\n    return parseInnerList(input);\n  }\n  return parseItemInternal(input);\n}\n\n/** 4.2.1.2.  Parsing an Inner List **/\nfunction parseInnerList(input: Input): InnerList|Error {\n  if (input.peek() !== '(') {\n    return makeError();\n  }\n  input.eat();\n\n  const items: Item[] = [];\n  while (!input.atEnd()) {\n    input.skipSP();\n    if (input.peek() === ')') {\n      input.eat();\n      const params: Parameters|Error = parseParameters(input);\n      if (params.kind === ResultKind.ERROR) {\n        return params;\n      }\n      return {\n        kind: ResultKind.INNER_LIST,\n        items,\n        parameters: params,\n      };\n    }\n    const item: Item|Error = parseItemInternal(input);\n    if (item.kind === ResultKind.ERROR) {\n      return item;\n    }\n    items.push(item);\n    if (input.peek() !== ' ' && input.peek() !== ')') {\n      return makeError();\n    }\n  }\n\n  // Didn't see ), so error.\n  return makeError();\n}\n\n/** 4.2.3.  Parsing an Item **/\nfunction parseItemInternal(input: Input): Item|Error {\n  const bareItem: BareItem|Error = parseBareItem(input);\n  if (bareItem.kind === ResultKind.ERROR) {\n    return bareItem;\n  }\n  const params: Parameters|Error = parseParameters(input);\n  if (params.kind === ResultKind.ERROR) {\n    return params;\n  }\n  return {kind: ResultKind.ITEM, value: bareItem, parameters: params};\n}\n\n/** 4.2.3.1.  Parsing a Bare Item **/\nfunction parseBareItem(input: Input): BareItem|Error {\n  const upcoming = input.peekCharCode();\n  if (upcoming === CHAR_MINUS || isDigit(upcoming)) {\n    return parseIntegerOrDecimal(input);\n  }\n  if (upcoming === CHAR_DQUOTE) {\n    return parseString(input);\n  }\n  if (upcoming === CHAR_COLON) {\n    return parseByteSequence(input);\n  }\n  if (upcoming === CHAR_QUESTION_MARK) {\n    return parseBoolean(input);\n  }\n  if (upcoming === CHAR_STAR || isAlpha(upcoming)) {\n    return parseToken(input);\n  }\n  return makeError();\n}\n\n/** 4.2.3.2.  Parsing Parameters **/\nfunction parseParameters(input: Input): Parameters|Error {\n  // The main noteworthy thing here is handling of duplicates and ordering:\n  //\n  // \"Note that Parameters are ordered as serialized\"\n  //\n  // \"If parameters already contains a name param_name (comparing\n  // character-for-character), overwrite its value.\"\n  //\n  // \"Note that when duplicate Parameter keys are encountered, this has the\n  // effect of ignoring all but the last instance.\"\n  const items: Map<string, Parameter> = new Map<string, Parameter>();\n  while (!input.atEnd()) {\n    if (input.peek() !== ';') {\n      break;\n    }\n    input.eat();\n    input.skipSP();\n    const paramName = parseKey(input);\n    if (paramName.kind === ResultKind.ERROR) {\n      return paramName;\n    }\n\n    let paramValue: BareItem = {kind: ResultKind.BOOLEAN, value: true};\n    if (input.peek() === '=') {\n      input.eat();\n      const parsedParamValue: BareItem|Error = parseBareItem(input);\n      if (parsedParamValue.kind === ResultKind.ERROR) {\n        return parsedParamValue;\n      }\n      paramValue = parsedParamValue;\n    }\n\n    // Delete any previous occurrence of duplicates to get the ordering right.\n    if (items.has(paramName.value)) {\n      items.delete(paramName.value);\n    }\n\n    items.set(paramName.value, {kind: ResultKind.PARAMETER, name: paramName, value: paramValue});\n  }\n\n  return {kind: ResultKind.PARAMETERS, items: [...items.values()]};\n}\n\n/** 4.2.3.3.  Parsing a Key **/\nfunction parseKey(input: Input): ParamName|Error {\n  let outputString = '';\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isLcAlpha(first)) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (!isLcAlpha(upcoming) && !isDigit(upcoming) && upcoming !== CHAR_UNDERSCORE && upcoming !== CHAR_MINUS &&\n        upcoming !== CHAR_DOT && upcoming !== CHAR_STAR) {\n      break;\n    }\n    outputString += input.peek();\n    input.eat();\n  }\n\n  return {kind: ResultKind.PARAM_NAME, value: outputString};\n}\n\n/** 4.2.4.  Parsing an Integer or Decimal **/\nfunction parseIntegerOrDecimal(input: Input): Integer|Decimal|Error {\n  let resultKind = ResultKind.INTEGER;\n  let sign = 1;\n  let inputNumber = '';\n  if (input.peek() === '-') {\n    input.eat();\n    sign = -1;\n  }\n\n  // This case includes end of input.\n  if (!isDigit(input.peekCharCode())) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    if (char !== undefined && isDigit(char)) {\n      input.eat();\n      inputNumber += String.fromCodePoint(char);\n    } else if (char === CHAR_DOT && resultKind === ResultKind.INTEGER) {\n      input.eat();\n      if (inputNumber.length > 12) {\n        return makeError();\n      }\n      inputNumber += '.';\n      resultKind = ResultKind.DECIMAL;\n    } else {\n      break;\n    }\n    if (resultKind === ResultKind.INTEGER && inputNumber.length > 15) {\n      return makeError();\n    }\n    if (resultKind === ResultKind.DECIMAL && inputNumber.length > 16) {\n      return makeError();\n    }\n  }\n\n  if (resultKind === ResultKind.INTEGER) {\n    const num = sign * Number.parseInt(inputNumber, 10);\n    if (num < -999999999999999 || num > 999999999999999) {\n      return makeError();\n    }\n    return {kind: ResultKind.INTEGER, value: num};\n  }\n  const afterDot = inputNumber.length - 1 - inputNumber.indexOf('.');\n  if (afterDot > 3 || afterDot === 0) {\n    return makeError();\n  }\n  return {kind: ResultKind.DECIMAL, value: sign * Number.parseFloat(inputNumber)};\n}\n\n/** 4.2.5.  Parsing a String **/\nfunction parseString(input: Input): String|Error {\n  let outputString = '';\n  if (input.peek() !== '\"') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_BACKSLASH) {\n      if (input.atEnd()) {\n        return makeError();\n      }\n      const nextChar = input.peekCharCode();\n      input.eat();\n      if (nextChar !== CHAR_BACKSLASH && nextChar !== CHAR_DQUOTE) {\n        return makeError();\n      }\n      outputString += String.fromCodePoint(nextChar);\n    } else if (char === CHAR_DQUOTE) {\n      return {kind: ResultKind.STRING, value: outputString};\n    } else if (char<CHAR_MIN_ASCII_PRINTABLE || char>CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    } else {\n      outputString += String.fromCodePoint(char);\n    }\n  }\n\n  // No closing quote.\n  return makeError();\n}\n\n/** 4.2.6.  Parsing a Token **/\nfunction parseToken(input: Input): Token|Error {\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isAlpha(first)) {\n    return makeError();\n  }\n  let outputString = '';\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (upcoming === undefined || !isTChar(upcoming) && upcoming !== CHAR_COLON && upcoming !== CHAR_SLASH) {\n      break;\n    }\n    input.eat();\n    outputString += String.fromCodePoint(upcoming);\n  }\n  return {kind: ResultKind.TOKEN, value: outputString};\n}\n\n/** 4.2.7.  Parsing a Byte Sequence **/\nfunction parseByteSequence(input: Input): Binary|Error {\n  let outputString = '';\n  if (input.peek() !== ':') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_COLON) {\n      return {kind: ResultKind.BINARY, value: outputString};\n    }\n    if (isDigit(char) || isAlpha(char) || char === CHAR_PLUS || char === CHAR_SLASH || char === CHAR_EQUALS) {\n      outputString += String.fromCodePoint(char);\n    } else {\n      return makeError();\n    }\n  }\n\n  // No closing :\n  return makeError();\n}\n\n/** 4.2.8.  Parsing a Boolean **/\nfunction parseBoolean(input: Input): Boolean|Error {\n  if (input.peek() !== '?') {\n    return makeError();\n  }\n  input.eat();\n  if (input.peek() === '0') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: false};\n  }\n  if (input.peek() === '1') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: true};\n  }\n  return makeError();\n}\n\nexport function parseItem(input: string): Item|Error {\n  const i = new Input(input);\n  const result: Item|Error = parseItemInternal(i);\n  if (!i.allParsed()) {\n    return makeError();\n  }\n  return result;\n}\n\nexport function parseList(input: string): List|Error {\n  // No need to look for trailing stuff here since parseListInternal does it already.\n  return parseListInternal(new Input(input));\n}\n\n/** 4.1.3.  Serializing an Item **/\nexport function serializeItem(input: Item): SerializationResult|Error {\n  const bareItemVal = serializeBareItem(input.value);\n  if (bareItemVal.kind === ResultKind.ERROR) {\n    return bareItemVal;\n  }\n  const paramVal = serializeParameters(input.parameters);\n  if (paramVal.kind === ResultKind.ERROR) {\n    return paramVal;\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: bareItemVal.value + paramVal.value};\n}\n\n/** 4.1.1.  Serializing a List **/\nexport function serializeList(input: List): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const item = input.items[i];\n    if (item.kind === ResultKind.INNER_LIST) {\n      const itemResult = serializeInnerList(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    } else {\n      const itemResult = serializeItem(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    }\n  }\n  const output = outputPieces.join(', ');\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n/** 4.1.1.1.  Serializing an Inner List **/\nfunction serializeInnerList(input: InnerList): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const itemResult = serializeItem(input.items[i]);\n    if (itemResult.kind === ResultKind.ERROR) {\n      return itemResult;\n    }\n    outputPieces.push(itemResult.value);\n  }\n  let output = '(' + outputPieces.join(' ') + ')';\n  const paramResult = serializeParameters(input.parameters);\n  if (paramResult.kind === ResultKind.ERROR) {\n    return paramResult;\n  }\n  output += paramResult.value;\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n/** 4.1.1.2.  Serializing Parameters **/\nfunction serializeParameters(input: Parameters): SerializationResult|Error {\n  let output = '';\n  for (const item of input.items) {\n    output += ';';\n    const nameResult = serializeKey(item.name);\n    if (nameResult.kind === ResultKind.ERROR) {\n      return nameResult;\n    }\n    output += nameResult.value;\n    const itemVal: BareItem = item.value;\n    if (itemVal.kind !== ResultKind.BOOLEAN || !itemVal.value) {\n      output += '=';\n      const itemValResult = serializeBareItem(itemVal);\n      if (itemValResult.kind === ResultKind.ERROR) {\n        return itemValResult;\n      }\n      output += itemValResult.value;\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n/** 4.1.1.3.  Serializing a Key **/\nfunction serializeKey(input: ParamName): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isLcAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isLcAlpha(char) && !isDigit(char) && char !== CHAR_UNDERSCORE && char !== CHAR_MINUS && char !== CHAR_DOT &&\n        char !== CHAR_STAR) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n/** 4.1.3.1.  Serializing a Bare Item **/\nfunction serializeBareItem(input: BareItem): SerializationResult|Error {\n  if (input.kind === ResultKind.INTEGER) {\n    return serializeInteger(input);\n  }\n  if (input.kind === ResultKind.DECIMAL) {\n    return serializeDecimal(input);\n  }\n  if (input.kind === ResultKind.STRING) {\n    return serializeString(input);\n  }\n  if (input.kind === ResultKind.TOKEN) {\n    return serializeToken(input);\n  }\n  if (input.kind === ResultKind.BOOLEAN) {\n    return serializeBoolean(input);\n  }\n  if (input.kind === ResultKind.BINARY) {\n    return serializeByteSequence(input);\n  }\n  return makeError();\n}\n\n/** 4.1.4.  Serializing an Integer **/\nfunction serializeInteger(input: Integer): SerializationResult|Error {\n  if (input.value < -999999999999999 || input.value > 999999999999999 || !Number.isInteger(input.value)) {\n    return makeError();\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value.toString(10)};\n}\n\n/** 4.1.5.  Serializing a Decimal **/\nfunction serializeDecimal(_input: Decimal): SerializationResult|Error {\n  throw new Error('Unimplemented');\n}\n\n/** 4.1.6.  Serializing a String **/\nfunction serializeString(input: String): SerializationResult|Error {\n  // Only printable ASCII strings are supported by the spec.\n  for (let i = 0; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (char<CHAR_MIN_ASCII_PRINTABLE || char>CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    }\n  }\n  let output = '\"';\n  for (let i = 0; i < input.value.length; ++i) {\n    const charStr = input.value[i];\n    if (charStr === '\"' || charStr === '\\\\') {\n      output += '\\\\';\n    }\n    output += charStr;\n  }\n  output += '\"';\n\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n/** 4.1.7.  Serializing a Token **/\nfunction serializeToken(input: Token): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isTChar(char) && char !== CHAR_COLON && char !== CHAR_SLASH) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n/** 4.1.8.  Serializing a Byte Sequence **/\nfunction serializeByteSequence(_input: Binary): SerializationResult|Error {\n  throw new Error('Unimplemented');\n}\n\n/** 4.1.9.  Serializing a Boolean **/\nfunction serializeBoolean(input: Boolean): SerializationResult|Error {\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value ? '?1' : '?0'};\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\n// Helper functions for working with UserAgentMetadata protocol objects, in\n// particular their plain string representation.\n\nimport type * as Protocol from '../../../../generated/protocol.js';\nimport type * as UI from '../../../../ui/legacy/legacy.js';\n\nimport {\n  type Item,\n  type List,\n  type Parameters,\n  type ParamName,\n  parseList,\n  ResultKind,\n  serializeItem,\n  serializeList,\n  type String as SHString,\n} from './StructuredHeaders.js';\n\n/* Returned string is for error, either parseErrorString or structErrorString.\n */\nexport function parseBrandsList(stringForm: string, parseErrorString: string, structErrorString: string):\n    Protocol.Emulation.UserAgentBrandVersion[]|string {\n  const brandList: Protocol.Emulation.UserAgentBrandVersion[] = [];\n  const parseResult = parseList(stringForm);\n  if (parseResult.kind === ResultKind.ERROR) {\n    return parseErrorString;\n  }\n  for (const listItem of parseResult.items) {\n    if (listItem.kind !== ResultKind.ITEM) {\n      return structErrorString;\n    }\n    const bareItem = listItem.value;\n    if (bareItem.kind !== ResultKind.STRING) {\n      return structErrorString;\n    }\n    if (listItem.parameters.items.length !== 1) {\n      return structErrorString;\n    }\n    const param = listItem.parameters.items[0];\n    if (param.name.value !== 'v') {\n      return structErrorString;\n    }\n    const paramValue = param.value;\n    if (paramValue.kind !== ResultKind.STRING) {\n      return structErrorString;\n    }\n\n    brandList.push({brand: bareItem.value, version: paramValue.value});\n  }\n\n  return brandList;\n}\n\nexport function serializeBrandsList(brands: Protocol.Emulation.UserAgentBrandVersion[]): string {\n  const shList: List = {kind: ResultKind.LIST, items: []};\n  const vParamName: ParamName = {kind: ResultKind.PARAM_NAME, value: 'v'};\n  for (const brand of brands) {\n    const nameString: SHString = {kind: ResultKind.STRING, value: brand.brand};\n    const verString: SHString = {kind: ResultKind.STRING, value: brand.version};\n    const verParams: Parameters = {\n      kind: ResultKind.PARAMETERS,\n      items: [{kind: ResultKind.PARAMETER, name: vParamName, value: verString}],\n    };\n\n    const shItem: Item = {kind: ResultKind.ITEM, value: nameString, parameters: verParams};\n    shList.items.push(shItem);\n  }\n\n  const serializeResult = serializeList(shList);\n  return serializeResult.kind === ResultKind.ERROR ? '' : serializeResult.value;\n}\n\n/*\n * This checks whether the value provided is representable as a structured headers string,\n * which is the validity requirement for the fields in UserAgentMetadata that are not the brand list\n * or mobile bool.\n *\n * errorMessage will be passed through on failure.\n */\nexport function validateAsStructuredHeadersString(value: string, errorString: string): UI.ListWidget.ValidatorResult {\n  const parsedResult = serializeItem({\n    kind: ResultKind.ITEM,\n    value: {kind: ResultKind.STRING, value},\n    parameters: {kind: ResultKind.PARAMETERS, items: []},\n  });\n  if (parsedResult.kind === ResultKind.ERROR) {\n    return {valid: false, errorMessage: errorString};\n  }\n  return {valid: true, errorMessage: undefined};\n}\n"],
  "mappings": "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",
  "names": []
}
