{"version":3,"file":"Overlays.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Overlays.ts"],"names":[],"mappings":"AAwCA,MAAM,OAAO,QAAQ;IACnB;;;;;;;OAOG;IACH,kBAAkB,GAA2C,IAAI,GAAG,EAAE,CAAC;IAEvE,WAAW,GAAqB;QAC9B,KAAK,EAAE;YACL,aAAa,EAAE,IAAI;SACpB;QACD,MAAM,EAAE;YACN,IAAI,EAAE,IAAI;YACV,OAAO,EAAE,IAAI;SACd;KACF,CAAC;IAEF;;;;OAIG;IACH,kBAAkB,GAAqB,IAAI,CAAC;IAE5C,YAAY,IAEX;QACC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC;IAC3C,CAAC;IAED;;OAEG;IACH,UAAU,CAAC,OAAwB;QACjC,IAAI,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;YACzC,OAAO;QACT,CAAC;QAED,2EAA2E;QAC3E,uDAAuD;QACvD,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED;;;OAGG;IACH,qBAAqB,CAAC,KAAuB,EAAE,UAAgC;QAC7E,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACH,mBAAmB,CAAC,aAA+D;QACjF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;IACvD,CAAC;IAED;;;;OAIG;IACH,KAAK;QACH,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC5B,IAAI,CAAC,kBAAkB,CAAC,SAAS,GAAG,EAAE,CAAC;QACzC,CAAC;QACD,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;QAEhC,kDAAkD;QAClD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC;QAC5C,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;QACpC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;IACzC,CAAC;IAED,MAAM;IACN,CAAC;IAED;;;;;;;OAOG;IACH,qBAAqB,CAAC,KAAuB,EAAE,KAAmD;QAChG,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,KAAK,IAAI,EAAE,CAAC;YAClD,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAC;QAC3E,CAAC;QACD,MAAM,iBAAiB,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,WAAW,IAAI,IAAI,CAAC;QAC9E,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvB,MAAM,IAAI,KAAK,CAAC,mCAAmC,KAAK,cAAc,CAAC,CAAC;QAC1E,CAAC;QAED,MAAM,YAAY,GAAG,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,CAAC;QACzE,MAAM,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC;QACjE,OAAO,IAAI,CAAC,KAAK,CACb,YAAY,GAAG,aAAa,GAAG,iBAAiB,CACnD,CAAC;IACJ,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as TraceEngine from '../../models/trace/trace.js';\n\n/**\n * Represents when a user has selected an entry in the timeline\n */\nexport interface EntrySelected {\n  type: 'ENTRY_SELECTED';\n  entry: TraceEngine.Types.TraceEvents.TraceEventData;\n}\n\n/**\n * All supported overlay types. Expected to grow in time!\n */\nexport type TimelineOverlay = EntrySelected;\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n}\n\nexport class Overlays {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #elementForOverlay: Map<TimelineOverlay, HTMLElement|null> = new Map();\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement|null = null;\n\n  constructor(init: {\n    container: HTMLElement,\n  }) {\n    this.#overlaysContainer = init.container;\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  addOverlay(overlay: TimelineOverlay): void {\n    if (this.#elementForOverlay.has(overlay)) {\n      return;\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#elementForOverlay.set(overlay, null);\n  }\n\n  /**\n   * Update the dimenions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: 'main'|'network', dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the preivous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#elementForOverlay.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  update(): void {\n  }\n\n  /**\n   * Calculate the X pixel position for an event on the timeline.\n   * @param chart - the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   *\n   * @param event - the trace event you want to get the pixel position of\n   */\n  xPixelForEventOnChart(chart: 'main'|'network', event: TraceEngine.Types.TraceEvents.TraceEventData): number {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      throw new Error('Cannot calculate xPixel without visible trace window.');\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (!canvasWidthPixels) {\n      throw new Error(`Cannot calculate xPixel without ${chart} dimensions.`);\n    }\n\n    const timeFromLeft = event.ts - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n}\n"]}