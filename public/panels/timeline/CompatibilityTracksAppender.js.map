{"version":3,"file":"CompatibilityTracksAppender.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/CompatibilityTracksAppender.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as Trace from '../../models/trace/trace.js';\nimport type * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as ThemeSupport from '../../ui/legacy/theme_support/theme_support.js';\n\nimport {AnimationsTrackAppender} from './AnimationsTrackAppender.js';\nimport {getDurationString, getEventLevel, type LastTimestampByLevel} from './AppenderUtils.js';\nimport * as TimelineComponents from './components/components.js';\nimport {ExtensionTrackAppender} from './ExtensionTrackAppender.js';\nimport {GPUTrackAppender} from './GPUTrackAppender.js';\nimport {InteractionsTrackAppender} from './InteractionsTrackAppender.js';\nimport {LayoutShiftsTrackAppender} from './LayoutShiftsTrackAppender.js';\nimport {ServerTimingsTrackAppender} from './ServerTimingsTrackAppender.js';\nimport {ThreadAppender} from './ThreadAppender.js';\nimport {\n  EntryType,\n  InstantEventVisibleDurationMs,\n} from './TimelineFlameChartDataProvider.js';\nimport {TimelinePanel} from './TimelinePanel.js';\nimport {TimingsTrackAppender} from './TimingsTrackAppender.js';\nimport * as TimelineUtils from './utils/utils.js';\n\nexport interface PopoverInfo {\n  title: string;\n  formattedTime: string;\n  url: string|null;\n  warningElements: HTMLSpanElement[];\n  additionalElements: HTMLElement[];\n}\n\nlet showPostMessageEvents: boolean|undefined;\nfunction isShowPostMessageEventsEnabled(): boolean {\n  // Everytime the experiment is toggled devtools is reloaded so the\n  // cache is updated automatically.\n  if (showPostMessageEvents === undefined) {\n    showPostMessageEvents =\n        Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.TIMELINE_SHOW_POST_MESSAGE_EVENTS);\n  }\n  return showPostMessageEvents;\n}\n\nexport function entryIsVisibleInTimeline(\n    entry: Trace.Types.Events.Event, parsedTrace?: Trace.Handlers.Types.ParsedTrace): boolean {\n  if (parsedTrace?.Meta.traceIsGeneric) {\n    return true;\n  }\n\n  if (Trace.Types.Events.isUpdateCounters(entry)) {\n    // These events are not \"visible\" on the timeline because they are instant events with 0 duration.\n    // However, the Memory view (CountersGraph in the codebase) relies on\n    // finding the UpdateCounters events within the user's active trace\n    // selection in order to show the memory usage for the selected time\n    // period.\n    // Therefore we mark them as visible so they are appended onto the Thread\n    // track, and hence accessible by the CountersGraph view.\n    return true;\n  }\n\n  if (isShowPostMessageEventsEnabled()) {\n    if (Trace.Types.Events.isSchedulePostMessage(entry) || Trace.Types.Events.isHandlePostMessage(entry)) {\n      return true;\n    }\n  }\n\n  if (Trace.Types.Extensions.isSyntheticExtensionEntry(entry) || Trace.Types.Events.isSyntheticServerTiming(entry)) {\n    return true;\n  }\n\n  // Default styles are globally defined for each event name. Some\n  // events are hidden by default.\n  const eventStyle = TimelineUtils.EntryStyles.getEventStyle(entry.name as Trace.Types.Events.Name);\n  const eventIsTiming = Trace.Types.Events.isConsoleTime(entry) || Trace.Types.Events.isPerformanceMeasure(entry) ||\n      Trace.Types.Events.isPerformanceMark(entry);\n\n  return (eventStyle && !eventStyle.hidden) || eventIsTiming;\n}\n\n/**\n * Track appenders add the data of each track into the timeline flame\n * chart. Each track appender also implements functions tha allow the\n * canvas renderer to gather more information about an event in a track,\n * like its display name or color.\n *\n * At the moment, tracks in the timeline flame chart are appended in\n * two locations: in the TimelineFlameChartDataProvider and in the track\n * appenders exported by this module. As part of the work to use a new\n * trace parsing engine, a track appender will be defined with this API\n * for each of the tracks in the timeline. With this implementation in\n * place its counterpart in the TimelineFlameChartDataProvider can be\n * removed. This processes of doing this for a track is referred to as\n * \"migrating the track\" to the new system.\n *\n * The migration implementation will result beneficial among other\n * things because the complexity of rendering the details of each track\n * is distributed among multiple standalone modules.\n * Read more at go/rpp-flamechart-arch\n */\n\nexport interface TrackAppender {\n  /**\n   * The unique name given to the track appender.\n   */\n  appenderName: TrackAppenderName;\n\n  /**\n   * Appends into the flame chart data the data corresponding to a track.\n   * @param level the horizontal level of the flame chart events where the\n   * track's events will start being appended.\n   * @param expanded wether the track should be rendered expanded.\n   * @returns the first available level to append more data after having\n   * appended the track's events.\n   */\n  appendTrackAtLevel(level: number, expanded?: boolean): number;\n  /**\n   * Returns the color an event is shown with in the timeline.\n   */\n  colorForEvent(event: Trace.Types.Events.Event): string;\n  /**\n   * Returns the title an event is shown with in the timeline.\n   */\n  titleForEvent?(event: Trace.Types.Events.Event): string;\n  /**\n   * Updates the standard popover (AKA tooltip) some appender specific details.\n   */\n  setPopoverInfo?(event: Trace.Types.Events.Event, info: PopoverInfo): void;\n  /**\n   * Returns the a callback function to draw an event to overrides the normal rectangle draw operation.\n   */\n  getDrawOverride?(event: Trace.Types.Events.Event): DrawOverride|undefined;\n}\n\nexport const TrackNames = [\n  'Animations',\n  'Timings',\n  'Interactions',\n  'GPU',\n  'LayoutShifts',\n  'Thread',\n  'Thread_AuctionWorklet',\n  'Extension',\n  'ServerTimings',\n] as const;\n// Network track will use TrackAppender interface, but it won't be shown in Main flamechart.\n// So manually add it to TrackAppenderName.\nexport type TrackAppenderName = typeof TrackNames[number]|'Network';\n\nexport type DrawOverride = PerfUI.FlameChart.DrawOverride;\n\n/**\n * Used as the context when a track (aka group) is selected and we log\n * something to the VE Logging framework.\n * This enum broadly corresponds with the list of TrackNames, but can be more\n * specific in some situations such as when we want to identify the thread type\n * rather than log \"thread\" - it is useful to know if the thread is the main\n * thread or not.\n * VE context needs to be kebab-case, and not contain any PII, which is why we\n * log this set list rather than full track names, which in the case of threads\n * can contain URLswhich we do not want to log.\n */\nexport const enum VisualLoggingTrackName {\n  ANIMATIONS = 'animations',\n  TIMINGS = 'timings',\n  INTERACTIONS = 'interactions',\n  GPU = 'gpu',\n  LAYOUT_SHIFTS = 'layout-shifts',\n  SERVER_TIMINGS = 'server.timings',\n  THREAD_CPU_PROFILE = 'thread.cpu-profile',\n  THREAD_MAIN = 'thread.main',\n  THREAD_FRAME = 'thread.frame',\n  THREAD_WORKER = 'thread.worker',\n  THREAD_AUCTION_WORKLET = 'thread.auction-worklet',\n  THREAD_RASTERIZER = 'thread.rasterizer',\n  THREAD_POOL = 'thread.pool',\n  THREAD_OTHER = 'thread.other',\n  EXTENSION = 'extension',\n  NETWORK = 'network',\n}\n\nexport class CompatibilityTracksAppender {\n  #trackForLevel = new Map<number, TrackAppender>();\n  #trackForGroup = new Map<PerfUI.FlameChart.Group, TrackAppender>();\n  #eventsForTrack = new Map<TrackAppender, Trace.Types.Events.Event[]>();\n  #trackEventsForTreeview = new Map<TrackAppender, Trace.Types.Events.Event[]>();\n  #flameChartData: PerfUI.FlameChart.FlameChartTimelineData;\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n  #entryData: Trace.Types.Events.Event[];\n  #colorGenerator: Common.Color.Generator;\n  #allTrackAppenders: TrackAppender[] = [];\n  #visibleTrackNames = new Set<TrackAppenderName>([...TrackNames]);\n\n  #legacyEntryTypeByLevel: EntryType[];\n  #timingsTrackAppender: TimingsTrackAppender;\n  #animationsTrackAppender: AnimationsTrackAppender;\n  #interactionsTrackAppender: InteractionsTrackAppender;\n  #gpuTrackAppender: GPUTrackAppender;\n  #layoutShiftsTrackAppender: LayoutShiftsTrackAppender;\n  #threadAppenders: ThreadAppender[] = [];\n  #serverTimingsTrackAppender: ServerTimingsTrackAppender;\n  #entityMapper: TimelineUtils.EntityMapper.EntityMapper|null;\n\n  /**\n   * @param flameChartData the data used by the flame chart renderer on\n   * which the track data will be appended.\n   * @param parsedTrace the trace parsing engines output.\n   * @param entryData the array containing all event to be rendered in\n   * the flamechart.\n   * @param legacyEntryTypeByLevel an array containing the type of\n   * each entry in the entryData array. Indexed by the position the\n   * corresponding entry occupies in the entryData array. This reference\n   * is needed only for compatibility with the legacy flamechart\n   * architecture and should be removed once all tracks use the new\n   * system.\n   * @param entityMapper 3P entity data for the trace.\n   */\n  constructor(\n      flameChartData: PerfUI.FlameChart.FlameChartTimelineData, parsedTrace: Trace.Handlers.Types.ParsedTrace,\n      entryData: Trace.Types.Events.Event[], legacyEntryTypeByLevel: EntryType[],\n      entityMapper: TimelineUtils.EntityMapper.EntityMapper|null) {\n    this.#flameChartData = flameChartData;\n    this.#parsedTrace = parsedTrace;\n    this.#entityMapper = entityMapper;\n    this.#entryData = entryData;\n    this.#colorGenerator = new Common.Color.Generator(\n        /* hueSpace= */ {min: 30, max: 55, count: undefined},\n        /* satSpace= */ {min: 70, max: 100, count: 6},\n        /* lightnessSpace= */ 50,\n        /* alphaSpace= */ 0.7);\n    this.#legacyEntryTypeByLevel = legacyEntryTypeByLevel;\n    this.#timingsTrackAppender = new TimingsTrackAppender(this, this.#parsedTrace, this.#colorGenerator);\n    this.#allTrackAppenders.push(this.#timingsTrackAppender);\n\n    this.#interactionsTrackAppender = new InteractionsTrackAppender(this, this.#parsedTrace, this.#colorGenerator);\n    this.#allTrackAppenders.push(this.#interactionsTrackAppender);\n\n    this.#animationsTrackAppender = new AnimationsTrackAppender(this, this.#parsedTrace);\n    this.#allTrackAppenders.push(this.#animationsTrackAppender);\n\n    this.#gpuTrackAppender = new GPUTrackAppender(this, this.#parsedTrace);\n    this.#allTrackAppenders.push(this.#gpuTrackAppender);\n\n    this.#layoutShiftsTrackAppender = new LayoutShiftsTrackAppender(this, this.#parsedTrace);\n    this.#allTrackAppenders.push(this.#layoutShiftsTrackAppender);\n\n    this.#serverTimingsTrackAppender = new ServerTimingsTrackAppender(this, this.#parsedTrace);\n    this.#allTrackAppenders.push(this.#serverTimingsTrackAppender);\n    this.#addThreadAppenders();\n    this.#addExtensionAppenders();\n\n    this.onThemeChange = this.onThemeChange.bind(this);\n    ThemeSupport.ThemeSupport.instance().addEventListener(ThemeSupport.ThemeChangeEvent.eventName, this.onThemeChange);\n  }\n\n  reset(): void {\n    ThemeSupport.ThemeSupport.instance().removeEventListener(\n        ThemeSupport.ThemeChangeEvent.eventName, this.onThemeChange);\n  }\n\n  setFlameChartDataAndEntryData(\n      flameChartData: PerfUI.FlameChart.FlameChartTimelineData, entryData: Trace.Types.Events.Event[],\n      legacyEntryTypeByLevel: EntryType[]): void {\n    this.#trackForGroup.clear();\n    this.#flameChartData = flameChartData;\n    this.#entryData = entryData;\n    this.#legacyEntryTypeByLevel = legacyEntryTypeByLevel;\n  }\n\n  getFlameChartTimelineData(): PerfUI.FlameChart.FlameChartTimelineData {\n    return this.#flameChartData;\n  }\n\n  private onThemeChange(): void {\n    for (const group of this.#flameChartData.groups) {\n      // We only need to update the color here, because FlameChart will call `scheduleUpdate()` when theme is changed.\n      group.style.color = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-on-surface');\n      group.style.backgroundColor =\n          ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-cdt-base-container');\n    }\n  }\n\n  #addExtensionAppenders(): void {\n    if (!TimelinePanel.extensionDataVisibilitySetting().get()) {\n      return;\n    }\n    const tracks = this.#parsedTrace.ExtensionTraceData.extensionTrackData;\n    for (const trackData of tracks) {\n      this.#allTrackAppenders.push(new ExtensionTrackAppender(this, trackData));\n    }\n  }\n\n  #addThreadAppenders(): void {\n    const threadTrackOrder = (appender: ThreadAppender): number => {\n      switch (appender.threadType) {\n        case Trace.Handlers.Threads.ThreadType.MAIN_THREAD: {\n          if (appender.isOnMainFrame) {\n            // Ensure `about:blank` or `chrome://new-tab-page` are deprioritized, as they're likely not the profiling targets\n            const url = appender.getUrl();\n            if (url.startsWith('about:') || url.startsWith('chrome:')) {\n              return 2;\n            }\n            return 0;\n          }\n          return 1;\n        }\n        case Trace.Handlers.Threads.ThreadType.WORKER:\n          return 3;\n        case Trace.Handlers.Threads.ThreadType.AUCTION_WORKLET:\n          return 3;\n        case Trace.Handlers.Threads.ThreadType.RASTERIZER:\n          return 4;\n        case Trace.Handlers.Threads.ThreadType.THREAD_POOL:\n          return 5;\n        case Trace.Handlers.Threads.ThreadType.OTHER:\n          return 7;\n        default:\n          return 8;\n      }\n    };\n    const threads = Trace.Handlers.Threads.threadsInTrace(this.#parsedTrace);\n    const showAllEvents = Root.Runtime.experiments.isEnabled('timeline-show-all-events');\n\n    for (const {pid, tid, name, type, entries, tree} of threads) {\n      if (this.#parsedTrace.Meta.traceIsGeneric) {\n        // If the trace is generic, we just push all of the threads with no effort to differentiate them, hence\n        // overriding the thread type to be OTHER for all threads.\n        this.#threadAppenders.push(new ThreadAppender(\n            this, this.#parsedTrace, pid, tid, name, Trace.Handlers.Threads.ThreadType.OTHER, entries, tree));\n        continue;\n      }\n      // These threads have no useful information. Omit them\n      if ((name === 'Chrome_ChildIOThread' || name === 'Compositor' || name === 'GpuMemoryThread') && !showAllEvents) {\n        continue;\n      }\n\n      const matchingWorklet = this.#parsedTrace.AuctionWorklets.worklets.get(pid);\n      if (matchingWorklet) {\n        // Each AuctionWorklet has two key threads:\n        // 1. the Utility Thread\n        // 2. the V8 Helper Thread - either a bidder or seller. see buildNameForAuctionWorklet()\n        // There are other threads in a worklet process, but we don't render them.\n        const tids = [matchingWorklet.args.data.utilityThread.tid, matchingWorklet.args.data.v8HelperThread.tid];\n        if (tids.includes(tid)) {\n          this.#threadAppenders.push(new ThreadAppender(\n              this, this.#parsedTrace, pid, tid, '', Trace.Handlers.Threads.ThreadType.AUCTION_WORKLET, entries, tree));\n        }\n        continue;\n      }\n\n      // The Common case… Add the main thread, or iframe, or thread pool, etc.\n      this.#threadAppenders.push(new ThreadAppender(this, this.#parsedTrace, pid, tid, name, type, entries, tree));\n    }\n    // Sort first by track order, then break ties by placing busier tracks first.\n    this.#threadAppenders.sort(\n        (a, b) => (threadTrackOrder(a) - threadTrackOrder(b)) || (b.getEntries().length - a.getEntries().length));\n    this.#allTrackAppenders.push(...this.#threadAppenders);\n  }\n\n  timingsTrackAppender(): TimingsTrackAppender {\n    return this.#timingsTrackAppender;\n  }\n\n  animationsTrackAppender(): AnimationsTrackAppender {\n    return this.#animationsTrackAppender;\n  }\n\n  interactionsTrackAppender(): InteractionsTrackAppender {\n    return this.#interactionsTrackAppender;\n  }\n\n  gpuTrackAppender(): GPUTrackAppender {\n    return this.#gpuTrackAppender;\n  }\n\n  layoutShiftsTrackAppender(): LayoutShiftsTrackAppender {\n    return this.#layoutShiftsTrackAppender;\n  }\n\n  threadAppenders(): ThreadAppender[] {\n    return this.#threadAppenders;\n  }\n\n  serverTimingsTrackAppender(): ServerTimingsTrackAppender {\n    return this.#serverTimingsTrackAppender;\n  }\n\n  eventsInTrack(trackAppender: TrackAppender): Trace.Types.Events.Event[] {\n    const cachedData = this.#eventsForTrack.get(trackAppender);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    // Calculate the levels occupied by a track.\n    let trackStartLevel = null;\n    let trackEndLevel = null;\n    for (const [level, track] of this.#trackForLevel) {\n      if (track !== trackAppender) {\n        continue;\n      }\n      if (trackStartLevel === null) {\n        trackStartLevel = level;\n      }\n      trackEndLevel = level;\n    }\n\n    if (trackStartLevel === null || trackEndLevel === null) {\n      throw new Error(`Could not find events for track: ${trackAppender}`);\n    }\n    const entryLevels = this.#flameChartData.entryLevels;\n    const events = [];\n    for (let i = 0; i < entryLevels.length; i++) {\n      if (trackStartLevel <= entryLevels[i] && entryLevels[i] <= trackEndLevel) {\n        events.push(this.#entryData[i]);\n      }\n    }\n    events.sort((a, b) => a.ts - b.ts);  // TODO(paulirish): Remove as I'm 90% it's already sorted.\n\n    this.#eventsForTrack.set(trackAppender, events);\n    return events;\n  }\n\n  /**\n   * Gets the events to be shown in the tree views of the details pane\n   * (Bottom-up, Call tree, etc.). These are the events from the track\n   * that can be arranged in a tree shape.\n   */\n  eventsForTreeView(trackAppender: TrackAppender): Trace.Types.Events.Event[] {\n    const cachedData = this.#trackEventsForTreeview.get(trackAppender);\n    if (cachedData) {\n      return cachedData;\n    }\n\n    let trackEvents = this.eventsInTrack(trackAppender);\n    if (!Trace.Helpers.TreeHelpers.canBuildTreesFromEvents(trackEvents)) {\n      // Some tracks can include both async and sync events. When this\n      // happens, we use all events for the tree views if a trees can be\n      // built from both sync and async events. If this is not possible,\n      // async events are filtered out and only sync events are used\n      // (it's assumed a tree can always be built using a tracks sync\n      // events).\n      trackEvents = trackEvents.filter(e => !Trace.Types.Events.isPhaseAsync(e.ph));\n    }\n    this.#trackEventsForTreeview.set(trackAppender, trackEvents);\n    return trackEvents;\n  }\n\n  /**\n   * Caches the track appender that owns a flame chart group. FlameChart\n   * groups are created for each track in the timeline. When an user\n   * selects a track in the UI, the track's group is passed to the model\n   * layer to inform about the selection.\n   */\n  registerTrackForGroup(group: PerfUI.FlameChart.Group, appender: TrackAppender): void {\n    this.#flameChartData.groups.push(group);\n    this.#trackForGroup.set(group, appender);\n  }\n\n  /**\n   * Returns number of tracks of given type already appended.\n   * Used to name the \"Raster Thread 6\" tracks, etc\n   */\n  getCurrentTrackCountForThreadType(\n      threadType: Trace.Handlers.Threads.ThreadType.RASTERIZER|Trace.Handlers.Threads.ThreadType.THREAD_POOL): number {\n    return this.#threadAppenders.filter(appender => appender.threadType === threadType && appender.headerAppended())\n        .length;\n  }\n\n  /**\n   * Looks up a FlameChart group for a given appender.\n   */\n  groupForAppender(targetAppender: TrackAppender): PerfUI.FlameChart.Group|null {\n    let foundGroup: PerfUI.FlameChart.Group|null = null;\n    for (const [group, appender] of this.#trackForGroup) {\n      if (appender === targetAppender) {\n        foundGroup = group;\n        break;\n      }\n    }\n    return foundGroup;\n  }\n\n  /**\n   * Given a FlameChart group, gets the events to be shown in the tree\n   * views if that group was registered by the appender system.\n   */\n  groupEventsForTreeView(group: PerfUI.FlameChart.Group): Trace.Types.Events.Event[]|null {\n    const track = this.#trackForGroup.get(group);\n    if (!track) {\n      return null;\n    }\n    return this.eventsForTreeView(track);\n  }\n\n  groupForLevel(level: number): PerfUI.FlameChart.Group|null {\n    const appenderForLevel = this.#trackForLevel.get(level);\n    if (!appenderForLevel) {\n      return null;\n    }\n    return this.groupForAppender(appenderForLevel);\n  }\n\n  /**\n   * Adds an event to the flame chart data at a defined level.\n   * @param event the event to be appended,\n   * @param level the level to append the event,\n   * @param appender the track which the event belongs to.\n   * @returns the index of the event in all events to be rendered in the flamechart.\n   */\n  appendEventAtLevel(event: Trace.Types.Events.Event, level: number, appender: TrackAppender): number {\n    // TODO(crbug.com/1442454) Figure out how to avoid the circular calls.\n    this.#trackForLevel.set(level, appender);\n    const index = this.#entryData.length;\n    this.#entryData.push(event);\n    this.#legacyEntryTypeByLevel[level] = EntryType.TRACK_APPENDER;\n    this.#flameChartData.entryLevels[index] = level;\n    this.#flameChartData.entryStartTimes[index] = Trace.Helpers.Timing.microToMilli(event.ts);\n    const dur = event.dur || Trace.Helpers.Timing.milliToMicro(InstantEventVisibleDurationMs);\n    this.#flameChartData.entryTotalTimes[index] = Trace.Helpers.Timing.microToMilli(dur);\n    return index;\n  }\n\n  /**\n   * Adds into the flame chart data a list of trace events.\n   * @param events the trace events that will be appended to the flame chart.\n   * The events should be taken straight from the trace handlers. The handlers\n   * should sort the events by start time, and the parent event is before the\n   * child.\n   * @param trackStartLevel the flame chart level from which the events will\n   * be appended.\n   * @param appender the track that the trace events belong to.\n   * @param eventAppendedCallback an optional function called after the\n   * event has been added to the timeline data. This allows the caller\n   * to know f.e. the position of the event in the entry data. Use this\n   * hook to customize the data after it has been appended, f.e. to add\n   * decorations to a set of the entries.\n   * @returns the next level after the last occupied by the appended these\n   * trace events (the first available level to append next track).\n   */\n  appendEventsAtLevel<T extends Trace.Types.Events.Event>(\n      events: readonly T[], trackStartLevel: number, appender: TrackAppender,\n      eventAppendedCallback?: (event: T, index: number) => void): number {\n    const lastTimestampByLevel: LastTimestampByLevel = [];\n    for (let i = 0; i < events.length; ++i) {\n      const event = events[i];\n      if (!entryIsVisibleInTimeline(event, this.#parsedTrace)) {\n        continue;\n      }\n\n      const level = getEventLevel(event, lastTimestampByLevel);\n      const index = this.appendEventAtLevel(event, trackStartLevel + level, appender);\n      eventAppendedCallback?.(event, index);\n    }\n\n    this.#legacyEntryTypeByLevel.length = trackStartLevel + lastTimestampByLevel.length;\n    this.#legacyEntryTypeByLevel.fill(EntryType.TRACK_APPENDER, trackStartLevel);\n    return trackStartLevel + lastTimestampByLevel.length;\n  }\n\n  /**\n   * Gets the all track appenders that have been set to be visible.\n   */\n  allVisibleTrackAppenders(): TrackAppender[] {\n    return this.#allTrackAppenders.filter(track => this.#visibleTrackNames.has(track.appenderName));\n  }\n\n  allThreadAppendersByProcess(): Map<Trace.Types.Events.ProcessID, ThreadAppender[]> {\n    const appenders = this.allVisibleTrackAppenders();\n    const result = new Map<Trace.Types.Events.ProcessID, ThreadAppender[]>();\n    for (const appender of appenders) {\n      if (!(appender instanceof ThreadAppender)) {\n        continue;\n      }\n      const existing = result.get(appender.processId()) ?? [];\n      existing.push(appender);\n      result.set(appender.processId(), existing);\n    }\n    return result;\n  }\n\n  /**\n   * Sets the visible tracks internally\n   * @param visibleTracks set with the names of the visible track\n   * appenders. If undefined, all tracks are set to be visible.\n   */\n  setVisibleTracks(visibleTracks?: Set<TrackAppenderName>): void {\n    if (!visibleTracks) {\n      this.#visibleTrackNames = new Set([...TrackNames]);\n      return;\n    }\n    this.#visibleTrackNames = visibleTracks;\n  }\n\n  getDrawOverride(event: Trace.Types.Events.Event, level: number): DrawOverride|undefined {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n    return track.getDrawOverride?.(event);\n  }\n\n  /**\n   * Returns the color an event is shown with in the timeline.\n   */\n  colorForEvent(event: Trace.Types.Events.Event, level: number): string {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n    return track.colorForEvent(event);\n  }\n  /**\n   * Returns the title an event is shown with in the timeline.\n   */\n  titleForEvent(event: Trace.Types.Events.Event, level: number): string {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n\n    // Historically all tracks would have a titleForEvent() method. However a\n    // lot of these were duplicated so we worked on removing them in favour of\n    // the EntryName.nameForEntry method called below (see crbug.com/365047728).\n    // However, sometimes an appender needs to customise the titles slightly;\n    // for example the LayoutShiftsTrackAppender does not show any titles as we\n    // use diamonds to represent layout shifts.\n    // So whilst we expect most appenders to not define this method, we do\n    // allow appenders to override it.\n    if (track.titleForEvent) {\n      return track.titleForEvent(event);\n    }\n    return TimelineUtils.EntryName.nameForEntry(event, this.#parsedTrace);\n  }\n  /**\n   * Returns the info shown when an event in the timeline is hovered.\n   */\n  popoverInfo(event: Trace.Types.Events.Event, level: number): PopoverInfo {\n    const track = this.#trackForLevel.get(level);\n    if (!track) {\n      throw new Error('Track not found for level');\n    }\n\n    // Defaults here, though tracks may chose to redefine title/formattedTime\n    const info: PopoverInfo = {\n      title: this.titleForEvent(event, level),\n      formattedTime: getDurationString(event.dur),\n      warningElements: TimelineComponents.DetailsView.buildWarningElementsForEvent(event, this.#parsedTrace),\n      additionalElements: [],\n      url: null,\n    };\n\n    // If the track defines its own popoverInfo(), it'll update values within\n    if (track.setPopoverInfo) {\n      track.setPopoverInfo(event, info);\n    }\n\n    // If there's a url associated, add into additionalElements\n    const url = URL.parse(\n        info.url ?? TimelineUtils.SourceMapsResolver.SourceMapsResolver.resolvedURLForEntry(this.#parsedTrace, event) ??\n        '');\n    if (url) {\n      const MAX_PATH_LENGTH = 45;\n      const path = Platform.StringUtilities.trimMiddle(url.href.replace(url.origin, ''), MAX_PATH_LENGTH);\n      const urlElems = document.createElement('div');\n      urlElems.createChild('span', 'popoverinfo-url-path').textContent = path;\n      const entity = this.#entityMapper ? this.#entityMapper.entityForEvent(event) : null;\n      // Include entity with origin if it's non made-up entity, otherwise there'd be\n      // repetition with the origin.\n      const originWithEntity = TimelineUtils.Helpers.formatOriginWithEntity(url, entity);\n      urlElems.createChild('span', 'popoverinfo-url-origin').textContent = `(${originWithEntity})`;\n      info.additionalElements.push(urlElems);\n    }\n\n    return info;\n  }\n}\n"]}