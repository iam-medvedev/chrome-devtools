{"version":3,"file":"SourceMapsResolver.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/SourceMapsResolver.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAG7B,OAAO,KAAK,GAAG,MAAM,0BAA0B,CAAC;AAEhD,OAAO,KAAK,QAAQ,MAAM,sCAAsC,CAAC;AACjE,OAAO,KAAK,eAAe,MAAM,wDAAwD,CAAC;AAC1F,OAAO,KAAK,KAAK,MAAM,gCAAgC,CAAC;AACxD,OAAO,KAAK,SAAS,MAAM,wCAAwC,CAAC;AAMpE,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAC9C,MAAM,CAAU,SAAS,GAAG,uBAAuB,CAAC;IAEpD;QACE,KAAK,CAAC,qBAAqB,CAAC,SAAS,EAAE;YACrC,QAAQ,EAAE,IAAI;YACd,OAAO,EAAE,IAAI;SACd,CAAC,CAAC;IACL,CAAC;;AAGH,gDAAgD;AAChD,wCAAwC;AACxC,qEAAqE;AACrE,MAAM,CAAC,MAAM,6BAA6B,GAElC,IAAI,GAAG,EAAE,CAAC;AAElB,MAAM,OAAO,kBAAmB,SAAQ,WAAW;IACjD,YAAY,CAAmC;IAE/C,YAAY,GAAG,KAAK,CAAC;IAErB,uEAAuE;IACvE,wEAAwE;IACxE,qEAAqE;IACrE,2EAA2E;IAC3E,qBAAqB;IACrB,uBAAuB,GAAG,IAAI,GAAG,EAAmC,CAAC;IAErE,YAAY,WAA6C;QACvD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;IAClC,CAAC;IAED,MAAM,CAAC,sBAAsB;QAC3B,6BAA6B,CAAC,KAAK,EAAE,CAAC;IACxC,CAAC;IACD,MAAM,CAAC,kBAAkB,CAAC,SAAqC;QAC7D,OAAO,GAAG,SAAS,CAAC,GAAG,MAAM,SAAS,CAAC,QAAQ,MAAM,SAAS,CAAC,YAAY,MAAM,SAAS,CAAC,UAAU,MACjG,SAAS,CAAC,YAAY,EAAE,CAAC;IAC/B,CAAC;IAED;;;;;;;;;;OAUG;IACH,MAAM,CAAC,4BAA4B,CAAC,KAA+B;QACjE,IAAI,SAAS,GAAG,IAAI,CAAC;QACrB,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC;YAC5C,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;QAC9B,CAAC;aAAM,CAAC;YACN,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,gCAAgC,CAAC,KAAK,CAAC,CAAC;YAC/E,IAAI,UAAU,KAAK,IAAI,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACjD,OAAO,IAAI,CAAC;YACd,CAAC;YACD,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAC5B,CAAC;QACD,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAuC,CAAC,CAAC;QACzF,OAAO,6BAA6B,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;IACpG,CAAC;IAED,MAAM,CAAC,mBAAmB,CAAC,WAA6C,EAAE,KAA+B;QAEvG,MAAM,oBAAoB,GACtB,kBAAkB,CAAC,4BAA4B,CAAC,KAAK,CAAC,EAAE,gBAAgB,EAAE,YAAY,CAAC,GAAG,EAAE,CAAC;QACjG,IAAI,oBAAoB,EAAE,CAAC;YACzB,OAAO,oBAAoB,CAAC;QAC9B,CAAC;QACD,kEAAkE;QAClE,0DAA0D;QAC1D,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,cAAc,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QACxE,IAAI,GAAG,EAAE,CAAC;YACR,OAAO,SAAS,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,GAAG,CAAC;QAC5F,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,CAAC,6BAA6B,CAChC,GAAiC,EAAE,GAAgC,EAAE,SAAqC,EAC1G,wBAAkD;QACpD,MAAM,cAAc,GAAG,6BAA6B,CAAC,GAAG,CAAC,GAAG,CAAC;YACzD,IAAI,GAAG,EAA2E,CAAC;QACvF,MAAM,cAAc,GAAG,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,GAAG,EAAyC,CAAC;QACnG,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QAC3D,cAAc,CAAC,GAAG,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;QAC9D,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;QACxC,6BAA6B,CAAC,GAAG,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;IACzD,CAAC;IAED,KAAK,CAAC,OAAO;QACX,KAAK,MAAM,kBAAkB,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,iBAAiB,CAAC,MAAM,EAAE,EAAE,CAAC;YACtF,KAAK,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,kBAAkB,EAAE,CAAC;gBAChD,MAAM,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;gBAC5C,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACjC,SAAS;gBACX,CAAC;gBAED,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;gBAC1C,MAAM,aAAa,GAAG,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;gBACrE,IAAI,CAAC,aAAa,EAAE,CAAC;oBACnB,SAAS;gBACX,CAAC;gBACD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,MAAM,MAAM,GAAG,aAAa,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1E,MAAM,uBAAuB,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC;oBAC/D,IAAI,CAAC,uBAAuB,EAAE,CAAC;wBAC7B,SAAS;oBACX,CAAC;oBACD,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBAClD,CAAC;YACH,CAAC;QACH,CAAC;QAED,KAAK,MAAM,aAAa,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;YACzD,aAAa,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,CAC7C,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,IAAI,CAAC,CAAC;QAC9F,CAAC;QAED,yEAAyE;QACzE,qEAAqE;QACrE,oEAAoE;QACpE,MAAM,IAAI,CAAC,+BAA+B,EAAE,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACH,SAAS;QACP,KAAK,MAAM,aAAa,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;YACzD,aAAa,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAChD,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,IAAI,CAAC,CAAC;QAC9F,CAAC;QACD,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,CAAC;IACvC,CAAC;IAED,KAAK,CAAC,+BAA+B;QACnC,KAAK,MAAM,CAAC,GAAG,EAAE,gBAAgB,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC;YAClF,KAAK,MAAM,CAAC,GAAG,EAAE,aAAa,CAAC,IAAI,gBAAgB,EAAE,CAAC;gBACpD,MAAM,KAAK,GAAG,aAAa,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC;gBACxD,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;gBAC1C,IAAI,CAAC,MAAM,EAAE,CAAC;oBACZ,SAAS;gBACX,CAAC;gBACD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,MAAM,oBAAoB,GACtB,MAAM,eAAe,CAAC,aAAa,CAAC,+BAA+B,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;oBAChG,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,CAAC;oBAE3C,MAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;oBACpE,MAAM,QAAQ,GAAG,aAAa;wBAC1B,IAAI,GAAG,CAAC,aAAa,CAAC,QAAQ,CAC1B,aAAa,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;oBACxG,MAAM,UAAU,GAAG,QAAQ;wBACvB,MAAM,QAAQ,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,QAAQ,EAAE,CAAC,uBAAuB,CAC/F,QAAQ,CAAC,CAAC;oBAElB,kBAAkB,CAAC,6BAA6B,CAC5C,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,SAAS,EAAE,EAAC,IAAI,EAAE,oBAAoB,EAAE,gBAAgB,EAAE,UAAU,EAAC,CAAC,CAAC;gBAC5F,CAAC;YACH,CAAC;QACH,CAAC;QACD,IAAI,CAAC,aAAa,CAAC,IAAI,qBAAqB,EAAE,CAAC,CAAC;IAClD,CAAC;IAED,oBAAoB;QAClB,uEAAuE;QACvE,+DAA+D;QAC/D,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,OAAO;QACT,CAAC;QAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,0FAA0F;QAC1F,6FAA6F;QAC7F,0FAA0F;QAC1F,yFAAyF;QACzF,wCAAwC;QACxC,UAAU,CAAC,KAAK,IAAI,EAAE;YACpB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;YAC1B,MAAM,IAAI,CAAC,+BAA+B,EAAE,CAAC;QAC/C,CAAC,EAAE,GAAG,CAAC,CAAC;IACV,CAAC;IAED,mEAAmE;IACnE,gEAAgE;IAChE,gBAAgB,CAAC,GAAgC;QAC/C,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC1E,IAAI,aAAa,EAAE,CAAC;YAClB,OAAO,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;QAC9E,CAAC;QACD,OAAO,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,iBAAiB,EAAE,CAAC;IACxE,CAAC;CACF","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Bindings from '../../../models/bindings/bindings.js';\nimport * as SourceMapScopes from '../../../models/source_map_scopes/source_map_scopes.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as Workspace from '../../../models/workspace/workspace.js';\n\ntype ResolvedCodeLocationData = {\n  name: string|null,\n  devtoolsLocation: Workspace.UISourceCode.UILocation|null,\n};\nexport class SourceMappingsUpdated extends Event {\n  static readonly eventName = 'sourcemappingsupdated';\n\n  constructor() {\n    super(SourceMappingsUpdated.eventName, {\n      composed: true,\n      bubbles: true,\n    });\n  }\n}\n\n// Resolved code location data is keyed based on\n// ProcessID=>ThreadID=> Call frame key.\n// The code location key is created as a concatenation of its fields.\nexport const resolvedCodeLocationDataNames:\n    Map<Trace.Types.Events.ProcessID, Map<Trace.Types.Events.ThreadID, Map<string, ResolvedCodeLocationData|null>>> =\n        new Map();\n\nexport class SourceMapsResolver extends EventTarget {\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n\n  #isResolving = false;\n\n  // We need to gather up a list of all the DebuggerModels that we should\n  // listen to for source map attached events. For most pages this will be\n  // the debugger model for the primary page target, but if a trace has\n  // workers, we would also need to gather up the DebuggerModel instances for\n  // those workers too.\n  #debuggerModelsToListen = new Set<SDK.DebuggerModel.DebuggerModel>();\n\n  constructor(parsedTrace: Trace.Handlers.Types.ParsedTrace) {\n    super();\n    this.#parsedTrace = parsedTrace;\n  }\n\n  static clearResolvedNodeNames(): void {\n    resolvedCodeLocationDataNames.clear();\n  }\n  static keyForCodeLocation(callFrame: Protocol.Runtime.CallFrame): string {\n    return `${callFrame.url}$$$${callFrame.scriptId}$$$${callFrame.functionName}$$$${callFrame.lineNumber}$$$${\n        callFrame.columnNumber}`;\n  }\n\n  /**\n   * For trace events containing a call frame / source location\n   * (f.e. a stack trace), attempts to obtain the resolved source\n   * location based on the those that have been resolved so far from\n   * listened source maps.\n   *\n   * Note that a single deployed URL can map to multiple authored URLs\n   * (f.e. if an app is bundled). Thus, beyond a URL we can use code\n   * location data like line and column numbers to obtain the specific\n   * authored code according to the source mappings.\n   */\n  static resolvedCodeLocationForEntry(entry: Trace.Types.Events.Event): ResolvedCodeLocationData|null {\n    let callFrame = null;\n    if (Trace.Types.Events.isProfileCall(entry)) {\n      callFrame = entry.callFrame;\n    } else {\n      const stackTrace = Trace.Helpers.Trace.getZeroIndexedStackTraceForEvent(entry);\n      if (stackTrace === null || stackTrace.length < 1) {\n        return null;\n      }\n      callFrame = stackTrace[0];\n    }\n    const codeLocationKey = this.keyForCodeLocation(callFrame as Protocol.Runtime.CallFrame);\n    return resolvedCodeLocationDataNames.get(entry.pid)?.get(entry.tid)?.get(codeLocationKey) ?? null;\n  }\n\n  static resolvedURLForEntry(parsedTrace: Trace.Handlers.Types.ParsedTrace, entry: Trace.Types.Events.Event):\n      Platform.DevToolsPath.UrlString|null {\n    const resolvedCallFrameURL =\n        SourceMapsResolver.resolvedCodeLocationForEntry(entry)?.devtoolsLocation?.uiSourceCode.url();\n    if (resolvedCallFrameURL) {\n      return resolvedCallFrameURL;\n    }\n    // If no source mapping was found for an entry's URL, then default\n    // to the URL value contained in the event itself, if any.\n    const url = Trace.Extras.URLForEntry.getNonResolved(parsedTrace, entry);\n    if (url) {\n      return Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url)?.url() ?? url;\n    }\n    return null;\n  }\n\n  static storeResolvedNodeDataForEntry(\n      pid: Trace.Types.Events.ProcessID, tid: Trace.Types.Events.ThreadID, callFrame: Protocol.Runtime.CallFrame,\n      resolvedCodeLocationData: ResolvedCodeLocationData): void {\n    const resolvedForPid = resolvedCodeLocationDataNames.get(pid) ||\n        new Map<Trace.Types.Events.ThreadID, Map<string, ResolvedCodeLocationData|null>>();\n    const resolvedForTid = resolvedForPid.get(tid) || new Map<string, ResolvedCodeLocationData|null>();\n    const keyForCallFrame = this.keyForCodeLocation(callFrame);\n    resolvedForTid.set(keyForCallFrame, resolvedCodeLocationData);\n    resolvedForPid.set(tid, resolvedForTid);\n    resolvedCodeLocationDataNames.set(pid, resolvedForPid);\n  }\n\n  async install(): Promise<void> {\n    for (const threadToProfileMap of this.#parsedTrace.Samples.profilesInProcess.values()) {\n      for (const [tid, profile] of threadToProfileMap) {\n        const nodes = profile.parsedProfile.nodes();\n        if (!nodes || nodes.length === 0) {\n          continue;\n        }\n\n        const target = this.#targetForThread(tid);\n        const debuggerModel = target?.model(SDK.DebuggerModel.DebuggerModel);\n        if (!debuggerModel) {\n          continue;\n        }\n        for (const node of nodes) {\n          const script = debuggerModel.scriptForId(String(node.callFrame.scriptId));\n          const shouldListenToSourceMap = !script || script.sourceMapURL;\n          if (!shouldListenToSourceMap) {\n            continue;\n          }\n          this.#debuggerModelsToListen.add(debuggerModel);\n        }\n      }\n    }\n\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().addEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, () => this.#onAttachedSourceMap(), this);\n    }\n\n    // Although we have added listeners for SourceMapAttached events, we also\n    // immediately try to resolve function names. This ensures we use any\n    // sourcemaps that were attached before we bound our event listener.\n    await this.#resolveMappingsForProfileNodes();\n  }\n\n  /**\n   * Removes the event listeners and stops tracking newly added sourcemaps.\n   * Should be called before destroying an instance of this class to avoid leaks\n   * with listeners.\n   */\n  uninstall(): void {\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().removeEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, () => this.#onAttachedSourceMap(), this);\n    }\n    this.#debuggerModelsToListen.clear();\n  }\n\n  async #resolveMappingsForProfileNodes(): Promise<void> {\n    for (const [pid, threadsInProcess] of this.#parsedTrace.Samples.profilesInProcess) {\n      for (const [tid, threadProfile] of threadsInProcess) {\n        const nodes = threadProfile.parsedProfile.nodes() ?? [];\n        const target = this.#targetForThread(tid);\n        if (!target) {\n          continue;\n        }\n        for (const node of nodes) {\n          const resolvedFunctionName =\n              await SourceMapScopes.NamesResolver.resolveProfileFrameFunctionName(node.callFrame, target);\n          node.setFunctionName(resolvedFunctionName);\n\n          const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n          const location = debuggerModel &&\n              new SDK.DebuggerModel.Location(\n                  debuggerModel, node.callFrame.scriptId, node.callFrame.lineNumber, node.callFrame.columnNumber);\n          const uiLocation = location &&\n              await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().rawLocationToUILocation(\n                  location);\n\n          SourceMapsResolver.storeResolvedNodeDataForEntry(\n              pid, tid, node.callFrame, {name: resolvedFunctionName, devtoolsLocation: uiLocation});\n        }\n      }\n    }\n    this.dispatchEvent(new SourceMappingsUpdated());\n  }\n\n  #onAttachedSourceMap(): void {\n    // Exit if we are already resolving so that we batch requests; if pages\n    // have a lot of sourcemaps we can get a lot of events at once.\n    if (this.#isResolving) {\n      return;\n    }\n\n    this.#isResolving = true;\n    // Resolving names triggers a repaint of the flame chart. Instead of attempting to resolve\n    // names every time a source map is attached, wait for some time once the first source map is\n    // attached. This way we allow for other source maps to be parsed before attempting a name\n    // resolving using the available source maps. Otherwise the UI is blocked when the number\n    // of source maps is particularly large.\n    setTimeout(async () => {\n      this.#isResolving = false;\n      await this.#resolveMappingsForProfileNodes();\n    }, 500);\n  }\n\n  // Figure out the target for the node. If it is in a worker thread,\n  // that is the target, otherwise we use the primary page target.\n  #targetForThread(tid: Trace.Types.Events.ThreadID): SDK.Target.Target|null {\n    const maybeWorkerId = this.#parsedTrace.Workers.workerIdByThread.get(tid);\n    if (maybeWorkerId) {\n      return SDK.TargetManager.TargetManager.instance().targetById(maybeWorkerId);\n    }\n    return SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  }\n}\n"]}