{"version":3,"file":"SourceMapsResolver.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/SourceMapsResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Bindings from '../../../models/bindings/bindings.js';\nimport * as SourceMapScopes from '../../../models/source_map_scopes/source_map_scopes.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as Workspace from '../../../models/workspace/workspace.js';\n\nimport type * as EntityMapper from './EntityMapper.js';\n\ninterface ResolvedCodeLocationData {\n  name: string|null;\n  devtoolsLocation: Workspace.UISourceCode.UILocation|null;\n  script: SDK.Script.Script|null;\n}\nexport class SourceMappingsUpdated extends Event {\n  static readonly eventName = 'sourcemappingsupdated';\n  constructor() {\n    super(SourceMappingsUpdated.eventName, {composed: true, bubbles: true});\n  }\n}\n\n// The code location key is created as a concatenation of its fields.\nexport const resolvedCodeLocationDataNames = new Map<string, ResolvedCodeLocationData|null>();\n\nexport class SourceMapsResolver extends EventTarget {\n  private executionContextNamesByOrigin = new Map<Platform.DevToolsPath.UrlString, string>();\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n  #entityMapper: EntityMapper.EntityMapper|null = null;\n\n  #isResolving = false;\n\n  // We need to gather up a list of all the DebuggerModels that we should\n  // listen to for source map attached events. For most pages this will be\n  // the debugger model for the primary page target, but if a trace has\n  // workers, we would also need to gather up the DebuggerModel instances for\n  // those workers too.\n  #debuggerModelsToListen = new Set<SDK.DebuggerModel.DebuggerModel>();\n\n  constructor(parsedTrace: Trace.Handlers.Types.ParsedTrace, entityMapper?: EntityMapper.EntityMapper) {\n    super();\n    this.#parsedTrace = parsedTrace;\n    this.#entityMapper = entityMapper ?? null;\n  }\n\n  static clearResolvedNodeNames(): void {\n    resolvedCodeLocationDataNames.clear();\n  }\n  static keyForCodeLocation(callFrame: Protocol.Runtime.CallFrame): string {\n    return `${callFrame.url}$$$${callFrame.scriptId}$$$${callFrame.functionName}$$$${callFrame.lineNumber}$$$${\n        callFrame.columnNumber}`;\n  }\n\n  /**\n   * For trace events containing a call frame / source location\n   * (f.e. a stack trace), attempts to obtain the resolved source\n   * location based on the those that have been resolved so far from\n   * listened source maps.\n   *\n   * Note that a single deployed URL can map to multiple authored URLs\n   * (f.e. if an app is bundled). Thus, beyond a URL we can use code\n   * location data like line and column numbers to obtain the specific\n   * authored code according to the source mappings.\n   *\n   * TODO(andoli): This can return incorrect scripts if the target page has been reloaded since the trace.\n   */\n  static resolvedCodeLocationForCallFrame(callFrame: Protocol.Runtime.CallFrame): ResolvedCodeLocationData|null {\n    const codeLocationKey = this.keyForCodeLocation(callFrame);\n    return resolvedCodeLocationDataNames.get(codeLocationKey) ?? null;\n  }\n\n  static resolvedCodeLocationForEntry(entry: Trace.Types.Events.Event): ResolvedCodeLocationData|null {\n    let callFrame = null;\n    if (Trace.Types.Events.isProfileCall(entry)) {\n      callFrame = entry.callFrame;\n    } else {\n      const stackTrace = Trace.Helpers.Trace.getZeroIndexedStackTraceForEvent(entry);\n      if (stackTrace === null || stackTrace.length < 1) {\n        return null;\n      }\n      callFrame = stackTrace[0];\n    }\n    return SourceMapsResolver.resolvedCodeLocationForCallFrame(callFrame as Protocol.Runtime.CallFrame);\n  }\n\n  static resolvedURLForEntry(parsedTrace: Trace.Handlers.Types.ParsedTrace, entry: Trace.Types.Events.Event):\n      Platform.DevToolsPath.UrlString|null {\n    const resolvedCallFrameURL =\n        SourceMapsResolver.resolvedCodeLocationForEntry(entry)?.devtoolsLocation?.uiSourceCode.url();\n    if (resolvedCallFrameURL) {\n      return resolvedCallFrameURL;\n    }\n    // If no source mapping was found for an entry's URL, then default\n    // to the URL value contained in the event itself, if any.\n    const url = Trace.Handlers.Helpers.getNonResolvedURL(entry, parsedTrace);\n    if (url) {\n      return Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url)?.url() ?? url;\n    }\n    return null;\n  }\n\n  static storeResolvedCodeDataForCallFrame(\n      callFrame: Protocol.Runtime.CallFrame, resolvedCodeLocationData: ResolvedCodeLocationData): void {\n    const keyForCallFrame = this.keyForCodeLocation(callFrame);\n    resolvedCodeLocationDataNames.set(keyForCallFrame, resolvedCodeLocationData);\n  }\n\n  async install(): Promise<void> {\n    for (const threadToProfileMap of this.#parsedTrace.Samples.profilesInProcess.values()) {\n      for (const [tid, profile] of threadToProfileMap) {\n        const nodes = profile.parsedProfile.nodes();\n        if (!nodes || nodes.length === 0) {\n          continue;\n        }\n\n        const target = this.#targetForThread(tid);\n        const debuggerModel = target?.model(SDK.DebuggerModel.DebuggerModel);\n        if (!debuggerModel) {\n          continue;\n        }\n        for (const node of nodes) {\n          const script = debuggerModel.scriptForId(String(node.callFrame.scriptId));\n          const shouldListenToSourceMap = !script || script.sourceMapURL;\n          if (!shouldListenToSourceMap) {\n            continue;\n          }\n          this.#debuggerModelsToListen.add(debuggerModel);\n        }\n      }\n    }\n\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().addEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n\n    this.#updateExtensionNames();\n\n    // Although we have added listeners for SourceMapAttached events, we also\n    // immediately try to resolve function names. This ensures we use any\n    // sourcemaps that were attached before we bound our event listener.\n    await this.#resolveMappingsForProfileNodes();\n  }\n\n  /**\n   * Removes the event listeners and stops tracking newly added sourcemaps.\n   * Should be called before destroying an instance of this class to avoid leaks\n   * with listeners.\n   */\n  uninstall(): void {\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().removeEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n    this.#debuggerModelsToListen.clear();\n  }\n\n  async #resolveMappingsForProfileNodes(): Promise<void> {\n    // Used to track if source mappings were updated when a source map\n    // is attach. If not, we do not notify the flamechart that mappings\n    // were updated, since that would trigger a rerender.\n    let updatedMappings = false;\n    for (const [, threadsInProcess] of this.#parsedTrace.Samples.profilesInProcess) {\n      for (const [tid, threadProfile] of threadsInProcess) {\n        const nodes = threadProfile.parsedProfile.nodes() ?? [];\n        const target = this.#targetForThread(tid);\n        if (!target) {\n          continue;\n        }\n        for (const node of nodes) {\n          const resolvedFunctionName =\n              await SourceMapScopes.NamesResolver.resolveProfileFrameFunctionName(node.callFrame, target);\n          updatedMappings ||= Boolean(resolvedFunctionName);\n          node.setFunctionName(resolvedFunctionName);\n\n          const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n          const script = debuggerModel?.scriptForId(node.scriptId) || null;\n          const location = debuggerModel &&\n              new SDK.DebuggerModel.Location(\n                  debuggerModel, node.callFrame.scriptId, node.callFrame.lineNumber, node.callFrame.columnNumber);\n          const uiLocation = location &&\n              await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().rawLocationToUILocation(\n                  location);\n          updatedMappings ||= Boolean(uiLocation);\n          if (uiLocation?.uiSourceCode.url() && this.#entityMapper) {\n            // Update mappings for the related events of the entity.\n            this.#entityMapper.updateSourceMapEntities(node.callFrame, uiLocation.uiSourceCode.url());\n          }\n\n          SourceMapsResolver.storeResolvedCodeDataForCallFrame(\n              node.callFrame, {name: resolvedFunctionName, devtoolsLocation: uiLocation, script});\n        }\n      }\n    }\n    if (!updatedMappings) {\n      return;\n    }\n    this.dispatchEvent(new SourceMappingsUpdated());\n  }\n\n  #onAttachedSourceMap(): void {\n    // Exit if we are already resolving so that we batch requests; if pages\n    // have a lot of sourcemaps we can get a lot of events at once.\n    if (this.#isResolving) {\n      return;\n    }\n\n    this.#isResolving = true;\n    // Resolving names triggers a repaint of the flame chart. Instead of attempting to resolve\n    // names every time a source map is attached, wait for some time once the first source map is\n    // attached. This way we allow for other source maps to be parsed before attempting a name\n    // resolving using the available source maps. Otherwise the UI is blocked when the number\n    // of source maps is particularly large.\n    setTimeout(async () => {\n      this.#isResolving = false;\n      await this.#resolveMappingsForProfileNodes();\n    }, 500);\n  }\n\n  // Figure out the target for the node. If it is in a worker thread,\n  // that is the target, otherwise we use the primary page target.\n  #targetForThread(tid: Trace.Types.Events.ThreadID): SDK.Target.Target|null {\n    const maybeWorkerId = this.#parsedTrace.Workers.workerIdByThread.get(tid);\n    if (maybeWorkerId) {\n      return SDK.TargetManager.TargetManager.instance().targetById(maybeWorkerId);\n    }\n    return SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  }\n\n  #updateExtensionNames(): void {\n    for (const runtimeModel of SDK.TargetManager.TargetManager.instance().models(SDK.RuntimeModel.RuntimeModel)) {\n      for (const context of runtimeModel.executionContexts()) {\n        this.executionContextNamesByOrigin.set(context.origin, context.name);\n      }\n    }\n    this.#entityMapper?.updateExtensionEntitiesWithName(this.executionContextNamesByOrigin);\n  }\n}\n"]}