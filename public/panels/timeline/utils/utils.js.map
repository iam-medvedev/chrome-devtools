{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/timeline/utils/AICallTree.ts", "../../../../../../../front_end/panels/timeline/utils/AIContext.ts", "../../../../../../../front_end/panels/timeline/utils/EntryNodes.ts", "../../../../../../../front_end/panels/timeline/utils/FreshRecording.ts", "../../../../../../../front_end/panels/timeline/utils/Helpers.ts", "../../../../../../../front_end/panels/timeline/utils/IgnoreList.ts", "../../../../../../../front_end/panels/timeline/utils/ImageCache.ts", "../../../../../../../front_end/panels/timeline/utils/InsightAIContext.ts", "../../../../../../../front_end/panels/timeline/utils/Treemap.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Root from '../../../core/root/root.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as SourceMapsResolver from '../../../models/trace_source_maps_resolver/trace_source_maps_resolver.js';\n\n/** Iterates from a node down through its descendents. If the callback returns true, the loop stops. */\nfunction depthFirstWalk(\n    nodes: MapIterator<Trace.Extras.TraceTree.Node>, callback: (arg0: Trace.Extras.TraceTree.Node) => void|true): void {\n  for (const node of nodes) {\n    if (callback?.(node)) {\n      break;\n    }\n    depthFirstWalk(node.children().values(), callback);  // Go deeper.\n  }\n}\n\nexport interface FromTimeOnThreadOptions {\n  thread: {pid: Trace.Types.Events.ProcessID, tid: Trace.Types.Events.ThreadID};\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  bounds: Trace.Types.Timing.TraceWindowMicro;\n}\n\nexport class AICallTree {\n  constructor(\n      public selectedNode: Trace.Extras.TraceTree.Node|null,\n      public rootNode: Trace.Extras.TraceTree.TopDownRootNode,\n      public parsedTrace: Trace.TraceModel.ParsedTrace,\n  ) {\n  }\n\n  static findEventsForThread({thread, parsedTrace, bounds}: FromTimeOnThreadOptions): Trace.Types.Events.Event[]|null {\n    const threadEvents = parsedTrace.data.Renderer.processes.get(thread.pid)?.threads.get(thread.tid)?.entries;\n    if (!threadEvents) {\n      return null;\n    }\n\n    return threadEvents.filter(e => Trace.Helpers.Timing.eventIsInBounds(e, bounds));\n  }\n\n  static findMainThreadTasks({thread, parsedTrace, bounds}: FromTimeOnThreadOptions):\n      Trace.Types.Events.RunTask[]|null {\n    const threadEvents = parsedTrace.data.Renderer.processes.get(thread.pid)?.threads.get(thread.tid)?.entries;\n    if (!threadEvents) {\n      return null;\n    }\n\n    return threadEvents.filter(Trace.Types.Events.isRunTask)\n        .filter(e => Trace.Helpers.Timing.eventIsInBounds(e, bounds));\n  }\n\n  /**\n   * Builds a call tree representing all calls within the given timeframe for\n   * the provided thread.\n   * Events that are less than 0.05% of the range duration are removed.\n   */\n  static fromTimeOnThread({thread, parsedTrace, bounds}: FromTimeOnThreadOptions): AICallTree|null {\n    const overlappingEvents = this.findEventsForThread({thread, parsedTrace, bounds});\n    if (!overlappingEvents) {\n      return null;\n    }\n\n    const visibleEventsFilter = new Trace.Extras.TraceFilter.VisibleEventsFilter(Trace.Styles.visibleTypes());\n\n    // By default, we remove events whose duration is less than 0.5% of the total\n    // range. So if the range is 10s, an event must be 0.05s+ to be included.\n    // This does risk eliminating useful data when we pass it to the LLM, but\n    // we are trying to balance context window sizes and not using it up too\n    // eagerly. We will experiment with this filter and likely make it smarter\n    // or tweak it based on range size rather than using a blanket value. Or we\n    // could consider limiting the depth when we serialize. Or some\n    // combination!\n    const minDuration = Trace.Types.Timing.Micro(bounds.range * 0.005);\n    const minDurationFilter = new MinDurationFilter(minDuration);\n    const compileCodeFilter = new ExcludeCompileCodeFilter();\n    // Build a tree bounded by the selected event's timestamps, and our other filters applied\n    const rootNode = new Trace.Extras.TraceTree.TopDownRootNode(overlappingEvents, {\n      filters: [minDurationFilter, compileCodeFilter, visibleEventsFilter],\n      startTime: Trace.Helpers.Timing.microToMilli(bounds.min),\n      endTime: Trace.Helpers.Timing.microToMilli(bounds.max),\n      doNotAggregate: true,\n      includeInstantEvents: true,\n    });\n\n    const instance = new AICallTree(null /* no selected node*/, rootNode, parsedTrace);\n    return instance;\n  }\n  /**\n   * Attempts to build an AICallTree from a given selected event. It also\n   * validates that this event is one that we support being used with the AI\n   * Assistance panel, which [as of January 2025] means:\n   * 1. It is on the main thread.\n   * 2. It exists in either the Renderer or Sample handler's entryToNode map.\n   * This filters out other events we make such as SyntheticLayoutShifts which are not valid\n   * If the event is not valid, or there is an unexpected error building the tree, `null` is returned.\n   */\n  static fromEvent(selectedEvent: Trace.Types.Events.Event, parsedTrace: Trace.TraceModel.ParsedTrace): AICallTree\n      |null {\n    // Special case: performance.mark events are shown on the main thread\n    // technically, but because they are instant events they are shown with a\n    // tiny duration. Because they are instant, they also don't have any\n    // children or a call tree, and so if the user has selected a performance\n    // mark in the timings track, we do not want to attempt to build a call\n    // tree. Context: crbug.com/418223469\n    // Note that we do not have to repeat this check for performance.measure\n    // events because those are synthetic, and therefore the check\n    // further down about if this event is known to the RenderHandler\n    // deals with this.\n    if (Trace.Types.Events.isPerformanceMark(selectedEvent)) {\n      return null;\n    }\n\n    // First: check that the selected event is on the thread we have identified as the main thread.\n    const threads = Trace.Handlers.Threads.threadsInTrace(parsedTrace.data);\n    const thread = threads.find(t => t.pid === selectedEvent.pid && t.tid === selectedEvent.tid);\n    if (!thread) {\n      return null;\n    }\n    // We allow two thread types to deal with the NodeJS use case.\n    // MAIN_THREAD is used when a trace has been generated through Chrome\n    //   tracing on a website (and we have a renderer)\n    // CPU_PROFILE is used only when we have received a CPUProfile - in this\n    //   case all the threads are CPU_PROFILE so we allow those. If we only allow\n    //   MAIN_THREAD then we wouldn't ever allow NodeJS users to use the AI\n    //   integration.\n    if (thread.type !== Trace.Handlers.Threads.ThreadType.MAIN_THREAD &&\n        thread.type !== Trace.Handlers.Threads.ThreadType.CPU_PROFILE) {\n      return null;\n    }\n\n    // Ensure that the event is known to either the Renderer or Samples\n    // handler. This helps exclude synthetic events we build up for other\n    // information such as Layout Shift clusters.\n    // We check Renderer + Samples to ensure we support CPU Profiles (which do\n    // not populate the Renderer Handler)\n    const data = parsedTrace.data;\n    if (!data.Renderer.entryToNode.has(selectedEvent) && !data.Samples.entryToNode.has(selectedEvent)) {\n      return null;\n    }\n\n    const allEventsEnabled = Root.Runtime.experiments.isEnabled('timeline-show-all-events');\n    const {startTime, endTime} = Trace.Helpers.Timing.eventTimingsMilliSeconds(selectedEvent);\n    const selectedEventBounds = Trace.Helpers.Timing.traceWindowFromMicroSeconds(\n        Trace.Helpers.Timing.milliToMicro(startTime), Trace.Helpers.Timing.milliToMicro(endTime));\n    let threadEvents = data.Renderer.processes.get(selectedEvent.pid)?.threads.get(selectedEvent.tid)?.entries;\n    if (!threadEvents) {\n      // None from the renderer: try the samples handler, this might be a CPU trace.\n      threadEvents = data.Samples.profilesInProcess.get(selectedEvent.pid)?.get(selectedEvent.tid)?.profileCalls;\n    }\n\n    if (!threadEvents) {\n      console.warn(`AICallTree: could not find thread for selected entry: ${selectedEvent}`);\n      return null;\n    }\n    const overlappingEvents = threadEvents.filter(e => Trace.Helpers.Timing.eventIsInBounds(e, selectedEventBounds));\n\n    const filters: Trace.Extras.TraceFilter.TraceFilter[] =\n        [new SelectedEventDurationFilter(selectedEvent), new ExcludeCompileCodeFilter(selectedEvent)];\n\n    // If the \"Show all events\" experiment is on, we don't filter out any\n    // events here, otherwise the generated call tree will not match what the\n    // user is seeing.\n    if (!allEventsEnabled) {\n      filters.push(new Trace.Extras.TraceFilter.VisibleEventsFilter(Trace.Styles.visibleTypes()));\n    }\n\n    // Build a tree bounded by the selected event's timestamps, and our other filters applied\n    const rootNode = new Trace.Extras.TraceTree.TopDownRootNode(overlappingEvents, {\n      filters,\n      startTime,\n      endTime,\n      includeInstantEvents: true,\n    });\n\n    // Walk the tree to find selectedNode\n    let selectedNode: Trace.Extras.TraceTree.Node|null = null;\n    depthFirstWalk([rootNode].values(), node => {\n      if (node.event === selectedEvent) {\n        selectedNode = node;\n        return true;\n      }\n      return;\n    });\n\n    if (selectedNode === null) {\n      console.warn(`Selected event ${selectedEvent} not found within its own tree.`);\n      return null;\n    }\n    const instance = new AICallTree(selectedNode, rootNode, parsedTrace);\n    // instance.logDebug();\n    return instance;\n  }\n\n  /**\n   * Iterates through nodes level by level using a Breadth-First Search (BFS) algorithm.\n   * BFS is important here because the serialization process assumes that direct child nodes\n   * will have consecutive IDs (horizontally across each depth).\n   *\n   * Example tree with IDs:\n   *\n   *             1\n   *            / \\\n   *           2   3\n   *        / / /   \\\n   *      4  5 6     7\n   *\n   * Here, node with an ID 2 has consecutive children in the 4-6 range.\n   *\n   * To optimize for space, the provided `callback` function is called to serialize\n   * each node as it's visited during the BFS traversal.\n   *\n   * When serializing a node, the callback receives:\n   * 1. The current node being visited.\n   * 2. The ID assigned to this current node (a simple incrementing index based on visit order).\n   * 3. The predicted starting ID for the children of this current node.\n   *\n   * A serialized node needs to know the ID range of its children. However,\n   * child node IDs are only assigned when those children are themselves visited.\n   * To handle this, we predict the starting ID for a node's children. This prediction\n   * is based on a running count of all nodes that have ever been added to the BFS queue.\n   * Since IDs are assigned consecutively as nodes are processed from the queue, and a\n   * node's children are added to the end of the queue when the parent is visited,\n   * their eventual IDs will follow this running count.\n   */\n  breadthFirstWalk(\n      nodes: MapIterator<Trace.Extras.TraceTree.Node>,\n      serializeNodeCallback:\n          (currentNode: Trace.Extras.TraceTree.Node, nodeId: number, childrenStartingId?: number) => void): void {\n    const queue: Trace.Extras.TraceTree.Node[] = Array.from(nodes);\n    let nodeIndex = 1;\n    // To predict the visited children indexes\n    let nodesAddedToQueueCount = queue.length;\n\n    let currentNode = queue.shift();\n\n    while (currentNode) {\n      if (currentNode.children().size > 0) {\n        serializeNodeCallback(currentNode, nodeIndex, nodesAddedToQueueCount + 1);\n      } else {\n        serializeNodeCallback(currentNode, nodeIndex);\n      }\n\n      queue.push(...Array.from(currentNode.children().values()));\n      nodesAddedToQueueCount += currentNode.children().size;\n\n      currentNode = queue.shift();\n      nodeIndex++;\n    }\n  }\n\n  serialize(headerLevel = 1): string {\n    const header = '#'.repeat(headerLevel);\n\n    // Keep a map of URLs. We'll output a LUT to keep size down.\n    const allUrls: string[] = [];\n\n    let nodesStr = '';\n    this.breadthFirstWalk(this.rootNode.children().values(), (node, nodeId, childStartingNode) => {\n      nodesStr +=\n          '\\n' + this.stringifyNode(node, nodeId, this.parsedTrace, this.selectedNode, allUrls, childStartingNode);\n    });\n\n    let output = '';\n    if (allUrls.length) {\n      // Output lookup table of URLs within this tree\n      output += `\\n${header} All URLs:\\n\\n` + allUrls.map((url, index) => `  * ${index}: ${url}`).join('\\n');\n    }\n    output += `\\n\\n${header} Call tree:\\n${nodesStr}`;\n    return output;\n  }\n\n  /*\n  * Each node is serialized into a single line to minimize token usage in the context window.\n  * The format is a semicolon-separated string with the following fields:\n  * Format: `id;name;duration;selfTime;urlIndex;childRange;[S]\n  *\n  *   1. `id`: A unique numerical identifier for the node assigned by BFS.\n  *   2. `name`: The name of the event represented by the node.\n  *   3. `duration`: The total duration of the event in milliseconds, rounded to one decimal place.\n  *   4. `selfTime`: The self time of the event in milliseconds, rounded to one decimal place.\n  *   5. `urlIndex`: An index referencing a URL in the `allUrls` array. If no URL is present, this is an empty string.\n  *   6. `childRange`: A string indicating the range of IDs for the node's children. Children should always have consecutive IDs.\n  *                    If there is only one child, it's a single ID.\n  *   7. `[S]`: An optional marker indicating that this node is the selected node.\n  *\n  * Example:\n  *   `1;Parse HTML;2.5;0.3;0;2-5;S`\n  *   This represents:\n  *     - Node ID 1\n  *     - Name \"Parse HTML\"\n  *     - Total duration of 2.5ms\n  *     - Self time of 0.3ms\n  *     - URL index 0 (meaning the URL is the first one in the `allUrls` array)\n  *     - Child range of IDs 2 to 5\n  *     - This node is the selected node (S marker)\n  */\n  stringifyNode(\n      node: Trace.Extras.TraceTree.Node, nodeId: number, parsedTrace: Trace.TraceModel.ParsedTrace,\n      selectedNode: Trace.Extras.TraceTree.Node|null, allUrls: string[], childStartingNodeIndex?: number): string {\n    const event = node.event;\n    if (!event) {\n      throw new Error('Event required');\n    }\n\n    // 1. ID\n    const idStr = String(nodeId);\n\n    // 2. Name\n    const name = Trace.Name.forEntry(event, parsedTrace);\n\n    // Round milliseconds to one decimal place, return empty string if zero/undefined\n    const roundToTenths = (num: number|undefined): string => {\n      if (!num) {\n        return '';\n      }\n      return String(Math.round(num * 10) / 10);\n    };\n\n    // 3. Duration\n    const durationStr = roundToTenths(node.totalTime);\n\n    // 4. Self Time\n    const selfTimeStr = roundToTenths(node.selfTime);\n\n    // 5. URL Index\n    const url = SourceMapsResolver.SourceMapsResolver.resolvedURLForEntry(parsedTrace, event);\n    let urlIndexStr = '';\n    if (url) {\n      const existingIndex = allUrls.indexOf(url);\n      if (existingIndex === -1) {\n        urlIndexStr = String(allUrls.push(url) - 1);\n      } else {\n        urlIndexStr = String(existingIndex);\n      }\n    }\n\n    // 6. Child Range\n    const children = Array.from(node.children().values());\n    let childRangeStr = '';\n    if (childStartingNodeIndex) {\n      childRangeStr = (children.length === 1) ? String(childStartingNodeIndex) :\n                                                `${childStartingNodeIndex}-${childStartingNodeIndex + children.length}`;\n    }\n\n    // 7. Selected Marker\n    const selectedMarker = selectedNode?.event === node.event ? 'S' : '';\n\n    // Combine fields\n    let line = idStr;\n    line += ';' + name;\n    line += ';' + durationStr;\n    line += ';' + selfTimeStr;\n    line += ';' + urlIndexStr;\n    line += ';' + childRangeStr;\n\n    if (selectedMarker) {\n      line += ';' + selectedMarker;\n    }\n\n    return line;\n  }\n\n  // Only used for debugging.\n  logDebug(): void {\n    const str = this.serialize();\n    // eslint-disable-next-line no-console\n    console.log('🎆', str);\n    if (str.length > 45_000) {\n      // Manual testing shows 45k fits. 50k doesn't.\n      // Max is 32k _tokens_, but tokens to bytes is wishywashy, so... hard to know for sure.\n      console.warn('Output will likely not fit in the context window. Expect an AIDA error.');\n    }\n  }\n}\n\n/**\n * These events are very noisy and take up room in the context window for no real benefit.\n */\nexport class ExcludeCompileCodeFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #selectedEvent: Trace.Types.Events.Event|null = null;\n  constructor(selectedEvent?: Trace.Types.Events.Event) {\n    super();\n    this.#selectedEvent = selectedEvent ?? null;\n  }\n\n  accept(event: Trace.Types.Events.Event): boolean {\n    if (this.#selectedEvent && event === this.#selectedEvent) {\n      // If the user selects this event, we should accept it, else the\n      // behaviour is confusing when the selected event is not used.\n      return true;\n    }\n    return event.name !== Trace.Types.Events.Name.COMPILE_CODE;\n  }\n}\n\nexport class SelectedEventDurationFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #minDuration: Trace.Types.Timing.Micro;\n  #selectedEvent: Trace.Types.Events.Event;\n  constructor(selectedEvent: Trace.Types.Events.Event) {\n    super();\n    // The larger the selected event is, the less small ones matter. We'll exclude items under ½% of the selected event's size\n    this.#minDuration = Trace.Types.Timing.Micro((selectedEvent.dur ?? 1) * 0.005);\n    this.#selectedEvent = selectedEvent;\n  }\n  accept(event: Trace.Types.Events.Event): boolean {\n    if (event === this.#selectedEvent) {\n      return true;\n    }\n    return event.dur ? event.dur >= this.#minDuration : false;\n  }\n}\n\nexport class MinDurationFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #minDuration: Trace.Types.Timing.Micro;\n\n  constructor(minDuration: Trace.Types.Timing.Micro) {\n    super();\n    this.#minDuration = minDuration;\n  }\n\n  accept(event: Trace.Types.Events.Event): boolean {\n    return event.dur ? event.dur >= this.#minDuration : false;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport type {AICallTree} from './AICallTree.js';\n\nexport interface AgentFocusDataFull {\n  type: 'full';\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  insightSet: Trace.Insights.Types.InsightSet|null;\n}\n\ninterface AgentFocusDataCallTree {\n  type: 'call-tree';\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  insightSet: Trace.Insights.Types.InsightSet|null;\n  callTree: AICallTree;\n}\n\nexport interface AgentFocusDataInsight {\n  type: 'insight';\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  insightSet: Trace.Insights.Types.InsightSet|null;\n  insight: Trace.Insights.Types.InsightModel;\n}\n\ntype AgentFocusData = AgentFocusDataCallTree|AgentFocusDataInsight|AgentFocusDataFull;\n\nfunction getFirstInsightSet(insights: Trace.Insights.Types.TraceInsightSets): Trace.Insights.Types.InsightSet|null {\n  // Currently only support a single insight set. Pick the first one with a navigation.\n  // TODO(cjamcl): we should just give the agent the entire insight set, and give\n  // summary detail about all of them + the ability to query each.\n  return [...insights.values()].filter(insightSet => insightSet.navigation).at(0) ?? null;\n}\n\nexport class AgentFocus {\n  static full(parsedTrace: Trace.TraceModel.ParsedTrace): AgentFocus {\n    if (!parsedTrace.insights) {\n      throw new Error('missing insights');\n    }\n\n    const insightSet = getFirstInsightSet(parsedTrace.insights);\n    return new AgentFocus({\n      type: 'full',\n      parsedTrace,\n      insightSet,\n    });\n  }\n\n  static fromInsight(parsedTrace: Trace.TraceModel.ParsedTrace, insight: Trace.Insights.Types.InsightModel):\n      AgentFocus {\n    if (!parsedTrace.insights) {\n      throw new Error('missing insights');\n    }\n\n    const insightSet = getFirstInsightSet(parsedTrace.insights);\n    return new AgentFocus({\n      type: 'insight',\n      parsedTrace,\n      insightSet,\n      insight,\n    });\n  }\n\n  static fromCallTree(callTree: AICallTree): AgentFocus {\n    const insights = callTree.parsedTrace.insights;\n\n    // Select the insight set containing the call tree.\n    // If for some reason that fails, fallback to the first one.\n    let insightSet = null;\n    if (insights) {\n      const callTreeTimeRange = Trace.Helpers.Timing.traceWindowFromEvent(callTree.rootNode.event);\n      insightSet = insights.values().find(set => Trace.Helpers.Timing.boundsIncludeTimeRange({\n        timeRange: callTreeTimeRange,\n        bounds: set.bounds,\n      })) ??\n          getFirstInsightSet(insights);\n    }\n\n    return new AgentFocus({type: 'call-tree', parsedTrace: callTree.parsedTrace, insightSet, callTree});\n  }\n\n  #data: AgentFocusData;\n\n  constructor(data: AgentFocusData) {\n    this.#data = data;\n  }\n\n  get data(): AgentFocusData {\n    return this.#data;\n  }\n}\n\nexport function getPerformanceAgentFocusFromModel(model: Trace.TraceModel.Model): AgentFocus|null {\n  const parsedTrace = model.parsedTrace();\n  if (!parsedTrace) {\n    return null;\n  }\n\n  return AgentFocus.full(parsedTrace);\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Trace from '../../../models/trace/trace.js';\n\nconst nodeIdsForEventCache = new WeakMap<Trace.Types.Events.Event, Set<Protocol.DOM.BackendNodeId>>();\nconst domNodesForEventCache =\n    new WeakMap<Trace.Types.Events.Event, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\n\n/**\n * Extracts a set of NodeIds for a given event.\n * The result is cached so you can safely call this multiple times.\n **/\nexport function nodeIdsForEvent(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    event: Trace.Types.Events.Event,\n    ): Set<Protocol.DOM.BackendNodeId> {\n  const fromCache = nodeIdsForEventCache.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const foundIds = new Set<Protocol.DOM.BackendNodeId>();\n\n  if (Trace.Types.Events.isLayout(event)) {\n    event.args.endData?.layoutRoots.forEach(root => foundIds.add(root.nodeId));\n  } else if (Trace.Types.Events.isSyntheticLayoutShift(event) && event.args.data?.impacted_nodes) {\n    event.args.data.impacted_nodes.forEach(node => foundIds.add(node.node_id));\n  } else if (\n      Trace.Types.Events.isLargestContentfulPaintCandidate(event) && typeof event.args.data?.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isPaint(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isPaintImage(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isScrollLayer(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (\n      Trace.Types.Events.isSyntheticAnimation(event) &&\n      typeof event.args.data.beginEvent.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.beginEvent.args.data.nodeId);\n  } else if (Trace.Types.Events.isDecodeImage(event)) {\n    // For a DecodeImage event, we can use the ImagePaintingHandler, which has\n    // done the work to build the relationship between a DecodeImage event and\n    // the corresponding PaintImage event.\n    const paintImageEvent = parsedTrace.data.ImagePainting.paintImageForEvent.get(event);\n    if (typeof paintImageEvent?.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Trace.Types.Events.isDrawLazyPixelRef(event) && event.args?.LazyPixelRef) {\n    const paintImageEvent = parsedTrace.data.ImagePainting.paintImageByDrawLazyPixelRef.get(event.args.LazyPixelRef);\n    if (typeof paintImageEvent?.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Trace.Types.Events.isParseMetaViewport(event) && typeof event.args?.data.node_id !== 'undefined') {\n    foundIds.add(event.args.data.node_id);\n  }\n  nodeIdsForEventCache.set(event, foundIds);\n  return foundIds;\n}\n\n/**\n * Looks up for backend node ids in different types of trace events\n * and resolves them into related DOM nodes.\n * This method is cached for the given event.\n */\nexport async function relatedDOMNodesForEvent(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    event: Trace.Types.Events.Event): Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>|null> {\n  const fromCache = domNodesForEventCache.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  const nodeIds = nodeIdsForEvent(parsedTrace, event);\n  if (nodeIds.size) {\n    const frame = event.args?.data?.frame as Protocol.Page.FrameId;\n    const result = await domNodesForBackendIds(frame, nodeIds);\n    domNodesForEventCache.set(event, result);\n    return result;\n  }\n\n  return null;\n}\n\n/**\n * Takes a set of Protocol.DOM.BackendNodeId ids and will return a map of NodeId=>DOMNode.\n */\nexport async function domNodesForBackendIds(frameId: Protocol.Page.FrameId, nodeIds: Set<Protocol.DOM.BackendNodeId>):\n    Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>> {\n  const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  const resourceTreeModel = target?.model(SDK.ResourceTreeModel.ResourceTreeModel);\n  if (!domModel || !resourceTreeModel) {\n    return new Map();\n  }\n\n  // The node is only relevant if the target contains the specified frame.\n  // For now, allow events that specify no frame id to continue to resolve a node.\n  if (frameId && !resourceTreeModel.frames().some(frame => frame.id === frameId)) {\n    return new Map();\n  }\n\n  return await domModel.pushNodesByBackendIdsToFrontend(nodeIds) || new Map();\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Trace from '../../../models/trace/trace.js';\n\nlet instance: Tracker|null = null;\n\n/**\n * In multiple places we need to know if the trace we are working on is fresh\n * or not. We cannot store that data in the trace file's metadata (otherwise a\n * loaded trace file could claim to be fresh), so we store it here. When a new trace\n * is loaded, we set this flag accordingly.\n **/\nexport class Tracker {\n  #freshRecordings = new WeakSet<Trace.TraceModel.ParsedTrace>();\n\n  static instance(opts: {forceNew: boolean} = {forceNew: false}): Tracker {\n    if (!instance || opts.forceNew) {\n      instance = new Tracker();\n    }\n    return instance;\n  }\n\n  registerFreshRecording(data: Trace.TraceModel.ParsedTrace): void {\n    this.#freshRecordings.add(data);\n  }\n\n  recordingIsFresh(data: Trace.TraceModel.ParsedTrace): boolean {\n    return this.#freshRecordings.has(data);\n  }\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport * as CrUXManager from '../../../models/crux-manager/crux-manager.js';\nimport type * as Trace from '../../../models/trace/trace.js';\n\nconst MAX_ORIGIN_LENGTH = 60;\n\nexport function getThrottlingRecommendations(): {\n  cpuOption: SDK.CPUThrottlingManager.CPUThrottlingOption|null,\n  networkConditions: SDK.NetworkManager.Conditions|null,\n} {\n  let cpuOption: SDK.CPUThrottlingManager.CPUThrottlingOption =\n      SDK.CPUThrottlingManager.CalibratedMidTierMobileThrottlingOption;\n  if (cpuOption.rate() === 0) {\n    cpuOption = SDK.CPUThrottlingManager.MidTierThrottlingOption;\n  }\n\n  let networkConditions = null;\n  const response = CrUXManager.CrUXManager.instance().getSelectedFieldMetricData('round_trip_time');\n  if (response?.percentiles) {\n    const rtt = Number(response.percentiles.p75);\n    networkConditions = SDK.NetworkManager.getRecommendedNetworkPreset(rtt);\n  }\n\n  return {\n    cpuOption,\n    networkConditions,\n  };\n}\n\nfunction createTrimmedUrlSearch(url: URL): string {\n  const maxSearchValueLength = 8;\n  let search = '';\n\n  for (const [key, value] of url.searchParams) {\n    if (search) {\n      search += '&';\n    }\n    if (value) {\n      search += `${key}=${Platform.StringUtilities.trimEndWithMaxLength(value, maxSearchValueLength)}`;\n    } else {\n      search += key;\n    }\n  }\n  if (search) {\n    search = '?' + search;\n  }\n\n  return search;\n}\n\n/**\n * Shortens URLs as much as possible while keeping important context.\n *\n * - Elides the host if the previous url is the same host+protocol\n * - Always elide search param values\n * - Always includes protocol/domain if there is a mix of protocols\n * - First URL is elided fully to show just the pathname, unless there is a mix of protocols (see above)\n */\nexport function createUrlLabels(urls: URL[]): string[] {\n  const labels: string[] = [];\n  const isAllHttps = urls.every(url => url.protocol === 'https:');\n\n  for (const [index, url] of urls.entries()) {\n    const previousUrl = urls[index - 1];\n    const sameHostAndProtocol = previousUrl && url.host === previousUrl.host && url.protocol === previousUrl.protocol;\n    let elideHost = sameHostAndProtocol;\n    let elideProtocol = isAllHttps;\n\n    // For the first URL, show just the pathname and search - this will be relative to the domain as seen in the\n    // trace dropdown selector. Exception is if there are non-https protocols, in which case we're only going to elide\n    // parts of the query string.\n    if (index === 0 && isAllHttps) {\n      elideHost = true;\n      elideProtocol = true;\n    }\n\n    const search = createTrimmedUrlSearch(url);\n    if (!elideProtocol) {\n      labels.push(`${url.protocol}//${url.host}${url.pathname}${search}`);\n    } else if (!elideHost) {\n      labels.push(`${url.host}${url.pathname}${search}`);\n    } else {\n      labels.push(`${url.pathname}${search}`);\n    }\n  }\n\n  // Lastly, remove any trailing `/`.\n  return labels.map(label => label.length > 1 && label.endsWith('/') ? label.substring(0, label.length - 1) : label);\n}\n\n/**\n * Shortens the provided URL for use within a narrow display usecase.\n *\n * The resulting string will at least contain the last path component of the URL.\n * More components are included until a limit of maxChars (default 20) is reached.\n * No querystring is included.\n *\n * If the last path component is larger than maxChars characters, the middle is elided.\n */\nexport function shortenUrl(url: URL, maxChars = 20): string {\n  const parts = url.pathname === '/' ? [url.host] : url.pathname.split('/');\n  let shortenedUrl = parts.at(-1) ?? '';\n\n  if (shortenedUrl.length > maxChars) {\n    return Platform.StringUtilities.trimMiddle(shortenedUrl, maxChars);\n  }\n\n  let i = parts.length - 1;\n  while (--i >= 0) {\n    if (shortenedUrl.length + parts[i].length <= maxChars) {\n      shortenedUrl = `${parts[i]}/${shortenedUrl}`;\n    }\n  }\n\n  return shortenedUrl;\n}\n\n/**\n * Returns a string containing both the origin and its 3rd party entity.\n *\n * By default we construct by diving with a hyphen, but with an optional\n * parenthesizeEntity to parenthesize the entity.\n *\n * @example 'uk-script.dotmetrics.net - DotMetrics'\n * @example 'securepubads.g.doubleclick.net (Google/Doubleclick Ads)'\n */\nexport function formatOriginWithEntity(\n    url: URL, entity: Trace.Handlers.Helpers.Entity|null, parenthesizeEntity?: boolean): string {\n  const origin = url.origin.replace('https://', '');\n  if (!entity) {\n    return origin;\n  }\n  let originWithEntity;\n  // If we have an unrecognized entity, entity name would be the same as the origin.\n  if (entity.isUnrecognized) {\n    originWithEntity = `${origin}`;\n  } else {\n    originWithEntity = parenthesizeEntity ? `${origin} (${entity.name})` : `${origin} - ${entity.name}`;\n  }\n\n  originWithEntity = Platform.StringUtilities.trimEndWithMaxLength(originWithEntity, MAX_ORIGIN_LENGTH);\n  return originWithEntity;\n}\n\n// Thin wrapper class to enable revealing an individual insight in Timeline panel.\nexport class RevealableInsight {\n  constructor(public insight: Trace.Insights.Types.InsightModel) {\n  }\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as SourceMapsResolver from '../../../models/trace_source_maps_resolver/trace_source_maps_resolver.js';\nimport * as Workspace from '../../../models/workspace/workspace.js';\n\nconst UIStrings = {\n  /**\n   * @description Refers to when skipping content scripts is enabled and the current script is ignored because it's a content script.\n   */\n  skipContentScripts: 'Content script',\n  /**\n   * @description Refers to when skipping known third party scripts is enabled and the current script is ignored because it's a known third party script.\n   */\n  skip3rdPartyScripts: 'Marked with ignoreList in source map',\n  /**\n   * @description Refers to when skipping anonymous scripts is enabled and the current script is ignored because is an anonymous script.\n   */\n  skipAnonymousScripts: 'Anonymous script',\n  /**\n   * @description Refers to when the current script is ignored because of an unknown rule.\n   */\n  unknown: 'Unknown',\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/utils/IgnoreList.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nfunction getUrlAndIgnoreListOptions(entry: Trace.Types.Events.SyntheticProfileCall):\n    {url: Platform.DevToolsPath.UrlString, ignoreListOptions: Workspace.IgnoreListManager.IgnoreListGeneralRules} {\n  const rawUrl = entry.callFrame.url as Platform.DevToolsPath.UrlString;\n\n  const sourceMappedData = SourceMapsResolver.SourceMapsResolver.resolvedCodeLocationForEntry(entry);\n  const script = sourceMappedData?.script;\n  const uiSourceCode = sourceMappedData?.devtoolsLocation?.uiSourceCode;\n  const resolvedUrl = uiSourceCode?.url();\n  const isKnownThirdParty = uiSourceCode?.isKnownThirdParty();\n  const isContentScript = script?.isContentScript();\n  const ignoreListOptions: Workspace.IgnoreListManager.IgnoreListGeneralRules = {isContentScript, isKnownThirdParty};\n  const url = resolvedUrl || rawUrl;\n  return {url, ignoreListOptions};\n}\n\nexport function isIgnoreListedEntry(entry: Trace.Types.Events.Event): boolean {\n  if (!Trace.Types.Events.isProfileCall(entry)) {\n    return false;\n  }\n  const {url, ignoreListOptions} = getUrlAndIgnoreListOptions(entry);\n  return isIgnoreListedURL(url, ignoreListOptions);\n}\n\nfunction isIgnoreListedURL(\n    url: Platform.DevToolsPath.UrlString, options?: Workspace.IgnoreListManager.IgnoreListGeneralRules): boolean {\n  return Workspace.IgnoreListManager.IgnoreListManager.instance().isUserIgnoreListedURL(url, options);\n}\n\n/**\n * Returns the ignore reason for the given entry.\n *\n * This function should be called when `isIgnoreListedEntry(entry)` is true\n */\nexport function getIgnoredReasonString(entry: Trace.Types.Events.Event): string {\n  if (!Trace.Types.Events.isProfileCall(entry)) {\n    console.warn('Ignore list feature should only support ProfileCall.');\n    return '';\n  }\n  const {url, ignoreListOptions} = getUrlAndIgnoreListOptions(entry);\n\n  const ignoreListMgr = Workspace.IgnoreListManager.IgnoreListManager.instance();\n  if (ignoreListOptions.isContentScript && ignoreListMgr.skipContentScripts) {\n    return i18nString(UIStrings.skipContentScripts);\n  }\n  if (ignoreListOptions.isKnownThirdParty && ignoreListMgr.automaticallyIgnoreListKnownThirdPartyScripts) {\n    return i18nString(UIStrings.skip3rdPartyScripts);\n  }\n\n  if (!url) {\n    if (ignoreListMgr.skipAnonymousScripts) {\n      return i18nString(UIStrings.skipAnonymousScripts);\n    }\n    // This branch shouldn't be reached because when |skipAnonymousScripts| is false, this url is not ignored.\n    // So just return empty string to make the type check work.\n    return '';\n  }\n  const regex = ignoreListMgr.getFirstMatchedRegex(url);\n  return regex ? regex.source : i18nString(UIStrings.unknown);\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nconst imageCache =\n    new WeakMap<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot, HTMLImageElement|null>();\nexport const emitter = new EventTarget();\n\n/**\n * Synchronously returns an image, or return `null` while queuing up an async load of that image.\n * If the image load fails, we cache a null to avoid reattempts.\n */\nexport function getOrQueue(screenshot: Trace.Types.Events.LegacySyntheticScreenshot|\n                           Trace.Types.Events.Screenshot): HTMLImageElement|null {\n  if (imageCache.has(screenshot)) {\n    return imageCache.get(screenshot) ?? null;\n  }\n\n  const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n\n  loadImage(uri)\n      .then(imageOrNull => {\n        imageCache.set(screenshot, imageOrNull);\n        emitter.dispatchEvent(new CustomEvent('screenshot-loaded', {detail: {screenshot, image: imageOrNull}}));\n      })\n      .catch(() => {});\n  return null;\n}\n\n/** Load an image (probably data URI). If it fails, resolve with null. */\nfunction loadImage(url: string): Promise<HTMLImageElement|null> {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => resolve(null));\n    image.src = url;\n  });\n}\n\n/** Populate the cache ahead of use, to allow for getOrQueue to synchronously return images. */\nexport function preload(screenshots: Array<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot>):\n    Promise<void[]> {\n  const promises = screenshots.map(screenshot => {\n    if (imageCache.has(screenshot)) {\n      return;\n    }\n    const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n    return loadImage(uri).then(image => {\n      imageCache.set(screenshot, image);\n      return;\n    });\n  });\n  return Promise.all(promises);\n}\n\nexport const cacheForTesting = imageCache;\nexport const loadImageForTesting = loadImage;\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport {AICallTree} from './AICallTree.js';\n\nexport class AIQueries {\n  static findMainThread(navigationId: string|undefined, parsedTrace: Trace.TraceModel.ParsedTrace):\n      Trace.Handlers.Threads.ThreadData|null {\n    /**\n     * We cannot assume that there is one main thread as there are scenarios\n     * where there can be multiple (see crbug.com/402658800) as an example.\n     * Therefore we calculate the main thread by using the thread that the\n     * Insight has been associated to. Most Insights relate to a navigation, so\n     * in this case we can use the navigation's PID/TID as we know that will\n     * have run on the main thread that we are interested in.\n     * If we do not have a navigation, we fall back to looking for the first\n     * thread we find that is of type MAIN_THREAD.\n     * Longer term we should solve this at the Trace Engine level to avoid\n     * look-ups like this; this is the work that is tracked in\n     * crbug.com/402658800.\n     */\n    let mainThreadPID: Trace.Types.Events.ProcessID|null = null;\n    let mainThreadTID: Trace.Types.Events.ThreadID|null = null;\n\n    if (navigationId) {\n      const navigation = parsedTrace.data.Meta.navigationsByNavigationId.get(navigationId);\n      if (navigation?.args.data?.isOutermostMainFrame) {\n        mainThreadPID = navigation.pid;\n        mainThreadTID = navigation.tid;\n      }\n    }\n\n    const threads = Trace.Handlers.Threads.threadsInTrace(parsedTrace.data);\n    const thread = threads.find(thread => {\n      if (mainThreadPID && mainThreadTID) {\n        return thread.pid === mainThreadPID && thread.tid === mainThreadTID;\n      }\n      return thread.type === Trace.Handlers.Threads.ThreadType.MAIN_THREAD;\n    });\n\n    return thread ?? null;\n  }\n\n  /**\n   * Returns bottom up activity for the given range.\n   */\n  static mainThreadActivityBottomUp(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.TraceModel.ParsedTrace): Trace.Extras.TraceTree.BottomUpRootNode|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    const events = AICallTree.findEventsForThread({thread, parsedTrace, bounds});\n    if (!events) {\n      return null;\n    }\n\n    // Use the same filtering as front_end/panels/timeline/TimelineTreeView.ts.\n    const visibleEvents = Trace.Helpers.Trace.VISIBLE_TRACE_EVENT_TYPES.values().toArray();\n    const filter = new Trace.Extras.TraceFilter.VisibleEventsFilter(\n        visibleEvents.concat([Trace.Types.Events.Name.SYNTHETIC_NETWORK_REQUEST]));\n\n    // The bottom up root node handles all the \"in Tracebounds\" checks we need for the insight.\n    const startTime = Trace.Helpers.Timing.microToMilli(bounds.min);\n    const endTime = Trace.Helpers.Timing.microToMilli(bounds.max);\n    return new Trace.Extras.TraceTree.BottomUpRootNode(events, {\n      textFilter: new Trace.Extras.TraceFilter.ExclusiveNameFilter([]),\n      filters: [filter],\n      startTime,\n      endTime,\n    });\n  }\n\n  /**\n   * Returns an AI Call Tree representing the activity on the main thread for\n   * the relevant time range of the given insight.\n   */\n  static mainThreadActivityTopDown(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.TraceModel.ParsedTrace): AICallTree|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    return AICallTree.fromTimeOnThread({\n      thread: {\n        pid: thread.pid,\n        tid: thread.tid,\n      },\n      parsedTrace,\n      bounds,\n    });\n  }\n\n  /**\n   * Returns the top longest tasks as AI Call Trees.\n   */\n  static longestTasks(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.TraceModel.ParsedTrace, limit = 3): AICallTree[]|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    const tasks = AICallTree.findMainThreadTasks({thread, parsedTrace, bounds});\n    if (!tasks) {\n      return null;\n    }\n\n    const topTasks = tasks.filter(e => e.name === 'RunTask').sort((a, b) => b.dur - a.dur).slice(0, limit);\n    return topTasks\n        .map(task => {\n          const tree = AICallTree.fromEvent(task, parsedTrace);\n          if (tree) {\n            tree.selectedNode = null;\n          }\n          return tree;\n        })\n        .filter(tree => !!tree);\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Trace from '../../../models/trace/trace.js';\n\ninterface TreemapNode {\n  /** Could be a url, a path component from a source map, or an arbitrary string. */\n  name: string;\n  resourceBytes: number;\n  /** Transfer size of the script. Only set for non-inline top-level script nodes. */\n  encodedBytes?: number;\n  /** If present, this module is a duplicate. String is normalized source path. See ScriptDuplication.normalizeSource */\n  duplicatedNormalizedModuleName?: string;\n  children?: TreemapNode[];\n}\n\nexport type TreemapData = TreemapNode[];\ntype SourceData = Omit<TreemapNode, 'name'|'children'>;\n\n/**\n * Takes an UTF-8, gzips then base64's it.\n */\nasync function toCompressedBase64(string: string): Promise<string> {\n  const compAb = await Common.Gzip.compress(string);\n  const strb64 = await Common.Base64.encode(compAb);\n  return strb64;\n}\n\n/**\n * Opens a new tab to an external page and sends data via base64 encoded url params.\n */\nasync function openTabWithUrlData(data: object, urlString: string, windowName: string): Promise<void> {\n  const url = new URL(urlString);\n  url.hash = await toCompressedBase64(JSON.stringify(data));\n  url.searchParams.set('gzip', '1');\n  window.open(url.toString(), windowName);\n}\n\n/**\n * Opens a new tab to the treemap app and sends the data using URL.fragment\n */\nexport function openTreemap(treemapData: TreemapData, mainDocumentUrl: string, windowNameSuffix: string): void {\n  const treemapOptions = {\n    lhr: {\n      mainDocumentUrl,\n      audits: {\n        'script-treemap-data': {\n          details: {\n            type: 'treemap-data',\n            nodes: treemapData,\n          },\n        },\n      },\n      configSettings: {\n        locale: i18n.DevToolsLocale.DevToolsLocale.instance().locale,\n      },\n    },\n    initialView: 'duplicate-modules',\n  };\n  const url = 'https://googlechrome.github.io/lighthouse/treemap/';\n  const windowName = `treemap-${windowNameSuffix}`;\n\n  void openTabWithUrlData(treemapOptions, url, windowName);\n}\n\n/**\n * Returns a tree data structure where leaf nodes are sources (ie. real files from\n * source tree) from a source map, and non-leaf nodes are directories. Leaf nodes\n * have data for bytes, coverage, etc., when available, and non-leaf nodes have the\n * same data as the sum of all descendant leaf nodes.\n */\nexport function makeScriptNode(src: string, sourceRoot: string, sourcesData: Record<string, SourceData>): TreemapNode {\n  function newNode(name: string): TreemapNode {\n    return {\n      name,\n      resourceBytes: 0,\n      encodedBytes: undefined,\n    };\n  }\n\n  const sourceRootNode = newNode(sourceRoot);\n\n  /**\n   * Given a slash-delimited path, traverse the Node structure and increment\n   * the data provided for each node in the chain. Creates nodes as needed.\n   * Ex: path/to/file.js will find or create \"path\" on `node`, increment the data fields,\n   *     and continue with \"to\", and so on.\n   */\n  function addAllNodesInSourcePath(source: string, data: SourceData): void {\n    let node = sourceRootNode;\n\n    // Apply the data to the sourceRootNode.\n    sourceRootNode.resourceBytes += data.resourceBytes;\n\n    // Strip off the shared root.\n    const sourcePathSegments = source.replace(sourceRoot, '').split(/\\/+/);\n    sourcePathSegments.forEach((sourcePathSegment, i) => {\n      if (sourcePathSegment.length === 0) {\n        return;\n      }\n\n      const isLeaf = i === sourcePathSegments.length - 1;\n\n      let child = node.children?.find(child => child.name === sourcePathSegment);\n      if (!child) {\n        child = newNode(sourcePathSegment);\n        node.children = node.children || [];\n        node.children.push(child);\n      }\n      node = child;\n\n      // Now that we've found or created the next node in the path, apply the data.\n      node.resourceBytes += data.resourceBytes;\n\n      // Only leaf nodes might have duplication data.\n      if (isLeaf && data.duplicatedNormalizedModuleName !== undefined) {\n        node.duplicatedNormalizedModuleName = data.duplicatedNormalizedModuleName;\n      }\n    });\n  }\n\n  // For every source file, apply the data to all components\n  // of the source path, creating nodes as necessary.\n  for (const [source, data] of Object.entries(sourcesData)) {\n    addAllNodesInSourcePath(source, data);\n  }\n\n  /**\n   * Collapse nodes that have only one child.\n   */\n  function collapseAll(node: TreemapNode): void {\n    while (node.children && node.children.length === 1) {\n      const child = node.children[0];\n      node.name += '/' + child.name;\n      if (child.duplicatedNormalizedModuleName) {\n        node.duplicatedNormalizedModuleName = child.duplicatedNormalizedModuleName;\n      }\n      node.children = child.children;\n    }\n\n    if (node.children) {\n      for (const child of node.children) {\n        collapseAll(child);\n      }\n    }\n  }\n  collapseAll(sourceRootNode);\n\n  // If sourceRootNode.name is falsy (no defined sourceRoot + no collapsed common prefix),\n  // collapse the sourceRootNode children into the scriptNode.\n  // Otherwise, we add another node.\n  if (!sourceRootNode.name) {\n    return {\n      ...sourceRootNode,\n      name: src,\n      children: sourceRootNode.children,\n    };\n  }\n\n  // Script node should be just the script src.\n  const scriptNode = {...sourceRootNode};\n  scriptNode.name = src;\n  scriptNode.children = [sourceRootNode];\n  return scriptNode;\n}\n\nfunction getNetworkRequestSizes(request: Trace.Types.Events.SyntheticNetworkRequest):\n    {resourceSize: number, transferSize: number, headersTransferSize: number} {\n  const resourceSize = request.args.data.decodedBodyLength;\n  const transferSize = request.args.data.encodedDataLength;\n  // TODO: add something like `responseHeadersTransferSize` to trace\n  // SyntheticNetworkRequest (see Lighthouse). For now, incorrectly include the size\n  // of the headers here.\n  const headersTransferSize = 0;\n  return {resourceSize, transferSize, headersTransferSize};\n}\n\n/**\n * Returns an array of nodes, where the first level of nodes represents every script.\n *\n * Every external script has a node.\n * All inline scripts are combined into a single node.\n * If a script has a source map, that node will be created by makeScriptNode.\n *\n * Example return result:\n *  - index.html (inline scripts)\n *  - main.js\n *  - - webpack://\n *  - - - react.js\n *  - - - app.js\n *  - i-have-no-map.js\n */\nexport function createTreemapData(\n    scripts: Trace.Handlers.ModelHandlers.Scripts.ScriptsData,\n    duplication: Trace.Extras.ScriptDuplication.ScriptDuplication): TreemapData {\n  const nodes: TreemapNode[] = [];\n  const htmlNodesByFrameId = new Map<string, TreemapNode>();\n\n  for (const script of scripts.scripts) {\n    if (!script.url) {\n      continue;\n    }\n\n    const name = script.url;\n    const sizes = Trace.Handlers.ModelHandlers.Scripts.getScriptGeneratedSizes(script);\n\n    let node: TreemapNode;\n    if (script.sourceMap && sizes && !('errorMessage' in sizes)) {\n      // Create nodes for each module in a bundle.\n\n      const sourcesData: Record<string, SourceData> = {};\n      for (const [source, resourceBytes] of Object.entries(sizes.files)) {\n        const sourceData: SourceData = {\n          resourceBytes,\n          encodedBytes: undefined,\n        };\n\n        const key = Trace.Extras.ScriptDuplication.normalizeSource(source);\n        if (duplication.has(key)) {\n          sourceData.duplicatedNormalizedModuleName = key;\n        }\n\n        sourcesData[source] = sourceData;\n      }\n\n      if (sizes.unmappedBytes) {\n        const sourceData: SourceData = {\n          resourceBytes: sizes.unmappedBytes,\n        };\n        sourcesData['(unmapped)'] = sourceData;\n      }\n\n      node = makeScriptNode(script.url, script.url, sourcesData);\n    } else {\n      // No valid source map for this script, so we can only produce a single node.\n      node = {\n        name,\n        resourceBytes: script.content?.length ?? 0,\n        encodedBytes: undefined,\n      };\n    }\n\n    // If this is an inline script, place the node inside a top-level (aka depth-one)\n    // node. Also separate each iframe / the main page's inline scripts into their\n    // own top-level nodes.\n    if (script.inline) {\n      let htmlNode = htmlNodesByFrameId.get(script.frame);\n      if (!htmlNode) {\n        htmlNode = {\n          name,\n          resourceBytes: 0,\n          encodedBytes: undefined,\n          children: [],\n        };\n        htmlNodesByFrameId.set(script.frame, htmlNode);\n        nodes.push(htmlNode);\n      }\n      htmlNode.resourceBytes += node.resourceBytes;\n      node.name = script.content ? '(inline) ' + script.content.trimStart().substring(0, 15) + '…' : '(inline)';\n      htmlNode.children?.push(node);\n    } else {\n      // Non-inline scripts each have their own top-level node.\n      nodes.push(node);\n\n      if (script.request) {\n        const {transferSize, headersTransferSize} = getNetworkRequestSizes(script.request);\n        const bodyTransferSize = transferSize - headersTransferSize;\n        node.encodedBytes = bodyTransferSize;\n      } else {\n        node.encodedBytes = node.resourceBytes;\n      }\n    }\n  }\n\n  // For the HTML nodes, set encodedBytes to be the size of all the inline\n  // scripts multiplied by the average compression ratio of the HTML document.\n  for (const [frameId, node] of htmlNodesByFrameId) {\n    const script = scripts.scripts.find(\n        s => s.request?.args.data.resourceType === 'Document' && s.request?.args.data.frame === frameId);\n    if (script?.request) {\n      const {resourceSize, transferSize, headersTransferSize} = getNetworkRequestSizes(script.request);\n      const inlineScriptsPct = node.resourceBytes / resourceSize;\n      const bodyTransferSize = transferSize - headersTransferSize;\n      node.encodedBytes = Math.floor(bodyTransferSize * inlineScriptsPct);\n    } else {\n      node.encodedBytes = node.resourceBytes;\n    }\n  }\n\n  return nodes;\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;;;;AAIA,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB,YAAY,wBAAwB;AAGpC,SAAS,eACL,OAAiD,UAA0D;AAC7G,aAAW,QAAQ,OAAO;AACxB,QAAI,WAAW,IAAI,GAAG;AACpB;IACF;AACA,mBAAe,KAAK,SAAQ,EAAG,OAAM,GAAI,QAAQ;EACnD;AACF;AAQM,IAAO,aAAP,MAAO,YAAU;EAEV;EACA;EACA;EAHX,YACW,cACA,UACA,aAAyC;AAFzC,SAAA,eAAA;AACA,SAAA,WAAA;AACA,SAAA,cAAA;EAEX;EAEA,OAAO,oBAAoB,EAAC,QAAQ,aAAa,OAAM,GAA0B;AAC/E,UAAM,eAAe,YAAY,KAAK,SAAS,UAAU,IAAI,OAAO,GAAG,GAAG,QAAQ,IAAI,OAAO,GAAG,GAAG;AACnG,QAAI,CAAC,cAAc;AACjB,aAAO;IACT;AAEA,WAAO,aAAa,OAAO,OAAW,cAAQ,OAAO,gBAAgB,GAAG,MAAM,CAAC;EACjF;EAEA,OAAO,oBAAoB,EAAC,QAAQ,aAAa,OAAM,GAA0B;AAE/E,UAAM,eAAe,YAAY,KAAK,SAAS,UAAU,IAAI,OAAO,GAAG,GAAG,QAAQ,IAAI,OAAO,GAAG,GAAG;AACnG,QAAI,CAAC,cAAc;AACjB,aAAO;IACT;AAEA,WAAO,aAAa,OAAa,YAAM,OAAO,SAAS,EAClD,OAAO,OAAW,cAAQ,OAAO,gBAAgB,GAAG,MAAM,CAAC;EAClE;;;;;;EAOA,OAAO,iBAAiB,EAAC,QAAQ,aAAa,OAAM,GAA0B;AAC5E,UAAM,oBAAoB,KAAK,oBAAoB,EAAC,QAAQ,aAAa,OAAM,CAAC;AAChF,QAAI,CAAC,mBAAmB;AACtB,aAAO;IACT;AAEA,UAAM,sBAAsB,IAAU,aAAO,YAAY,oBAA0B,aAAO,aAAY,CAAE;AAUxG,UAAM,cAAoB,YAAM,OAAO,MAAM,OAAO,QAAQ,IAAK;AACjE,UAAM,oBAAoB,IAAI,kBAAkB,WAAW;AAC3D,UAAM,oBAAoB,IAAI,yBAAwB;AAEtD,UAAM,WAAW,IAAU,aAAO,UAAU,gBAAgB,mBAAmB;MAC7E,SAAS,CAAC,mBAAmB,mBAAmB,mBAAmB;MACnE,WAAiB,cAAQ,OAAO,aAAa,OAAO,GAAG;MACvD,SAAe,cAAQ,OAAO,aAAa,OAAO,GAAG;MACrD,gBAAgB;MAChB,sBAAsB;KACvB;AAED,UAAMA,YAAW,IAAI,YAAW,MAA4B,UAAU,WAAW;AACjF,WAAOA;EACT;;;;;;;;;;EAUA,OAAO,UAAU,eAAyC,aAAyC;AAYjG,QAAU,YAAM,OAAO,kBAAkB,aAAa,GAAG;AACvD,aAAO;IACT;AAGA,UAAM,UAAgB,eAAS,QAAQ,eAAe,YAAY,IAAI;AACtE,UAAM,SAAS,QAAQ,KAAK,OAAK,EAAE,QAAQ,cAAc,OAAO,EAAE,QAAQ,cAAc,GAAG;AAC3F,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAQA,QAAI,OAAO,SAAI,iBACX,OAAO,SAAI,eAAoD;AACjE,aAAO;IACT;AAOA,UAAM,OAAO,YAAY;AACzB,QAAI,CAAC,KAAK,SAAS,YAAY,IAAI,aAAa,KAAK,CAAC,KAAK,QAAQ,YAAY,IAAI,aAAa,GAAG;AACjG,aAAO;IACT;AAEA,UAAM,mBAAwB,aAAQ,YAAY,UAAU,0BAA0B;AACtF,UAAM,EAAC,WAAW,QAAO,IAAU,cAAQ,OAAO,yBAAyB,aAAa;AACxF,UAAM,sBAA4B,cAAQ,OAAO,4BACvC,cAAQ,OAAO,aAAa,SAAS,GAAS,cAAQ,OAAO,aAAa,OAAO,CAAC;AAC5F,QAAI,eAAe,KAAK,SAAS,UAAU,IAAI,cAAc,GAAG,GAAG,QAAQ,IAAI,cAAc,GAAG,GAAG;AACnG,QAAI,CAAC,cAAc;AAEjB,qBAAe,KAAK,QAAQ,kBAAkB,IAAI,cAAc,GAAG,GAAG,IAAI,cAAc,GAAG,GAAG;IAChG;AAEA,QAAI,CAAC,cAAc;AACjB,cAAQ,KAAK,yDAAyD,aAAa,EAAE;AACrF,aAAO;IACT;AACA,UAAM,oBAAoB,aAAa,OAAO,OAAW,cAAQ,OAAO,gBAAgB,GAAG,mBAAmB,CAAC;AAE/G,UAAM,UACF,CAAC,IAAI,4BAA4B,aAAa,GAAG,IAAI,yBAAyB,aAAa,CAAC;AAKhG,QAAI,CAAC,kBAAkB;AACrB,cAAQ,KAAK,IAAU,aAAO,YAAY,oBAA0B,aAAO,aAAY,CAAE,CAAC;IAC5F;AAGA,UAAM,WAAW,IAAU,aAAO,UAAU,gBAAgB,mBAAmB;MAC7E;MACA;MACA;MACA,sBAAsB;KACvB;AAGD,QAAI,eAAiD;AACrD,mBAAe,CAAC,QAAQ,EAAE,OAAM,GAAI,UAAO;AACzC,UAAI,KAAK,UAAU,eAAe;AAChC,uBAAe;AACf,eAAO;MACT;AACA;IACF,CAAC;AAED,QAAI,iBAAiB,MAAM;AACzB,cAAQ,KAAK,kBAAkB,aAAa,iCAAiC;AAC7E,aAAO;IACT;AACA,UAAMA,YAAW,IAAI,YAAW,cAAc,UAAU,WAAW;AAEnE,WAAOA;EACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiCA,iBACI,OACA,uBACmG;AACrG,UAAM,QAAuC,MAAM,KAAK,KAAK;AAC7D,QAAI,YAAY;AAEhB,QAAI,yBAAyB,MAAM;AAEnC,QAAI,cAAc,MAAM,MAAK;AAE7B,WAAO,aAAa;AAClB,UAAI,YAAY,SAAQ,EAAG,OAAO,GAAG;AACnC,8BAAsB,aAAa,WAAW,yBAAyB,CAAC;MAC1E,OAAO;AACL,8BAAsB,aAAa,SAAS;MAC9C;AAEA,YAAM,KAAK,GAAG,MAAM,KAAK,YAAY,SAAQ,EAAG,OAAM,CAAE,CAAC;AACzD,gCAA0B,YAAY,SAAQ,EAAG;AAEjD,oBAAc,MAAM,MAAK;AACzB;IACF;EACF;EAEA,UAAU,cAAc,GAAC;AACvB,UAAM,SAAS,IAAI,OAAO,WAAW;AAGrC,UAAM,UAAoB,CAAA;AAE1B,QAAI,WAAW;AACf,SAAK,iBAAiB,KAAK,SAAS,SAAQ,EAAG,OAAM,GAAI,CAAC,MAAM,QAAQ,sBAAqB;AAC3F,kBACI,OAAO,KAAK,cAAc,MAAM,QAAQ,KAAK,aAAa,KAAK,cAAc,SAAS,iBAAiB;IAC7G,CAAC;AAED,QAAI,SAAS;AACb,QAAI,QAAQ,QAAQ;AAElB,gBAAU;EAAK,MAAM;;IAAmB,QAAQ,IAAI,CAAC,KAAK,UAAU,OAAO,KAAK,KAAK,GAAG,EAAE,EAAE,KAAK,IAAI;IACvG;AACA,cAAU;;EAAO,MAAM;EAAgB,QAAQ;AAC/C,WAAO;EACT;;;;;;;;;;;;;;;;;;;;;;;;;;EA2BA,cACI,MAAmC,QAAgB,aACnD,cAAgD,SAAmB,wBAA+B;AACpG,UAAM,QAAQ,KAAK;AACnB,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,gBAAgB;IAClC;AAGA,UAAM,QAAQ,OAAO,MAAM;AAG3B,UAAM,OAAa,WAAK,SAAS,OAAO,WAAW;AAGnD,UAAM,gBAAgB,CAAC,QAAiC;AACtD,UAAI,CAAC,KAAK;AACR,eAAO;MACT;AACA,aAAO,OAAO,KAAK,MAAM,MAAM,EAAE,IAAI,EAAE;IACzC;AAGA,UAAM,cAAc,cAAc,KAAK,SAAS;AAGhD,UAAM,cAAc,cAAc,KAAK,QAAQ;AAG/C,UAAM,MAAyB,sCAAmB,oBAAoB,aAAa,KAAK;AACxF,QAAI,cAAc;AAClB,QAAI,KAAK;AACP,YAAM,gBAAgB,QAAQ,QAAQ,GAAG;AACzC,UAAI,kBAAkB,IAAI;AACxB,sBAAc,OAAO,QAAQ,KAAK,GAAG,IAAI,CAAC;MAC5C,OAAO;AACL,sBAAc,OAAO,aAAa;MACpC;IACF;AAGA,UAAM,WAAW,MAAM,KAAK,KAAK,SAAQ,EAAG,OAAM,CAAE;AACpD,QAAI,gBAAgB;AACpB,QAAI,wBAAwB;AAC1B,sBAAiB,SAAS,WAAW,IAAK,OAAO,sBAAsB,IAC7B,GAAG,sBAAsB,IAAI,yBAAyB,SAAS,MAAM;IACjH;AAGA,UAAM,iBAAiB,cAAc,UAAU,KAAK,QAAQ,MAAM;AAGlE,QAAI,OAAO;AACX,YAAQ,MAAM;AACd,YAAQ,MAAM;AACd,YAAQ,MAAM;AACd,YAAQ,MAAM;AACd,YAAQ,MAAM;AAEd,QAAI,gBAAgB;AAClB,cAAQ,MAAM;IAChB;AAEA,WAAO;EACT;;EAGA,WAAQ;AACN,UAAM,MAAM,KAAK,UAAS;AAE1B,YAAQ,IAAI,aAAM,GAAG;AACrB,QAAI,IAAI,SAAS,MAAQ;AAGvB,cAAQ,KAAK,yEAAyE;IACxF;EACF;;AAMI,IAAO,2BAAP,cAA8C,aAAO,YAAY,YAAW;EAChF,iBAAgD;EAChD,YAAY,eAAwC;AAClD,UAAK;AACL,SAAK,iBAAiB,iBAAiB;EACzC;EAEA,OAAO,OAA+B;AACpC,QAAI,KAAK,kBAAkB,UAAU,KAAK,gBAAgB;AAGxD,aAAO;IACT;AACA,WAAO,MAAM,SAAI;EACnB;;AAGI,IAAO,8BAAP,cAAiD,aAAO,YAAY,YAAW;EACnF;EACA;EACA,YAAY,eAAuC;AACjD,UAAK;AAEL,SAAK,eAAqB,YAAM,OAAO,OAAO,cAAc,OAAO,KAAK,IAAK;AAC7E,SAAK,iBAAiB;EACxB;EACA,OAAO,OAA+B;AACpC,QAAI,UAAU,KAAK,gBAAgB;AACjC,aAAO;IACT;AACA,WAAO,MAAM,MAAM,MAAM,OAAO,KAAK,eAAe;EACtD;;AAGI,IAAO,oBAAP,cAAuC,aAAO,YAAY,YAAW;EACzE;EAEA,YAAY,aAAqC;AAC/C,UAAK;AACL,SAAK,eAAe;EACtB;EAEA,OAAO,OAA+B;AACpC,WAAO,MAAM,MAAM,MAAM,OAAO,KAAK,eAAe;EACtD;;;;ACxaF;;;;;AAIA,YAAYC,YAAW;AA0BvB,SAAS,mBAAmB,UAA+C;AAIzE,SAAO,CAAC,GAAG,SAAS,OAAM,CAAE,EAAE,OAAO,gBAAc,WAAW,UAAU,EAAE,GAAG,CAAC,KAAK;AACrF;AAEM,IAAO,aAAP,MAAO,YAAU;EACrB,OAAO,KAAK,aAAyC;AACnD,QAAI,CAAC,YAAY,UAAU;AACzB,YAAM,IAAI,MAAM,kBAAkB;IACpC;AAEA,UAAM,aAAa,mBAAmB,YAAY,QAAQ;AAC1D,WAAO,IAAI,YAAW;MACpB,MAAM;MACN;MACA;KACD;EACH;EAEA,OAAO,YAAY,aAA2C,SAA0C;AAEtG,QAAI,CAAC,YAAY,UAAU;AACzB,YAAM,IAAI,MAAM,kBAAkB;IACpC;AAEA,UAAM,aAAa,mBAAmB,YAAY,QAAQ;AAC1D,WAAO,IAAI,YAAW;MACpB,MAAM;MACN;MACA;MACA;KACD;EACH;EAEA,OAAO,aAAa,UAAoB;AACtC,UAAM,WAAW,SAAS,YAAY;AAItC,QAAI,aAAa;AACjB,QAAI,UAAU;AACZ,YAAM,oBAA0B,eAAQ,OAAO,qBAAqB,SAAS,SAAS,KAAK;AAC3F,mBAAa,SAAS,OAAM,EAAG,KAAK,SAAa,eAAQ,OAAO,uBAAuB;QACrF,WAAW;QACX,QAAQ,IAAI;OACb,CAAC,KACE,mBAAmB,QAAQ;IACjC;AAEA,WAAO,IAAI,YAAW,EAAC,MAAM,aAAa,aAAa,SAAS,aAAa,YAAY,SAAQ,CAAC;EACpG;EAEA;EAEA,YAAY,MAAoB;AAC9B,SAAK,QAAQ;EACf;EAEA,IAAI,OAAI;AACN,WAAO,KAAK;EACd;;AAGI,SAAU,kCAAkC,OAA6B;AAC7E,QAAM,cAAc,MAAM,YAAW;AACrC,MAAI,CAAC,aAAa;AAChB,WAAO;EACT;AAEA,SAAO,WAAW,KAAK,WAAW;AACpC;;;ACtGA;;;;;;AAIA,YAAY,SAAS;AAErB,YAAYC,YAAW;AAEvB,IAAM,uBAAuB,oBAAI,QAAO;AACxC,IAAM,wBACF,oBAAI,QAAO;AAMT,SAAU,gBACZ,aACA,OAA+B;AAEjC,QAAM,YAAY,qBAAqB,IAAI,KAAK;AAChD,MAAI,WAAW;AACb,WAAO;EACT;AACA,QAAM,WAAW,oBAAI,IAAG;AAExB,MAAU,aAAM,OAAO,SAAS,KAAK,GAAG;AACtC,UAAM,KAAK,SAAS,YAAY,QAAQ,UAAQ,SAAS,IAAI,KAAK,MAAM,CAAC;EAC3E,WAAiB,aAAM,OAAO,uBAAuB,KAAK,KAAK,MAAM,KAAK,MAAM,gBAAgB;AAC9F,UAAM,KAAK,KAAK,eAAe,QAAQ,UAAQ,SAAS,IAAI,KAAK,OAAO,CAAC;EAC3E,WACU,aAAM,OAAO,kCAAkC,KAAK,KAAK,OAAO,MAAM,KAAK,MAAM,WAAW,aAAa;AACjH,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,aAAM,OAAO,QAAQ,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AAC7F,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,aAAM,OAAO,aAAa,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AAClG,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,aAAM,OAAO,cAAc,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AACnG,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WACU,aAAM,OAAO,qBAAqB,KAAK,KAC7C,OAAO,MAAM,KAAK,KAAK,WAAW,KAAK,KAAK,WAAW,aAAa;AACtE,aAAS,IAAI,MAAM,KAAK,KAAK,WAAW,KAAK,KAAK,MAAM;EAC1D,WAAiB,aAAM,OAAO,cAAc,KAAK,GAAG;AAIlD,UAAM,kBAAkB,YAAY,KAAK,cAAc,mBAAmB,IAAI,KAAK;AACnF,QAAI,OAAO,iBAAiB,KAAK,KAAK,WAAW,aAAa;AAC5D,eAAS,IAAI,gBAAgB,KAAK,KAAK,MAAM;IAC/C;EACF,WAAiB,aAAM,OAAO,mBAAmB,KAAK,KAAK,MAAM,MAAM,cAAc;AACnF,UAAM,kBAAkB,YAAY,KAAK,cAAc,6BAA6B,IAAI,MAAM,KAAK,YAAY;AAC/G,QAAI,OAAO,iBAAiB,KAAK,KAAK,WAAW,aAAa;AAC5D,eAAS,IAAI,gBAAgB,KAAK,KAAK,MAAM;IAC/C;EACF,WAAiB,aAAM,OAAO,oBAAoB,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,YAAY,aAAa;AAC3G,aAAS,IAAI,MAAM,KAAK,KAAK,OAAO;EACtC;AACA,uBAAqB,IAAI,OAAO,QAAQ;AACxC,SAAO;AACT;AAOA,eAAsB,wBAClB,aACA,OAA+B;AACjC,QAAM,YAAY,sBAAsB,IAAI,KAAK;AACjD,MAAI,WAAW;AACb,WAAO;EACT;AAEA,QAAM,UAAU,gBAAgB,aAAa,KAAK;AAClD,MAAI,QAAQ,MAAM;AAChB,UAAM,QAAQ,MAAM,MAAM,MAAM;AAChC,UAAM,SAAS,MAAM,sBAAsB,OAAO,OAAO;AACzD,0BAAsB,IAAI,OAAO,MAAM;AACvC,WAAO;EACT;AAEA,SAAO;AACT;AAKA,eAAsB,sBAAsB,SAAgC,SAAwC;AAElH,QAAM,SAAa,kBAAc,cAAc,SAAQ,EAAG,kBAAiB;AAC3E,QAAM,WAAW,QAAQ,MAAU,aAAS,QAAQ;AACpD,QAAM,oBAAoB,QAAQ,MAAU,sBAAkB,iBAAiB;AAC/E,MAAI,CAAC,YAAY,CAAC,mBAAmB;AACnC,WAAO,oBAAI,IAAG;EAChB;AAIA,MAAI,WAAW,CAAC,kBAAkB,OAAM,EAAG,KAAK,WAAS,MAAM,OAAO,OAAO,GAAG;AAC9E,WAAO,oBAAI,IAAG;EAChB;AAEA,SAAO,MAAM,SAAS,gCAAgC,OAAO,KAAK,oBAAI,IAAG;AAC3E;;;ACrGA;;;;IAAI,WAAyB;AAQvB,IAAO,UAAP,MAAO,SAAO;EAClB,mBAAmB,oBAAI,QAAO;EAE9B,OAAO,SAAS,OAA4B,EAAC,UAAU,MAAK,GAAC;AAC3D,QAAI,CAAC,YAAY,KAAK,UAAU;AAC9B,iBAAW,IAAI,SAAO;IACxB;AACA,WAAO;EACT;EAEA,uBAAuB,MAAkC;AACvD,SAAK,iBAAiB,IAAI,IAAI;EAChC;EAEA,iBAAiB,MAAkC;AACjD,WAAO,KAAK,iBAAiB,IAAI,IAAI;EACvC;;;;AC7BF;;;;;;;;AAIA,YAAY,cAAc;AAC1B,YAAYC,UAAS;AACrB,YAAY,iBAAiB;AAG7B,IAAM,oBAAoB;AAEpB,SAAU,+BAA4B;AAI1C,MAAI,YACI,0BAAqB;AAC7B,MAAI,UAAU,KAAI,MAAO,GAAG;AAC1B,gBAAgB,0BAAqB;EACvC;AAEA,MAAI,oBAAoB;AACxB,QAAM,WAAuB,wBAAY,SAAQ,EAAG,2BAA2B,iBAAiB;AAChG,MAAI,UAAU,aAAa;AACzB,UAAM,MAAM,OAAO,SAAS,YAAY,GAAG;AAC3C,wBAAwB,oBAAe,4BAA4B,GAAG;EACxE;AAEA,SAAO;IACL;IACA;;AAEJ;AAEA,SAAS,uBAAuB,KAAQ;AACtC,QAAM,uBAAuB;AAC7B,MAAI,SAAS;AAEb,aAAW,CAAC,KAAK,KAAK,KAAK,IAAI,cAAc;AAC3C,QAAI,QAAQ;AACV,gBAAU;IACZ;AACA,QAAI,OAAO;AACT,gBAAU,GAAG,GAAG,IAAa,yBAAgB,qBAAqB,OAAO,oBAAoB,CAAC;IAChG,OAAO;AACL,gBAAU;IACZ;EACF;AACA,MAAI,QAAQ;AACV,aAAS,MAAM;EACjB;AAEA,SAAO;AACT;AAUM,SAAU,gBAAgB,MAAW;AACzC,QAAM,SAAmB,CAAA;AACzB,QAAM,aAAa,KAAK,MAAM,SAAO,IAAI,aAAa,QAAQ;AAE9D,aAAW,CAAC,OAAO,GAAG,KAAK,KAAK,QAAO,GAAI;AACzC,UAAM,cAAc,KAAK,QAAQ,CAAC;AAClC,UAAM,sBAAsB,eAAe,IAAI,SAAS,YAAY,QAAQ,IAAI,aAAa,YAAY;AACzG,QAAI,YAAY;AAChB,QAAI,gBAAgB;AAKpB,QAAI,UAAU,KAAK,YAAY;AAC7B,kBAAY;AACZ,sBAAgB;IAClB;AAEA,UAAM,SAAS,uBAAuB,GAAG;AACzC,QAAI,CAAC,eAAe;AAClB,aAAO,KAAK,GAAG,IAAI,QAAQ,KAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACpE,WAAW,CAAC,WAAW;AACrB,aAAO,KAAK,GAAG,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACnD,OAAO;AACL,aAAO,KAAK,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACxC;EACF;AAGA,SAAO,OAAO,IAAI,WAAS,MAAM,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,MAAM,UAAU,GAAG,MAAM,SAAS,CAAC,IAAI,KAAK;AACnH;AAWM,SAAU,WAAW,KAAU,WAAW,IAAE;AAChD,QAAM,QAAQ,IAAI,aAAa,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,SAAS,MAAM,GAAG;AACxE,MAAI,eAAe,MAAM,GAAG,EAAE,KAAK;AAEnC,MAAI,aAAa,SAAS,UAAU;AAClC,WAAgB,yBAAgB,WAAW,cAAc,QAAQ;EACnE;AAEA,MAAI,IAAI,MAAM,SAAS;AACvB,SAAO,EAAE,KAAK,GAAG;AACf,QAAI,aAAa,SAAS,MAAM,CAAC,EAAE,UAAU,UAAU;AACrD,qBAAe,GAAG,MAAM,CAAC,CAAC,IAAI,YAAY;IAC5C;EACF;AAEA,SAAO;AACT;AAWM,SAAU,uBACZ,KAAU,QAA4C,oBAA4B;AACpF,QAAM,SAAS,IAAI,OAAO,QAAQ,YAAY,EAAE;AAChD,MAAI,CAAC,QAAQ;AACX,WAAO;EACT;AACA,MAAI;AAEJ,MAAI,OAAO,gBAAgB;AACzB,uBAAmB,GAAG,MAAM;EAC9B,OAAO;AACL,uBAAmB,qBAAqB,GAAG,MAAM,KAAK,OAAO,IAAI,MAAM,GAAG,MAAM,MAAM,OAAO,IAAI;EACnG;AAEA,qBAA4B,yBAAgB,qBAAqB,kBAAkB,iBAAiB;AACpG,SAAO;AACT;AAGM,IAAO,oBAAP,MAAwB;EACT;EAAnB,YAAmB,SAA0C;AAA1C,SAAA,UAAA;EACnB;;;;ACxJF;;;;;AAIA,YAAY,UAAU;AAEtB,YAAYC,YAAW;AACvB,YAAYC,yBAAwB;AACpC,YAAY,eAAe;AAE3B,IAAM,YAAY;;;;EAIhB,oBAAoB;;;;EAIpB,qBAAqB;;;;EAIrB,sBAAsB;;;;EAItB,SAAS;;AAGX,IAAM,OAAY,UAAK,kBAAkB,uCAAuC,SAAS;AACzF,IAAM,aAAkB,UAAK,mBAAmB,KAAK,QAAW,IAAI;AAEpE,SAAS,2BAA2B,OAA8C;AAEhF,QAAM,SAAS,MAAM,UAAU;AAE/B,QAAM,mBAAsC,uCAAmB,6BAA6B,KAAK;AACjG,QAAM,SAAS,kBAAkB;AACjC,QAAM,eAAe,kBAAkB,kBAAkB;AACzD,QAAM,cAAc,cAAc,IAAG;AACrC,QAAM,oBAAoB,cAAc,kBAAiB;AACzD,QAAM,kBAAkB,QAAQ,gBAAe;AAC/C,QAAM,oBAAwE,EAAC,iBAAiB,kBAAiB;AACjH,QAAM,MAAM,eAAe;AAC3B,SAAO,EAAC,KAAK,kBAAiB;AAChC;AAEM,SAAU,oBAAoB,OAA+B;AACjE,MAAI,CAAO,aAAM,OAAO,cAAc,KAAK,GAAG;AAC5C,WAAO;EACT;AACA,QAAM,EAAC,KAAK,kBAAiB,IAAI,2BAA2B,KAAK;AACjE,SAAO,kBAAkB,KAAK,iBAAiB;AACjD;AAEA,SAAS,kBACL,KAAsC,SAA4D;AACpG,SAAiB,4BAAkB,kBAAkB,SAAQ,EAAG,sBAAsB,KAAK,OAAO;AACpG;AAOM,SAAU,uBAAuB,OAA+B;AACpE,MAAI,CAAO,aAAM,OAAO,cAAc,KAAK,GAAG;AAC5C,YAAQ,KAAK,sDAAsD;AACnE,WAAO;EACT;AACA,QAAM,EAAC,KAAK,kBAAiB,IAAI,2BAA2B,KAAK;AAEjE,QAAM,gBAA0B,4BAAkB,kBAAkB,SAAQ;AAC5E,MAAI,kBAAkB,mBAAmB,cAAc,oBAAoB;AACzE,WAAO,WAAW,UAAU,kBAAkB;EAChD;AACA,MAAI,kBAAkB,qBAAqB,cAAc,+CAA+C;AACtG,WAAO,WAAW,UAAU,mBAAmB;EACjD;AAEA,MAAI,CAAC,KAAK;AACR,QAAI,cAAc,sBAAsB;AACtC,aAAO,WAAW,UAAU,oBAAoB;IAClD;AAGA,WAAO;EACT;AACA,QAAM,QAAQ,cAAc,qBAAqB,GAAG;AACpD,SAAO,QAAQ,MAAM,SAAS,WAAW,UAAU,OAAO;AAC5D;;;AC1FA;;;;;;;;AAIA,YAAYC,YAAW;AAEvB,IAAM,aACF,oBAAI,QAAO;AACR,IAAM,UAAU,IAAI,YAAW;AAMhC,SAAU,WAAW,YAC6B;AACtD,MAAI,WAAW,IAAI,UAAU,GAAG;AAC9B,WAAO,WAAW,IAAI,UAAU,KAAK;EACvC;AAEA,QAAM,MAAY,gBAAS,cAAc,YAAY,uBAAuB,UAAU;AAEtF,YAAU,GAAG,EACR,KAAK,iBAAc;AAClB,eAAW,IAAI,YAAY,WAAW;AACtC,YAAQ,cAAc,IAAI,YAAY,qBAAqB,EAAC,QAAQ,EAAC,YAAY,OAAO,YAAW,EAAC,CAAC,CAAC;EACxG,CAAC,EACA,MAAM,MAAK;EAAE,CAAC;AACnB,SAAO;AACT;AAGA,SAAS,UAAU,KAAW;AAC5B,SAAO,IAAI,QAAQ,aAAU;AAC3B,UAAM,QAAQ,IAAI,MAAK;AACvB,UAAM,iBAAiB,QAAQ,MAAM,QAAQ,KAAK,CAAC;AACnD,UAAM,iBAAiB,SAAS,MAAM,QAAQ,IAAI,CAAC;AACnD,UAAM,MAAM;EACd,CAAC;AACH;AAGM,SAAU,QAAQ,aAA8F;AAEpH,QAAM,WAAW,YAAY,IAAI,gBAAa;AAC5C,QAAI,WAAW,IAAI,UAAU,GAAG;AAC9B;IACF;AACA,UAAM,MAAY,gBAAS,cAAc,YAAY,uBAAuB,UAAU;AACtF,WAAO,UAAU,GAAG,EAAE,KAAK,WAAQ;AACjC,iBAAW,IAAI,YAAY,KAAK;AAChC;IACF,CAAC;EACH,CAAC;AACD,SAAO,QAAQ,IAAI,QAAQ;AAC7B;AAEO,IAAM,kBAAkB;AACxB,IAAM,sBAAsB;;;AC1DnC;;;;AAIA,YAAYC,YAAW;AAIjB,IAAO,YAAP,MAAgB;EACpB,OAAO,eAAe,cAAgC,aAAyC;AAe7F,QAAI,gBAAmD;AACvD,QAAI,gBAAkD;AAEtD,QAAI,cAAc;AAChB,YAAM,aAAa,YAAY,KAAK,KAAK,0BAA0B,IAAI,YAAY;AACnF,UAAI,YAAY,KAAK,MAAM,sBAAsB;AAC/C,wBAAgB,WAAW;AAC3B,wBAAgB,WAAW;MAC7B;IACF;AAEA,UAAM,UAAgB,gBAAS,QAAQ,eAAe,YAAY,IAAI;AACtE,UAAM,SAAS,QAAQ,KAAK,CAAAC,YAAS;AACnC,UAAI,iBAAiB,eAAe;AAClC,eAAOA,QAAO,QAAQ,iBAAiBA,QAAO,QAAQ;MACxD;AACA,aAAOA,QAAO,SAAI;IACpB,CAAC;AAED,WAAO,UAAU;EACnB;;;;EAKA,OAAO,2BACH,cAAgC,QAChC,aAAyC;AAC3C,UAAM,SAAS,KAAK,eAAe,cAAc,WAAW;AAC5D,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAEA,UAAM,SAAS,WAAW,oBAAoB,EAAC,QAAQ,aAAa,OAAM,CAAC;AAC3E,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAGA,UAAM,gBAAsB,eAAQ,MAAM,0BAA0B,OAAM,EAAG,QAAO;AACpF,UAAM,SAAS,IAAU,cAAO,YAAY,oBACxC,cAAc,OAAO;MAAA;;IAAA,CAAmD,CAAC;AAG7E,UAAM,YAAkB,eAAQ,OAAO,aAAa,OAAO,GAAG;AAC9D,UAAM,UAAgB,eAAQ,OAAO,aAAa,OAAO,GAAG;AAC5D,WAAO,IAAU,cAAO,UAAU,iBAAiB,QAAQ;MACzD,YAAY,IAAU,cAAO,YAAY,oBAAoB,CAAA,CAAE;MAC/D,SAAS,CAAC,MAAM;MAChB;MACA;KACD;EACH;;;;;EAMA,OAAO,0BACH,cAAgC,QAChC,aAAyC;AAC3C,UAAM,SAAS,KAAK,eAAe,cAAc,WAAW;AAC5D,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAEA,WAAO,WAAW,iBAAiB;MACjC,QAAQ;QACN,KAAK,OAAO;QACZ,KAAK,OAAO;;MAEd;MACA;KACD;EACH;;;;EAKA,OAAO,aACH,cAAgC,QAChC,aAA2C,QAAQ,GAAC;AACtD,UAAM,SAAS,KAAK,eAAe,cAAc,WAAW;AAC5D,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAEA,UAAM,QAAQ,WAAW,oBAAoB,EAAC,QAAQ,aAAa,OAAM,CAAC;AAC1E,QAAI,CAAC,OAAO;AACV,aAAO;IACT;AAEA,UAAM,WAAW,MAAM,OAAO,OAAK,EAAE,SAAS,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAG,KAAK;AACrG,WAAO,SACF,IAAI,UAAO;AACV,YAAM,OAAO,WAAW,UAAU,MAAM,WAAW;AACnD,UAAI,MAAM;AACR,aAAK,eAAe;MACtB;AACA,aAAO;IACT,CAAC,EACA,OAAO,UAAQ,CAAC,CAAC,IAAI;EAC5B;;;;AC9HF;;;;;;AAIA,YAAY,YAAY;AACxB,YAAYC,WAAU;AACtB,YAAYC,YAAW;AAmBvB,eAAe,mBAAmB,QAAc;AAC9C,QAAM,SAAS,MAAa,YAAK,SAAS,MAAM;AAChD,QAAM,SAAS,MAAa,cAAO,OAAO,MAAM;AAChD,SAAO;AACT;AAKA,eAAe,mBAAmB,MAAc,WAAmB,YAAkB;AACnF,QAAM,MAAM,IAAI,IAAI,SAAS;AAC7B,MAAI,OAAO,MAAM,mBAAmB,KAAK,UAAU,IAAI,CAAC;AACxD,MAAI,aAAa,IAAI,QAAQ,GAAG;AAChC,SAAO,KAAK,IAAI,SAAQ,GAAI,UAAU;AACxC;AAKM,SAAU,YAAY,aAA0B,iBAAyB,kBAAwB;AACrG,QAAM,iBAAiB;IACrB,KAAK;MACH;MACA,QAAQ;QACN,uBAAuB;UACrB,SAAS;YACP,MAAM;YACN,OAAO;;;;MAIb,gBAAgB;QACd,QAAa,qBAAe,eAAe,SAAQ,EAAG;;;IAG1D,aAAa;;AAEf,QAAM,MAAM;AACZ,QAAM,aAAa,WAAW,gBAAgB;AAE9C,OAAK,mBAAmB,gBAAgB,KAAK,UAAU;AACzD;AAQM,SAAU,eAAe,KAAa,YAAoB,aAAuC;AACrG,WAAS,QAAQ,MAAY;AAC3B,WAAO;MACL;MACA,eAAe;MACf,cAAc;;EAElB;AAEA,QAAM,iBAAiB,QAAQ,UAAU;AAQzC,WAAS,wBAAwB,QAAgB,MAAgB;AAC/D,QAAI,OAAO;AAGX,mBAAe,iBAAiB,KAAK;AAGrC,UAAM,qBAAqB,OAAO,QAAQ,YAAY,EAAE,EAAE,MAAM,KAAK;AACrE,uBAAmB,QAAQ,CAAC,mBAAmB,MAAK;AAClD,UAAI,kBAAkB,WAAW,GAAG;AAClC;MACF;AAEA,YAAM,SAAS,MAAM,mBAAmB,SAAS;AAEjD,UAAI,QAAQ,KAAK,UAAU,KAAK,CAAAC,WAASA,OAAM,SAAS,iBAAiB;AACzE,UAAI,CAAC,OAAO;AACV,gBAAQ,QAAQ,iBAAiB;AACjC,aAAK,WAAW,KAAK,YAAY,CAAA;AACjC,aAAK,SAAS,KAAK,KAAK;MAC1B;AACA,aAAO;AAGP,WAAK,iBAAiB,KAAK;AAG3B,UAAI,UAAU,KAAK,mCAAmC,QAAW;AAC/D,aAAK,iCAAiC,KAAK;MAC7C;IACF,CAAC;EACH;AAIA,aAAW,CAAC,QAAQ,IAAI,KAAK,OAAO,QAAQ,WAAW,GAAG;AACxD,4BAAwB,QAAQ,IAAI;EACtC;AAKA,WAAS,YAAY,MAAiB;AACpC,WAAO,KAAK,YAAY,KAAK,SAAS,WAAW,GAAG;AAClD,YAAM,QAAQ,KAAK,SAAS,CAAC;AAC7B,WAAK,QAAQ,MAAM,MAAM;AACzB,UAAI,MAAM,gCAAgC;AACxC,aAAK,iCAAiC,MAAM;MAC9C;AACA,WAAK,WAAW,MAAM;IACxB;AAEA,QAAI,KAAK,UAAU;AACjB,iBAAW,SAAS,KAAK,UAAU;AACjC,oBAAY,KAAK;MACnB;IACF;EACF;AACA,cAAY,cAAc;AAK1B,MAAI,CAAC,eAAe,MAAM;AACxB,WAAO;MACL,GAAG;MACH,MAAM;MACN,UAAU,eAAe;;EAE7B;AAGA,QAAM,aAAa,EAAC,GAAG,eAAc;AACrC,aAAW,OAAO;AAClB,aAAW,WAAW,CAAC,cAAc;AACrC,SAAO;AACT;AAEA,SAAS,uBAAuB,SAAmD;AAEjF,QAAM,eAAe,QAAQ,KAAK,KAAK;AACvC,QAAM,eAAe,QAAQ,KAAK,KAAK;AAIvC,QAAM,sBAAsB;AAC5B,SAAO,EAAC,cAAc,cAAc,oBAAmB;AACzD;AAiBM,SAAU,kBACZ,SACA,aAA6D;AAC/D,QAAM,QAAuB,CAAA;AAC7B,QAAM,qBAAqB,oBAAI,IAAG;AAElC,aAAW,UAAU,QAAQ,SAAS;AACpC,QAAI,CAAC,OAAO,KAAK;AACf;IACF;AAEA,UAAM,OAAO,OAAO;AACpB,UAAM,QAAc,gBAAS,cAAc,QAAQ,wBAAwB,MAAM;AAEjF,QAAI;AACJ,QAAI,OAAO,aAAa,SAAS,EAAE,kBAAkB,QAAQ;AAG3D,YAAM,cAA0C,CAAA;AAChD,iBAAW,CAAC,QAAQ,aAAa,KAAK,OAAO,QAAQ,MAAM,KAAK,GAAG;AACjE,cAAM,aAAyB;UAC7B;UACA,cAAc;;AAGhB,cAAM,MAAY,cAAO,kBAAkB,gBAAgB,MAAM;AACjE,YAAI,YAAY,IAAI,GAAG,GAAG;AACxB,qBAAW,iCAAiC;QAC9C;AAEA,oBAAY,MAAM,IAAI;MACxB;AAEA,UAAI,MAAM,eAAe;AACvB,cAAM,aAAyB;UAC7B,eAAe,MAAM;;AAEvB,oBAAY,YAAY,IAAI;MAC9B;AAEA,aAAO,eAAe,OAAO,KAAK,OAAO,KAAK,WAAW;IAC3D,OAAO;AAEL,aAAO;QACL;QACA,eAAe,OAAO,SAAS,UAAU;QACzC,cAAc;;IAElB;AAKA,QAAI,OAAO,QAAQ;AACjB,UAAI,WAAW,mBAAmB,IAAI,OAAO,KAAK;AAClD,UAAI,CAAC,UAAU;AACb,mBAAW;UACT;UACA,eAAe;UACf,cAAc;UACd,UAAU,CAAA;;AAEZ,2BAAmB,IAAI,OAAO,OAAO,QAAQ;AAC7C,cAAM,KAAK,QAAQ;MACrB;AACA,eAAS,iBAAiB,KAAK;AAC/B,WAAK,OAAO,OAAO,UAAU,cAAc,OAAO,QAAQ,UAAS,EAAG,UAAU,GAAG,EAAE,IAAI,WAAM;AAC/F,eAAS,UAAU,KAAK,IAAI;IAC9B,OAAO;AAEL,YAAM,KAAK,IAAI;AAEf,UAAI,OAAO,SAAS;AAClB,cAAM,EAAC,cAAc,oBAAmB,IAAI,uBAAuB,OAAO,OAAO;AACjF,cAAM,mBAAmB,eAAe;AACxC,aAAK,eAAe;MACtB,OAAO;AACL,aAAK,eAAe,KAAK;MAC3B;IACF;EACF;AAIA,aAAW,CAAC,SAAS,IAAI,KAAK,oBAAoB;AAChD,UAAM,SAAS,QAAQ,QAAQ,KAC3B,OAAK,EAAE,SAAS,KAAK,KAAK,iBAAiB,cAAc,EAAE,SAAS,KAAK,KAAK,UAAU,OAAO;AACnG,QAAI,QAAQ,SAAS;AACnB,YAAM,EAAC,cAAc,cAAc,oBAAmB,IAAI,uBAAuB,OAAO,OAAO;AAC/F,YAAM,mBAAmB,KAAK,gBAAgB;AAC9C,YAAM,mBAAmB,eAAe;AACxC,WAAK,eAAe,KAAK,MAAM,mBAAmB,gBAAgB;IACpE,OAAO;AACL,WAAK,eAAe,KAAK;IAC3B;EACF;AAEA,SAAO;AACT;",
  "names": ["instance", "Trace", "Trace", "SDK", "Trace", "SourceMapsResolver", "Trace", "Trace", "thread", "i18n", "Trace", "child"]
}
