{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/timeline/utils/EntryNodes.ts", "../../../../../../../front_end/panels/timeline/utils/Helpers.ts", "../../../../../../../front_end/panels/timeline/utils/IgnoreList.ts", "../../../../../../../front_end/panels/timeline/utils/ImageCache.ts", "../../../../../../../front_end/panels/timeline/utils/Treemap.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Trace from '../../../models/trace/trace.js';\n\nconst nodeIdsForEventCache = new WeakMap<Trace.Types.Events.Event, Set<Protocol.DOM.BackendNodeId>>();\nconst domNodesForEventCache =\n    new WeakMap<Trace.Types.Events.Event, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\n\n/**\n * Extracts a set of NodeIds for a given event.\n * The result is cached so you can safely call this multiple times.\n **/\nexport function nodeIdsForEvent(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    event: Trace.Types.Events.Event,\n    ): Set<Protocol.DOM.BackendNodeId> {\n  const fromCache = nodeIdsForEventCache.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const foundIds = new Set<Protocol.DOM.BackendNodeId>();\n\n  if (Trace.Types.Events.isLayout(event)) {\n    event.args.endData?.layoutRoots.forEach(root => foundIds.add(root.nodeId));\n  } else if (Trace.Types.Events.isSyntheticLayoutShift(event) && event.args.data?.impacted_nodes) {\n    event.args.data.impacted_nodes.forEach(node => foundIds.add(node.node_id));\n  } else if (\n      Trace.Types.Events.isLargestContentfulPaintCandidate(event) && typeof event.args.data?.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isPaint(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isPaintImage(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Trace.Types.Events.isScrollLayer(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (\n      Trace.Types.Events.isSyntheticAnimation(event) &&\n      typeof event.args.data.beginEvent.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.beginEvent.args.data.nodeId);\n  } else if (Trace.Types.Events.isDecodeImage(event)) {\n    // For a DecodeImage event, we can use the ImagePaintingHandler, which has\n    // done the work to build the relationship between a DecodeImage event and\n    // the corresponding PaintImage event.\n    const paintImageEvent = parsedTrace.data.ImagePainting.paintImageForEvent.get(event);\n    if (typeof paintImageEvent?.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Trace.Types.Events.isDrawLazyPixelRef(event) && event.args?.LazyPixelRef) {\n    const paintImageEvent = parsedTrace.data.ImagePainting.paintImageByDrawLazyPixelRef.get(event.args.LazyPixelRef);\n    if (typeof paintImageEvent?.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Trace.Types.Events.isParseMetaViewport(event) && typeof event.args?.data.node_id !== 'undefined') {\n    foundIds.add(event.args.data.node_id);\n  }\n  nodeIdsForEventCache.set(event, foundIds);\n  return foundIds;\n}\n\n/**\n * Looks up for backend node ids in different types of trace events\n * and resolves them into related DOM nodes.\n * This method is cached for the given event.\n */\nexport async function relatedDOMNodesForEvent(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    event: Trace.Types.Events.Event): Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>|null> {\n  const fromCache = domNodesForEventCache.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  const nodeIds = nodeIdsForEvent(parsedTrace, event);\n  if (nodeIds.size) {\n    const frame = event.args?.data?.frame as Protocol.Page.FrameId;\n    const result = await domNodesForBackendIds(frame, nodeIds);\n    domNodesForEventCache.set(event, result);\n    return result;\n  }\n\n  return null;\n}\n\n/**\n * Takes a set of Protocol.DOM.BackendNodeId ids and will return a map of NodeId=>DOMNode.\n */\nexport async function domNodesForBackendIds(frameId: Protocol.Page.FrameId, nodeIds: Set<Protocol.DOM.BackendNodeId>):\n    Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>> {\n  const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  const resourceTreeModel = target?.model(SDK.ResourceTreeModel.ResourceTreeModel);\n  if (!domModel || !resourceTreeModel) {\n    return new Map();\n  }\n\n  // The node is only relevant if the target contains the specified frame.\n  // For now, allow events that specify no frame id to continue to resolve a node.\n  if (frameId && !resourceTreeModel.frames().some(frame => frame.id === frameId)) {\n    return new Map();\n  }\n\n  return await domModel.pushNodesByBackendIdsToFrontend(nodeIds) || new Map();\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport * as CrUXManager from '../../../models/crux-manager/crux-manager.js';\nimport type * as Trace from '../../../models/trace/trace.js';\n\nconst MAX_ORIGIN_LENGTH = 60;\n\nexport function getThrottlingRecommendations(): {\n  cpuOption: SDK.CPUThrottlingManager.CPUThrottlingOption|null,\n  networkConditions: SDK.NetworkManager.Conditions|null,\n} {\n  let cpuOption: SDK.CPUThrottlingManager.CPUThrottlingOption =\n      SDK.CPUThrottlingManager.CalibratedMidTierMobileThrottlingOption;\n  if (cpuOption.rate() === 0) {\n    cpuOption = SDK.CPUThrottlingManager.MidTierThrottlingOption;\n  }\n\n  let networkConditions = null;\n  const response = CrUXManager.CrUXManager.instance().getSelectedFieldMetricData('round_trip_time');\n  if (response?.percentiles) {\n    const rtt = Number(response.percentiles.p75);\n    networkConditions = SDK.NetworkManager.getRecommendedNetworkPreset(rtt);\n  }\n\n  return {\n    cpuOption,\n    networkConditions,\n  };\n}\n\nfunction createTrimmedUrlSearch(url: URL): string {\n  const maxSearchValueLength = 8;\n  let search = '';\n\n  for (const [key, value] of url.searchParams) {\n    if (search) {\n      search += '&';\n    }\n    if (value) {\n      search += `${key}=${Platform.StringUtilities.trimEndWithMaxLength(value, maxSearchValueLength)}`;\n    } else {\n      search += key;\n    }\n  }\n  if (search) {\n    search = '?' + search;\n  }\n\n  return search;\n}\n\n/**\n * Shortens URLs as much as possible while keeping important context.\n *\n * - Elides the host if the previous url is the same host+protocol\n * - Always elide search param values\n * - Always includes protocol/domain if there is a mix of protocols\n * - First URL is elided fully to show just the pathname, unless there is a mix of protocols (see above)\n */\nexport function createUrlLabels(urls: URL[]): string[] {\n  const labels: string[] = [];\n  const isAllHttps = urls.every(url => url.protocol === 'https:');\n\n  for (const [index, url] of urls.entries()) {\n    const previousUrl = urls[index - 1];\n    const sameHostAndProtocol = previousUrl && url.host === previousUrl.host && url.protocol === previousUrl.protocol;\n    let elideHost = sameHostAndProtocol;\n    let elideProtocol = isAllHttps;\n\n    // For the first URL, show just the pathname and search - this will be relative to the domain as seen in the\n    // trace dropdown selector. Exception is if there are non-https protocols, in which case we're only going to elide\n    // parts of the query string.\n    if (index === 0 && isAllHttps) {\n      elideHost = true;\n      elideProtocol = true;\n    }\n\n    const search = createTrimmedUrlSearch(url);\n    if (!elideProtocol) {\n      labels.push(`${url.protocol}//${url.host}${url.pathname}${search}`);\n    } else if (!elideHost) {\n      labels.push(`${url.host}${url.pathname}${search}`);\n    } else {\n      labels.push(`${url.pathname}${search}`);\n    }\n  }\n\n  // Lastly, remove any trailing `/`.\n  return labels.map(label => label.length > 1 && label.endsWith('/') ? label.substring(0, label.length - 1) : label);\n}\n\n/**\n * Shortens the provided URL for use within a narrow display usecase.\n *\n * The resulting string will at least contain the last path component of the URL.\n * More components are included until a limit of maxChars (default 20) is reached.\n * No querystring is included.\n *\n * If the last path component is larger than maxChars characters, the middle is elided.\n */\nexport function shortenUrl(url: URL, maxChars = 20): string {\n  const parts = url.pathname === '/' ? [url.host] : url.pathname.split('/');\n  let shortenedUrl = parts.at(-1) ?? '';\n\n  if (shortenedUrl.length > maxChars) {\n    return Platform.StringUtilities.trimMiddle(shortenedUrl, maxChars);\n  }\n\n  let i = parts.length - 1;\n  while (--i >= 0) {\n    if (shortenedUrl.length + parts[i].length <= maxChars) {\n      shortenedUrl = `${parts[i]}/${shortenedUrl}`;\n    }\n  }\n\n  return shortenedUrl;\n}\n\n/**\n * Returns a string containing both the origin and its 3rd party entity.\n *\n * By default we construct by diving with a hyphen, but with an optional\n * parenthesizeEntity to parenthesize the entity.\n *\n * @example 'uk-script.dotmetrics.net - DotMetrics'\n * @example 'securepubads.g.doubleclick.net (Google/Doubleclick Ads)'\n */\nexport function formatOriginWithEntity(\n    url: URL, entity: Trace.Handlers.Helpers.Entity|null, parenthesizeEntity?: boolean): string {\n  const origin = url.origin.replace('https://', '');\n  if (!entity) {\n    return origin;\n  }\n  let originWithEntity;\n  // If we have an unrecognized entity, entity name would be the same as the origin.\n  if (entity.isUnrecognized) {\n    originWithEntity = `${origin}`;\n  } else {\n    originWithEntity = parenthesizeEntity ? `${origin} (${entity.name})` : `${origin} - ${entity.name}`;\n  }\n\n  originWithEntity = Platform.StringUtilities.trimEndWithMaxLength(originWithEntity, MAX_ORIGIN_LENGTH);\n  return originWithEntity;\n}\n\n/** Thin wrapper class to enable revealing an individual insight in Timeline panel. **/\nexport class RevealableInsight {\n  constructor(public insight: Trace.Insights.Types.InsightModel) {\n  }\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as SourceMapsResolver from '../../../models/trace_source_maps_resolver/trace_source_maps_resolver.js';\nimport * as Workspace from '../../../models/workspace/workspace.js';\n\nconst UIStrings = {\n  /**\n   * @description Refers to when skipping content scripts is enabled and the current script is ignored because it's a content script.\n   */\n  skipContentScripts: 'Content script',\n  /**\n   * @description Refers to when skipping known third party scripts is enabled and the current script is ignored because it's a known third party script.\n   */\n  skip3rdPartyScripts: 'Marked with ignoreList in source map',\n  /**\n   * @description Refers to when skipping anonymous scripts is enabled and the current script is ignored because is an anonymous script.\n   */\n  skipAnonymousScripts: 'Anonymous script',\n  /**\n   * @description Refers to when the current script is ignored because of an unknown rule.\n   */\n  unknown: 'Unknown',\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/utils/IgnoreList.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nfunction getUrlAndIgnoreListOptions(entry: Trace.Types.Events.SyntheticProfileCall):\n    {url: Platform.DevToolsPath.UrlString, ignoreListOptions: Workspace.IgnoreListManager.IgnoreListGeneralRules} {\n  const rawUrl = entry.callFrame.url as Platform.DevToolsPath.UrlString;\n\n  const sourceMappedData = SourceMapsResolver.SourceMapsResolver.resolvedCodeLocationForEntry(entry);\n  const script = sourceMappedData?.script;\n  const uiSourceCode = sourceMappedData?.devtoolsLocation?.uiSourceCode;\n  const resolvedUrl = uiSourceCode?.url();\n  const isKnownThirdParty = uiSourceCode?.isKnownThirdParty();\n  const isContentScript = script?.isContentScript();\n  const ignoreListOptions: Workspace.IgnoreListManager.IgnoreListGeneralRules = {isContentScript, isKnownThirdParty};\n  const url = resolvedUrl || rawUrl;\n  return {url, ignoreListOptions};\n}\n\nexport function isIgnoreListedEntry(entry: Trace.Types.Events.Event): boolean {\n  if (!Trace.Types.Events.isProfileCall(entry)) {\n    return false;\n  }\n  const {url, ignoreListOptions} = getUrlAndIgnoreListOptions(entry);\n  return isIgnoreListedURL(url, ignoreListOptions);\n}\n\nfunction isIgnoreListedURL(\n    url: Platform.DevToolsPath.UrlString, options?: Workspace.IgnoreListManager.IgnoreListGeneralRules): boolean {\n  return Workspace.IgnoreListManager.IgnoreListManager.instance().isUserIgnoreListedURL(url, options);\n}\n\n/**\n * Returns the ignore reason for the given entry.\n *\n * This function should be called when `isIgnoreListedEntry(entry)` is true\n */\nexport function getIgnoredReasonString(entry: Trace.Types.Events.Event): string {\n  if (!Trace.Types.Events.isProfileCall(entry)) {\n    console.warn('Ignore list feature should only support ProfileCall.');\n    return '';\n  }\n  const {url, ignoreListOptions} = getUrlAndIgnoreListOptions(entry);\n\n  const ignoreListMgr = Workspace.IgnoreListManager.IgnoreListManager.instance();\n  if (ignoreListOptions.isContentScript && ignoreListMgr.skipContentScripts) {\n    return i18nString(UIStrings.skipContentScripts);\n  }\n  if (ignoreListOptions.isKnownThirdParty && ignoreListMgr.automaticallyIgnoreListKnownThirdPartyScripts) {\n    return i18nString(UIStrings.skip3rdPartyScripts);\n  }\n\n  if (!url) {\n    if (ignoreListMgr.skipAnonymousScripts) {\n      return i18nString(UIStrings.skipAnonymousScripts);\n    }\n    // This branch shouldn't be reached because when |skipAnonymousScripts| is false, this url is not ignored.\n    // So just return empty string to make the type check work.\n    return '';\n  }\n  const regex = ignoreListMgr.getFirstMatchedRegex(url);\n  return regex ? regex.source : i18nString(UIStrings.unknown);\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nconst imageCache =\n    new WeakMap<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot, HTMLImageElement|null>();\nexport const emitter = new EventTarget();\n\n/**\n * Synchronously returns an image, or return `null` while queuing up an async load of that image.\n * If the image load fails, we cache a null to avoid reattempts.\n */\nexport function getOrQueue(screenshot: Trace.Types.Events.LegacySyntheticScreenshot|\n                           Trace.Types.Events.Screenshot): HTMLImageElement|null {\n  if (imageCache.has(screenshot)) {\n    return imageCache.get(screenshot) ?? null;\n  }\n\n  const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n\n  loadImage(uri)\n      .then(imageOrNull => {\n        imageCache.set(screenshot, imageOrNull);\n        emitter.dispatchEvent(new CustomEvent('screenshot-loaded', {detail: {screenshot, image: imageOrNull}}));\n      })\n      .catch(() => {});\n  return null;\n}\n\n/** Load an image (probably data URI). If it fails, resolve with null. */\nfunction loadImage(url: string): Promise<HTMLImageElement|null> {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => resolve(null));\n    image.src = url;\n  });\n}\n\n/** Populate the cache ahead of use, to allow for getOrQueue to synchronously return images. */\nexport function preload(screenshots: Array<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot>):\n    Promise<void[]> {\n  const promises = screenshots.map(screenshot => {\n    if (imageCache.has(screenshot)) {\n      return;\n    }\n    const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n    return loadImage(uri).then(image => {\n      imageCache.set(screenshot, image);\n      return;\n    });\n  });\n  return Promise.all(promises);\n}\n\nexport const cacheForTesting = imageCache;\nexport const loadImageForTesting = loadImage;\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Trace from '../../../models/trace/trace.js';\n\ninterface TreemapNode {\n  /** Could be a url, a path component from a source map, or an arbitrary string. */\n  name: string;\n  resourceBytes: number;\n  /** Transfer size of the script. Only set for non-inline top-level script nodes. */\n  encodedBytes?: number;\n  /** If present, this module is a duplicate. String is normalized source path. See ScriptDuplication.normalizeSource */\n  duplicatedNormalizedModuleName?: string;\n  children?: TreemapNode[];\n}\n\nexport type TreemapData = TreemapNode[];\ntype SourceData = Omit<TreemapNode, 'name'|'children'>;\n\n/**\n * Takes an UTF-8, gzips then base64's it.\n */\nasync function toCompressedBase64(string: string): Promise<string> {\n  const compAb = await Common.Gzip.compress(string);\n  const strb64 = await Common.Base64.encode(compAb);\n  return strb64;\n}\n\n/**\n * Opens a new tab to an external page and sends data via base64 encoded url params.\n */\nasync function openTabWithUrlData(data: object, urlString: string, windowName: string): Promise<void> {\n  const url = new URL(urlString);\n  url.hash = await toCompressedBase64(JSON.stringify(data));\n  url.searchParams.set('gzip', '1');\n  window.open(url.toString(), windowName);\n}\n\n/**\n * Opens a new tab to the treemap app and sends the data using URL.fragment\n */\nexport function openTreemap(treemapData: TreemapData, mainDocumentUrl: string, windowNameSuffix: string): void {\n  const treemapOptions = {\n    lhr: {\n      mainDocumentUrl,\n      audits: {\n        'script-treemap-data': {\n          details: {\n            type: 'treemap-data',\n            nodes: treemapData,\n          },\n        },\n      },\n      configSettings: {\n        locale: i18n.DevToolsLocale.DevToolsLocale.instance().locale,\n      },\n    },\n    initialView: 'duplicate-modules',\n  };\n  const url = 'https://googlechrome.github.io/lighthouse/treemap/';\n  const windowName = `treemap-${windowNameSuffix}`;\n\n  void openTabWithUrlData(treemapOptions, url, windowName);\n}\n\n/**\n * Returns a tree data structure where leaf nodes are sources (ie. real files from\n * source tree) from a source map, and non-leaf nodes are directories. Leaf nodes\n * have data for bytes, coverage, etc., when available, and non-leaf nodes have the\n * same data as the sum of all descendant leaf nodes.\n */\nexport function makeScriptNode(src: string, sourceRoot: string, sourcesData: Record<string, SourceData>): TreemapNode {\n  function newNode(name: string): TreemapNode {\n    return {\n      name,\n      resourceBytes: 0,\n      encodedBytes: undefined,\n    };\n  }\n\n  const sourceRootNode = newNode(sourceRoot);\n\n  /**\n   * Given a slash-delimited path, traverse the Node structure and increment\n   * the data provided for each node in the chain. Creates nodes as needed.\n   * Ex: path/to/file.js will find or create \"path\" on `node`, increment the data fields,\n   *     and continue with \"to\", and so on.\n   */\n  function addAllNodesInSourcePath(source: string, data: SourceData): void {\n    let node = sourceRootNode;\n\n    // Apply the data to the sourceRootNode.\n    sourceRootNode.resourceBytes += data.resourceBytes;\n\n    // Strip off the shared root.\n    const sourcePathSegments = source.replace(sourceRoot, '').split(/\\/+/);\n    sourcePathSegments.forEach((sourcePathSegment, i) => {\n      if (sourcePathSegment.length === 0) {\n        return;\n      }\n\n      const isLeaf = i === sourcePathSegments.length - 1;\n\n      let child = node.children?.find(child => child.name === sourcePathSegment);\n      if (!child) {\n        child = newNode(sourcePathSegment);\n        node.children = node.children || [];\n        node.children.push(child);\n      }\n      node = child;\n\n      // Now that we've found or created the next node in the path, apply the data.\n      node.resourceBytes += data.resourceBytes;\n\n      // Only leaf nodes might have duplication data.\n      if (isLeaf && data.duplicatedNormalizedModuleName !== undefined) {\n        node.duplicatedNormalizedModuleName = data.duplicatedNormalizedModuleName;\n      }\n    });\n  }\n\n  // For every source file, apply the data to all components\n  // of the source path, creating nodes as necessary.\n  for (const [source, data] of Object.entries(sourcesData)) {\n    addAllNodesInSourcePath(source, data);\n  }\n\n  /**\n   * Collapse nodes that have only one child.\n   */\n  function collapseAll(node: TreemapNode): void {\n    while (node.children && node.children.length === 1) {\n      const child = node.children[0];\n      node.name += '/' + child.name;\n      if (child.duplicatedNormalizedModuleName) {\n        node.duplicatedNormalizedModuleName = child.duplicatedNormalizedModuleName;\n      }\n      node.children = child.children;\n    }\n\n    if (node.children) {\n      for (const child of node.children) {\n        collapseAll(child);\n      }\n    }\n  }\n  collapseAll(sourceRootNode);\n\n  // If sourceRootNode.name is falsy (no defined sourceRoot + no collapsed common prefix),\n  // collapse the sourceRootNode children into the scriptNode.\n  // Otherwise, we add another node.\n  if (!sourceRootNode.name) {\n    return {\n      ...sourceRootNode,\n      name: src,\n      children: sourceRootNode.children,\n    };\n  }\n\n  // Script node should be just the script src.\n  const scriptNode = {...sourceRootNode};\n  scriptNode.name = src;\n  scriptNode.children = [sourceRootNode];\n  return scriptNode;\n}\n\nfunction getNetworkRequestSizes(request: Trace.Types.Events.SyntheticNetworkRequest):\n    {resourceSize: number, transferSize: number, headersTransferSize: number} {\n  const resourceSize = request.args.data.decodedBodyLength;\n  const transferSize = request.args.data.encodedDataLength;\n  // TODO: add something like `responseHeadersTransferSize` to trace\n  // SyntheticNetworkRequest (see Lighthouse). For now, incorrectly include the size\n  // of the headers here.\n  const headersTransferSize = 0;\n  return {resourceSize, transferSize, headersTransferSize};\n}\n\n/**\n * Returns an array of nodes, where the first level of nodes represents every script.\n *\n * Every external script has a node.\n * All inline scripts are combined into a single node.\n * If a script has a source map, that node will be created by makeScriptNode.\n *\n * Example return result:\n *  - index.html (inline scripts)\n *  - main.js\n *  - - webpack://\n *  - - - react.js\n *  - - - app.js\n *  - i-have-no-map.js\n */\nexport function createTreemapData(\n    scripts: Trace.Handlers.ModelHandlers.Scripts.ScriptsData,\n    duplication: Trace.Extras.ScriptDuplication.ScriptDuplication): TreemapData {\n  const nodes: TreemapNode[] = [];\n  const htmlNodesByFrameId = new Map<string, TreemapNode>();\n\n  for (const script of scripts.scripts) {\n    if (!script.url) {\n      continue;\n    }\n\n    const name = script.url;\n    const sizes = Trace.Handlers.ModelHandlers.Scripts.getScriptGeneratedSizes(script);\n\n    let node: TreemapNode;\n    if (script.sourceMap && sizes && !('errorMessage' in sizes)) {\n      // Create nodes for each module in a bundle.\n\n      const sourcesData: Record<string, SourceData> = {};\n      for (const [source, resourceBytes] of Object.entries(sizes.files)) {\n        const sourceData: SourceData = {\n          resourceBytes,\n          encodedBytes: undefined,\n        };\n\n        const key = Trace.Extras.ScriptDuplication.normalizeSource(source);\n        if (duplication.has(key)) {\n          sourceData.duplicatedNormalizedModuleName = key;\n        }\n\n        sourcesData[source] = sourceData;\n      }\n\n      if (sizes.unmappedBytes) {\n        const sourceData: SourceData = {\n          resourceBytes: sizes.unmappedBytes,\n        };\n        sourcesData['(unmapped)'] = sourceData;\n      }\n\n      node = makeScriptNode(script.url, script.url, sourcesData);\n    } else {\n      // No valid source map for this script, so we can only produce a single node.\n      node = {\n        name,\n        resourceBytes: script.content?.length ?? 0,\n        encodedBytes: undefined,\n      };\n    }\n\n    // If this is an inline script, place the node inside a top-level (aka depth-one)\n    // node. Also separate each iframe / the main page's inline scripts into their\n    // own top-level nodes.\n    if (script.inline) {\n      let htmlNode = htmlNodesByFrameId.get(script.frame);\n      if (!htmlNode) {\n        htmlNode = {\n          name,\n          resourceBytes: 0,\n          encodedBytes: undefined,\n          children: [],\n        };\n        htmlNodesByFrameId.set(script.frame, htmlNode);\n        nodes.push(htmlNode);\n      }\n      htmlNode.resourceBytes += node.resourceBytes;\n      node.name = script.content ? '(inline) ' + script.content.trimStart().substring(0, 15) + '…' : '(inline)';\n      htmlNode.children?.push(node);\n    } else {\n      // Non-inline scripts each have their own top-level node.\n      nodes.push(node);\n\n      if (script.request) {\n        const {transferSize, headersTransferSize} = getNetworkRequestSizes(script.request);\n        const bodyTransferSize = transferSize - headersTransferSize;\n        node.encodedBytes = bodyTransferSize;\n      } else {\n        node.encodedBytes = node.resourceBytes;\n      }\n    }\n  }\n\n  // For the HTML nodes, set encodedBytes to be the size of all the inline\n  // scripts multiplied by the average compression ratio of the HTML document.\n  for (const [frameId, node] of htmlNodesByFrameId) {\n    const script = scripts.scripts.find(\n        s => s.request?.args.data.resourceType === 'Document' && s.request?.args.data.frame === frameId);\n    if (script?.request) {\n      const {resourceSize, transferSize, headersTransferSize} = getNetworkRequestSizes(script.request);\n      const inlineScriptsPct = node.resourceBytes / resourceSize;\n      const bodyTransferSize = transferSize - headersTransferSize;\n      node.encodedBytes = Math.floor(bodyTransferSize * inlineScriptsPct);\n    } else {\n      node.encodedBytes = node.resourceBytes;\n    }\n  }\n\n  return nodes;\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;;;AAIA,YAAY,SAAS;AAErB,YAAY,WAAW;AAEvB,IAAM,uBAAuB,oBAAI,QAAO;AACxC,IAAM,wBACF,oBAAI,QAAO;AAMT,SAAU,gBACZ,aACA,OAA+B;AAEjC,QAAM,YAAY,qBAAqB,IAAI,KAAK;AAChD,MAAI,WAAW;AACb,WAAO;EACT;AACA,QAAM,WAAW,oBAAI,IAAG;AAExB,MAAU,YAAM,OAAO,SAAS,KAAK,GAAG;AACtC,UAAM,KAAK,SAAS,YAAY,QAAQ,UAAQ,SAAS,IAAI,KAAK,MAAM,CAAC;EAC3E,WAAiB,YAAM,OAAO,uBAAuB,KAAK,KAAK,MAAM,KAAK,MAAM,gBAAgB;AAC9F,UAAM,KAAK,KAAK,eAAe,QAAQ,UAAQ,SAAS,IAAI,KAAK,OAAO,CAAC;EAC3E,WACU,YAAM,OAAO,kCAAkC,KAAK,KAAK,OAAO,MAAM,KAAK,MAAM,WAAW,aAAa;AACjH,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,YAAM,OAAO,QAAQ,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AAC7F,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,YAAM,OAAO,aAAa,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AAClG,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WAAiB,YAAM,OAAO,cAAc,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,aAAa;AACnG,aAAS,IAAI,MAAM,KAAK,KAAK,MAAM;EACrC,WACU,YAAM,OAAO,qBAAqB,KAAK,KAC7C,OAAO,MAAM,KAAK,KAAK,WAAW,KAAK,KAAK,WAAW,aAAa;AACtE,aAAS,IAAI,MAAM,KAAK,KAAK,WAAW,KAAK,KAAK,MAAM;EAC1D,WAAiB,YAAM,OAAO,cAAc,KAAK,GAAG;AAIlD,UAAM,kBAAkB,YAAY,KAAK,cAAc,mBAAmB,IAAI,KAAK;AACnF,QAAI,OAAO,iBAAiB,KAAK,KAAK,WAAW,aAAa;AAC5D,eAAS,IAAI,gBAAgB,KAAK,KAAK,MAAM;IAC/C;EACF,WAAiB,YAAM,OAAO,mBAAmB,KAAK,KAAK,MAAM,MAAM,cAAc;AACnF,UAAM,kBAAkB,YAAY,KAAK,cAAc,6BAA6B,IAAI,MAAM,KAAK,YAAY;AAC/G,QAAI,OAAO,iBAAiB,KAAK,KAAK,WAAW,aAAa;AAC5D,eAAS,IAAI,gBAAgB,KAAK,KAAK,MAAM;IAC/C;EACF,WAAiB,YAAM,OAAO,oBAAoB,KAAK,KAAK,OAAO,MAAM,MAAM,KAAK,YAAY,aAAa;AAC3G,aAAS,IAAI,MAAM,KAAK,KAAK,OAAO;EACtC;AACA,uBAAqB,IAAI,OAAO,QAAQ;AACxC,SAAO;AACT;AAOA,eAAsB,wBAClB,aACA,OAA+B;AACjC,QAAM,YAAY,sBAAsB,IAAI,KAAK;AACjD,MAAI,WAAW;AACb,WAAO;EACT;AAEA,QAAM,UAAU,gBAAgB,aAAa,KAAK;AAClD,MAAI,QAAQ,MAAM;AAChB,UAAM,QAAQ,MAAM,MAAM,MAAM;AAChC,UAAM,SAAS,MAAM,sBAAsB,OAAO,OAAO;AACzD,0BAAsB,IAAI,OAAO,MAAM;AACvC,WAAO;EACT;AAEA,SAAO;AACT;AAKA,eAAsB,sBAAsB,SAAgC,SAAwC;AAElH,QAAM,SAAa,kBAAc,cAAc,SAAQ,EAAG,kBAAiB;AAC3E,QAAM,WAAW,QAAQ,MAAU,aAAS,QAAQ;AACpD,QAAM,oBAAoB,QAAQ,MAAU,sBAAkB,iBAAiB;AAC/E,MAAI,CAAC,YAAY,CAAC,mBAAmB;AACnC,WAAO,oBAAI,IAAG;EAChB;AAIA,MAAI,WAAW,CAAC,kBAAkB,OAAM,EAAG,KAAK,WAAS,MAAM,OAAO,OAAO,GAAG;AAC9E,WAAO,oBAAI,IAAG;EAChB;AAEA,SAAO,MAAM,SAAS,gCAAgC,OAAO,KAAK,oBAAI,IAAG;AAC3E;;;AC1GA;;;;;;;;AAIA,YAAY,cAAc;AAC1B,YAAYA,UAAS;AACrB,YAAY,iBAAiB;AAG7B,IAAM,oBAAoB;AAEpB,SAAU,+BAA4B;AAI1C,MAAI,YACI,0BAAqB;AAC7B,MAAI,UAAU,KAAI,MAAO,GAAG;AAC1B,gBAAgB,0BAAqB;EACvC;AAEA,MAAI,oBAAoB;AACxB,QAAM,WAAuB,wBAAY,SAAQ,EAAG,2BAA2B,iBAAiB;AAChG,MAAI,UAAU,aAAa;AACzB,UAAM,MAAM,OAAO,SAAS,YAAY,GAAG;AAC3C,wBAAwB,oBAAe,4BAA4B,GAAG;EACxE;AAEA,SAAO;IACL;IACA;;AAEJ;AAEA,SAAS,uBAAuB,KAAQ;AACtC,QAAM,uBAAuB;AAC7B,MAAI,SAAS;AAEb,aAAW,CAAC,KAAK,KAAK,KAAK,IAAI,cAAc;AAC3C,QAAI,QAAQ;AACV,gBAAU;IACZ;AACA,QAAI,OAAO;AACT,gBAAU,GAAG,GAAG,IAAa,yBAAgB,qBAAqB,OAAO,oBAAoB,CAAC;IAChG,OAAO;AACL,gBAAU;IACZ;EACF;AACA,MAAI,QAAQ;AACV,aAAS,MAAM;EACjB;AAEA,SAAO;AACT;AAUM,SAAU,gBAAgB,MAAW;AACzC,QAAM,SAAmB,CAAA;AACzB,QAAM,aAAa,KAAK,MAAM,SAAO,IAAI,aAAa,QAAQ;AAE9D,aAAW,CAAC,OAAO,GAAG,KAAK,KAAK,QAAO,GAAI;AACzC,UAAM,cAAc,KAAK,QAAQ,CAAC;AAClC,UAAM,sBAAsB,eAAe,IAAI,SAAS,YAAY,QAAQ,IAAI,aAAa,YAAY;AACzG,QAAI,YAAY;AAChB,QAAI,gBAAgB;AAKpB,QAAI,UAAU,KAAK,YAAY;AAC7B,kBAAY;AACZ,sBAAgB;IAClB;AAEA,UAAM,SAAS,uBAAuB,GAAG;AACzC,QAAI,CAAC,eAAe;AAClB,aAAO,KAAK,GAAG,IAAI,QAAQ,KAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACpE,WAAW,CAAC,WAAW;AACrB,aAAO,KAAK,GAAG,IAAI,IAAI,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACnD,OAAO;AACL,aAAO,KAAK,GAAG,IAAI,QAAQ,GAAG,MAAM,EAAE;IACxC;EACF;AAGA,SAAO,OAAO,IAAI,WAAS,MAAM,SAAS,KAAK,MAAM,SAAS,GAAG,IAAI,MAAM,UAAU,GAAG,MAAM,SAAS,CAAC,IAAI,KAAK;AACnH;AAWM,SAAU,WAAW,KAAU,WAAW,IAAE;AAChD,QAAM,QAAQ,IAAI,aAAa,MAAM,CAAC,IAAI,IAAI,IAAI,IAAI,SAAS,MAAM,GAAG;AACxE,MAAI,eAAe,MAAM,GAAG,EAAE,KAAK;AAEnC,MAAI,aAAa,SAAS,UAAU;AAClC,WAAgB,yBAAgB,WAAW,cAAc,QAAQ;EACnE;AAEA,MAAI,IAAI,MAAM,SAAS;AACvB,SAAO,EAAE,KAAK,GAAG;AACf,QAAI,aAAa,SAAS,MAAM,CAAC,EAAE,UAAU,UAAU;AACrD,qBAAe,GAAG,MAAM,CAAC,CAAC,IAAI,YAAY;IAC5C;EACF;AAEA,SAAO;AACT;AAWM,SAAU,uBACZ,KAAU,QAA4C,oBAA4B;AACpF,QAAM,SAAS,IAAI,OAAO,QAAQ,YAAY,EAAE;AAChD,MAAI,CAAC,QAAQ;AACX,WAAO;EACT;AACA,MAAI;AAEJ,MAAI,OAAO,gBAAgB;AACzB,uBAAmB,GAAG,MAAM;EAC9B,OAAO;AACL,uBAAmB,qBAAqB,GAAG,MAAM,KAAK,OAAO,IAAI,MAAM,GAAG,MAAM,MAAM,OAAO,IAAI;EACnG;AAEA,qBAA4B,yBAAgB,qBAAqB,kBAAkB,iBAAiB;AACpG,SAAO;AACT;AAGM,IAAO,oBAAP,MAAwB;EACT;EAAnB,YAAmB,SAA0C;AAA1C,SAAA,UAAA;EACnB;;;;ACxJF;;;;;AAIA,YAAY,UAAU;AAEtB,YAAYC,YAAW;AACvB,YAAY,wBAAwB;AACpC,YAAY,eAAe;AAE3B,IAAM,YAAY;;;;EAIhB,oBAAoB;;;;EAIpB,qBAAqB;;;;EAIrB,sBAAsB;;;;EAItB,SAAS;;AAGX,IAAM,OAAY,UAAK,kBAAkB,uCAAuC,SAAS;AACzF,IAAM,aAAkB,UAAK,mBAAmB,KAAK,QAAW,IAAI;AAEpE,SAAS,2BAA2B,OAA8C;AAEhF,QAAM,SAAS,MAAM,UAAU;AAE/B,QAAM,mBAAsC,sCAAmB,6BAA6B,KAAK;AACjG,QAAM,SAAS,kBAAkB;AACjC,QAAM,eAAe,kBAAkB,kBAAkB;AACzD,QAAM,cAAc,cAAc,IAAG;AACrC,QAAM,oBAAoB,cAAc,kBAAiB;AACzD,QAAM,kBAAkB,QAAQ,gBAAe;AAC/C,QAAM,oBAAwE,EAAC,iBAAiB,kBAAiB;AACjH,QAAM,MAAM,eAAe;AAC3B,SAAO,EAAC,KAAK,kBAAiB;AAChC;AAEM,SAAU,oBAAoB,OAA+B;AACjE,MAAI,CAAO,aAAM,OAAO,cAAc,KAAK,GAAG;AAC5C,WAAO;EACT;AACA,QAAM,EAAC,KAAK,kBAAiB,IAAI,2BAA2B,KAAK;AACjE,SAAO,kBAAkB,KAAK,iBAAiB;AACjD;AAEA,SAAS,kBACL,KAAsC,SAA4D;AACpG,SAAiB,4BAAkB,kBAAkB,SAAQ,EAAG,sBAAsB,KAAK,OAAO;AACpG;AAOM,SAAU,uBAAuB,OAA+B;AACpE,MAAI,CAAO,aAAM,OAAO,cAAc,KAAK,GAAG;AAC5C,YAAQ,KAAK,sDAAsD;AACnE,WAAO;EACT;AACA,QAAM,EAAC,KAAK,kBAAiB,IAAI,2BAA2B,KAAK;AAEjE,QAAM,gBAA0B,4BAAkB,kBAAkB,SAAQ;AAC5E,MAAI,kBAAkB,mBAAmB,cAAc,oBAAoB;AACzE,WAAO,WAAW,UAAU,kBAAkB;EAChD;AACA,MAAI,kBAAkB,qBAAqB,cAAc,+CAA+C;AACtG,WAAO,WAAW,UAAU,mBAAmB;EACjD;AAEA,MAAI,CAAC,KAAK;AACR,QAAI,cAAc,sBAAsB;AACtC,aAAO,WAAW,UAAU,oBAAoB;IAClD;AAGA,WAAO;EACT;AACA,QAAM,QAAQ,cAAc,qBAAqB,GAAG;AACpD,SAAO,QAAQ,MAAM,SAAS,WAAW,UAAU,OAAO;AAC5D;;;AC1FA;;;;;;;;AAIA,YAAYC,YAAW;AAEvB,IAAM,aACF,oBAAI,QAAO;AACR,IAAM,UAAU,IAAI,YAAW;AAMhC,SAAU,WAAW,YAC6B;AACtD,MAAI,WAAW,IAAI,UAAU,GAAG;AAC9B,WAAO,WAAW,IAAI,UAAU,KAAK;EACvC;AAEA,QAAM,MAAY,gBAAS,cAAc,YAAY,uBAAuB,UAAU;AAEtF,YAAU,GAAG,EACR,KAAK,iBAAc;AAClB,eAAW,IAAI,YAAY,WAAW;AACtC,YAAQ,cAAc,IAAI,YAAY,qBAAqB,EAAC,QAAQ,EAAC,YAAY,OAAO,YAAW,EAAC,CAAC,CAAC;EACxG,CAAC,EACA,MAAM,MAAK;EAAE,CAAC;AACnB,SAAO;AACT;AAGA,SAAS,UAAU,KAAW;AAC5B,SAAO,IAAI,QAAQ,aAAU;AAC3B,UAAM,QAAQ,IAAI,MAAK;AACvB,UAAM,iBAAiB,QAAQ,MAAM,QAAQ,KAAK,CAAC;AACnD,UAAM,iBAAiB,SAAS,MAAM,QAAQ,IAAI,CAAC;AACnD,UAAM,MAAM;EACd,CAAC;AACH;AAGM,SAAU,QAAQ,aAA8F;AAEpH,QAAM,WAAW,YAAY,IAAI,gBAAa;AAC5C,QAAI,WAAW,IAAI,UAAU,GAAG;AAC9B;IACF;AACA,UAAM,MAAY,gBAAS,cAAc,YAAY,uBAAuB,UAAU;AACtF,WAAO,UAAU,GAAG,EAAE,KAAK,WAAQ;AACjC,iBAAW,IAAI,YAAY,KAAK;AAChC;IACF,CAAC;EACH,CAAC;AACD,SAAO,QAAQ,IAAI,QAAQ;AAC7B;AAEO,IAAM,kBAAkB;AACxB,IAAM,sBAAsB;;;AC1DnC;;;;;;AAIA,YAAY,YAAY;AACxB,YAAYC,WAAU;AACtB,YAAYC,YAAW;AAmBvB,eAAe,mBAAmB,QAAc;AAC9C,QAAM,SAAS,MAAa,YAAK,SAAS,MAAM;AAChD,QAAM,SAAS,MAAa,cAAO,OAAO,MAAM;AAChD,SAAO;AACT;AAKA,eAAe,mBAAmB,MAAc,WAAmB,YAAkB;AACnF,QAAM,MAAM,IAAI,IAAI,SAAS;AAC7B,MAAI,OAAO,MAAM,mBAAmB,KAAK,UAAU,IAAI,CAAC;AACxD,MAAI,aAAa,IAAI,QAAQ,GAAG;AAChC,SAAO,KAAK,IAAI,SAAQ,GAAI,UAAU;AACxC;AAKM,SAAU,YAAY,aAA0B,iBAAyB,kBAAwB;AACrG,QAAM,iBAAiB;IACrB,KAAK;MACH;MACA,QAAQ;QACN,uBAAuB;UACrB,SAAS;YACP,MAAM;YACN,OAAO;;;;MAIb,gBAAgB;QACd,QAAa,qBAAe,eAAe,SAAQ,EAAG;;;IAG1D,aAAa;;AAEf,QAAM,MAAM;AACZ,QAAM,aAAa,WAAW,gBAAgB;AAE9C,OAAK,mBAAmB,gBAAgB,KAAK,UAAU;AACzD;AAQM,SAAU,eAAe,KAAa,YAAoB,aAAuC;AACrG,WAAS,QAAQ,MAAY;AAC3B,WAAO;MACL;MACA,eAAe;MACf,cAAc;;EAElB;AAEA,QAAM,iBAAiB,QAAQ,UAAU;AAQzC,WAAS,wBAAwB,QAAgB,MAAgB;AAC/D,QAAI,OAAO;AAGX,mBAAe,iBAAiB,KAAK;AAGrC,UAAM,qBAAqB,OAAO,QAAQ,YAAY,EAAE,EAAE,MAAM,KAAK;AACrE,uBAAmB,QAAQ,CAAC,mBAAmB,MAAK;AAClD,UAAI,kBAAkB,WAAW,GAAG;AAClC;MACF;AAEA,YAAM,SAAS,MAAM,mBAAmB,SAAS;AAEjD,UAAI,QAAQ,KAAK,UAAU,KAAK,CAAAC,WAASA,OAAM,SAAS,iBAAiB;AACzE,UAAI,CAAC,OAAO;AACV,gBAAQ,QAAQ,iBAAiB;AACjC,aAAK,WAAW,KAAK,YAAY,CAAA;AACjC,aAAK,SAAS,KAAK,KAAK;MAC1B;AACA,aAAO;AAGP,WAAK,iBAAiB,KAAK;AAG3B,UAAI,UAAU,KAAK,mCAAmC,QAAW;AAC/D,aAAK,iCAAiC,KAAK;MAC7C;IACF,CAAC;EACH;AAIA,aAAW,CAAC,QAAQ,IAAI,KAAK,OAAO,QAAQ,WAAW,GAAG;AACxD,4BAAwB,QAAQ,IAAI;EACtC;AAKA,WAAS,YAAY,MAAiB;AACpC,WAAO,KAAK,YAAY,KAAK,SAAS,WAAW,GAAG;AAClD,YAAM,QAAQ,KAAK,SAAS,CAAC;AAC7B,WAAK,QAAQ,MAAM,MAAM;AACzB,UAAI,MAAM,gCAAgC;AACxC,aAAK,iCAAiC,MAAM;MAC9C;AACA,WAAK,WAAW,MAAM;IACxB;AAEA,QAAI,KAAK,UAAU;AACjB,iBAAW,SAAS,KAAK,UAAU;AACjC,oBAAY,KAAK;MACnB;IACF;EACF;AACA,cAAY,cAAc;AAK1B,MAAI,CAAC,eAAe,MAAM;AACxB,WAAO;MACL,GAAG;MACH,MAAM;MACN,UAAU,eAAe;;EAE7B;AAGA,QAAM,aAAa,EAAC,GAAG,eAAc;AACrC,aAAW,OAAO;AAClB,aAAW,WAAW,CAAC,cAAc;AACrC,SAAO;AACT;AAEA,SAAS,uBAAuB,SAAmD;AAEjF,QAAM,eAAe,QAAQ,KAAK,KAAK;AACvC,QAAM,eAAe,QAAQ,KAAK,KAAK;AAIvC,QAAM,sBAAsB;AAC5B,SAAO,EAAC,cAAc,cAAc,oBAAmB;AACzD;AAiBM,SAAU,kBACZ,SACA,aAA6D;AAC/D,QAAM,QAAuB,CAAA;AAC7B,QAAM,qBAAqB,oBAAI,IAAG;AAElC,aAAW,UAAU,QAAQ,SAAS;AACpC,QAAI,CAAC,OAAO,KAAK;AACf;IACF;AAEA,UAAM,OAAO,OAAO;AACpB,UAAM,QAAc,gBAAS,cAAc,QAAQ,wBAAwB,MAAM;AAEjF,QAAI;AACJ,QAAI,OAAO,aAAa,SAAS,EAAE,kBAAkB,QAAQ;AAG3D,YAAM,cAA0C,CAAA;AAChD,iBAAW,CAAC,QAAQ,aAAa,KAAK,OAAO,QAAQ,MAAM,KAAK,GAAG;AACjE,cAAM,aAAyB;UAC7B;UACA,cAAc;;AAGhB,cAAM,MAAY,cAAO,kBAAkB,gBAAgB,MAAM;AACjE,YAAI,YAAY,IAAI,GAAG,GAAG;AACxB,qBAAW,iCAAiC;QAC9C;AAEA,oBAAY,MAAM,IAAI;MACxB;AAEA,UAAI,MAAM,eAAe;AACvB,cAAM,aAAyB;UAC7B,eAAe,MAAM;;AAEvB,oBAAY,YAAY,IAAI;MAC9B;AAEA,aAAO,eAAe,OAAO,KAAK,OAAO,KAAK,WAAW;IAC3D,OAAO;AAEL,aAAO;QACL;QACA,eAAe,OAAO,SAAS,UAAU;QACzC,cAAc;;IAElB;AAKA,QAAI,OAAO,QAAQ;AACjB,UAAI,WAAW,mBAAmB,IAAI,OAAO,KAAK;AAClD,UAAI,CAAC,UAAU;AACb,mBAAW;UACT;UACA,eAAe;UACf,cAAc;UACd,UAAU,CAAA;;AAEZ,2BAAmB,IAAI,OAAO,OAAO,QAAQ;AAC7C,cAAM,KAAK,QAAQ;MACrB;AACA,eAAS,iBAAiB,KAAK;AAC/B,WAAK,OAAO,OAAO,UAAU,cAAc,OAAO,QAAQ,UAAS,EAAG,UAAU,GAAG,EAAE,IAAI,WAAM;AAC/F,eAAS,UAAU,KAAK,IAAI;IAC9B,OAAO;AAEL,YAAM,KAAK,IAAI;AAEf,UAAI,OAAO,SAAS;AAClB,cAAM,EAAC,cAAc,oBAAmB,IAAI,uBAAuB,OAAO,OAAO;AACjF,cAAM,mBAAmB,eAAe;AACxC,aAAK,eAAe;MACtB,OAAO;AACL,aAAK,eAAe,KAAK;MAC3B;IACF;EACF;AAIA,aAAW,CAAC,SAAS,IAAI,KAAK,oBAAoB;AAChD,UAAM,SAAS,QAAQ,QAAQ,KAC3B,OAAK,EAAE,SAAS,KAAK,KAAK,iBAAiB,cAAc,EAAE,SAAS,KAAK,KAAK,UAAU,OAAO;AACnG,QAAI,QAAQ,SAAS;AACnB,YAAM,EAAC,cAAc,cAAc,oBAAmB,IAAI,uBAAuB,OAAO,OAAO;AAC/F,YAAM,mBAAmB,KAAK,gBAAgB;AAC9C,YAAM,mBAAmB,eAAe;AACxC,WAAK,eAAe,KAAK,MAAM,mBAAmB,gBAAgB;IACpE,OAAO;AACL,WAAK,eAAe,KAAK;IAC3B;EACF;AAEA,SAAO;AACT;",
  "names": ["SDK", "Trace", "Trace", "i18n", "Trace", "child"]
}
