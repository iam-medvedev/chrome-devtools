{"version":3,"file":"EntityMapper.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/EntityMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Trace from '../../../models/trace/trace.js';\n\nexport class EntityMapper {\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n  #entityMappings: Trace.Handlers.Helpers.EntityMappings;\n  #firstPartyEntity: Trace.Handlers.Helpers.Entity|null;\n  #thirdPartyEvents: Trace.Types.Events.Event[] = [];\n  /**\n   * When resolving urls and updating our entity mapping in the\n   * SourceMapsResolver, a single call frame can appear multiple times\n   * as different cpu profile nodes. To avoid duplicate work on the\n   * same CallFrame, we can keep track of them.\n   */\n  #resolvedCallFrames: Set<Protocol.Runtime.CallFrame> = new Set();\n\n  constructor(parsedTrace: Trace.Handlers.Types.ParsedTrace) {\n    this.#parsedTrace = parsedTrace;\n    this.#entityMappings = this.#initializeEntityMappings(this.#parsedTrace);\n    this.#firstPartyEntity = this.#findFirstPartyEntity();\n    this.#thirdPartyEvents = this.#getThirdPartyEvents();\n  }\n\n  /**\n   * This initializes our maps using the parsedTrace data from both the RendererHandler and\n   * the NetworkRequestsHandler.\n   */\n  #initializeEntityMappings(parsedTrace: Trace.Handlers.Types.ParsedTrace): Trace.Handlers.Helpers.EntityMappings {\n    // NetworkRequestHandler caches.\n    const entityByNetworkEvent = parsedTrace.NetworkRequests.entityMappings.entityByEvent;\n    const networkEventsByEntity = parsedTrace.NetworkRequests.entityMappings.eventsByEntity;\n    const networkCreatedCache = parsedTrace.NetworkRequests.entityMappings.createdEntityCache;\n\n    // RendrerHandler caches.\n    const entityByRendererEvent = parsedTrace.Renderer.entityMappings.entityByEvent;\n    const rendererEventsByEntity = parsedTrace.Renderer.entityMappings.eventsByEntity;\n    const rendererCreatedCache = parsedTrace.Renderer.entityMappings.createdEntityCache;\n\n    // Build caches.\n    const entityByEvent = new Map([...entityByNetworkEvent, ...entityByRendererEvent]);\n    const createdEntityCache = new Map([...networkCreatedCache, ...rendererCreatedCache]);\n    const eventsByEntity = this.#mergeEventsByEntities(rendererEventsByEntity, networkEventsByEntity);\n\n    return {\n      entityByEvent,\n      eventsByEntity,\n      createdEntityCache,\n    };\n  }\n\n  #findFirstPartyEntity(): Trace.Handlers.Helpers.Entity|null {\n    // As a starting point, we consider the first navigation as the 1P.\n    const nav = Array.from(this.#parsedTrace.Meta.navigationsByNavigationId.values()).sort((a, b) => a.ts - b.ts)[0];\n    const firstPartyUrl = nav?.args.data?.documentLoaderURL ?? this.#parsedTrace.Meta.mainFrameURL;\n    return Trace.Handlers.Helpers.getEntityForUrl(firstPartyUrl, this.#entityMappings.createdEntityCache) ?? null;\n  }\n\n  #getThirdPartyEvents(): Trace.Types.Events.Event[] {\n    const entries = Array.from(this.#entityMappings.eventsByEntity.entries());\n    const thirdPartyEvents = entries.flatMap(([entity, requests]) => {\n      return entity.name !== this.#firstPartyEntity?.name ? requests : [];\n    });\n    return thirdPartyEvents;\n  }\n\n  #mergeEventsByEntities(\n      a: Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]>,\n      b: Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]>):\n      Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]> {\n    const merged = new Map(a);\n    for (const [entity, events] of b.entries()) {\n      if (merged.has(entity)) {\n        const currentEvents = merged.get(entity) ?? [];\n        merged.set(entity, [...currentEvents, ...events]);\n      } else {\n        merged.set(entity, [...events]);\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Returns an entity for a given event if any.\n   */\n  entityForEvent(event: Trace.Types.Events.Event): Trace.Handlers.Helpers.Entity|null {\n    return this.#entityMappings.entityByEvent.get(event) ?? null;\n  }\n\n  /**\n   * Returns trace events that correspond with a given entity if any.\n   */\n  eventsForEntity(entity: Trace.Handlers.Helpers.Entity): Trace.Types.Events.Event[] {\n    return this.#entityMappings.eventsByEntity.get(entity) ?? [];\n  }\n\n  firstPartyEntity(): Trace.Handlers.Helpers.Entity|null {\n    return this.#firstPartyEntity;\n  }\n\n  thirdPartyEvents(): Trace.Types.Events.Event[] {\n    return this.#thirdPartyEvents;\n  }\n\n  mappings(): Trace.Handlers.Helpers.EntityMappings {\n    return this.#entityMappings;\n  }\n\n  /**\n   * This updates entity mapping given a callFrame and sourceURL (newly resolved),\n   * updating both eventsByEntity and entityByEvent. The call frame provides us the\n   * URL and sourcemap source location that events map to. This describes the exact events we\n   * want to update. We then update the events with the new sourceURL.\n   *\n   * compiledURLs -> the actual file's url (e.g. my-big-bundle.min.js)\n   * sourceURLs -> the resolved urls (e.g. react.development.js, my-app.ts)\n   * @param callFrame\n   * @param sourceURL\n   */\n  updateSourceMapEntities(callFrame: Protocol.Runtime.CallFrame, sourceURL: string): void {\n    // Avoid the extra work, if we have already resolved this callFrame.\n    if (this.#resolvedCallFrames.has(callFrame)) {\n      return;\n    }\n\n    const compiledURL = callFrame.url;\n    const currentEntity = Trace.Handlers.Helpers.getEntityForUrl(compiledURL, this.#entityMappings.createdEntityCache);\n    const resolvedEntity = Trace.Handlers.Helpers.getEntityForUrl(sourceURL, this.#entityMappings.createdEntityCache);\n    // If the entity changed, then we should update our caches. If we don't have a currentEntity,\n    // we can't do much with that. Additionally without our current entity, we don't have a reference to the related\n    // events so there are no relationships to be made.\n    if ((resolvedEntity === currentEntity) || (!currentEntity || !resolvedEntity)) {\n      return;\n    }\n    const currentEntityEvents = (currentEntity && this.#entityMappings.eventsByEntity.get(currentEntity)) ?? [];\n    // The events of the entity that match said source location.\n    const sourceLocationEvents: Trace.Types.Events.Event[] = [];\n    // The events that don't match the source location, but that we should keep mapped to its current entity.\n    const unrelatedEvents: Trace.Types.Events.Event[] = [];\n    currentEntityEvents?.forEach(e => {\n      const stackTrace = Trace.Helpers.Trace.getZeroIndexedStackTraceForEvent(e);\n      const cf = stackTrace?.at(0);\n\n      const matchesCallFrame = cf && Trace.Helpers.Trace.isMatchingCallFrame(cf, callFrame);\n      if (matchesCallFrame) {\n        sourceLocationEvents.push(e);\n      } else {\n        unrelatedEvents.push(e);\n      }\n    });\n    // Update current entity.\n    this.#entityMappings.eventsByEntity.set(currentEntity, unrelatedEvents);\n    // Map the source location events to the new entity.\n    this.#entityMappings.eventsByEntity.set(resolvedEntity, sourceLocationEvents);\n    sourceLocationEvents.forEach(e => {\n      this.#entityMappings.entityByEvent.set(e, resolvedEntity);\n    });\n    // Update our CallFrame cache when we've got a resolved entity.\n    this.#resolvedCallFrames.add(callFrame);\n  }\n}\n"]}