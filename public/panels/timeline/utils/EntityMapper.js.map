{"version":3,"file":"EntityMapper.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/EntityMapper.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAI7B,MAAM,OAAO,YAAY;IACvB,YAAY,CAAmC;IAC/C,eAAe,CAAwC;IAEvD,YAAY,WAA6C;QACvD,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC3E,CAAC;IAED;;;OAGG;IACH,yBAAyB,CAAC,WAA6C;QACrE,+BAA+B;QAC/B,MAAM,oBAAoB,GAAG,WAAW,CAAC,eAAe,CAAC,cAAc,CAAC,aAAa,CAAC;QACtF,MAAM,qBAAqB,GAAG,WAAW,CAAC,eAAe,CAAC,cAAc,CAAC,cAAc,CAAC;QACxF,MAAM,mBAAmB,GAAG,WAAW,CAAC,eAAe,CAAC,cAAc,CAAC,kBAAkB,CAAC;QAE1F,yBAAyB;QACzB,MAAM,qBAAqB,GAAG,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,aAAa,CAAC;QAChF,MAAM,sBAAsB,GAAG,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC;QAClF,MAAM,oBAAoB,GAAG,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,kBAAkB,CAAC;QAEpF,gBAAgB;QAChB,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,oBAAoB,EAAE,GAAG,qBAAqB,CAAC,CAAC,CAAC;QACnF,MAAM,kBAAkB,GAAG,IAAI,GAAG,CAAC,CAAC,GAAG,mBAAmB,EAAE,GAAG,oBAAoB,CAAC,CAAC,CAAC;QACtF,MAAM,cAAc,GAAG,IAAI,CAAC,sBAAsB,CAAC,sBAAsB,EAAE,qBAAqB,CAAC,CAAC;QAElG,OAAO;YACL,aAAa;YACb,cAAc;YACd,kBAAkB;SACnB,CAAC;IACJ,CAAC;IAED,sBAAsB,CAClB,CAAiE,EACjE,CAAiE;QAEnE,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;QAC1B,KAAK,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC;YAC3C,IAAI,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;gBACvB,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;gBAC/C,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,aAAa,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC;YACpD,CAAC;iBAAM,CAAC;gBACN,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;YAClC,CAAC;QACH,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,KAA+B;QAC5C,OAAO,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC;IAC/D,CAAC;IAED;;OAEG;IACH,eAAe,CAAC,MAAqC;QACnD,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;IAC/D,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Trace from '../../../models/trace/trace.js';\n\nexport class EntityMapper {\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n  #entityMappings: Trace.Handlers.Helpers.EntityMappings;\n\n  constructor(parsedTrace: Trace.Handlers.Types.ParsedTrace) {\n    this.#parsedTrace = parsedTrace;\n    this.#entityMappings = this.#initializeEntityMappings(this.#parsedTrace);\n  }\n\n  /**\n   * This initializes our maps using the parsedTrace data from both the RendererHandler and\n   * the NetworkRequestsHandler.\n   */\n  #initializeEntityMappings(parsedTrace: Trace.Handlers.Types.ParsedTrace): Trace.Handlers.Helpers.EntityMappings {\n    // NetworkRequestHander caches.\n    const entityByNetworkEvent = parsedTrace.NetworkRequests.entityMappings.entityByEvent;\n    const networkEventsByEntity = parsedTrace.NetworkRequests.entityMappings.eventsByEntity;\n    const networkCreatedCache = parsedTrace.NetworkRequests.entityMappings.createdEntityCache;\n\n    // RendrerHandler caches.\n    const entityByRendererEvent = parsedTrace.Renderer.entityMappings.entityByEvent;\n    const rendererEventsByEntity = parsedTrace.Renderer.entityMappings.eventsByEntity;\n    const rendererCreatedCache = parsedTrace.Renderer.entityMappings.createdEntityCache;\n\n    // Build caches.\n    const entityByEvent = new Map([...entityByNetworkEvent, ...entityByRendererEvent]);\n    const createdEntityCache = new Map([...networkCreatedCache, ...rendererCreatedCache]);\n    const eventsByEntity = this.#mergeEventsByEntities(rendererEventsByEntity, networkEventsByEntity);\n\n    return {\n      entityByEvent,\n      eventsByEntity,\n      createdEntityCache,\n    };\n  }\n\n  #mergeEventsByEntities(\n      a: Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]>,\n      b: Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]>):\n      Map<Trace.Handlers.Helpers.Entity, Trace.Types.Events.Event[]> {\n    const merged = new Map(a);\n    for (const [entity, events] of b.entries()) {\n      if (merged.has(entity)) {\n        const currentEvents = merged.get(entity) ?? [];\n        merged.set(entity, [...currentEvents, ...events]);\n      } else {\n        merged.set(entity, [...events]);\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Returns an entity for a given event if any.\n   */\n  entityForEvent(event: Trace.Types.Events.Event): Trace.Handlers.Helpers.Entity|null {\n    return this.#entityMappings.entityByEvent.get(event) ?? null;\n  }\n\n  /**\n   * Returns trace events that correspond with a given entity if any.\n   */\n  eventsForEntity(entity: Trace.Handlers.Helpers.Entity): Trace.Types.Events.Event[] {\n    return this.#entityMappings.eventsByEntity.get(entity) ?? [];\n  }\n\n  mappings(): Trace.Handlers.Helpers.EntityMappings {\n    return this.#entityMappings;\n  }\n}\n"]}