{"version":3,"file":"InsightAIContext.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/InsightAIContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport {AICallTree} from './AICallTree.js';\n\nexport class AIQueries {\n  /**\n   * Returns the set of network requests that occurred within the timeframe of this Insight.\n   */\n  static networkRequests(\n      insight: Trace.Insights.Types.InsightModel, insightSetBounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): readonly Trace.Types.Events.SyntheticNetworkRequest[] {\n    const bounds = insightBounds(insight, insightSetBounds);\n\n    // Now we find network requests that:\n    // 1. began within the bounds\n    // 2. completed within the bounds\n    const matchedRequests: Trace.Types.Events.SyntheticNetworkRequest[] = [];\n    for (const request of parsedTrace.NetworkRequests.byTime) {\n      // Requests are ordered by time ASC, so if we find one request that is\n      // beyond the max, the rest are guaranteed to be also and we can break early.\n      if (request.ts > bounds.max) {\n        break;\n      }\n      if (request.args.data.url.startsWith('data:')) {\n        // For the sake of the LLM querying data, we don't care about data: URLs.\n        continue;\n      }\n      if (request.ts >= bounds.min && request.ts + request.dur <= bounds.max) {\n        matchedRequests.push(request);\n      }\n    }\n\n    return matchedRequests;\n  }\n\n  /**\n   * Returns the single network request. We do not check to filter this by the\n   * bounds of the insight, because the only way that the LLM has found this\n   * request is by first inspecting a summary of relevant network requests for\n   * the given insight. So if it then looks up a request by URL, we know that\n   * is a valid and relevant request.\n   */\n  static networkRequest(parsedTrace: Trace.Handlers.Types.ParsedTrace, url: string):\n      Trace.Types.Events.SyntheticNetworkRequest|null {\n    return parsedTrace.NetworkRequests.byTime.find(r => r.args.data.url === url) ?? null;\n  }\n\n  /**\n   * Returns an AI Call Tree representing the activity on the main thread for\n   * the relevant time range of the given insight.\n   */\n  static mainThreadActivity(\n      insight: Trace.Insights.Types.InsightModel, insightSetBounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): AICallTree|null {\n    /**\n     * We cannot assume that there is one main thread as there are scenarios\n     * where there can be multiple (see crbug.com/402658800) as an example.\n     * Therefore we calculate the main thread by using the thread that the\n     * Insight has been associated to. Most Insights relate to a navigation, so\n     * in this case we can use the navigation's PID/TID as we know that will\n     * have run on the main thread that we are interested in.\n     * If we do not have a navigation, we fall back to looking for the first\n     * thread we find that is of type MAIN_THREAD.\n     * Longer term we should solve this at the Trace Engine level to avoid\n     * look-ups like this; this is the work that is tracked in\n     * crbug.com/402658800.\n     */\n    let mainThreadPID: Trace.Types.Events.ProcessID|null = null;\n    let mainThreadTID: Trace.Types.Events.ThreadID|null = null;\n\n    if (insight.navigationId) {\n      const navigation = parsedTrace.Meta.navigationsByNavigationId.get(insight.navigationId);\n      if (navigation?.args.data?.isOutermostMainFrame) {\n        mainThreadPID = navigation.pid;\n        mainThreadTID = navigation.tid;\n      }\n    }\n\n    const threads = Trace.Handlers.Threads.threadsInTrace(parsedTrace);\n    const thread = threads.find(thread => {\n      if (mainThreadPID && mainThreadTID) {\n        return thread.pid === mainThreadPID && thread.tid === mainThreadTID;\n      }\n      return thread.type === Trace.Handlers.Threads.ThreadType.MAIN_THREAD;\n    });\n    if (!thread) {\n      return null;\n    }\n\n    const bounds = insightBounds(insight, insightSetBounds);\n    return AICallTree.fromTimeOnThread({\n      thread: {\n        pid: thread.pid,\n        tid: thread.tid,\n      },\n      parsedTrace,\n      bounds,\n    });\n  }\n}\n\n/**\n * Calculates the trace bounds for the given insight that are relevant.\n *\n * Uses the insight's overlays to determine the relevant trace bounds. If there are\n * no overlays, falls back to the insight set's navigation bounds.\n */\nfunction insightBounds(\n    insight: Trace.Insights.Types.InsightModel,\n    insightSetBounds: Trace.Types.Timing.TraceWindowMicro): Trace.Types.Timing.TraceWindowMicro {\n  const overlays = insight.createOverlays?.() ?? [];\n  const windows = overlays.map(Trace.Helpers.Timing.traceWindowFromOverlay).filter(bounds => !!bounds);\n  const overlaysBounds = Trace.Helpers.Timing.combineTraceWindowsMicro(windows);\n  if (overlaysBounds) {\n    return overlaysBounds;\n  }\n\n  return insightSetBounds;\n}\n"]}