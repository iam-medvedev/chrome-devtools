{"version":3,"file":"InsightAIContext.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/InsightAIContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport {AICallTree} from './AICallTree.js';\n\n/**\n * This class holds the Insight that is active when the user has entered the\n * Ask AI flow from the Insights sidebar.\n * Ideally we would just use the InsightModel instance itself, but we need to\n * also store a reference to the parsed trace as we use that to populate the\n * data provided to the LLM, so we use this class as a container for the insight\n * and the parsed trace.\n */\nexport class ActiveInsight {\n  #insight: Trace.Insights.Types.InsightModel;\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n\n  constructor(insight: Trace.Insights.Types.InsightModel, parsedTrace: Trace.Handlers.Types.ParsedTrace) {\n    this.#insight = insight;\n    this.#parsedTrace = parsedTrace;\n  }\n\n  get insight(): Readonly<Trace.Insights.Types.InsightModel> {\n    return this.#insight;\n  }\n  get parsedTrace(): Trace.Handlers.Types.ParsedTrace {\n    return this.#parsedTrace;\n  }\n\n  title(): string {\n    return this.#insight.title;\n  }\n}\n\nexport class AIQueries {\n  /**\n   * Returns the set of network requests that occurred within the timeframe of this Insight.\n   */\n  static networkRequests(insight: Trace.Insights.Types.InsightModel, parsedTrace: Trace.Handlers.Types.ParsedTrace):\n      readonly Trace.Types.Events.SyntheticNetworkRequest[] {\n    const bounds = insightBounds(insight, parsedTrace);\n\n    // Now we find network requests that:\n    // 1. began within the bounds\n    // 2. completed within the bounds\n    const matchedRequests: Trace.Types.Events.SyntheticNetworkRequest[] = [];\n    for (const request of parsedTrace.NetworkRequests.byTime) {\n      // Requests are ordered by time ASC, so if we find one request that is\n      // beyond the max, the rest are guaranteed to be also and we can break early.\n      if (request.ts > bounds.max) {\n        break;\n      }\n      if (request.args.data.url.startsWith('data:')) {\n        // For the sake of the LLM querying data, we don't care about data: URLs.\n        continue;\n      }\n      if (request.ts >= bounds.min && request.ts + request.dur <= bounds.max) {\n        matchedRequests.push(request);\n      }\n    }\n\n    return matchedRequests;\n  }\n\n  /**\n   * Returns the single network request. We do not check to filter this by the\n   * bounds of the insight, because the only way that the LLM has found this\n   * request is by first inspecting a summary of relevant network requests for\n   * the given insight. So if it then looks up a request by URL, we know that\n   * is a valid and relevant request.\n   */\n  static networkRequest(parsedTrace: Trace.Handlers.Types.ParsedTrace, url: string):\n      Trace.Types.Events.SyntheticNetworkRequest|null {\n    return parsedTrace.NetworkRequests.byTime.find(r => r.args.data.url === url) ?? null;\n  }\n\n  /**\n   * Returns an AI Call Tree representing the activity on the main thread for\n   * the relevant time range of the given insight.\n   */\n  static mainThreadActivity(insight: Trace.Insights.Types.InsightModel, parsedTrace: Trace.Handlers.Types.ParsedTrace):\n      AICallTree|null {\n    const bounds = insightBounds(insight, parsedTrace);\n    return AICallTree.fromTime(bounds.min, bounds.max, parsedTrace);\n  }\n}\n\n/**\n * Calculates the time bounds for the given insight that are relevant.\n * If the insight is attached to a navigation, this will be the start of that\n * navigation through to either the next navigation, or the end of the trace.\n * For some insights we change the bounds; for LCP insights we treat the max\n * bound as LCP time, as anything that happens after that cannot have impacted\n * it.\n */\nfunction insightBounds(insight: Trace.Insights.Types.InsightModel, parsedTrace: Trace.Handlers.Types.ParsedTrace):\n    Trace.Types.Timing.TraceWindowMicro {\n  const navigationStart =\n      insight.navigationId ? parsedTrace.Meta.navigationsByNavigationId.get(insight.navigationId) : undefined;\n  const minBound = navigationStart?.ts ?? parsedTrace.Meta.traceBounds.min;\n\n  let maxBound = customMaxBoundForInsight(insight);\n  if (!maxBound) {\n    maxBound = parsedTrace.Meta.traceBounds.max;\n    if (navigationStart) {\n      const nextNavigation = getNextNavigation(navigationStart, parsedTrace);\n      if (nextNavigation) {\n        maxBound = nextNavigation.ts;\n      }\n    }\n  }\n  return Trace.Helpers.Timing.traceWindowFromMicroSeconds(minBound, maxBound);\n}\n\n/**\n * For a given navigation on the main frame, return the next navigation, if there was one.\n */\nfunction getNextNavigation(\n    navigation: Trace.Types.Events.NavigationStart,\n    parsedTrace: Trace.Handlers.Types.ParsedTrace): Trace.Types.Events.NavigationStart|null {\n  for (let i = 0; i < parsedTrace.Meta.mainFrameNavigations.length; i++) {\n    const currentNavigationStart = parsedTrace.Meta.mainFrameNavigations[i];\n    if (currentNavigationStart.args.data?.navigationId === navigation.args.data?.navigationId) {\n      return parsedTrace.Meta.mainFrameNavigations.at(i + 1) ?? null;\n    }\n  }\n  return null;\n}\n\nfunction customMaxBoundForInsight(insight: Trace.Insights.Types.InsightModel): Trace.Types.Timing.Micro|null {\n  if (Trace.Insights.Models.LCPPhases.isLCPPhases(insight) && insight.lcpEvent) {\n    return insight.lcpEvent.ts;\n  }\n  return null;\n}\n"]}