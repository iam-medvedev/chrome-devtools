{"version":3,"file":"InsightAIContext.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/InsightAIContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport {AICallTree} from './AICallTree.js';\n\nexport class AIQueries {\n  /**\n   * Returns the set of network requests that occurred within the timeframe of this Insight.\n   */\n  static networkRequests(\n      insight: Trace.Insights.Types.InsightModel, insightSetBounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): readonly Trace.Types.Events.SyntheticNetworkRequest[] {\n    const bounds = insightBounds(insight, insightSetBounds);\n\n    // Now we find network requests that:\n    // 1. began within the bounds\n    // 2. completed within the bounds\n    const matchedRequests: Trace.Types.Events.SyntheticNetworkRequest[] = [];\n    for (const request of parsedTrace.NetworkRequests.byTime) {\n      // Requests are ordered by time ASC, so if we find one request that is\n      // beyond the max, the rest are guaranteed to be also and we can break early.\n      if (request.ts > bounds.max) {\n        break;\n      }\n      if (request.args.data.url.startsWith('data:')) {\n        // For the sake of the LLM querying data, we don't care about data: URLs.\n        continue;\n      }\n      if (request.ts >= bounds.min && request.ts + request.dur <= bounds.max) {\n        matchedRequests.push(request);\n      }\n    }\n\n    return matchedRequests;\n  }\n\n  /**\n   * Returns the single network request. We do not check to filter this by the\n   * bounds of the insight, because the only way that the LLM has found this\n   * request is by first inspecting a summary of relevant network requests for\n   * the given insight. So if it then looks up a request by URL, we know that\n   * is a valid and relevant request.\n   */\n  static networkRequest(parsedTrace: Trace.Handlers.Types.ParsedTrace, url: string):\n      Trace.Types.Events.SyntheticNetworkRequest|null {\n    return parsedTrace.NetworkRequests.byTime.find(r => r.args.data.url === url) ?? null;\n  }\n\n  static findMainThread(navigationId: string|undefined, parsedTrace: Trace.Handlers.Types.ParsedTrace):\n      Trace.Handlers.Threads.ThreadData|null {\n    /**\n     * We cannot assume that there is one main thread as there are scenarios\n     * where there can be multiple (see crbug.com/402658800) as an example.\n     * Therefore we calculate the main thread by using the thread that the\n     * Insight has been associated to. Most Insights relate to a navigation, so\n     * in this case we can use the navigation's PID/TID as we know that will\n     * have run on the main thread that we are interested in.\n     * If we do not have a navigation, we fall back to looking for the first\n     * thread we find that is of type MAIN_THREAD.\n     * Longer term we should solve this at the Trace Engine level to avoid\n     * look-ups like this; this is the work that is tracked in\n     * crbug.com/402658800.\n     */\n    let mainThreadPID: Trace.Types.Events.ProcessID|null = null;\n    let mainThreadTID: Trace.Types.Events.ThreadID|null = null;\n\n    if (navigationId) {\n      const navigation = parsedTrace.Meta.navigationsByNavigationId.get(navigationId);\n      if (navigation?.args.data?.isOutermostMainFrame) {\n        mainThreadPID = navigation.pid;\n        mainThreadTID = navigation.tid;\n      }\n    }\n\n    const threads = Trace.Handlers.Threads.threadsInTrace(parsedTrace);\n    const thread = threads.find(thread => {\n      if (mainThreadPID && mainThreadTID) {\n        return thread.pid === mainThreadPID && thread.tid === mainThreadTID;\n      }\n      return thread.type === Trace.Handlers.Threads.ThreadType.MAIN_THREAD;\n    });\n\n    return thread ?? null;\n  }\n\n  /**\n   * Returns bottom up activity for the given range.\n   */\n  static mainThreadActivityBottomUp(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): Trace.Extras.TraceTree.BottomUpRootNode|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    const events = AICallTree.findEventsForThread({thread, parsedTrace, bounds});\n    if (!events) {\n      return null;\n    }\n\n    // Use the same filtering as front_end/panels/timeline/TimelineTreeView.ts.\n    const visibleEvents = Trace.Helpers.Trace.VISIBLE_TRACE_EVENT_TYPES.values().toArray();\n    const filter = new Trace.Extras.TraceFilter.VisibleEventsFilter(\n        visibleEvents.concat([Trace.Types.Events.Name.SYNTHETIC_NETWORK_REQUEST]));\n\n    // The bottom up root node handles all the \"in Tracebounds\" checks we need for the insight.\n    const startTime = Trace.Helpers.Timing.microToMilli(bounds.min);\n    const endTime = Trace.Helpers.Timing.microToMilli(bounds.max);\n    return new Trace.Extras.TraceTree.BottomUpRootNode(events, {\n      textFilter: new Trace.Extras.TraceFilter.ExclusiveNameFilter([]),\n      filters: [filter],\n      startTime,\n      endTime,\n    });\n  }\n\n  /**\n   * Returns an AI Call Tree representing the activity on the main thread for\n   * the relevant time range of the given insight.\n   */\n  static mainThreadActivityTopDown(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): AICallTree|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    return AICallTree.fromTimeOnThread({\n      thread: {\n        pid: thread.pid,\n        tid: thread.tid,\n      },\n      parsedTrace,\n      bounds,\n    });\n  }\n\n  /**\n   * Returns an AI Call Tree representing the activity on the main thread for\n   * the relevant time range of the given insight.\n   */\n  static mainThreadActivityForInsight(\n      insight: Trace.Insights.Types.InsightModel, insightSetBounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): AICallTree|null {\n    const bounds = insightBounds(insight, insightSetBounds);\n    return this.mainThreadActivityTopDown(insight.navigationId, bounds, parsedTrace);\n  }\n\n  /**\n   * Returns the top longest tasks as AI Call Trees.\n   */\n  static longestTasks(\n      navigationId: string|undefined, bounds: Trace.Types.Timing.TraceWindowMicro,\n      parsedTrace: Trace.Handlers.Types.ParsedTrace, limit = 3): AICallTree[]|null {\n    const thread = this.findMainThread(navigationId, parsedTrace);\n    if (!thread) {\n      return null;\n    }\n\n    const tasks = AICallTree.findMainThreadTasks({thread, parsedTrace, bounds});\n    if (!tasks) {\n      return null;\n    }\n\n    const topTasks = tasks.filter(e => e.name === 'RunTask').sort((a, b) => b.dur - a.dur).slice(0, limit);\n    return topTasks\n        .map(task => {\n          const tree = AICallTree.fromEvent(task, parsedTrace);\n          if (tree) {\n            tree.selectedNode = null;\n          }\n          return tree;\n        })\n        .filter(tree => !!tree);\n  }\n}\n\n/**\n * Calculates the trace bounds for the given insight that are relevant.\n *\n * Uses the insight's overlays to determine the relevant trace bounds. If there are\n * no overlays, falls back to the insight set's navigation bounds.\n */\nexport function insightBounds(\n    insight: Trace.Insights.Types.InsightModel,\n    insightSetBounds: Trace.Types.Timing.TraceWindowMicro): Trace.Types.Timing.TraceWindowMicro {\n  const overlays = insight.createOverlays?.() ?? [];\n  const windows = overlays.map(Trace.Helpers.Timing.traceWindowFromOverlay).filter(bounds => !!bounds);\n  const overlaysBounds = Trace.Helpers.Timing.combineTraceWindowsMicro(windows);\n  if (overlaysBounds) {\n    return overlaysBounds;\n  }\n\n  return insightSetBounds;\n}\n"]}