{"version":3,"file":"ImageCache.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/ImageCache.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAI7B,MAAM,UAAU,GAA2E,IAAI,OAAO,EAAE,CAAC;AACzG,MAAM,CAAC,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;AAEzC;;;GAGG;AACH,MAAM,UAAU,UAAU,CAAC,UAAkD;IAC3E,IAAI,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;QAC/B,OAAO,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC;IAC5C,CAAC;IAED,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC;IAErC,SAAS,CAAC,IAAI,CAAC;SACV,IAAI,CAAC,WAAW,CAAC,EAAE;QAClB,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;QACxC,OAAO,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,mBAAmB,EAAE,EAAC,MAAM,EAAE,EAAC,UAAU,EAAE,KAAK,EAAE,WAAW,EAAC,EAAC,CAAC,CAAC,CAAC;IAC1G,CAAC,CAAC;SACD,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;IACrB,OAAO,IAAI,CAAC;AACd,CAAC;AAED,yEAAyE;AACzE,SAAS,SAAS,CAAC,GAAW;IAC5B,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;QAC3B,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;QAC1B,KAAK,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACrD,KAAK,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QACrD,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;IAClB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,+FAA+F;AAC/F,MAAM,UAAU,OAAO,CAAC,WAAqD;IAC3E,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;QAC5C,IAAI,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;YAC/B,OAAO;QACT,CAAC;QACD,OAAO,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YACrD,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAClC,OAAO;QACT,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAC/B,CAAC;AAED,MAAM,CAAC,MAAM,eAAe,GAAG,UAAU,CAAC;AAC1C,MAAM,CAAC,MAAM,mBAAmB,GAAG,SAAS,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Trace from '../../../models/trace/trace.js';\n\nconst imageCache: WeakMap<Trace.Types.Events.SyntheticScreenshot, HTMLImageElement|null> = new WeakMap();\nexport const emitter = new EventTarget();\n\n/**\n * Synchronously returns an image, or return `null` while queuing up an async load of that image.\n * If the image load fails, we cache a null to avoid reattempts.\n */\nexport function getOrQueue(screenshot: Trace.Types.Events.SyntheticScreenshot): HTMLImageElement|null {\n  if (imageCache.has(screenshot)) {\n    return imageCache.get(screenshot) ?? null;\n  }\n\n  const data = screenshot.args.dataUri;\n\n  loadImage(data)\n      .then(imageOrNull => {\n        imageCache.set(screenshot, imageOrNull);\n        emitter.dispatchEvent(new CustomEvent('screenshot-loaded', {detail: {screenshot, image: imageOrNull}}));\n      })\n      .catch(() => {});\n  return null;\n}\n\n/** Load an image (probably data URI). If it fails, resolve with null. */\nfunction loadImage(url: string): Promise<HTMLImageElement|null> {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => resolve(null));\n    image.src = url;\n  });\n}\n\n/** Populate the cache ahead of use, to allow for getOrQueue to synchronously return images. */\nexport function preload(screenshots: Trace.Types.Events.SyntheticScreenshot[]): Promise<void[]> {\n  const promises = screenshots.map(screenshot => {\n    if (imageCache.has(screenshot)) {\n      return;\n    }\n    return loadImage(screenshot.args.dataUri).then(image => {\n      imageCache.set(screenshot, image);\n      return;\n    });\n  });\n  return Promise.all(promises);\n}\n\nexport const cacheForTesting = imageCache;\nexport const loadImageForTesting = loadImage;\n"]}