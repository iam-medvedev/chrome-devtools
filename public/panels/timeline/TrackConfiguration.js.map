{"version":3,"file":"TrackConfiguration.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/TrackConfiguration.ts"],"names":[],"mappings":"AAMA;;;;;;;;GAQG;AACH,MAAM,UAAU,oBAAoB,CAAC,MAA0C,EAAE,oBAA8B;IAE7G,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;QACjC,uDAAuD;QACvD,mEAAmE;QACnE,uGAAuG;QACvG,MAAM,cAAc,GAAG,oBAAoB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAE3D,OAAO;YACL,QAAQ,EAAE,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC;YACjC,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC;YAC7B,aAAa,EAAE,KAAK;YACpB,WAAW,EAAE,cAAc;YAC3B,SAAS,EAAE,KAAK,CAAC,IAAI;SACtB,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAuC;IACvE,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;AACpC,CAAC","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Trace from '../../models/trace/trace.js';\nimport type * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\n\n/**\n * Builds an array of group configs that we persist in memory and to disk when\n * the trace is saved. The order of the final array represents the user visible\n * order of the groups on the timeline.\n * The groups will be supplied in their original order; once they are defined\n * they do not change the order. What changes is the array of indexes that\n * represents the order in the UI. For example, this might be [1, 2, 0], which\n * means the group that was first (index 0) is now last.\n */\nexport function buildPersistedConfig(groups: readonly PerfUI.FlameChart.Group[], indexesInVisualOrder: number[]):\n    PerfUI.FlameChart.PersistedGroupConfig[] {\n  return groups.map((group, index) => {\n    // indexesInVisualOrder will look like [0, 2, 3, 4, 1];\n    // In this case the group originally at index 1 should now be last.\n    // So to get the new index, we look up the position of the old index in the indexesInVisualOrder array.\n    const newVisualIndex = indexesInVisualOrder.indexOf(index);\n\n    return {\n      expanded: Boolean(group.expanded),\n      hidden: Boolean(group.hidden),\n      originalIndex: index,\n      visualIndex: newVisualIndex,\n      trackName: group.name,\n    };\n  });\n}\n\n/**\n * Defines the key that is used when storing trace group configs into memory.\n * We store them with a key to ensure that if the user has >1 active traces, the configs are persisted but do not clash.\n * There is no guaranteed uuid for a trace file; but given that the timestamps\n * are monotonic microseconds, the chances of the user having more than one\n * trace with the exact same start time is very unlikely.\n * It's not impossible, but unlikely enough that we think the min trace bounds time is a good enough value to use as a uuid.\n */\nexport function keyForTraceConfig(trace: Trace.Handlers.Types.ParsedTrace): Trace.Types.Timing.Micro {\n  return trace.Meta.traceBounds.min;\n}\n"]}