{"version":3,"file":"EntriesFilter.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/EntriesFilter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TraceEngine from '../../models/trace/trace.js';\nimport {\n  entryIsVisibleInTimeline,\n} from './CompatibilityTracksAppender.js';\nimport * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\n\ntype EntryToNodeMap = Map<TraceEngine.Types.TraceEvents.SyntheticTraceEntry, TraceEngine.Helpers.TreeHelpers.TraceEntryNode>;\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the invisibleEntries() method will return the\n * entries that are invisible, and this is the list of entries that should be\n * removed before rendering the resulting thread on the timeline.\n */\nexport class EntriesFilter {\n  // Maps from an individual TraceEvent entry to its representation as a\n  // RendererEntryNode. We need this so we can then parse the tree structure\n  // generated by the RendererHandler.\n  #entryToNode: EntryToNodeMap;\n\n  // Track the set of invisible entries.\n  #invisibleEntries: TraceEngine.Types.TraceEvents.TraceEventData[] = [];\n  // List of entries whose children are hidden. This list is used to\n  // keep track of entries that should be identified in the UI as \"expandable\",\n  // since they can be clicked to reveal their hidden children.\n  #expandableEntries: TraceEngine.Types.TraceEvents.TraceEventData[] = [];\n  // Cache for descendants of entry that have already been gathered. The descendants\n  // will never change so we can avoid running the potentially expensive search again.\n  #entryToDescendantsMap: Map<TraceEngine.Helpers.TreeHelpers.TraceEntryNode, TraceEngine.Types.TraceEvents.TraceEventData[]> = new Map();\n\n  constructor(entryToNodeMap: EntryToNodeMap) {\n    this.#entryToNode = entryToNodeMap;\n  }\n\n  /**\n   * Checks which actions can be applied on an entry. This allows us to only show possible actions in the Context Menu.\n   * For example, if an entry has no children, COLLAPSE_FUNCTION will not change the FlameChart, therefore there is no need to show this action as an option.\n   */\n  findPossibleActions(entry: TraceEngine.Types.TraceEvents.SyntheticTraceEntry): PerfUI.FlameChart.PossibleFilterActions {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, return no possible actions.\n      return {\n        [PerfUI.FlameChart.FilterAction.MERGE_FUNCTION]: false,\n        [PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION]: false,\n        [PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: false,\n        [PerfUI.FlameChart.FilterAction.RESET_CHILDREN]: false,\n        [PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS]: false,\n      };\n    }\n    const entryParent = entryNode.parent;\n    const allVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => !this.#invisibleEntries.includes(descendant));\n    const allVisibleRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode).filter(\n        descendant => !this.#invisibleEntries.includes(descendant));\n    const allInVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => this.#invisibleEntries.includes(descendant));\n\n    // If there are children to hide, indicate action as possible\n    const possibleActions: PerfUI.FlameChart.PossibleFilterActions = {\n      [PerfUI.FlameChart.FilterAction.MERGE_FUNCTION]: entryParent !== null,\n      [PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION]: allVisibleDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: allVisibleRepeatingDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.RESET_CHILDREN]: allInVisibleDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS]: this.#invisibleEntries.length > 0,\n    };\n    return possibleActions;\n  }\n\n  /**\n   * Returns the amount of entry descendants that belong to the hidden entries array.\n   * */\n  findHiddenDescendantsAmount(entry: TraceEngine.Types.TraceEvents.SyntheticTraceEntry): number {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      return 0;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    return allDescendants.filter(descendant => this.invisibleEntries().includes(descendant)).length;\n  }\n\n  /**\n   * Returns the set of entries that are invisible given the set of applied actions.\n   */\n  invisibleEntries(): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Sets hidden and expandable. Called when a trace with modifications is loaded and some entries are set as hidden and expandable.\n   * Both arrays are set together because if there is one, the other must be present too.\n   */\n  setHiddenAndExpandableEntries(\n      invisibleEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n      expandableEntries: TraceEngine.Types.TraceEvents.TraceEventData[]): void {\n    this.#invisibleEntries.push(...invisibleEntries);\n    this.#expandableEntries.push(...expandableEntries);\n  }\n\n  inEntryInvisible(entry: TraceEngine.Types.TraceEvents.TraceEventData): boolean {\n    return this.#invisibleEntries.includes(entry);\n  }\n\n  /**\n   * Returns the array of entries that have a sign indicating that entries below are hidden,\n   * and so that they can be \"expanded\" to reveal their hidden children.\n   */\n  expandableEntries(): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    return this.#expandableEntries;\n  }\n\n  /**\n   * Applies an action to hide entries or removes entries\n   * from hidden entries array depending on the action.\n   */\n  applyFilterAction(action: PerfUI.FlameChart.UserFilterAction): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    // We apply new user action to the set of all entries, and mark\n    // any that should be hidden by adding them to this set.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set and return it as an array at the end.\n    const entriesToHide = new Set<TraceEngine.Types.TraceEvents.TraceEventData>();\n\n    switch (action.type) {\n      case PerfUI.FlameChart.FilterAction.MERGE_FUNCTION: {\n        // The entry that was clicked on is merged into its parent. All its\n        // children remain visible, so we just have to hide the entry that was\n        // selected.\n        entriesToHide.add(action.entry);\n        // If parent node exists, add it to expandableEntries, so it would be possible to uncollapse its children.\n        const actionNode = this.#entryToNode.get(action.entry) || null;\n        const parentNode = actionNode && this.#findNextVisibleParent(actionNode);\n        if (parentNode) {\n          this.#addExpandableEntry(parentNode.entry);\n        }\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION: {\n        // The entry itself remains visible, but all of its descendants are hidden.\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n        allDescendants.forEach(descendant => entriesToHide.add(descendant));\n        this.#addExpandableEntry(action.entry);\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS: {\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n        allRepeatingDescendants.forEach(descendant => entriesToHide.add(descendant));\n        if (entriesToHide.size > 0) {\n          this.#addExpandableEntry(action.entry);\n        }\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS: {\n        this.#invisibleEntries = [];\n        this.#expandableEntries = [];\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.RESET_CHILDREN: {\n        this.#makeEntryChildrenVisible(action.entry);\n        break;\n      }\n      default:\n        Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);\n    }\n\n    this.#invisibleEntries.push(...entriesToHide);\n\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Add an entry to the array of entries that have a sign indicating that entries below are hidden.\n   * Also, remove all of the child entries of the new expandable entry from the expandable array. Do that because\n   * to draw the initiator from the closest visible entry, we need to get the closest entry that is\n   * marked as expandable and we do not want to get some that are hidden.\n   */\n  #addExpandableEntry(entry: TraceEngine.Types.TraceEvents.TraceEventData): void {\n    this.#expandableEntries.push(entry);\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    if (allDescendants.length > 0) {\n      this.#expandableEntries = this.#expandableEntries.filter(entry => {\n        return !allDescendants.includes(entry);\n      });\n    }\n  }\n\n  // The direct parent might be hidden by other actions, therefore we look for the next visible parent.\n  #findNextVisibleParent(node: TraceEngine.Helpers.TreeHelpers.TraceEntryNode): TraceEngine.Helpers.TreeHelpers.TraceEntryNode|null {\n    let parent = node.parent;\n    while ((parent && this.#invisibleEntries.includes(parent.entry)) || (parent && !entryIsVisibleInTimeline(parent.entry))) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  #findAllDescendantsOfNode(root: TraceEngine.Helpers.TreeHelpers.TraceEntryNode): TraceEngine.Types.TraceEvents.TraceEventData[] {\n    const cachedDescendants = this.#entryToDescendantsMap.get(root);\n    if (cachedDescendants) {\n      return cachedDescendants;\n    }\n\n    const descendants: TraceEngine.Types.TraceEvents.TraceEventData[] = [];\n\n    // Walk through all the descendants, starting at the root node.\n    const children: TraceEngine.Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        descendants.push(childNode.entry);\n        const childNodeCachedDescendants = this.#entryToDescendantsMap.get(childNode);\n        // If the descendants of a child are cached, get them from the cache instead of iterating through them again\n        if (childNodeCachedDescendants) {\n          descendants.push(...childNodeCachedDescendants);\n        } else {\n          children.push(...childNode.children);\n        }\n      }\n    }\n\n    this.#entryToDescendantsMap.set(root, descendants);\n    return descendants;\n  }\n\n  #findAllRepeatingDescendantsOfNext(root: TraceEngine.Helpers.TreeHelpers.TraceEntryNode):\n  TraceEngine.Types.TraceEvents.SyntheticTraceEntry[] {\n    // Walk through all the ancestors, starting at the root node.\n    const children: TraceEngine.Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    const repeatingNodes: TraceEngine.Types.TraceEvents.SyntheticTraceEntry[] = [];\n    const rootIsProfileCall = TraceEngine.Types.TraceEvents.isProfileCall(root.entry);\n\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        const childIsProfileCall = TraceEngine.Types.TraceEvents.isProfileCall(childNode.entry);\n        if (/* Handle SyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {\n          const rootNodeEntry = root.entry as TraceEngine.Types.TraceEvents.SyntheticProfileCall;\n          const childNodeEntry = childNode.entry as TraceEngine.Types.TraceEvents.SyntheticProfileCall;\n\n          if (TraceEngine.Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(\n                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {\n            repeatingNodes.push(childNode.entry);\n          }\n        } /* Handle SyntheticRendererEvents */ else if (!rootIsProfileCall && !childIsProfileCall) {\n          if (root.entry.name === childNode.entry.name) {\n            repeatingNodes.push(childNode.entry);\n          }\n        }\n        children.push(...childNode.children);\n      }\n    }\n\n    return repeatingNodes;\n  }\n\n  /**\n   * If an entry was selected from a link instead of clicking on it,\n   * it might be in the invisible entries array.\n   * If it is, reveal it by resetting clidren the closest expandable entry,\n   */\n  revealEntry(entry: TraceEngine.Types.TraceEvents.SyntheticTraceEntry): void {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    let closestExpandableParent = entryNode;\n    while (closestExpandableParent.parent && !this.#expandableEntries.includes(closestExpandableParent.entry)) {\n      closestExpandableParent = closestExpandableParent.parent;\n    }\n    this.#makeEntryChildrenVisible(closestExpandableParent.entry);\n  }\n\n  /**\n   * Removes all of the entry children from the\n   * invisible entries array to make them visible.\n   */\n  #makeEntryChildrenVisible(entry: TraceEngine.Types.TraceEvents.SyntheticTraceEntry): void {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const descendants = this.#findAllDescendantsOfNode(entryNode);\n\n    /**\n     * Filter out all descendant of the node\n     * from the invisible entries list.\n     */\n    this.#invisibleEntries = this.#invisibleEntries.filter(entry => {\n      if (descendants.includes(entry)) {\n        return false;\n      }\n      return true;\n    });\n\n    /**\n     * Filter out all descentants and entry from expandable entries\n     * list to not show that some entries below those are hidden.\n     */\n    this.#expandableEntries = this.#expandableEntries.filter(iterEntry => {\n      if (descendants.includes(iterEntry) || iterEntry === entry) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  isEntryExpandable(event: TraceEngine.Types.TraceEvents.TraceEventData): boolean {\n    return this.#expandableEntries.includes(event);\n  }\n}\n"]}