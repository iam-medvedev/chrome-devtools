{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Initiators.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,WAAW,MAAM,6BAA6B,CAAC;AAQ3D;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CACrC,eAA0D,EAC1D,aAA2D,EAC3D,aAA6D,EAC7D,eAA+D;IAEjE,MAAM,KAAK,GAAG;QACZ,GAAG,mCAAmC,CAAC,eAAe,EAAE,aAAa,CAAC;QACtE,GAAG,uCAAuC,CAAC,eAAe,EAAE,aAAa,CAAC;KAC3E,CAAC;IAEF,+EAA+E;IAC/E,gFAAgF;IAChF,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,8BAA8B,CAAC,IAAI,EAAE,eAAe,EAAE,aAAa,EAAE,eAAe,CAAC,CAAC,CAAC;IAC7G,OAAO,KAAK,CAAC;AACf,CAAC;AAED,SAAS,mCAAmC,CACxC,eAA0D,EAC1D,aAA2D;IAE7D,MAAM,KAAK,GAAoB,EAAE,CAAC;IAElC,IAAI,YAAY,GAAsD,aAAa,CAAC;IAEpF,2CAA2C;IAC3C,OAAO,YAAY,EAAE;QACnB,MAAM,gBAAgB,GAAG,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAEvF,IAAI,gBAAgB,EAAE;YACpB,wDAAwD;YACxD,oDAAoD;YACpD,wDAAwD;YACxD,QAAQ;YACR,KAAK,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,gBAAgB,EAAC,CAAC,CAAC;YAC/D,YAAY,GAAG,gBAAgB,CAAC;YAChC,SAAS;SACV;QAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,WAAW,CAAC,qBAAqB,CAAC,YAAY,CAAC,EAAE;YACtE,qDAAqD;YACrD,6CAA6C;YAC7C,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,MAAM,mBAAmB,GAAG,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACnF,IAAI,CAAC,mBAAmB,EAAE;YACxB,wDAAwD;YACxD,uBAAuB;YACvB,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,uCAAuC;QACvC,YAAY,GAAG,mBAAmB,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC;KAC1D;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,SAAS,uCAAuC,CAC5C,eAA0D,EAC1D,aAA2D;IAE7D,MAAM,KAAK,GAAoB,EAAE,CAAC;IAElC,sDAAsD;IACtD,MAAM,wBAAwB,GAAG,eAAe,CAAC,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;IACjG,IAAI,wBAAwB,EAAE;QAC5B,wBAAwB,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACvC,KAAK,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,EAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,SAAS,8BAA8B,CACnC,IAAmB,EAAE,eAA+D,EACpF,aAA6D,EAC7D,eAA0D;IAC5D,IAAI,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACtC,IAAI,UAAU,GAAG,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC;QAC9E,OAAO,UAAU,EAAE,KAAK,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;YACxE,UAAU,GAAG,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC;SAC7C;QACD,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;QAC7C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;KAC3B;IAED,IAAI,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;QAC1C,IAAI,UAAU,GAAG,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC;QAClF,OAAO,UAAU,EAAE,KAAK,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;YACxE,UAAU,GAAG,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC;SAC7C;QACD,IAAI,CAAC,SAAS,GAAG,UAAU,EAAE,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC;QACrD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;KAC/B;IAED,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TraceEngine from '../../models/trace/trace.js';\n\nexport interface InitiatorPair {\n  event: TraceEngine.Types.TraceEvents.TraceEventData;\n  initiator: TraceEngine.Types.TraceEvents.TraceEventData;\n  isEntryHidden?: boolean;\n  isInitiatorHidden?: boolean;\n}\n/**\n * Given an event that the user has selected, this function returns all the\n * pairs of events and their initiators that need to be drawn on the flamechart.\n * The reason that this can return multiple pairs is because we draw the\n * entire chain: for each, we see if it had an initiator, and\n * work backwards to draw each one, as well as the events initiated directly by the entry.\n */\nexport function eventInitiatorPairsToDraw(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    hiddenEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    modifiedEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    ): readonly InitiatorPair[] {\n  const pairs = [\n    ...findEventInitiatorPairsPredecessors(traceEngineData, selectedEvent),\n    ...findEventInitiatorPairsDirectSuccessors(traceEngineData, selectedEvent),\n  ];\n\n  // For each pair, call a function that makes sure that neither entry is hidden.\n  // If they are, it will reassign the event or initiator to the closest ancestor.\n  pairs.forEach(pair => getClosestVisibleAncestorsPair(pair, modifiedEntries, hiddenEntries, traceEngineData));\n  return pairs;\n}\n\nfunction findEventInitiatorPairsPredecessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  const pairs: InitiatorPair[] = [];\n\n  let currentEvent: TraceEngine.Types.TraceEvents.TraceEventData|null = selectedEvent;\n\n  // Build event pairs up to the selected one\n  while (currentEvent) {\n    const currentInitiator = traceEngineData.Initiators.eventToInitiator.get(currentEvent);\n\n    if (currentInitiator) {\n      // Store the current pair, and then set the initiator to\n      // be the current event, so we work back through the\n      // trace and find the initiator of the initiator, and so\n      // on...\n      pairs.push({event: currentEvent, initiator: currentInitiator});\n      currentEvent = currentInitiator;\n      continue;\n    }\n\n    if (!TraceEngine.Types.TraceEvents.isSyntheticTraceEntry(currentEvent)) {\n      // If the current event is not a renderer, we have no\n      // concept of a parent event, so we can bail.\n      currentEvent = null;\n      break;\n    }\n\n    const nodeForCurrentEvent = traceEngineData.Renderer.entryToNode.get(currentEvent);\n    if (!nodeForCurrentEvent) {\n      // Should not happen - if it does something odd is going\n      // on so let's give up.\n      currentEvent = null;\n      break;\n    }\n\n    // Go up to the parent, and loop again.\n    currentEvent = nodeForCurrentEvent.parent?.entry || null;\n  }\n\n  return pairs;\n}\n\nfunction findEventInitiatorPairsDirectSuccessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  const pairs: InitiatorPair[] = [];\n\n  // Add all of the initiated events to the pairs array.\n  const eventsInitiatedByCurrent = traceEngineData.Initiators.initiatorToEvents.get(selectedEvent);\n  if (eventsInitiatedByCurrent) {\n    eventsInitiatedByCurrent.forEach(event => {\n      pairs.push({event: event, initiator: selectedEvent});\n    });\n  }\n\n  return pairs;\n}\n\n/**\n * Given a pair of an initiator and event, this function returns\n * the closest visible ancestors. We need to apply this to each pair because\n * the actual initiator or initiated event might be hidden form the flame chart.\n * If neither entry is hidden, this function returns the initial pair.\n */\nfunction getClosestVisibleAncestorsPair(\n    pair: InitiatorPair, modifiedEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    hiddenEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData): InitiatorPair {\n  if (hiddenEntries.includes(pair.event)) {\n    let nextParent = traceEngineData.Renderer.entryToNode.get(pair.event)?.parent;\n    while (nextParent?.entry && !modifiedEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    pair.event = nextParent?.entry ?? pair.event;\n    pair.isEntryHidden = true;\n  }\n\n  if (hiddenEntries.includes(pair.initiator)) {\n    let nextParent = traceEngineData.Renderer.entryToNode.get(pair.initiator)?.parent;\n    while (nextParent?.entry && !modifiedEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    pair.initiator = nextParent?.entry ?? pair.initiator;\n    pair.isInitiatorHidden = true;\n  }\n\n  return pair;\n}\n"]}