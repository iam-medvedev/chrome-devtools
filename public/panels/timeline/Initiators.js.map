{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Initiators.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,WAAW,MAAM,6BAA6B,CAAC;AAM3D;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CACrC,eAA0D,EAC1D,aAA2D;IAE7D,OAAO;QACL,GAAG,mCAAmC,CAAC,eAAe,EAAE,aAAa,CAAC;QACtE,GAAG,uCAAuC,CAAC,eAAe,EAAE,aAAa,CAAC;KAC3E,CAAC;AACJ,CAAC;AAED,SAAS,mCAAmC,CACxC,eAA0D,EAC1D,aAA2D;IAE7D,MAAM,KAAK,GAAoB,EAAE,CAAC;IAElC,IAAI,YAAY,GAAsD,aAAa,CAAC;IAEpF,2CAA2C;IAC3C,OAAO,YAAY,EAAE;QACnB,MAAM,gBAAgB,GAAG,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAEvF,IAAI,gBAAgB,EAAE;YACpB,wDAAwD;YACxD,oDAAoD;YACpD,wDAAwD;YACxD,QAAQ;YACR,KAAK,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,gBAAgB,EAAC,CAAC,CAAC;YAC/D,YAAY,GAAG,gBAAgB,CAAC;YAChC,SAAS;SACV;QAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,WAAW,CAAC,qBAAqB,CAAC,YAAY,CAAC,EAAE;YACtE,qDAAqD;YACrD,6CAA6C;YAC7C,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,MAAM,mBAAmB,GAAG,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACnF,IAAI,CAAC,mBAAmB,EAAE;YACxB,wDAAwD;YACxD,uBAAuB;YACvB,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,uCAAuC;QACvC,YAAY,GAAG,mBAAmB,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC;KAC1D;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,SAAS,uCAAuC,CAC5C,eAA0D,EAC1D,aAA2D;IAE7D,MAAM,KAAK,GAAoB,EAAE,CAAC;IAElC,sDAAsD;IACtD,MAAM,wBAAwB,GAAG,eAAe,CAAC,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;IACjG,IAAI,wBAAwB,EAAE;QAC5B,wBAAwB,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACvC,KAAK,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,aAAa,EAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TraceEngine from '../../models/trace/trace.js';\n\nexport interface InitiatorPair {\n  event: TraceEngine.Types.TraceEvents.TraceEventData;\n  initiator: TraceEngine.Types.TraceEvents.TraceEventData;\n}\n/**\n * Given an event that the user has selected, this function returns all the\n * pairs of events and their initiators that need to be drawn on the flamechart.\n * The reason that this can return multiple pairs is because we draw the\n * entire chain: for each, we see if it had an initiator, and\n * work backwards to draw each one, as well as the events initiated directly by the entry.\n */\nexport function eventInitiatorPairsToDraw(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  return [\n    ...findEventInitiatorPairsPredecessors(traceEngineData, selectedEvent),\n    ...findEventInitiatorPairsDirectSuccessors(traceEngineData, selectedEvent),\n  ];\n}\n\nfunction findEventInitiatorPairsPredecessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  const pairs: InitiatorPair[] = [];\n\n  let currentEvent: TraceEngine.Types.TraceEvents.TraceEventData|null = selectedEvent;\n\n  // Build event pairs up to the selected one\n  while (currentEvent) {\n    const currentInitiator = traceEngineData.Initiators.eventToInitiator.get(currentEvent);\n\n    if (currentInitiator) {\n      // Store the current pair, and then set the initiator to\n      // be the current event, so we work back through the\n      // trace and find the initiator of the initiator, and so\n      // on...\n      pairs.push({event: currentEvent, initiator: currentInitiator});\n      currentEvent = currentInitiator;\n      continue;\n    }\n\n    if (!TraceEngine.Types.TraceEvents.isSyntheticTraceEntry(currentEvent)) {\n      // If the current event is not a renderer, we have no\n      // concept of a parent event, so we can bail.\n      currentEvent = null;\n      break;\n    }\n\n    const nodeForCurrentEvent = traceEngineData.Renderer.entryToNode.get(currentEvent);\n    if (!nodeForCurrentEvent) {\n      // Should not happen - if it does something odd is going\n      // on so let's give up.\n      currentEvent = null;\n      break;\n    }\n\n    // Go up to the parent, and loop again.\n    currentEvent = nodeForCurrentEvent.parent?.entry || null;\n  }\n\n  return pairs;\n}\n\nfunction findEventInitiatorPairsDirectSuccessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  const pairs: InitiatorPair[] = [];\n\n  // Add all of the initiated events to the pairs array.\n  const eventsInitiatedByCurrent = traceEngineData.Initiators.initiatorToEvents.get(selectedEvent);\n  if (eventsInitiatedByCurrent) {\n    eventsInitiatedByCurrent.forEach(event => {\n      pairs.push({event: event, initiator: selectedEvent});\n    });\n  }\n\n  return pairs;\n}\n"]}