{"version":3,"file":"TimelineSelection.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/TimelineSelection.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,QAAQ,MAAM,iCAAiC,CAAC;AAC5D,OAAO,KAAK,KAAK,MAAM,6BAA6B,CAAC;AAcrD,MAAM,UAAU,kBAAkB,CAAC,KAA+B;IAChE,OAAO;QACL,KAAK;KACN,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,8BAA8B,CAC1C,GAA6B,EAAE,GAA6B;IAC9D,OAAO;QACL,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,CAAC,GAAG,EAAE,GAAG,CAAC;KACnE,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,8BAA8B,CAC1C,GAA6B,EAAE,GAA6B;IAC9D,OAAO;QACL,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,CAAC,GAAG,EAAE,GAAG,CAAC;KACnE,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,SAAiC;IAChE,OAAO,OAAO,CAAC,SAAS,IAAI,OAAO,IAAI,SAAS,CAAC,CAAC;AACpD,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,SAAiC;IAChE,OAAO,OAAO,CAAC,SAAS,IAAI,QAAQ,IAAI,SAAS,CAAC,CAAC;AACrD,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,SAA4B;IAC5D,IAAI,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC;QAChC,OAAO,SAAS,CAAC,MAAM,CAAC;IAC1B,CAAC;IAED,IAAI,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC;QAChC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,wBAAwB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC/E,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;IAC9F,CAAC;IACD,QAAQ,CAAC,WAAW,CAAC,SAAS,EAAE,wBAAwB,CAAC,CAAC;AAC5D,CAAC;AAED,MAAM,UAAU,eAAe,CAAC,EAAqB,EAAE,EAAqB;IAC1E,IAAI,gBAAgB,CAAC,EAAE,CAAC,IAAI,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC;QACjD,OAAO,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,KAAK,CAAC;IAC/B,CAAC;IAED,IAAI,gBAAgB,CAAC,EAAE,CAAC,IAAI,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC;QACjD,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;IACjE,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Trace from '../../models/trace/trace.js';\n\n// We could add a `type` field here to distinguish them, but it is not needed\n// as we use the existence of \"event\" or \"bounds\" to do that.\nexport interface EventSelection {\n  event: Trace.Types.Events.Event;\n}\n\nexport interface TimeRangeSelection {\n  bounds: Trace.Types.Timing.TraceWindowMicro;\n}\n\nexport type TimelineSelection = EventSelection|TimeRangeSelection;\n\nexport function selectionFromEvent(event: Trace.Types.Events.Event): EventSelection {\n  return {\n    event,\n  };\n}\n\nexport function selectionFromRangeMicroSeconds(\n    min: Trace.Types.Timing.Micro, max: Trace.Types.Timing.Micro): TimeRangeSelection {\n  return {\n    bounds: Trace.Helpers.Timing.traceWindowFromMicroSeconds(min, max),\n  };\n}\n\nexport function selectionFromRangeMilliSeconds(\n    min: Trace.Types.Timing.Milli, max: Trace.Types.Timing.Milli): TimeRangeSelection {\n  return {\n    bounds: Trace.Helpers.Timing.traceWindowFromMilliSeconds(min, max),\n  };\n}\n\nexport function selectionIsEvent(selection: TimelineSelection|null): selection is EventSelection {\n  return Boolean(selection && 'event' in selection);\n}\n\nexport function selectionIsRange(selection: TimelineSelection|null): selection is TimeRangeSelection {\n  return Boolean(selection && 'bounds' in selection);\n}\n\nexport function rangeForSelection(selection: TimelineSelection): Trace.Types.Timing.TraceWindowMicro {\n  if (selectionIsRange(selection)) {\n    return selection.bounds;\n  }\n\n  if (selectionIsEvent(selection)) {\n    const timings = Trace.Helpers.Timing.eventTimingsMicroSeconds(selection.event);\n    return Trace.Helpers.Timing.traceWindowFromMicroSeconds(timings.startTime, timings.endTime);\n  }\n  Platform.assertNever(selection, 'Unknown selection type');\n}\n\nexport function selectionsEqual(s1: TimelineSelection, s2: TimelineSelection): boolean {\n  if (selectionIsEvent(s1) && selectionIsEvent(s2)) {\n    return s1.event === s2.event;\n  }\n\n  if (selectionIsRange(s1) && selectionIsRange(s2)) {\n    return Trace.Helpers.Timing.windowsEqual(s1.bounds, s2.bounds);\n  }\n\n  return false;\n}\n"]}