{"version":3,"file":"EntryLabelOverlay.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/timeline/overlays/components/EntryLabelOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport '../../../../ui/components/icon_button/icon_button.js';\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport stylesRaw from './entryLabelOverlay.css.js';\n\nconst {html} = Lit;\n\n// TODO(crbug.com/391381439): Fully migrate off of constructed style sheets.\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(stylesRaw.cssContent);\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  entryLabel: 'Entry label',\n  /**\n   *@description Accessible label used to prompt the user to input text into the field.\n   */\n  inputTextPrompt: 'Enter an annotation label',\n  /**\n   *@description Text displayed on a button that generates an AI label.\n   */\n  generateLabelButton: 'Generate label',\n} as const;\n\n/*\n* Strings that don't need to be translated at this time.\n*/\nconst UIStringsNotTranslate = {\n  /**\n   *@description Security disclaimer text displayed when the information icon on a button that generates an AI label is hovered.\n   */\n  generateLabelSecurityDisclaimer:\n      'The selected call stack is sent to Google. The content you submit and that is generated by this feature will be used to improve Google’s AI models. This is an experimental AI feature and won’t always get it right.',\n\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntryLabelOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst lockedString = i18n.i18n.lockedString;\n\nexport class EmptyEntryLabelRemoveEvent extends Event {\n  static readonly eventName = 'emptyentrylabelremoveevent';\n\n  constructor() {\n    super(EmptyEntryLabelRemoveEvent.eventName);\n  }\n}\n\nexport class EntryLabelChangeEvent extends Event {\n  static readonly eventName = 'entrylabelchangeevent';\n\n  constructor(public newLabel: string) {\n    super(EntryLabelChangeEvent.eventName);\n  }\n}\n\nexport class EntryLabelOverlay extends HTMLElement {\n  // The label is angled on the left from the centre of the entry it belongs to.\n  // `LABEL_AND_CONNECTOR_SHIFT_LENGTH` specifies how many pixels to the left it is shifted.\n  static readonly LABEL_AND_CONNECTOR_SHIFT_LENGTH = 8;\n  // Length of the line that connects the label to the entry.\n  static readonly LABEL_CONNECTOR_HEIGHT = 7;\n  static readonly LABEL_HEIGHT = 17;\n  static readonly LABEL_PADDING = 4;\n  static readonly LABEL_AND_CONNECTOR_HEIGHT =\n      EntryLabelOverlay.LABEL_HEIGHT + EntryLabelOverlay.LABEL_PADDING * 2 + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n  // Set the max label length to avoid labels that could signicantly increase the file size.\n  static readonly MAX_LABEL_LENGTH = 100;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n\n  // Once a label is bound for deletion, we remove it from the DOM via events\n  // that are dispatched. But in the meantime the blur event of the input box\n  // can fire, and that triggers a second removal. So we set this flag after\n  // the first removal to avoid a duplicate event firing which is a no-op but\n  // causes errors when we try to delete an already deleted annotation.\n  #isPendingRemoval = false;\n\n  // The label is set to editable when it is double clicked. If the user clicks away from the label box\n  // element, the label is set to not editable until it double clicked.s\n  #isLabelEditable = true;\n  #entryLabelVisibleHeight: number|null = null;\n\n  #labelPartsWrapper: HTMLElement|null = null;\n  #entryHighlightWrapper: HTMLElement|null = null;\n  #inputField: HTMLElement|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #label: string;\n  #shouldDrawBelowEntry: boolean;\n  /**\n   * The entry label overlay consists of 3 parts - the label part with the label string inside,\n   * the line connecting the label to the entry, and a black box around an entry to highlight the entry with a label.\n   * ________\n   * |_label__|                <-- label part with the label string inside\n   *     \\\n   *      \\                   <-- line connecting the label to the entry with a circle at the end\n   *       \\\n   * _______◯_________\n   * |_____entry______|         <--- box around an entry\n   *\n   * `drawLabel` method below draws the first part.\n   * `drawConnector` method below draws the second part - the connector line with a circle and the svg container for them.\n   * `drawEntryHighlightWrapper` draws the third part.\n   * We only rerender the first part if the label changes and the third part if the size of the entry changes.\n   * The connector and circle shapes never change so we only draw the second part when the component is created.\n   *\n   * Otherwise, the entry label overlay object only gets repositioned.\n   */\n\n  constructor(label: string, shouldDrawBelowEntry = false) {\n    super();\n    this.#render();\n    this.#shouldDrawBelowEntry = shouldDrawBelowEntry;\n    this.#labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    this.#inputField = this.#labelPartsWrapper?.querySelector<HTMLElement>('.input-field') ?? null;\n    this.#connectorLineContainer = this.#labelPartsWrapper?.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#entryHighlightWrapper =\n        this.#labelPartsWrapper?.querySelector<HTMLElement>('.entry-highlight-wrapper') ?? null;\n    this.#label = label;\n    this.#drawLabel(label);\n    // If the label is not empty, it was loaded from the trace file.\n    // In that case, do not auto-focus it as if the user were creating it for the first time\n    if (label !== '') {\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n    }\n    const ariaLabel = label === '' ? i18nString(UIStrings.inputTextPrompt) : label;\n    this.#inputField?.setAttribute('aria-label', ariaLabel);\n\n    this.#drawConnector();\n  }\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  entryHighlightWrapper(): HTMLElement|null {\n    return this.#entryHighlightWrapper;\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event.\n    const labelBoxTextContent = this.#inputField?.textContent?.trim() ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n    }\n    this.#inputField?.setAttribute('aria-label', labelBoxTextContent);\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    if (!this.#inputField) {\n      return false;\n    }\n\n    const allowedKeysAfterReachingLenLimit = [\n      'Backspace',\n      'Delete',\n      'ArrowLeft',\n      'ArrowRight',\n    ];\n\n    // We do not want to create multi-line labels.\n    // Therefore, if the new key is `Enter` key, treat it\n    // as the end of the label input and blur the input field.\n    if (event.key === Platform.KeyboardUtilities.ENTER_KEY || event.key === Platform.KeyboardUtilities.ESCAPE_KEY) {\n      // Note that we do not stop the event propagating here; this is on\n      // purpose because we need it to bubble up into TimelineFlameChartView's\n      // handler. That updates the state and deals with the keydown.\n      this.#inputField.dispatchEvent(new FocusEvent('blur', {bubbles: true}));\n      return false;\n    }\n\n    // If the max limit is not reached, return true\n    if (this.#inputField.textContent !== null &&\n        this.#inputField.textContent.length <= EntryLabelOverlay.MAX_LABEL_LENGTH) {\n      return true;\n    }\n\n    if (allowedKeysAfterReachingLenLimit.includes(event.key)) {\n      return true;\n    }\n\n    if (event.key.length === 1 && event.ctrlKey /* Ctrl + A for selecting all */) {\n      return true;\n    }\n\n    event.preventDefault();\n    return false;\n  }\n\n  #handleLabelInputPaste(event: ClipboardEvent): void {\n    event.preventDefault();\n\n    const clipboardData = event.clipboardData;\n    if (!clipboardData || !this.#inputField) {\n      return;\n    }\n\n    const pastedText = clipboardData.getData('text');\n\n    const newText = this.#inputField.textContent + pastedText;\n    const trimmedText = newText.slice(0, EntryLabelOverlay.MAX_LABEL_LENGTH + 1);\n\n    this.#inputField.textContent = trimmedText;\n\n    // Reset the selection to the end\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(this.#inputField);\n    range.collapse(false);\n    selection?.removeAllRanges();\n    selection?.addRange(range);\n  }\n\n  set entryLabelVisibleHeight(entryLabelVisibleHeight: number) {\n    if (entryLabelVisibleHeight === this.#entryLabelVisibleHeight) {\n      // Even the position is not changed, the theme color might change, so we need to redraw the connector here.\n      this.#drawConnector();\n      return;\n    }\n\n    this.#entryLabelVisibleHeight = entryLabelVisibleHeight;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n    // If the label is editable, focus cursor on it.\n    // This method needs to be called after rendering the wrapper because it is the last label overlay element to render.\n    // By doing this, the cursor focuses when the label is created.\n    if (this.#isLabelEditable) {\n      this.#focusInputBox();\n    }\n    // The label and connector can move depending on the height of the entry\n    this.#drawLabel();\n    this.#drawConnector();\n  }\n\n  #drawConnector(): void {\n    if (!this.#connectorLineContainer) {\n      console.error('`connectorLineContainer` element is missing.');\n      return;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      const translation = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n\n      this.#connectorLineContainer.style.transform = `translateY(${translation}px) rotate(180deg)`;\n    }\n\n    const connector = this.#connectorLineContainer.querySelector('line');\n    const circle = this.#connectorLineContainer.querySelector('circle');\n    if (!connector || !circle) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n    // PART 2: draw the connector from label to the entry\n    // Set the width of the canvas that draws the connector to be equal to the length of the shift multiplied by two.\n    // That way, we can draw the connector from its corner to its middle. Since all elements are aligned in the middle, the connector\n    // will end in the middle of the entry.\n    this.#connectorLineContainer.setAttribute(\n        'width', (EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * 2).toString());\n    this.#connectorLineContainer.setAttribute('height', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    // Start drawing the top right corner.\n    connector.setAttribute('x1', '0');\n    connector.setAttribute('y1', '0');\n    // Finish drawing in middle of the connector container.\n    connector.setAttribute('x2', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    connector.setAttribute('y2', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    const connectorColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    connector.setAttribute('stroke', connectorColor);\n    connector.setAttribute('stroke-width', '2');\n\n    // Draw the circle at the bottom of the connector\n    circle.setAttribute('cx', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    circle.setAttribute('cy', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    circle.setAttribute('r', '3');\n    circle.setAttribute('fill', connectorColor);\n  }\n\n  #drawLabel(initialLabel?: string): void {\n    if (!this.#inputField) {\n      console.error('`labelBox`element is missing.');\n      return;\n    }\n\n    if (typeof initialLabel === 'string') {\n      this.#inputField.innerText = initialLabel;\n    }\n\n    let xTranslation: number|null = null;\n    let yTranslation: number|null = null;\n    // PART 1: draw the label box\n    if (this.#shouldDrawBelowEntry) {\n      // Label is drawn below and slightly to the right.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH;\n    } else {\n      // If the label is drawn above, the connector goes up and to the left, so\n      // we pull the label back slightly to align it nicely.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * -1;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      // Move the label down from above the entry to below it. The label is positioned by default quite far above the entry, hence why we add:\n      // 1. the height of the entry + of the label (inc its padding)\n      // 2. the height of the connector (*2), so we have room to draw it\n      const verticalTransform = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_HEIGHT +\n          EntryLabelOverlay.LABEL_PADDING * 2 + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT * 2;\n\n      yTranslation = verticalTransform;\n    }\n\n    let transformString = '';\n    if (xTranslation) {\n      transformString += `translateX(${xTranslation}px) `;\n    }\n    if (yTranslation) {\n      transformString += `translateY(${yTranslation}px)`;\n    }\n\n    if (transformString.length) {\n      this.#inputField.style.transform = transformString;\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#inputField) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#inputField.focus();\n  }\n\n  setLabelEditabilityAndRemoveEmptyLabel(editable: boolean): void {\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n    // On MacOS when clearing the input box it is left with a new line, so we\n    // trim the string to remove any accidental trailing whitespace.\n    const newLabelText = this.#inputField?.textContent?.trim() ?? '';\n    // If the label is empty when it is being navigated away from, dispatch an event to remove this entry overlay\n    if (!editable && newLabelText.length === 0 && !this.#isPendingRemoval) {\n      this.#isPendingRemoval = true;\n      this.dispatchEvent(new EmptyEntryLabelRemoveEvent());\n    }\n  }\n\n  #renderAiButton(): Lit.TemplateResult {\n    // clang-format off\n    return html`\n      <!-- TODO: On button click generate a label -->\n      <!-- 'preventDefault' on the AI label button to prevent the label removal on blur  -->\n      <span\n        class=\"ai-label-button-wrapper\"\n        @mousedown=${(e: Event) => e.preventDefault()}>\n        <button\n          class=\"ai-label-button\"\n          @click=${(): void => {}}>\n          <devtools-icon\n            class=\"pen-icon\"\n            .name=${'pen-spark'}\n            .data=${{\n            iconName: 'pen-spark', color: 'var(--color-primary)', width: '20px'}}>\n          </devtools-icon>\n          <span class=\"generate-label-text\">${i18nString(UIStrings.generateLabelButton)}</span>\n        </button>\n        <devtools-icon\n          class=\"pen-icon\"\n          title=${lockedString(UIStringsNotTranslate.generateLabelSecurityDisclaimer)}\n          .name=${'info'}\n          .data=${{\n          iconName: 'info', color: 'var(--color-background-inverted)', width: '20px'}}>\n        </devtools-icon>\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #render(): void {\n    // clang-format off\n    Lit.render(\n        html`\n        <span class=\"label-parts-wrapper\" role=\"region\" aria-label=${i18nString(UIStrings.entryLabel)}>\n          <span\n            class=\"label-button-input-wrapper\">\n            <span\n              class=\"input-field\"\n              role=\"textbox\"\n              @dblclick=${() => this.setLabelEditabilityAndRemoveEmptyLabel(true)}\n              @blur=${() => this.setLabelEditabilityAndRemoveEmptyLabel(false)}\n              @keydown=${this.#handleLabelInputKeyDown}\n              @paste=${this.#handleLabelInputPaste}\n              @keyup=${this.#handleLabelInputKeyUp}\n              contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n              jslog=${VisualLogging.textField('timeline.annotations.entry-label-input').track({keydown: true, click: true})}\n            ></span>\n            <!-- ${this.#renderAiButton()} -->\n          </span>\n          <svg class=\"connectorContainer\">\n            <line/>\n            <circle/>\n          </svg>\n          <div class=\"entry-highlight-wrapper\"></div>\n        </span>`,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\ncustomElements.define('devtools-entry-label-overlay', EntryLabelOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entry-label-overlay': EntryLabelOverlay;\n  }\n}\n"]}