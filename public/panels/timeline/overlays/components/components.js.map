{
  "version": 3,
  "sources": ["../../../../../../../../front_end/panels/timeline/overlays/components/EntriesLinkOverlay.ts", "entriesLinkOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/EntryLabelOverlay.ts", "entryLabelOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/TimeRangeOverlay.ts", "timeRangeOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts", "timespanBreakdownOverlay.css.js"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport '../../../../ui/components/icon_button/icon_button.js';\n\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport {html, render} from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport entriesLinkOverlayStyles from './entriesLinkOverlay.css.js';\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an arrow representing a link between two entries.\n   */\n  diagram: 'Links between entries',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntriesLinkOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class EntryLinkStartCreating extends Event {\n  static readonly eventName = 'entrylinkstartcreating';\n\n  constructor() {\n    super(EntryLinkStartCreating.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class EntriesLinkOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #coordinateFrom: {x: number, y: number};\n  #fromEntryDimensions: {width: number, height: number};\n  #coordinateTo: {x: number, y: number};\n  #toEntryDimensions: {width: number, height: number}|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #connector: SVGLineElement|null = null;\n  #entryFromWrapper: HTMLElement|null = null;\n  #entryToWrapper: HTMLElement|null = null;\n  #entryFromCirleConnector: SVGCircleElement|null = null;\n  #entryToCircleConnector: SVGCircleElement|null = null;\n  #entryFromVisible = true;\n  #entryToVisible = true;\n  #canvasRect: DOMRect|null = null;\n\n  // These flags let us know if the entry we are drawing from/to are the\n  // originals, or if they are the parent, which can happen if an entry is\n  // collapsed. We care about this because if the entry is not the source, we\n  // draw the border as dashed, not solid.\n  #fromEntryIsSource = true;\n  #toEntryIsSource = true;\n  #arrowHidden = false;\n  #linkState: Trace.Types.File.EntriesLinkState;\n\n  constructor(\n      initialFromEntryCoordinateAndDimensions: {x: number, y: number, width: number, height: number},\n      linkCreationNotStartedState: Trace.Types.File.EntriesLinkState) {\n    super();\n    this.#render();\n    this.#coordinateFrom = {x: initialFromEntryCoordinateAndDimensions.x, y: initialFromEntryCoordinateAndDimensions.y};\n    this.#fromEntryDimensions = {\n      width: initialFromEntryCoordinateAndDimensions.width,\n      height: initialFromEntryCoordinateAndDimensions.height,\n    };\n    this.#coordinateTo = {x: initialFromEntryCoordinateAndDimensions.x, y: initialFromEntryCoordinateAndDimensions.y};\n    this.#connectorLineContainer = this.#shadow.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#connector = this.#connectorLineContainer?.querySelector('line') ?? null;\n    this.#entryFromWrapper = this.#shadow.querySelector('.from-highlight-wrapper') ?? null;\n    this.#entryToWrapper = this.#shadow.querySelector('.to-highlight-wrapper') ?? null;\n    this.#entryFromCirleConnector = this.#connectorLineContainer?.querySelector('.entryFromConnector') ?? null;\n    this.#entryToCircleConnector = this.#connectorLineContainer?.querySelector('.entryToConnector') ?? null;\n    this.#linkState = linkCreationNotStartedState;\n    this.#render();\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  entryFromWrapper(): HTMLElement|null {\n    return this.#entryFromWrapper;\n  }\n\n  entryToWrapper(): HTMLElement|null {\n    return this.#entryToWrapper;\n  }\n\n  /**\n   * If one entry that is linked is in a collapsed track, we show the outlines\n   * but hide only the arrow.\n   */\n  set hideArrow(shouldHide: boolean) {\n    this.#arrowHidden = shouldHide;\n    if (this.#connector) {\n      this.#connector.style.display = shouldHide ? 'none' : 'block';\n    }\n  }\n\n  set fromEntryCoordinateAndDimensions(fromEntryParams: {x: number, y: number, length: number, height: number}) {\n    this.#coordinateFrom = {x: fromEntryParams.x, y: fromEntryParams.y};\n    this.#fromEntryDimensions = {width: fromEntryParams.length, height: fromEntryParams.height};\n    this.#updateCreateLinkBox();\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  set entriesVisibility(entriesVisibility: {fromEntryVisibility: boolean, toEntryVisibility: boolean}) {\n    this.#entryFromVisible = entriesVisibility.fromEntryVisibility;\n    this.#entryToVisible = entriesVisibility.toEntryVisibility;\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  // The arrow might be pointing either to an entry or an empty space.\n  // If the dimensions are not passed, it is pointing at an empty space.\n  set toEntryCoordinateAndDimensions(toEntryParams: {x: number, y: number, length?: number, height?: number}) {\n    this.#coordinateTo = {x: toEntryParams.x, y: toEntryParams.y};\n    if (toEntryParams.length && toEntryParams.height) {\n      this.#toEntryDimensions = {width: toEntryParams.length, height: toEntryParams.height};\n    } else {\n      this.#toEntryDimensions = null;\n    }\n\n    this.#updateCreateLinkBox();\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  set fromEntryIsSource(x: boolean) {\n    if (x === this.#fromEntryIsSource) {\n      return;\n    }\n    this.#fromEntryIsSource = x;\n    this.#render();\n  }\n\n  set toEntryIsSource(x: boolean) {\n    if (x === this.#toEntryIsSource) {\n      return;\n    }\n    this.#toEntryIsSource = x;\n    this.#render();\n  }\n\n  /*\n    Redraw all parts of the EntriesLink overlay\n     _________\n    |__entry__|o\\      <-- 'from 'entry wrapper and the circle connector next to it\n                 \\\n                  \\    <-- Arrow Connector\n                   \\   ________________\n                    âž˜ o|_____entry______|  <-- 'to' entry wrapper and the circle connector next to it\n  */\n  #redrawAllEntriesLinkParts(): void {\n    if (!this.#connector || !this.#entryFromWrapper || !this.#entryToWrapper || !this.#entryFromCirleConnector ||\n        !this.#entryToCircleConnector) {\n      console.error('one of the required Entries Link elements is missing.');\n      return;\n    }\n\n    if (this.#linkState === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      this.#entryFromCirleConnector.setAttribute('visibility', 'hidden');\n      this.#entryToCircleConnector.setAttribute('visibility', 'hidden');\n      this.#connector.style.display = 'none';\n      return;\n    }\n\n    this.#setEntriesWrappersVisibility();\n    this.#setConnectorCirclesVisibility();\n    this.#setArrowConnectorStyle();\n    this.#positionConnectorLineAndCircles();\n\n    this.#render();\n  }\n\n  // Only draw the entry wrapper if that entry is visible\n  #setEntriesWrappersVisibility(): void {\n    if (!this.#entryFromWrapper || !this.#entryToWrapper) {\n      return;\n    }\n    this.#entryFromWrapper.style.visibility = this.#entryFromVisible ? 'visible' : 'hidden';\n    this.#entryToWrapper.style.visibility = this.#entryToVisible ? 'visible' : 'hidden';\n  }\n\n  // Draw the entry connector circles:\n  //  - The entry the arrow is connecting to is the connection source\n  //  - That entry currently is visible\n  //  - There is enough space for the connector circle\n  #setConnectorCirclesVisibility(): void {\n    if (!this.#toEntryDimensions || !this.#entryFromCirleConnector || !this.#entryToCircleConnector) {\n      return;\n    }\n    // If the user is zoomed out, the connector circles can be as large as the\n    // event itself. So if the rectangle for this entry is too small, we\n    // don't draw the circles.\n    const minWidthToDrawConnectorCircles = 8;\n    const drawFromEntryConnectorCircle = this.#entryFromVisible && !this.#arrowHidden && this.#fromEntryIsSource &&\n        this.#fromEntryDimensions.width >= minWidthToDrawConnectorCircles;\n    const drawToEntryConnectorCircle = !this.#arrowHidden && this.#entryToVisible && this.#toEntryIsSource &&\n        this.#toEntryDimensions?.width >= minWidthToDrawConnectorCircles && !this.#arrowHidden;\n\n    this.#entryFromCirleConnector.setAttribute('visibility', drawFromEntryConnectorCircle ? 'visible' : 'hidden');\n    this.#entryToCircleConnector.setAttribute('visibility', drawToEntryConnectorCircle ? 'visible' : 'hidden');\n  }\n\n  #setArrowConnectorStyle(): void {\n    if (!this.#connector) {\n      return;\n    }\n\n    // If neither entry is visible, do not display the connector\n    this.#connector.style.display = (this.#entryFromVisible || this.#entryToVisible) ? 'block' : 'none';\n    this.#connector.setAttribute('stroke-width', '2');\n\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n\n    // Use a solid stroke if the 'to' entry's dimensions are unknown (during link creation) or if both entries are visible.\n    if (!this.#toEntryDimensions || (this.#entryFromVisible && this.#entryToVisible)) {\n      this.#connector.setAttribute('stroke', arrowColor);\n      return;\n    }\n\n    // If one entry is not visible and one is, fade the arrow.\n    if (this.#entryFromVisible && !this.#entryToVisible) {\n      this.#connector.setAttribute('stroke', 'url(#fromVisibleLineGradient)');\n    } else if (this.#entryToVisible && !this.#entryFromVisible) {\n      this.#connector.setAttribute('stroke', 'url(#toVisibleLineGradient)');\n    }\n  }\n\n  #positionConnectorLineAndCircles(): void {\n    if (!this.#connector || !this.#entryFromCirleConnector || !this.#entryToCircleConnector) {\n      return;\n    }\n\n    // If the entry is visible, the entry arrow starts from the middle of the right edge of the entry (end on the X axis and middle of the Y axis).\n    // If not, draw it to the y coordinate of the entry and the edge of the timeline so it is pointing in the direction of the entry.\n    const halfFromEntryHeight = this.#fromEntryDimensions.height / 2;\n    const fromX = this.#coordinateFrom.x + this.#fromEntryDimensions.width;\n    const fromY = this.#coordinateFrom.y + halfFromEntryHeight;\n\n    this.#connector.setAttribute('x1', fromX.toString());\n    this.#connector.setAttribute('y1', fromY.toString());\n\n    this.#entryFromCirleConnector.setAttribute('cx', fromX.toString());\n    this.#entryFromCirleConnector.setAttribute('cy', fromY.toString());\n\n    // If the arrow is pointing to the entry and that entry is visible, point it to the middle of the entry.\n    // If the entry is not visible, point the arrow to the edge of the screen towards the entry.\n    // Otherwise, the arrow is following the mouse so we assign it to the provided coordinates.\n    const toX = this.#coordinateTo.x;\n    const toY = this.#toEntryDimensions ? this.#coordinateTo.y + (this.#toEntryDimensions?.height ?? 0) / 2 :\n                                          this.#coordinateTo.y;\n\n    this.#connector.setAttribute('x2', toX.toString());\n    this.#connector.setAttribute('y2', toY.toString());\n\n    this.#entryToCircleConnector.setAttribute('cx', toX.toString());\n    this.#entryToCircleConnector.setAttribute('cy', toY.toString());\n  }\n\n  /*\n   * Calculates the gradient stop percentage when only one entry is visible.\n   * This percentage represents the portion of the line visible within the canvas,\n   * used to create a fade effect towards the off-screen entry.\n   * When one entry is off-screen, it is impossible to tell where exactly the line\n   * is going to. Therefore, to not needlessly take space, the faded line is very short.\n   *\n   * To achieve this, we need to calculate what percentage of the\n   * shole connection the short line is currently occupying and apply\n   * that gradient to the visible connection part.\n   */\n  #partlyVisibleConnectionLinePercentage(): number {\n    if (!this.#canvasRect) {\n      return 100;\n    }\n    const fadedLineLength = 25;\n\n    const lineLength = this.#coordinateTo.x - (this.#coordinateFrom.x + this.#fromEntryDimensions.width);\n    const visibleLineFromTotalPercentage = (fadedLineLength * 100) / lineLength;\n\n    return (visibleLineFromTotalPercentage < 100) ? visibleLineFromTotalPercentage : 100;\n  }\n\n  #updateCreateLinkBox(): void {\n    const createLinkBox = this.#shadow.querySelector<HTMLElement>('.create-link-box');\n    const createLinkIcon = createLinkBox?.querySelector<HTMLElement>('.create-link-icon') ?? null;\n\n    if (!createLinkBox || !createLinkIcon) {\n      console.error('creating element is missing.');\n      return;\n    }\n\n    if (this.#linkState !== Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      createLinkIcon.style.display = 'none';\n      return;\n    }\n\n    createLinkIcon.style.left = `${this.#coordinateFrom.x + this.#fromEntryDimensions.width}px`;\n    createLinkIcon.style.top = `${this.#coordinateFrom.y}px`;\n  }\n\n  #startCreatingConnection(): void {\n    this.#linkState = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n    this.dispatchEvent(new EntryLinkStartCreating());\n  }\n\n  /*\n  The entries link overlay is an arrow connecting 2 entries.\n  The Entries are drawn by Flamechart and this Overlay is only drawing the arrow between them.\n   _________\n  |__entry__|\\\n              \\\n               \\          <-- arrow connecting the sides of entries drawn by this overlay\n                \\   ________________\n                 âž˜ |_____entry______|\n  */\n  #render(): void {\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    // clang-format off\n    render(\n        html`\n          <style>${entriesLinkOverlayStyles}</style>\n          <svg class=\"connectorContainer\" width=\"100%\" height=\"100%\" role=\"region\" aria-label=${i18nString(UIStrings.diagram)}>\n            <defs>\n              <linearGradient\n                id=\"fromVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"0%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n                <stop\n                  offset=\"${this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n              </linearGradient>\n\n              <linearGradient\n                id=\"toVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"${100 - this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n                <stop\n                  offset=\"100%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n              </linearGradient>\n              <marker\n                id=\"arrow\"\n                orient=\"auto\"\n                markerWidth=\"3\"\n                markerHeight=\"4\"\n                fill-opacity=\"1\"\n                refX=\"4\"\n                refY=\"2\"\n                visibility=${this.#entryToVisible || !this.#toEntryDimensions ? 'visible' : 'hidden'}>\n                <path d=\"M0,0 V4 L4,2 Z\" fill=${arrowColor} />\n              </marker>\n            </defs>\n            <line\n              marker-end=\"url(#arrow)\"\n              stroke-dasharray=${!this.#fromEntryIsSource || !this.#toEntryIsSource ? DASHED_STROKE_AMOUNT : 'none'}\n              visibility=${!this.#entryFromVisible && !this.#entryToVisible ? 'hidden' : 'visible'}\n              />\n            <circle class=\"entryFromConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n            <circle class=\"entryToConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n          </svg>\n          <div class=\"entry-wrapper from-highlight-wrapper ${this.#fromEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"entry-wrapper to-highlight-wrapper ${this.#toEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"create-link-box ${this.#linkState ? 'visible' : 'hidden'}\">\n            <devtools-icon\n              class='create-link-icon'\n              jslog=${VisualLogging.action('timeline.annotations.create-entry-link').track({click: true})}\n              @click=${this.#startCreatingConnection}\n              name='arrow-right-circle'>\n            </devtools-icon>\n          </div>\n        `,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\nconst CONNECTOR_CIRCLE_RADIUS = 2;\nconst CONNECTOR_CIRCLE_STROKE_WIDTH = 1;\n\n// Defines the gap in the border when we are drawing a dashed outline.\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray\nconst DASHED_STROKE_AMOUNT = 4;\n\ncustomElements.define('devtools-entries-link-overlay', EntriesLinkOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entries-link-overlay': EntriesLinkOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.connectorContainer {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n\n.entry-wrapper {\n  pointer-events: none;\n  position: absolute;\n  display: block;\n  border: 2px solid var(--color-text-primary);\n  box-sizing: border-box;\n\n  &.cut-off-top {\n    border-top: none;\n  }\n\n  &.cut-off-bottom {\n    border-bottom: none;\n  }\n\n  &.cut-off-right {\n    border-right: none;\n  }\n\n  &.cut-off-left {\n    border-left: none;\n  }\n}\n\n.entry-is-not-source {\n  border: 2px dashed var(--color-text-primary);\n}\n\n.create-link-icon {\n  pointer-events: auto;\n  cursor: pointer;\n  color: var(--sys-color-on-surface);\n  width: 16px;\n  height: 16px;\n  position: absolute;\n}\n\n/*# sourceURL=${import.meta.resolve('./entriesLinkOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport '../../../../ui/components/icon_button/icon_button.js';\nimport '../../../../ui/components/tooltips/tooltips.js';\nimport '../../../../ui/components/spinners/spinners.js';\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Host from '../../../../core/host/host.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Root from '../../../../core/root/root.js';\nimport * as AiAssistanceModels from '../../../../models/ai_assistance/ai_assistance.js';\nimport * as Buttons from '../../../../ui/components/buttons/buttons.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as UI from '../../../../ui/legacy/legacy.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\nimport * as PanelCommon from '../../../common/common.js';\nimport type * as Utils from '../../utils/utils.js';\n\nimport entryLabelOverlayStyles from './entryLabelOverlay.css.js';\n\nconst {html, Directives} = Lit;\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  entryLabel: 'Entry label',\n  /**\n   * @description Accessible label used to prompt the user to input text into the field.\n   */\n  inputTextPrompt: 'Enter an annotation label',\n  /**\n   * @description Text displayed on a button that generates an AI label.\n   */\n  generateLabelButton: 'Generate label',\n  /**\n   * @description Label used for screenreaders on the FRE dialog\n   */\n  freDialog: 'Get AI-powered annotation suggestions dialog',\n  /**\n   * @description Screen-reader text for a tooltip link for navigating to \"AI innovations\" settings where the user can learn more about auto-annotations.\n   */\n  learnMoreAriaLabel: 'Learn more about auto annotations in settings',\n  /**\n   * @description Screen-reader text for a tooltip icon.\n   */\n  moreInfoAriaLabel: 'More information about this feature',\n} as const;\n\n/*\n* Strings that don't need to be translated at this time.\n*/\nconst UIStringsNotTranslate = {\n  /**\n   * @description Tooltip link for the navigating to \"AI innovations\" page in settings.\n   */\n  learnMore: 'Learn more in settings',\n  /**\n   * @description Security disclaimer text displayed when the information icon on a button that generates an AI label is hovered.\n   */\n  generateLabelSecurityDisclaimer:\n      'The selected call stack is sent to Google. The content you submit and that is generated by this feature will be used to improve Googleâ€™s AI models. This is an experimental AI feature and wonâ€™t always get it right.',\n  /**\n   * @description Enterprise users with logging off - Security disclaimer text displayed when the information icon on a button that generates an AI label is hovered.\n   */\n  generateLabelSecurityDisclaimerLogginOff:\n      'The selected call stack is sent to Google. The content you submit and that is generated by this feature will not be used to improve Googleâ€™s AI models. This is an experimental AI feature and wonâ€™t always get it right.',\n  /**\n   * @description The `Generate AI label button` tooltip disclaimer for when the feature is not available and the reason can be checked in settings.\n   */\n  autoAnnotationNotAvailableDisclaimer: 'Auto annotations are not available.',\n  /**\n   * @description The `Generate AI label button` tooltip disclaimer for when the feature is not available because the user is offline.\n   */\n  autoAnnotationNotAvailableOfflineDisclaimer: 'Auto annotations are not available because you are offline.',\n  /**\n   * @description Header text for the AI-powered annotations suggestions disclaimer dialog.\n   */\n  freDisclaimerHeader: 'Get AI-powered annotation suggestions',\n  /**\n   * @description Text shown when the AI-powered annotation is being generated.\n   */\n  generatingLabel: 'Generating label',\n  /**\n   * @description Text shown when the generation of the AI-powered annotation failed.\n   */\n  generationFailed: 'Generation failed',\n  /**\n   * @description First disclaimer item text for the fre dialog - AI won't always get it right.\n   */\n  freDisclaimerAiWontAlwaysGetItRight: 'This feature uses AI and wonâ€™t always get it right',\n  /**\n   * @description Second disclaimer item text for the fre dialog - trace data is sent to Google.\n   */\n  freDisclaimerPrivacyDataSentToGoogle:\n      'To generate annotation suggestions, your performance trace is sent to Google. This data may be seen by human reviewers to improve this feature.',\n  /**\n   * @description Second disclaimer item text for the fre dialog - trace data is sent to Google.\n   */\n  freDisclaimerPrivacyDataSentToGoogleNoLogging:\n      'To generate annotation suggestions, your performance trace is sent to Google. This data will not be used to improve Googleâ€™s AI models. Your organization may change these settings at any time.',\n  /**\n   * @description Text for the 'learn more' button displayed in fre.\n   */\n  learnMoreButton: 'Learn more',\n} as const;\n\nconst enum AIButtonState {\n  ENABLED = 'enabled',\n  DISABLED = 'disabled',\n  HIDDEN = 'hidden',\n  GENERATION_FAILED = 'generation_failed',\n  GENERATING_LABEL = 'generating_label',\n}\n\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntryLabelOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst lockedString = i18n.i18n.lockedString;\n\nfunction isAiAssistanceServerSideLoggingEnabled(): boolean {\n  return !Root.Runtime.hostConfig.aidaAvailability?.disallowLogging;\n}\n\nexport class EntryLabelRemoveEvent extends Event {\n  static readonly eventName = 'entrylabelremoveevent';\n\n  constructor() {\n    super(EntryLabelRemoveEvent.eventName);\n  }\n}\n\nexport class EntryLabelChangeEvent extends Event {\n  static readonly eventName = 'entrylabelchangeevent';\n\n  constructor(public newLabel: string) {\n    super(EntryLabelChangeEvent.eventName);\n  }\n}\n\nexport class LabelAnnotationsConsentDialogVisibilityChange extends Event {\n  static readonly eventName = 'labelannotationsconsentdialogvisiblitychange';\n  constructor(public isVisible: boolean) {\n    super(LabelAnnotationsConsentDialogVisibilityChange.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class EntryLabelOverlay extends HTMLElement {\n  // The label is angled on the left from the centre of the entry it belongs to.\n  // `LABEL_AND_CONNECTOR_SHIFT_LENGTH` specifies how many pixels to the left it is shifted.\n  static readonly LABEL_AND_CONNECTOR_SHIFT_LENGTH = 8;\n  // Length of the line that connects the label to the entry.\n  static readonly LABEL_CONNECTOR_HEIGHT = 7;\n  // Set the max label length to avoid labels that could signicantly increase the file size.\n  static readonly MAX_LABEL_LENGTH = 100;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  // Once a label is bound for deletion, we remove it from the DOM via events\n  // that are dispatched. But in the meantime the blur event of the input box\n  // can fire, and that triggers a second removal. So we set this flag after\n  // the first removal to avoid a duplicate event firing which is a no-op but\n  // causes errors when we try to delete an already deleted annotation.\n  #isPendingRemoval = false;\n\n  // The label is set to editable when it is double clicked. If the user clicks away from the label box\n  // element, the label is set to not editable until it double clicked.s\n  #isLabelEditable = true;\n  #entryLabelVisibleHeight: number|null = null;\n\n  #labelPartsWrapper: HTMLElement|null = null;\n  #entryHighlightWrapper: HTMLElement|null = null;\n  #inputField: HTMLElement|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #label: string;\n  #shouldDrawBelowEntry: boolean;\n  #richTooltip: Lit.Directives.Ref<HTMLElement> = Directives.createRef();\n  #noLogging: boolean;\n  /**\n   * Required to generate a label with AI.\n   */\n  #callTree: Utils.AICallTree.AICallTree|null = null;\n  // Creates or gets the setting if it exists.\n  #aiAnnotationsEnabledSetting = Common.Settings.Settings.instance().createSetting('ai-annotations-enabled', false);\n  #agent = new AiAssistanceModels.PerformanceAnnotationsAgent({\n    aidaClient: new Host.AidaClient.AidaClient(),\n    serverSideLoggingEnabled: isAiAssistanceServerSideLoggingEnabled(),\n  });\n  /**\n   * We track this because when the user is in this flow we don't want the\n   * empty annotation label to be removed on blur, as we take them to the flow &\n   * want to keep the label there for when they come back from the flow having\n   * consented, hopefully!\n   */\n  #inAIConsentDialogFlow = false;\n  #currAIButtonState: AIButtonState = AIButtonState.HIDDEN;\n\n  /**\n   * The entry label overlay consists of 3 parts - the label part with the label string inside,\n   * the line connecting the label to the entry, and a black box around an entry to highlight the entry with a label.\n   * ________\n   * |_label__|                <-- label part with the label string inside\n   *     \\\n   *      \\                   <-- line connecting the label to the entry with a circle at the end\n   *       \\\n   * _______â—¯_________\n   * |_____entry______|         <--- box around an entry\n   *\n   * `drawLabel` method below draws the first part.\n   * `drawConnector` method below draws the second part - the connector line with a circle and the svg container for them.\n   * `drawEntryHighlightWrapper` draws the third part.\n   * We only rerender the first part if the label changes and the third part if the size of the entry changes.\n   * The connector and circle shapes never change so we only draw the second part when the component is created.\n   *\n   * Otherwise, the entry label overlay object only gets repositioned.\n   */\n\n  constructor(label: string, shouldDrawBelowEntry = false) {\n    super();\n    this.#render();\n    this.#shouldDrawBelowEntry = shouldDrawBelowEntry;\n    this.#labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    this.#inputField = this.#labelPartsWrapper?.querySelector<HTMLElement>('.input-field') ?? null;\n    this.#connectorLineContainer = this.#labelPartsWrapper?.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#entryHighlightWrapper =\n        this.#labelPartsWrapper?.querySelector<HTMLElement>('.entry-highlight-wrapper') ?? null;\n    this.#label = label;\n    this.#noLogging = Root.Runtime.hostConfig.aidaAvailability?.enterprisePolicyValue ===\n        Root.Runtime.GenAiEnterprisePolicyValue.ALLOW_WITHOUT_LOGGING;\n    this.#drawLabel(label);\n    // If the label is not empty, it was loaded from the trace file.\n    // In that case, do not auto-focus it as if the user were creating it for the first time\n    if (label !== '') {\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n    }\n    const ariaLabel = label === '' ? i18nString(UIStrings.inputTextPrompt) : label;\n    this.#inputField?.setAttribute('aria-label', ariaLabel);\n\n    this.#drawConnector();\n  }\n\n  /**\n   * So we can provide a mocked agent in tests. Do not call this method outside of a test!\n   */\n  overrideAIAgentForTest(agent: AiAssistanceModels.PerformanceAnnotationsAgent): void {\n    this.#agent = agent;\n  }\n\n  entryHighlightWrapper(): HTMLElement|null {\n    return this.#entryHighlightWrapper;\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event.\n    const labelBoxTextContent = this.#inputField?.textContent?.trim() ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n      // Dispatch a fake change event; because we use contenteditable rather than an input, this event does not fire.\n      // But we want to listen to the change event in the VE logs, so we dispatch it here.\n      this.#inputField?.dispatchEvent(new Event('change', {bubbles: true, composed: true}));\n    }\n    this.#setAIButtonRenderState();\n    // Rerender the label component when the label text changes because we need to\n    // make sure the 'auto annotation' button is only shown when the label is empty.\n    this.#render();\n    this.#inputField?.setAttribute('aria-label', labelBoxTextContent);\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    if (!this.#inputField) {\n      return false;\n    }\n\n    const allowedKeysAfterReachingLenLimit = [\n      'Backspace',\n      'Delete',\n      'ArrowLeft',\n      'ArrowRight',\n    ];\n\n    // We do not want to create multi-line labels.\n    // Therefore, if the new key is `Enter` key, treat it\n    // as the end of the label input and blur the input field.\n    if ((event.key === Platform.KeyboardUtilities.ENTER_KEY || event.key === Platform.KeyboardUtilities.ESCAPE_KEY) &&\n        this.#isLabelEditable) {\n      // Note that we do not stop the event propagating here; this is on\n      // purpose because we need it to bubble up into TimelineFlameChartView's\n      // handler. That updates the state and deals with the keydown.\n      // In theory blur() should call the blur event listener, which in turn\n      // calls the setLabelEditabilityAndRemoveEmptyLabel method. However, we\n      // have seen this not work as part of the AI FRE flow where the privacy\n      // consent dialog is shown, which takes focus away from the input and\n      // causes the blur() to be a no-op. It's not entirely clear why this\n      // happens as visually it renders as focused, but as a back-up we call\n      // the setLabelEditabilityAndRemoveEmptyLabel method manually. It won't\n      // do anything if the editable state matches what is passed in, so it's\n      // safe to call this just in case the blur() didn't actually trigger.\n      this.#inputField.blur();\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n      return false;\n    }\n\n    // If the max limit is not reached, return true\n    if (this.#inputField.textContent !== null &&\n        this.#inputField.textContent.length <= EntryLabelOverlay.MAX_LABEL_LENGTH) {\n      return true;\n    }\n\n    if (allowedKeysAfterReachingLenLimit.includes(event.key)) {\n      return true;\n    }\n\n    if (event.key.length === 1 && event.ctrlKey /* Ctrl + A for selecting all */) {\n      return true;\n    }\n\n    event.preventDefault();\n    return false;\n  }\n\n  #handleLabelInputPaste(event: ClipboardEvent): void {\n    event.preventDefault();\n\n    const clipboardData = event.clipboardData;\n    if (!clipboardData || !this.#inputField) {\n      return;\n    }\n\n    // Remove newline characters to ensure single-line paste.\n    const pastedText = clipboardData.getData('text').replace(/(\\r\\n|\\n|\\r)/gm, '');\n    const newText = this.#inputField.textContent + pastedText;\n    const trimmedText = newText.slice(0, EntryLabelOverlay.MAX_LABEL_LENGTH + 1);\n    this.#inputField.textContent = trimmedText;\n    this.#placeCursorAtInputEnd();\n  }\n\n  set entryLabelVisibleHeight(entryLabelVisibleHeight: number) {\n    this.#entryLabelVisibleHeight = entryLabelVisibleHeight;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n    // If the label is editable, focus cursor on it.\n    // This method needs to be called after rendering the wrapper because it is the last label overlay element to render.\n    // By doing this, the cursor focuses when the label is created.\n    if (this.#isLabelEditable) {\n      this.#focusInputBox();\n    }\n    // The label and connector can move depending on the height of the entry\n    this.#drawLabel();\n    this.#drawConnector();\n  }\n\n  #drawConnector(): void {\n    if (!this.#connectorLineContainer) {\n      console.error('`connectorLineContainer` element is missing.');\n      return;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      const translation = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n\n      this.#connectorLineContainer.style.transform = `translateY(${translation}px) rotate(180deg)`;\n    }\n\n    const connector = this.#connectorLineContainer.querySelector('line');\n    const circle = this.#connectorLineContainer.querySelector('circle');\n    if (!connector || !circle) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n    // PART 2: draw the connector from label to the entry\n    // Set the width of the canvas that draws the connector to be equal to the length of the shift multiplied by two.\n    // That way, we can draw the connector from its corner to its middle. Since all elements are aligned in the middle, the connector\n    // will end in the middle of the entry.\n    this.#connectorLineContainer.setAttribute(\n        'width', (EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * 2).toString());\n    this.#connectorLineContainer.setAttribute('height', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    // Start drawing the top right corner.\n    connector.setAttribute('x1', '0');\n    connector.setAttribute('y1', '0');\n    // Finish drawing in middle of the connector container.\n    connector.setAttribute('x2', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    connector.setAttribute('y2', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    const connectorColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    connector.setAttribute('stroke', connectorColor);\n    connector.setAttribute('stroke-width', '2');\n\n    // Draw the circle at the bottom of the connector\n    circle.setAttribute('cx', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    // Add one to the offset of the circle which positions it perfectly centered on the border of the overlay.\n    circle.setAttribute('cy', (EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT + 1).toString());\n    circle.setAttribute('r', '3');\n    circle.setAttribute('fill', connectorColor);\n  }\n\n  #drawLabel(initialLabel?: string): void {\n    if (!this.#inputField) {\n      console.error('`labelBox`element is missing.');\n      return;\n    }\n\n    if (typeof initialLabel === 'string') {\n      this.#inputField.innerText = initialLabel;\n    }\n\n    let xTranslation: number|null = null;\n    let yTranslation: number|null = null;\n    // PART 1: draw the label box\n    if (this.#shouldDrawBelowEntry) {\n      // Label is drawn below and slightly to the right.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH;\n    } else {\n      // If the label is drawn above, the connector goes up and to the left, so\n      // we pull the label back slightly to align it nicely.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * -1;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      // Move the label down from above the entry to below it. The label is positioned by default quite far above the entry, hence why we add:\n      // 1. the height of the entry + of the label (inc its padding)\n      // 2. the height of the connector (*2), so we have room to draw it\n      const verticalTransform = this.#entryLabelVisibleHeight + (EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT * 2) +\n          this.#inputField?.offsetHeight;\n\n      yTranslation = verticalTransform;\n    }\n\n    let transformString = '';\n    if (xTranslation) {\n      transformString += `translateX(${xTranslation}px) `;\n    }\n    if (yTranslation) {\n      transformString += `translateY(${yTranslation}px)`;\n    }\n\n    if (transformString.length) {\n      this.#inputField.style.transform = transformString;\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#inputField) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#inputField.focus();\n  }\n\n  setLabelEditabilityAndRemoveEmptyLabel(editable: boolean): void {\n    // We skip this if we have taken the user to the AI FRE flow, because we want the label still there when they come back.\n    if (this.#inAIConsentDialogFlow && editable === false) {\n      return;\n    }\n\n    // Set an attribute on the host; this is used in the overlays CSS to bring\n    // the focused, editable label to the top above any others.\n    if (editable) {\n      this.setAttribute('data-user-editing-label', 'true');\n    } else {\n      this.removeAttribute('data-user-editing-label');\n    }\n\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it & put the cursor at the end\n    if (editable && this.#inputField) {\n      this.#placeCursorAtInputEnd();\n      this.#focusInputBox();\n    }\n    // On MacOS when clearing the input box it is left with a new line, so we\n    // trim the string to remove any accidental trailing whitespace.\n    const newLabelText = this.#inputField?.textContent?.trim() ?? '';\n    // If the label is empty when it is being navigated away from, dispatch an event to remove this entry overlay\n    if (!editable && newLabelText.length === 0 && !this.#isPendingRemoval) {\n      this.#isPendingRemoval = true;\n      this.dispatchEvent(new EntryLabelRemoveEvent());\n    }\n  }\n\n  /**\n   * Places the user's cursor at the end of the input. We do this when the user\n   * focuses the input with either the keyboard or mouse, and when they paste in\n   * text, so that the cursor is placed in a useful position to edit.\n   */\n  #placeCursorAtInputEnd(): void {\n    if (!this.#inputField) {\n      return;\n    }\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(this.#inputField);\n    range.collapse(false);\n    selection?.removeAllRanges();\n    selection?.addRange(range);\n  }\n\n  set callTree(callTree: Utils.AICallTree.AICallTree|null) {\n    this.#callTree = callTree;\n    // If the entry has a calltree, we need to check if we need to show the 'generate label' button.\n    this.#setAIButtonRenderState();\n  }\n\n  // Generate the AI label suggestion if:\n  // 1. the user has already already seen the fre dialog and confirmed the feature usage\n  // or\n  // 2. turned on the `generate AI labels` setting through the AI settings panel\n  //\n  // Otherwise, show the fre dialog with a 'Got it' button that turns the setting on.\n  async #handleAiButtonClick(): Promise<void> {\n    if (this.#aiAnnotationsEnabledSetting.get()) {\n      if (!this.#callTree || !this.#inputField) {\n        // Shouldn't happen as we only show the Generate UI when we have this, but this satisfies TS.\n        return;\n      }\n      try {\n        // Trigger a re-render to display the loading component in the place of the button when the label is being generated.\n        this.#currAIButtonState = AIButtonState.GENERATING_LABEL;\n        UI.ARIAUtils.LiveAnnouncer.alert(UIStringsNotTranslate.generatingLabel);\n        // Trigger a re-render to put focus back on the input box, otherwise\n        // when the button changes to a loading spinner, it loses focus and the\n        // editing state is reset because the component loses focus.\n        this.#render();\n        this.#focusInputBox();\n        void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n\n        this.#label = await this.#agent.generateAIEntryLabel(this.#callTree);\n        this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n        this.#inputField.innerText = this.#label;\n        this.#placeCursorAtInputEnd();\n        // Reset the button state because we want to hide it if the label is not empty.\n        this.#setAIButtonRenderState();\n        // Trigger a re-render to hide the AI Button and display the generated label.\n        this.#render();\n      } catch {\n        this.#currAIButtonState = AIButtonState.GENERATION_FAILED;\n        void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n      }\n    } else {\n      this.#inAIConsentDialogFlow = true;\n      this.#render();\n      const hasConsented = await this.#showUserAiFirstRunDialog();\n      this.#inAIConsentDialogFlow = false;\n      // This makes sure we put the user back in the editable state.\n      this.setLabelEditabilityAndRemoveEmptyLabel(true);\n      // If the user has consented, we now want to call this function again so\n      // the label generation happens without them having to click the button\n      // again.\n      if (hasConsented) {\n        await this.#handleAiButtonClick();\n      }\n    }\n  }\n\n  /**\n   * @returns `true` if the user has now consented, and `false` otherwise.\n   */\n  async #showUserAiFirstRunDialog(): Promise<boolean> {\n    this.dispatchEvent(new LabelAnnotationsConsentDialogVisibilityChange(true));\n    const userConsented = await PanelCommon.FreDialog.show({\n      ariaLabel: i18nString(UIStrings.freDialog),\n      header: {iconName: 'pen-spark', text: lockedString(UIStringsNotTranslate.freDisclaimerHeader)},\n      reminderItems: [\n        {\n          iconName: 'psychiatry',\n          content: lockedString(UIStringsNotTranslate.freDisclaimerAiWontAlwaysGetItRight),\n        },\n        {\n          iconName: 'google',\n          content: this.#noLogging ? lockedString(UIStringsNotTranslate.freDisclaimerPrivacyDataSentToGoogleNoLogging) :\n                                     lockedString(UIStringsNotTranslate.freDisclaimerPrivacyDataSentToGoogle),\n        },\n      ],\n      onLearnMoreClick: () => {\n        UI.UIUtils.openInNewTab('https://developer.chrome.com/docs/devtools/performance/annotations#auto-annotations');\n      },\n      learnMoreButtonTitle: UIStringsNotTranslate.learnMoreButton,\n    });\n    this.dispatchEvent(new LabelAnnotationsConsentDialogVisibilityChange(false));\n\n    if (userConsented) {\n      this.#aiAnnotationsEnabledSetting.set(true);\n    }\n    return this.#aiAnnotationsEnabledSetting.get();\n  }\n\n  #setAIButtonRenderState(): void {\n    const hasAiExperiment = Boolean(Root.Runtime.hostConfig.devToolsAiGeneratedTimelineLabels?.enabled);\n    const aiDisabledByEnterprisePolicy = Root.Runtime.hostConfig.aidaAvailability?.enterprisePolicyValue ===\n        Root.Runtime.GenAiEnterprisePolicyValue.DISABLE;\n    // If the call tree is not available, the entry is in a track other than the main track.\n    // Therefore, hide the button because, at the moment, the label can only be generated for main tracks\n    const dataToGenerateLabelAvailable = this.#callTree !== null;\n    /**\n     * Right now if the user \"retries\" the AI label generation the result will\n     * be almost identical because we don't change the input data or prompt. So\n     * we only show the generate button if the label is empty.\n     */\n    const labelIsEmpty = this.#label?.length <= 0;\n\n    if (!hasAiExperiment || aiDisabledByEnterprisePolicy || !dataToGenerateLabelAvailable || !labelIsEmpty) {\n      this.#currAIButtonState = AIButtonState.HIDDEN;\n    } else {\n      // To verify whether AI can be used, check if aida is available, the user is logged in, over 18, in a supported\n      // location and offline.\n      const aiAvailable = Root.Runtime.hostConfig.aidaAvailability?.enabled &&\n          !Root.Runtime.hostConfig.aidaAvailability?.blockedByAge &&\n          !Root.Runtime.hostConfig.aidaAvailability?.blockedByGeo && navigator.onLine;\n      if (aiAvailable) {\n        this.#currAIButtonState = AIButtonState.ENABLED;\n      } else {\n        // If AI features are not available, we show a disabled button.\n        this.#currAIButtonState = AIButtonState.DISABLED;\n      }\n    }\n  }\n\n  #renderAITooltip(opts: {textContent: string, includeSettingsButton: boolean}): Lit.TemplateResult {\n    // clang-format off\n    return html`<devtools-tooltip\n    variant=\"rich\"\n    id=\"info-tooltip\"\n    ${Directives.ref(this.#richTooltip)}>\n      <div class=\"info-tooltip-container\">\n        ${opts.textContent} ${opts.includeSettingsButton ? html`\n          <button\n            class=\"link tooltip-link\"\n            role=\"link\"\n            jslog=${VisualLogging.link('open-ai-settings').track({\n              click: true,\n            })}\n            @click=${this.#onTooltipLearnMoreClick}\n            aria-label=${i18nString(UIStrings.learnMoreAriaLabel)}\n          >${lockedString(UIStringsNotTranslate.learnMore)}</button>\n        ` : Lit.nothing}\n      </div>\n    </devtools-tooltip>`;\n    // clang-format on\n  }\n  #renderGeneratingLabelAiButton(): Lit.LitTemplate {\n    // clang-format off\n      return html`\n      <span\n        class=\"ai-label-loading\">\n        <devtools-spinner></devtools-spinner>\n        <span class=\"generate-label-text\">${lockedString(UIStringsNotTranslate.generatingLabel)}</span>\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #renderAiButton(): Lit.LitTemplate {\n    if (this.#currAIButtonState === AIButtonState.GENERATION_FAILED) {\n      // Only show the error message on the first component render render after the failure.\n      // clang-format off\n      return html`\n        <span\n          class=\"ai-label-error\">\n          <devtools-icon\n            class=\"warning extra-large\"\n            name=\"warning\"\n            style=\"color: var(--ref-palette-error50)\">\n          </devtools-icon>\n          <span class=\"generate-label-text\">${lockedString(UIStringsNotTranslate.generationFailed)}</span>\n        </span>\n      `;\n      // clang-format on\n    }\n    // clang-format off\n    return html`\n      <!-- 'preventDefault' on the AI label button to prevent the label removal on blur  -->\n      <span\n        class=\"ai-label-button-wrapper only-pen-wrapper\"\n        @mousedown=${(e: Event) => e.preventDefault()}>\n        <button\n          class=\"ai-label-button enabled\"\n          @click=${this.#handleAiButtonClick}>\n          <devtools-icon\n            class=\"pen-icon extra-large\"\n            name=\"pen-spark\"\n            style=\"color: var(--icon-primary);\">\n          </devtools-icon>\n          <span class=\"generate-label-text\">${i18nString(UIStrings.generateLabelButton)}</span>\n        </button>\n        <devtools-button\n          aria-details=\"info-tooltip\"\n          class=\"pen-icon\"\n          .title=${i18nString(UIStrings.moreInfoAriaLabel)}\n          .iconName=${'info'}\n          .variant=${Buttons.Button.Variant.ICON}\n          ></devtools-button>\n        ${this.#renderAITooltip({\n         textContent: this.#noLogging ? lockedString(UIStringsNotTranslate.generateLabelSecurityDisclaimerLogginOff) : lockedString(UIStringsNotTranslate.generateLabelSecurityDisclaimer),\n         includeSettingsButton: true,\n        })}\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #onTooltipLearnMoreClick(): void {\n    this.#richTooltip?.value?.hidePopover();\n    void UI.ViewManager.ViewManager.instance().showView('chrome-ai');\n  }\n\n  // The disabled button rendered when the `generate AI label` feature is not available\n  // because of the geolocation, age or if they are not logged in into the google account.\n  //\n  // If the user is offline, display the same button with a different tooltip.\n  #renderDisabledAiButton(): Lit.TemplateResult {\n    const noConnection = navigator.onLine === false;\n    // clang-format off\n    return html`\n      <!-- 'preventDefault' on the AI label button to prevent the label removal on blur  -->\n      <span\n        class=\"ai-label-disabled-button-wrapper only-pen-wrapper\"\n        @mousedown=${(e: Event) => e.preventDefault()}>\n        <button\n          class=\"ai-label-button disabled\"\n          ?disabled=${true}\n          @click=${this.#handleAiButtonClick}>\n          <devtools-icon\n            aria-details=\"info-tooltip\"\n            class=\"pen-icon extra-large\"\n            name=\"pen-spark\"\n            style=\"color: var(--sys-color-state-disabled);\">\n          </devtools-icon>\n        </button>\n        ${this.#renderAITooltip({\n          textContent: noConnection ? lockedString(UIStringsNotTranslate.autoAnnotationNotAvailableOfflineDisclaimer) : lockedString(UIStringsNotTranslate.autoAnnotationNotAvailableDisclaimer),\n          includeSettingsButton: !noConnection,\n        })}\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #handleFocusOutEvent(event: FocusEvent): void {\n    /**\n     * Usually when the text box loses focus, we want to stop the edit mode and\n     * just display the annotation. However, if the user tabs from the text box\n     * to focus the GenerateAI button, we need to ensure that we do not exit\n     * edit mode. The only reliable method is to listen to the focusout event\n     * (which bubbles, unlike `blur`) on the parent.\n     */\n    const relatedTarget = event.relatedTarget as Node | null;\n    // If the related target is null, it means the focus has left the browser\n    // window. If it's not null, we check if the new focused element is a\n    // descendant of this component's shadow root. If it is, we don't do anything.\n    if (relatedTarget && this.#shadow.contains(relatedTarget)) {\n      return;\n    }\n    this.setLabelEditabilityAndRemoveEmptyLabel(false);\n  }\n\n  #render(): void {\n    const inputFieldClasses = Lit.Directives.classMap({\n      'input-field': true,\n      // When the consent modal pops up, we want the input to look like it has focus so it visually doesn't change.\n      // Once the consent flow is closed, we restore focus and maintain the appearance.\n      'fake-focus-state': this.#inAIConsentDialogFlow,\n    });\n    // clang-format off\n    Lit.render(\n        html`\n        <style>${entryLabelOverlayStyles}</style>\n        <span class=\"label-parts-wrapper\" role=\"region\" aria-label=${i18nString(UIStrings.entryLabel)}\n          @focusout=${this.#handleFocusOutEvent}\n        >\n          <span\n            class=\"label-button-input-wrapper\">\n            <span\n              class=${inputFieldClasses}\n              role=\"textbox\"\n              @focus=${() => {\n                this.setLabelEditabilityAndRemoveEmptyLabel(true);\n              }}\n              @dblclick=${() => {\n                this.setLabelEditabilityAndRemoveEmptyLabel(true);\n              }}\n              @keydown=${this.#handleLabelInputKeyDown}\n              @paste=${this.#handleLabelInputPaste}\n              @input=${this.#handleLabelInputKeyUp}\n              contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n              jslog=${VisualLogging.textField('timeline.annotations.entry-label-input').track({keydown: true, click: true, change: true})}\n              tabindex=\"0\"\n            ></span>\n            ${this.#isLabelEditable && this.#inputField?.innerText !== '' ? html`\n              <button\n                class=\"delete-button\"\n                @click=${() => this.dispatchEvent(new EntryLabelRemoveEvent())}\n                jslog=${VisualLogging.action('timeline.annotations.delete-entry-label').track({click: true})}>\n              <devtools-icon name=\"cross\" class=\"small\" style=\"color: var(--color-background);\"\n              ></devtools-icon>\n              </button>\n            ` : Lit.nothing}\n            ${(() => {\n              switch (this.#currAIButtonState) {\n                case AIButtonState.HIDDEN:\n                  return Lit.nothing;\n                case AIButtonState.ENABLED:\n                  return this.#renderAiButton();\n                case AIButtonState.GENERATING_LABEL:\n                  return this.#renderGeneratingLabelAiButton();\n                case AIButtonState.GENERATION_FAILED:\n                  return this.#renderAiButton();\n                case AIButtonState.DISABLED:\n                  return this.#renderDisabledAiButton();\n              }\n            })()}\n          </span>\n          <svg class=\"connectorContainer\">\n            <line/>\n            <circle/>\n          </svg>\n          <div class=\"entry-highlight-wrapper\"></div>\n        </span>`,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\ncustomElements.define('devtools-entry-label-overlay', EntryLabelOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entry-label-overlay': EntryLabelOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.label-parts-wrapper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.label-button-input-wrapper {\n  display: flex;\n  position: relative;\n  overflow: visible;\n}\n\n.ai-label-button-wrapper,\n.ai-label-disabled-button-wrapper,\n.ai-label-loading,\n.ai-label-error {\n  /* position the button wrapper on the very right of the label */\n  position: absolute;\n  left: 100%;\n  display: flex;\n  /* Since the ai-button is a bit bigger than the label, lift it up for it to appear more centered */\n  transform: translateY(-3px);\n  flex-flow: row nowrap;\n  border: none;\n  border-radius: var(--sys-shape-corner-large);\n  background: var(--sys-color-surface3);\n  box-shadow: var(--drop-shadow);\n  align-items: center;\n  gap: var(--sys-size-4);\n  pointer-events: auto;\n  transition:\n    all var(--sys-motion-duration-medium2) var(--sys-motion-easing-emphasized);\n\n  &.only-pen-wrapper {\n    /* when the button wrapper is not hovered, set the max width to only fit the pen icon */\n    overflow: hidden;\n    width: var(--sys-size-12);\n    height: var(--sys-size-12);\n  }\n\n  * {\n    /* When unhovered, shift the contents left you don't see the border of the .ai-label-button  */\n    transform: translateX(-2px);\n  }\n}\n\n.delete-button {\n  display: flex;\n  pointer-events: auto;\n  position: absolute;\n  right: 0;\n  top: -5px;\n  border-radius: 50%;\n  padding: 0;\n  border: none;\n  background: var(--color-background-inverted);\n}\n\n.ai-label-loading,\n.ai-label-error {\n  gap: var(--sys-size-6);\n  padding: var(--sys-size-5) var(--sys-size-8);\n}\n\n.ai-label-button-wrapper:focus,\n.ai-label-button-wrapper:focus-within,\n.ai-label-button-wrapper:hover {\n  width: auto;\n  height: var(--sys-size-13);\n  padding: var(--sys-size-3) var(--sys-size-5);\n  transform: translateY(-9px); /* -9px is the original -3px minus 6px (coming from the padding adjustment) */\n\n  * {\n    transform: translateX(0);\n  }\n}\n\n.ai-label-button {\n  display: flex;\n  align-items: center;\n  gap: var(--sys-size-4);\n  padding: var(--sys-size-3) var(--sys-size-5);\n  border: 1px solid var(--color-primary);\n  border-radius: var(--sys-shape-corner-large);\n\n  &.enabled {\n    background: var(--sys-color-surface3);\n  }\n\n  &.disabled {\n    background: var(--sys-color-surface5);\n  }\n\n  &:hover {\n    background: var(--sys-color-state-hover-on-subtle);\n  }\n}\n\n.generate-label-text {\n  white-space: nowrap;\n  color: var(--color-primary);\n}\n\n.input-field {\n  background-color: var(--color-background-inverted);\n  color: var(--color-background);\n  pointer-events: auto;\n  border-radius: var(--sys-shape-corner-extra-small);\n  white-space: nowrap;\n  padding: var(--sys-size-3) var(--sys-size-4);\n  font-family: var(--default-font-family);\n  font-size: var(--sys-typescale-body2-size);\n  font-weight: var(--ref-typeface-weight-medium);\n  outline: 2px solid var(--color-background);\n}\n\n\n/* When the input field is focused we want to style it as a light background so\n * it's clear that the user is in it and can edit the text.\n* However we also do this styling when the user's focus is on the GenerateAI\n* button (using the :focus-within on the parent). This is so if you open an\n* empty annotation, and then tab to the GenerateAI button, the text field\n* styling doesn't change. */\n.input-field:focus,\n.label-parts-wrapper:focus-within .input-field,\n.input-field.fake-focus-state {\n  background-color: var(--color-background);\n  color: var(--color-background-inverted);\n  outline: 2px solid var(--color-background-inverted);\n}\n\n.connectorContainer {\n  overflow: visible;\n}\n\n.entry-highlight-wrapper {\n  box-sizing: border-box;\n  border: 2px solid var(--sys-color-on-surface);\n\n  &.cut-off-top {\n    border-top: none;\n  }\n\n  &.cut-off-bottom {\n    border-bottom: none;\n  }\n\n  &.cut-off-right {\n    border-right: none;\n  }\n\n  &.cut-off-left {\n    border-left: none;\n  }\n}\n\n/* The tooltip for the AI label generation info */\n.info-tooltip-container {\n  max-width: var(--sys-size-28);\n\n  button.link {\n    cursor: pointer;\n    text-decoration: underline;\n    border: none;\n    padding: 0;\n    background: none;\n    font: inherit;\n    font-weight: var(--ref-typeface-weight-medium);\n    display: block;\n    margin-top: var(--sys-size-4);\n    color: var(--sys-color-primary);\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./entryLabelOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport {html, render} from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport timeRangeOverlayStyles from './timeRangeOverlay.css.js';\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  timeRange: 'Time range',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/TimeRangeOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class TimeRangeLabelChangeEvent extends Event {\n  static readonly eventName = 'timerangelabelchange';\n\n  constructor(public newLabel: string) {\n    super(TimeRangeLabelChangeEvent.eventName);\n  }\n}\n\nexport class TimeRangeRemoveEvent extends Event {\n  static readonly eventName = 'timerangeremoveevent';\n\n  constructor() {\n    super(TimeRangeRemoveEvent.eventName);\n  }\n}\n\nexport class TimeRangeOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #duration: Trace.Types.Timing.Micro|null = null;\n  #canvasRect: DOMRect|null = null;\n  #label: string;\n\n  // The label is set to editable and in focus anytime the label is empty and when the label it is double clicked.\n  // If the user clicks away from the selected range element and the label is not empty, the label is set to not editable until it is double clicked.\n  #isLabelEditable = true;\n\n  #rangeContainer: HTMLElement|null = null;\n  #labelBox: HTMLElement|null = null;\n\n  constructor(initialLabel: string) {\n    super();\n    this.#render();\n    this.#rangeContainer = this.#shadow.querySelector<HTMLElement>('.range-container');\n    this.#labelBox = this.#rangeContainer?.querySelector<HTMLElement>('.label-text') ?? null;\n    this.#label = initialLabel;\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.innerText = initialLabel;\n    if (initialLabel) {\n      this.#labelBox?.setAttribute('aria-label', initialLabel);\n      // To construct a time range with a predefined label, it must have been\n      // loaded from the trace file. In this case we do not want it to default\n      // to editable.\n      this.#setLabelEditability(false);\n    }\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set duration(duration: Trace.Types.Timing.Micro|null) {\n    if (duration === this.#duration) {\n      return;\n    }\n    this.#duration = duration;\n    this.#render();\n  }\n\n  /**\n   * This calculates how much of the time range is in the user's view. This is\n   * used to determine how much of the label can fit into the view, and if we\n   * should even show the label.\n   */\n  #visibleOverlayWidth(overlayRect: DOMRect): number {\n    if (!this.#canvasRect) {\n      return 0;\n    }\n\n    const {x: overlayStartX, width} = overlayRect;\n    const overlayEndX = overlayStartX + width;\n\n    const canvasStartX = this.#canvasRect.x;\n    const canvasEndX = this.#canvasRect.x + this.#canvasRect.width;\n\n    const leftVisible = Math.max(canvasStartX, overlayStartX);\n    const rightVisible = Math.min(canvasEndX, overlayEndX);\n    return rightVisible - leftVisible;\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  updateLabelPositioning(): void {\n    if (!this.#rangeContainer) {\n      return;\n    }\n\n    if (!this.#canvasRect || !this.#labelBox) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n    const overlayRect = this.getBoundingClientRect();\n    const labelFocused = this.#shadow.activeElement === this.#labelBox;\n\n    const labelRect = this.#rangeContainer.getBoundingClientRect();\n    const visibleOverlayWidth = this.#visibleOverlayWidth(overlayRect) - paddingForScrollbar;\n\n    const durationBox = this.#rangeContainer.querySelector<HTMLElement>('.duration') ?? null;\n    const durationBoxLength = durationBox?.getBoundingClientRect().width;\n    if (!durationBoxLength) {\n      return;\n    }\n    const overlayTooNarrow = visibleOverlayWidth <= durationBoxLength;\n    // We do not hide the label if:\n    // 1. it is focused (user is typing into it)\n    // 2. it is empty - this means it's a new label and we need to let the user type into it!\n    // 3. it is too narrow - narrower than the duration length\n    const hideLabel = overlayTooNarrow && !labelFocused && this.#label.length > 0;\n    this.#rangeContainer.classList.toggle('labelHidden', hideLabel);\n\n    if (hideLabel) {\n      // Label is invisible, no need to do all the layout.\n      return;\n    }\n\n    // Check if label is off the LHS of the screen.\n    const labelLeftMarginToCenter = (overlayRect.width - labelRect.width) / 2;\n    const newLabelX = overlayRect.x + labelLeftMarginToCenter;\n\n    const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n    this.#rangeContainer.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n    // Check if label is off the RHS of the screen\n    const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n    // The label's right hand edge is the gap from the left of the range to the\n    // label, and then the width of the label.\n    const labelRightEdge = overlayRect.x + labelLeftMarginToCenter + labelRect.width;\n    const labelOffRightOfScreen = labelRightEdge > rightBound;\n    this.#rangeContainer.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n    if (labelOffLeftOfScreen) {\n      // If the label is off the left of the screen, we adjust by the\n      // difference between the X that represents the start of the cavnas, and\n      // the X that represents the start of the overlay.\n      // We then take the absolute value of this - because if the canvas starts\n      // at 0, and the overlay is -200px, we have to adjust the label by +200.\n      // Add on 9 pixels to pad from the left; this is the width of the sidebar\n      // on the RHS so we match it so the label is equally padded on either\n      // side.\n      this.#rangeContainer.style.marginLeft = `${Math.abs(this.#canvasRect.x - overlayRect.x) + paddingForScrollbar}px`;\n    } else if (labelOffRightOfScreen) {\n      // If the label is off the right of the screen, we adjust by adding the\n      // right margin equal to the difference between the right edge of the\n      // overlay and the right edge of the canvas.\n      this.#rangeContainer.style.marginRight = `${overlayRect.right - this.#canvasRect.right + paddingForScrollbar}px`;\n    } else {\n      // Keep the label central.\n      this.#rangeContainer.style.margin = '0px';\n    }\n\n    // If the text is empty, set the label editibility to true.\n    // Only allow to remove the focus and save the range as annotation if the label is not empty.\n    if (this.#labelBox?.innerText === '') {\n      this.#setLabelEditability(true);\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.focus();\n  }\n\n  #setLabelEditability(editable: boolean): void {\n    // Always keep focus on the label input field if the label is empty.\n    // TODO: Do not remove a range that is being navigated away from if the label is not empty\n    if (this.#labelBox?.innerText === '') {\n      this.#focusInputBox();\n      return;\n    }\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event\n    const labelBoxTextContent = this.#labelBox?.textContent ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new TimeRangeLabelChangeEvent(this.#label));\n      this.#labelBox?.setAttribute('aria-label', labelBoxTextContent);\n    }\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    // If the new key is `Enter` or `Escape` key, treat it\n    // as the end of the label input and blur the input field.\n    // If the text field is empty when `Enter` or `Escape` are pressed,\n    // dispatch an event to remove the time range.\n    if (event.key === Platform.KeyboardUtilities.ENTER_KEY || event.key === Platform.KeyboardUtilities.ESCAPE_KEY) {\n      // In DevTools, the `Escape` button will by default toggle the console\n      // drawer, which we don't want here, so we need to call\n      // `stopPropagation()`.\n      event.stopPropagation();\n      if (this.#label === '') {\n        this.dispatchEvent(new TimeRangeRemoveEvent());\n      }\n      this.#labelBox?.blur();\n      return false;\n    }\n\n    return true;\n  }\n\n  #render(): void {\n    const durationText = this.#duration ? i18n.TimeUtilities.formatMicroSecondsTime(this.#duration) : '';\n    // clang-format off\n    render(\n        html`\n          <style>${timeRangeOverlayStyles}</style>\n          <span class=\"range-container\" role=\"region\" aria-label=${i18nString(UIStrings.timeRange)}>\n            <span\n             class=\"label-text\"\n             role=\"textbox\"\n             @focusout=${() => this.#setLabelEditability(false)}\n             @dblclick=${() => this.#setLabelEditability(true)}\n             @keydown=${this.#handleLabelInputKeyDown}\n             @keyup=${this.#handleLabelInputKeyUp}\n             contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n             jslog=${VisualLogging.textField('timeline.annotations.time-range-label-input').track({keydown: true, click: true})}\n            ></span>\n            <span class=\"duration\">${durationText}</span>\n          </span>\n          `,\n        this.#shadow, {host: this});\n    // clang-format on\n\n    // Now we have rendered, we need to re-run the code to tweak the margin &\n    // positioning of the label.\n    this.updateLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-time-range-overlay', TimeRangeOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-time-range-overlay': TimeRangeOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  display: flex;\n  overflow: hidden;\n  flex-direction: column;\n  justify-content: flex-end;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  padding-bottom: 5px;\n  /* stylelint-disable-next-line plugin/use_theme_colors */\n  background: linear-gradient(\n    180deg,\n    rgb(255 125 210 / 0%) 0%,\n    rgb(255 125 210 / 15%) 85%\n  );\n  border-color: var(--ref-palette-pink55);\n  border-width: 0 1px 5px;\n  border-style: solid;\n  pointer-events: none;\n}\n\n.range-container {\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  text-align: center;\n  box-sizing: border-box;\n  pointer-events: all;\n  user-select: none;\n  color: var(--sys-color-pink);\n\n  &.labelHidden {\n    /* Have to use this not display: none so it maintains its width */\n    user-select: none;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  &.offScreenLeft {\n    align-items: flex-start;\n    text-align: left;\n  }\n\n  &.offScreenRight {\n    align-items: flex-end;\n    text-align: right;\n  }\n}\n\n.label-text {\n  /*\n  * The width priority is min-width > max-width > width\n  * When the range itself is smaller that 70px, expand 100% to fill the whole width.\n  * When the range is wider, only expand the textfield to over 70px\n  * if it's needed to fit the label text.\n  */\n  width: 100%;\n  max-width: 70px;\n  min-width: fit-content;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  word-break: normal;\n  overflow-wrap: anywhere;\n  margin-bottom: 3px;\n  display: -webkit-box;\n  white-space: break-spaces;\n  background: var(--sys-color-cdt-base-container);\n  line-clamp: 2;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n\n.duration {\n  background: var(--sys-color-cdt-base-container);\n}\n\n.label-text[contenteditable='true'] {\n  outline: none;\n  box-shadow: 0 0 0 1px var(--ref-palette-pink55);\n}\n\n.label-text[contenteditable='false'] {\n  width: auto;\n}\n\n/*# sourceURL=${import.meta.resolve('./timeRangeOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\n\nimport timespanBreakdownOverlayStyles from './timespanBreakdownOverlay.css.js';\n\nconst {html} = Lit;\n\n/**\n * An EntryBreakdown, or section, that makes up a TimespanBreakdown.\n */\nexport interface EntryBreakdown {\n  bounds: Trace.Types.Timing.TraceWindowMicro;\n  label: string|Lit.LitTemplate;\n  showDuration: boolean;\n}\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #canvasRect: DOMRect|null = null;\n  #sections: EntryBreakdown[]|null = null;\n\n  set isBelowEntry(isBelow: boolean) {\n    this.classList.toggle('is-below', isBelow);\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (this.#canvasRect && rect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set sections(sections: EntryBreakdown[]|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    this.#render();\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  checkSectionLabelPositioning(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  renderedSections(): HTMLElement[] {\n    return Array.from(this.#shadow.querySelectorAll('.timespan-breakdown-overlay-section'));\n  }\n\n  #renderSection(section: EntryBreakdown): Lit.TemplateResult {\n    // clang-format off\n    return html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">\n        ${section.showDuration ?\n          html`<span class=\"duration-text\">${i18n.TimeUtilities.formatMicroSecondsAsMillisFixed(section.bounds.range)}</span> ` : Lit.nothing}\n          <span class=\"section-label-text\">${section.label}</span>\n        </div>\n      </div>`;\n    // clang-format on\n  }\n\n  #render(): void {\n    if (this.#sections) {\n      this.classList.toggle('odd-number-of-sections', this.#sections.length % 2 === 1);\n      this.classList.toggle('even-number-of-sections', this.#sections.length % 2 === 0);\n    }\n    Lit.render(\n        html`<style>${timespanBreakdownOverlayStyles}</style>\n             ${this.#sections?.map(this.#renderSection)}`,\n        this.#shadow, {host: this});\n    this.checkSectionLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.timespan-breakdown-overlay-section {\n  border: solid;\n  border-color: var(--sys-color-on-surface);\n  border-width: 4px 1px 0;\n  align-content: flex-start;\n  text-align: center;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  background-image: linear-gradient(180deg, var(--sys-color-on-primary), transparent);\n  height: 90%;\n  box-sizing: border-box;\n  padding-top: var(--sys-size-2);\n\n  :host(.is-below) & {\n    border-top-width: 0;\n    border-bottom-width: 4px;\n    align-content: flex-end; /* anchor the text at the bottom */\n    padding-bottom: var(--sys-size-2);\n    padding-top: 0;\n\n    /* re-order so the timestamp is below label */\n    .timespan-breakdown-overlay-label {\n      display: flex;\n      flex-direction: column-reverse;\n    }\n  }\n}\n\n:host {\n  display: flex;\n  overflow: hidden;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: flex-end;\n  width: 100%;\n  box-sizing: border-box;\n  height: 100%;\n  max-height: 100px;\n\n  /* Ensure that the first & last sections always have the left/right border */\n  /* (disable stylelint because we need the !important to override border\n   * styles below + keeping them here is clearer to read) */\n  .timespan-breakdown-overlay-section:first-child {\n    border-left-width: 1px !important; /* stylelint-disable-line declaration-no-important */\n  }\n\n  .timespan-breakdown-overlay-section:last-child {\n    border-right-width: 1px !important; /* stylelint-disable-line declaration-no-important */\n  }\n}\n\n:host(.is-below) {\n  align-items: flex-start;\n}\n\n/* Depending on if the number of sections is odd or even, we alternate the\n * heights of the even/odd sections. We do this to ensure that the first item\n * is never a \"high\" item, because that looks a bit clunky. */\n:host(.odd-number-of-sections) {\n  .timespan-breakdown-overlay-section:nth-child(even) {\n    height: 100%;\n  }\n\n  .timespan-breakdown-overlay-section:nth-child(odd) {\n    border-left-width: 0;\n    border-right-width: 0;\n  }\n}\n\n:host(.even-number-of-sections) {\n  .timespan-breakdown-overlay-section:nth-child(odd) {\n    height: 100%;\n  }\n\n  .timespan-breakdown-overlay-section:nth-child(even) {\n    border-left-width: 0;\n    border-right-width: 0;\n  }\n}\n\n.timespan-breakdown-overlay-label {\n  font-family: var(--default-font-family);\n  font-size: var(--sys-typescale-body2-size);\n  line-height: var(--sys-typescale-body4-line-height);\n  font-weight: var(--ref-typeface-weight-medium);\n  color: var(--sys-color-on-surface);\n  text-align: center;\n  box-sizing: border-box;\n  width: max-content;\n  padding: 0 3px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-wrap: nowrap;\n\n  .duration-text {\n    font-size: var(--sys-typescale-body4-size);\n    text-overflow: ellipsis;\n    overflow: hidden;\n    text-wrap: nowrap;\n    display: block;\n  }\n\n  .discovery-time-ms {\n    font-weight: var(--ref-typeface-weight-bold);\n  }\n\n  &.labelHidden {\n    /* Have to use this not display: none so it maintains its width */\n    user-select: none;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  &.labelTruncated {\n    /* This means the label will show the text that fits with an ellipsis for\n     * the overflow */\n    max-width: 100%;\n  }\n\n  &.offScreenLeft {\n    text-align: left;\n  }\n\n  &.offScreenRight {\n    text-align: right;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./timespanBreakdownOverlay.css')} */`;"],
  "mappings": "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",
  "names": ["i18n", "ThemeSupport", "VisualLogging", "html", "Directives", "UIStrings", "str_", "i18nString", "i18n", "Platform", "html", "render", "VisualLogging", "UIStrings", "str_", "i18nString", "render", "html", "i18n", "Lit", "html", "Lit"]
}
