{"version":3,"file":"TimespanBreakdownOverlay.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAC7B,OAAO,KAAK,IAAI,MAAM,+BAA+B,CAAC;AACtD,OAAO,KAAK,WAAW,MAAM,mCAAmC,CAAC;AACjE,OAAO,KAAK,gBAAgB,MAAM,8CAA8C,CAAC;AACjF,OAAO,KAAK,OAAO,MAAM,qCAAqC,CAAC;AAE/D,OAAO,MAAM,MAAM,mCAAmC,CAAC;AAUvD,MAAM,OAAO,wBAAyB,SAAQ,WAAW;IACvD,MAAM,CAAU,UAAU,GAAG,OAAO,CAAC,OAAO,CAAA,qCAAqC,CAAC;IAClF;;OAEG;IACH,MAAM,CAAU,qCAAqC,GAAG,CAAC,CAAC;IAEjD,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;IAC5C,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAChD,WAAW,GAAiB,IAAI,CAAC;IACjC,SAAS,GAA+B,IAAI,CAAC;IAE7C,iBAAiB;QACf,IAAI,CAAC,OAAO,CAAC,kBAAkB,GAAG,CAAC,MAAM,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,IAAI,UAAU,CAAC,IAAkB;QAC/B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,KAAK,gBAAgB,CAAC,eAAe,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAChF,CAAC;IAED,IAAI,QAAQ,CAAC,QAAoC;QAC/C,IAAI,QAAQ,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;YAChC,OAAO;QACT,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,KAAK,gBAAgB,CAAC,eAAe,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAChF,CAAC;IAED;;;;;OAKG;IACH,kBAAkB;QAChB,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAc,qCAAqC,CAAC,CAAC;QACnG,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,OAAO;QACT,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,OAAO;QACT,CAAC;QAED,0EAA0E;QAC1E,2EAA2E;QAC3E,sEAAsE;QACtE,sCAAsC;QACtC,MAAM,mBAAmB,GAAG,CAAC,CAAC;QAE9B,2EAA2E;QAC3E,2CAA2C;QAC3C,MAAM,iBAAiB,GAAG,IAAI,GAAG,EAA+E,CAAC;QACjH,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,MAAM,KAAK,GAAG,OAAO,CAAC,aAAa,CAAc,mCAAmC,CAAC,CAAC;YACtF,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,SAAS;YACX,CAAC;YACD,MAAM,WAAW,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;YACpD,MAAM,SAAS,GAAG,KAAK,CAAC,qBAAqB,EAAE,CAAC;YAChD,iBAAiB,CAAC,GAAG,CAAC,OAAO,EAAE,EAAC,WAAW,EAAE,SAAS,EAAE,KAAK,EAAC,CAAC,CAAC;QAClE,CAAC;QAED,MAAM,6BAA6B,GAAG,EAAE,CAAC;QAEzC,mDAAmD;QACnD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,MAAM,UAAU,GAAG,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAClD,IAAI,CAAC,UAAU,EAAE,CAAC;gBAChB,MAAM;YACR,CAAC;YACD,MAAM,EAAC,SAAS,EAAE,WAAW,EAAE,KAAK,EAAC,GAAG,UAAU,CAAC;YAEnD,MAAM,WAAW,GAAG,WAAW,CAAC,KAAK,GAAG,6BAA6B,CAAC;YACtE,oEAAoE;YACpE,MAAM,cAAc,GAAG,WAAW,CAAC,KAAK,GAAG,CAAC,IAAI,SAAS,CAAC,KAAK,CAAC;YAChE,qEAAqE;YACrE,uEAAuE;YACvE,gDAAgD;YAChD,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;YACnD,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC;YAEzD,IAAI,WAAW,IAAI,cAAc,EAAE,CAAC;gBAClC,mEAAmE;gBACnE,4CAA4C;gBAC5C,SAAS;YACX,CAAC;YAED,+CAA+C;YAC/C,MAAM,uBAAuB,GAAG,CAAC,WAAW,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC1E,MAAM,SAAS,GAAG,WAAW,CAAC,CAAC,GAAG,uBAAuB,CAAC;YAE1D,MAAM,oBAAoB,GAAG,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC5D,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAAC;YAE9D,8CAA8C;YAC9C,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC;YAC/D,2EAA2E;YAC3E,0CAA0C;YAC1C,MAAM,cAAc,GAAG,WAAW,CAAC,CAAC,GAAG,uBAAuB,GAAG,SAAS,CAAC,KAAK,CAAC;YACjF,MAAM,qBAAqB,GAAG,cAAc,GAAG,UAAU,CAAC;YAC1D,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,gBAAgB,EAAE,qBAAqB,CAAC,CAAC;YAEhE,IAAI,oBAAoB,EAAE,CAAC;gBACzB,+DAA+D;gBAC/D,wEAAwE;gBACxE,kDAAkD;gBAClD,yEAAyE;gBACzE,wEAAwE;gBACxE,yEAAyE;gBACzE,qEAAqE;gBACrE,QAAQ;gBACR,KAAK,CAAC,KAAK,CAAC,UAAU,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,mBAAmB,IAAI,CAAC;YAErG,CAAC;iBAAM,IAAI,qBAAqB,EAAE,CAAC;gBACjC,sEAAsE;gBACtE,2DAA2D;gBAC3D,wEAAwE;gBACxE,wEAAwE;gBACxE,mCAAmC;gBACnC,MAAM,UAAU,GAAG,UAAU,GAAG,SAAS,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC;gBAEhE,KAAK,CAAC,KAAK,CAAC,UAAU,GAAG,GAAG,UAAU,IAAI,CAAC;YAE7C,CAAC;iBAAM,CAAC;gBACN,0BAA0B;gBAC1B,KAAK,CAAC,KAAK,CAAC,UAAU,GAAG,GAAG,uBAAuB,IAAI,CAAC;YAC1D,CAAC;QACH,CAAC;IACH,CAAC;IACD,aAAa,CAAC,OAAuB;QACnC,MAAM,YAAY,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,0BAA0B,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACjG,OAAO,OAAO,CAAC,IAAI,CAAA;;;wCAGiB,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,YAAY,EAAE,CAAC,CAAC;YACrF,OAAO,CAAC,KAAK;;aAEZ,CAAC;IACZ,CAAC;IAED,OAAO;QACL,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAA,GAAG,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,EAAC,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC;IACvG,CAAC;;AAGH,cAAc,CAAC,MAAM,CAAC,qCAAqC,EAAE,wBAAwB,CAAC,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as TraceEngine from '../../../../models/trace/trace.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\n\nimport styles from './timespanBreakdownOverlay.css.js';\n\n/**\n * An EntryBreakdown, or section, that makes up a TimespanBreakdown.\n */\nexport type EntryBreakdown = {\n  bounds: TraceEngine.Types.Timing.TraceWindowMicroSeconds,\n  label: string,\n};\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-timespan-breakdown-overlay`;\n  /**\n   * Size to stagger sections of a TimespanBreakdownOverlay.\n   */\n  static readonly TIMESPAN_BREAKDOWN_OVERLAY_STAGGER_PX = 5;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n  #canvasRect: DOMRect|null = null;\n  #sections: Array<EntryBreakdown>|null = null;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n    this.#render();\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    this.#canvasRect = rect;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  set sections(sections: Array<EntryBreakdown>|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  afterOverlayUpdate(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n  renderSection(section: EntryBreakdown): LitHtml.TemplateResult {\n    const sectionRange = TraceEngine.Helpers.Timing.microSecondsToMilliseconds(section.bounds.range);\n    return LitHtml.html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">\n          <span class=\"duration-text\">${i18n.TimeUtilities.preciseMillisToString(sectionRange, 2)}</span>\n          ${section.label}\n        </div>\n      </div>`;\n  }\n\n  #render(): void {\n    LitHtml.render(LitHtml.html`${this.#sections?.map(this.renderSection)}`, this.#shadow, {host: this});\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n"]}