{"version":3,"file":"TimespanBreakdownOverlay.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as TraceEngine from '../../../../models/trace/trace.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\n\nimport styles from './timespanBreakdownOverlay.css.js';\n\n/**\n * An EntryBreakdown, or section, that makes up a TimespanBreakdown.\n */\nexport type EntryBreakdown = {\n  bounds: TraceEngine.Types.Timing.TraceWindowMicroSeconds,\n  label: string,\n};\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-timespan-breakdown-overlay`;\n  /**\n   * Size to stagger sections of a TimespanBreakdownOverlay.\n   */\n  static readonly TIMESPAN_BREAKDOWN_OVERLAY_STAGGER_PX = 5;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n  #canvasRect: DOMRect|null = null;\n  #sections: Array<EntryBreakdown>|null = null;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n    this.#render();\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    this.#canvasRect = rect;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  set sections(sections: Array<EntryBreakdown>|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  /**\n   * This calculates how much of the time range is in the user's view. This is\n   * used to determine how much of the label can fit into the view, and if we\n   * should even show the label.\n   */\n  #visibleOverlayWidth(overlayRect: DOMRect): number {\n    if (!this.#canvasRect) {\n      return 0;\n    }\n\n    const {x: overlayStartX, width} = overlayRect;\n    const overlayEndX = overlayStartX + width;\n\n    const canvasStartX = this.#canvasRect.x;\n    const canvasEndX = this.#canvasRect.x + this.#canvasRect.width;\n\n    const leftVisible = Math.max(canvasStartX, overlayStartX);\n    const rightVisible = Math.min(canvasEndX, overlayEndX);\n    return rightVisible - leftVisible;\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  afterOverlayUpdate(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        break;\n      }\n      const overlayRect = this.getBoundingClientRect();\n\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n\n      const visibleOverlayWidth = this.#visibleOverlayWidth(overlayRect) - paddingForScrollbar;\n      const overlayTooNarrow = visibleOverlayWidth <= labelRect.width - paddingForScrollbar;\n      label.classList.toggle('labelHidden', overlayTooNarrow);\n\n      if (overlayTooNarrow) {\n        // Label is invisible, no need to do all the layout.\n        break;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  renderSection(section: EntryBreakdown): LitHtml.TemplateResult {\n    const sectionRange = TraceEngine.Helpers.Timing.microSecondsToMilliseconds(section.bounds.range);\n    return LitHtml.html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">${section.label}\n          <div>${i18n.TimeUtilities.preciseMillisToString(sectionRange, 2)}</div>\n        </div>\n      </div>`;\n  }\n\n  #render(): void {\n    LitHtml.render(LitHtml.html`${this.#sections?.map(this.renderSection)}`, this.#shadow, {host: this});\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n"]}