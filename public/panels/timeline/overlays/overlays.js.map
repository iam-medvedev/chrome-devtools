{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/timeline/overlays/OverlaysImpl.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport type * as PerfUI from '../../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as VisualLogging from '../../../ui/visual_logging/visual_logging.js';\nimport * as Utils from '../utils/utils.js';\n\nimport * as Components from './components/components.js';\n\nconst UIStrings = {\n  /**\n   * @description Text for showing that a metric was observed in the local environment.\n   * @example {LCP} PH1\n   */\n  fieldMetricMarkerLocal: '{PH1} - Local',\n\n  /**\n   * @description Text for showing that a metric was observed in the field, from real use data (CrUX). Also denotes if from URL or Origin dataset.\n   * @example {LCP} PH1\n   * @example {URL} PH2\n   */\n  fieldMetricMarkerField: '{PH1} - Field ({PH2})',\n  /**\n   * @description Label for an option that selects the page's specific URL as opposed to it's entire origin/domain.\n   */\n  urlOption: 'URL',\n  /**\n   * @description Label for an option that selects the page's entire origin/domain as opposed to it's specific URL.\n   */\n  originOption: 'Origin',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/OverlaysImpl.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\n/**\n * Below the network track there is a resize bar the user can click and drag.\n */\nconst NETWORK_RESIZE_ELEM_HEIGHT_PX = 8;\n\n/**\n * Represents which flamechart an entry is rendered in.\n * We need to know this because when we place an overlay for an entry we need\n * to adjust its Y value if it's in the main chart which is drawn below the\n * network chart\n */\nexport type EntryChartLocation = 'main'|'network';\n\n/**\n * Given a list of overlays, this method will calculate the smallest possible\n * trace window that will contain all of the overlays.\n * `overlays` is expected to be non-empty, and this will return `null` if it is empty.\n */\nexport function traceWindowContainingOverlays(overlays: Trace.Types.Overlays.Overlay[]):\n    Trace.Types.Timing.TraceWindowMicro|null {\n  const windows = overlays.map(Trace.Helpers.Timing.traceWindowFromOverlay).filter(b => !!b);\n  return Trace.Helpers.Timing.combineTraceWindowsMicro(windows);\n}\n\n/**\n * Get a list of entries for a given overlay.\n */\nexport function entriesForOverlay(overlay: Trace.Types.Overlays.Overlay): readonly Trace.Types.Overlays.OverlayEntry[] {\n  const entries: Trace.Types.Overlays.OverlayEntry[] = [];\n\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRY_OUTLINE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIME_RANGE': {\n      // Time ranges are not associated with entries.\n      break;\n    }\n    case 'ENTRY_LABEL': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRIES_LINK': {\n      entries.push(overlay.entryFrom);\n      if (overlay.entryTo) {\n        entries.push(overlay.entryTo);\n      }\n      break;\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      if (overlay.entry) {\n        entries.push(overlay.entry);\n      }\n      break;\n    }\n    case 'TIMESTAMP_MARKER': {\n      // This overlay type isn't associated to any entry, so just break here.\n      break;\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIMINGS_MARKER': {\n      entries.push(...overlay.entries);\n      break;\n    }\n    case 'BOTTOM_INFO_BAR':\n      break;\n    default:\n      Platform.assertNever(overlay, `Unknown overlay type ${JSON.stringify(overlay)}`);\n  }\n\n  return entries;\n}\nexport function chartForEntry(entry: Trace.Types.Overlays.OverlayEntry): EntryChartLocation {\n  if (Trace.Types.Events.isNetworkTrackEntry(entry)) {\n    return 'network';\n  }\n\n  return 'main';\n}\n\nexport interface TimelineOverlaySetOptions {\n  /** Whether to update the trace window. Defaults to false. */\n  updateTraceWindow?: boolean;\n  /**\n   * If updateTraceWindow is true, this is the total amount of space added as margins to the\n   * side of the bounds represented by the overlays, represented as a percentage relative to\n   * the width of the overlay bounds. The space is split evenly on either side of the overlay\n   * bounds. The intention is to neatly center the overlays in the middle of the viewport, with\n   * some additional context on either side.\n   *\n   * If 0, no margins will be added, and the precise bounds defined by the overlays will be used.\n   *\n   * If not provided, 100 is used (25% margin, 50% overlays, 25% margin).\n   */\n  updateTraceWindowPercentage?: number;\n}\n\n/**\n * Denotes overlays that are singletons; only one of these will be allowed to\n * exist at any given time. If one exists and the add() method is called, the\n * new overlay will replace the existing one.\n */\ntype SingletonOverlay = Trace.Types.Overlays.EntrySelected|Trace.Types.Overlays.TimestampMarker;\nexport function overlayIsSingleton(overlay: Trace.Types.Overlays.Overlay): overlay is SingletonOverlay {\n  return overlayTypeIsSingleton(overlay.type);\n}\n\nexport function overlayTypeIsSingleton(type: Trace.Types.Overlays.Overlay['type']): type is SingletonOverlay['type'] {\n  return type === 'TIMESTAMP_MARKER' || type === 'ENTRY_SELECTED' || type === 'BOTTOM_INFO_BAR';\n}\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n * Note that we can't use the visible trace window from the TraceBounds\n * service as that can get out of sync with rapid FlameChart draws. To ensure\n * we draw overlays smoothly as the FlameChart renders we use the latest values\n * provided to us from the FlameChart. In `FlameChart#draw` we dispatch an\n * event containing the latest dimensions, and those are passed into the\n * Overlays system via TimelineFlameChartView.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: Trace.Types.Timing.TraceWindowMicro|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\n/**\n * The dimensions each flame chart reports. Note that in the current UI they\n * will always have the same width, so theoretically we could only gather that\n * from one chart, but we gather it from both for simplicity and to cover us in\n * the future should the UI change and the charts have different widths.\n */\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n  // If every single group (e.g. track) within the chart is collapsed or not.\n  // This matters because in the network track if every group (there is only\n  // one) is collapsed, there is no resizer bar shown, which impacts our pixel\n  // calculations for overlay positioning.\n  allGroupsCollapsed: boolean;\n}\n\nexport interface TimelineCharts {\n  mainChart: PerfUI.FlameChart.FlameChart;\n  mainProvider: PerfUI.FlameChart.FlameChartDataProvider;\n  networkChart: PerfUI.FlameChart.FlameChart;\n  networkProvider: PerfUI.FlameChart.FlameChartDataProvider;\n}\n\nexport interface OverlayEntryQueries {\n  parsedTrace: () => Trace.TraceModel.ParsedTrace | null;\n  isEntryCollapsedByUser: (entry: Trace.Types.Events.Event) => boolean;\n  firstVisibleParentForEntry: (entry: Trace.Types.Events.Event) => Trace.Types.Events.Event | null;\n}\n\n// An event dispatched when one of the Annotation Overlays (overlay created by the user,\n// ex. Trace.Types.Overlays.EntryLabel) is removed or updated. When one of the Annotation Overlays is removed or updated,\n// ModificationsManager listens to this event and updates the current annotations.\nexport type UpdateAction = 'Remove'|'Update';\nexport class AnnotationOverlayActionEvent extends Event {\n  static readonly eventName = 'annotationoverlayactionsevent';\n\n  constructor(public overlay: Trace.Types.Overlays.Overlay, public action: UpdateAction) {\n    super(AnnotationOverlayActionEvent.eventName);\n  }\n}\nexport class ConsentDialogVisibilityChange extends Event {\n  static readonly eventName = 'consentdialogvisibilitychange';\n  constructor(public isVisible: boolean) {\n    super(ConsentDialogVisibilityChange.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class TimeRangeMouseOverEvent extends Event {\n  static readonly eventName = 'timerangemouseoverevent';\n\n  constructor(public overlay: Trace.Types.Overlays.TimeRangeLabel) {\n    super(TimeRangeMouseOverEvent.eventName, {bubbles: true});\n  }\n}\n\nexport class TimeRangeMouseOutEvent extends Event {\n  static readonly eventName = 'timerangemouseoutevent';\n\n  constructor() {\n    super(TimeRangeMouseOutEvent.eventName, {bubbles: true});\n  }\n}\n\nexport class EntryLabelMouseClick extends Event {\n  static readonly eventName = 'entrylabelmouseclick';\n  constructor(public overlay: Trace.Types.Overlays.EntryLabel) {\n    super(EntryLabelMouseClick.eventName, {composed: true, bubbles: true});\n  }\n}\n\ninterface EntriesLinkVisibleEntries {\n  entryFrom: Trace.Types.Events.Event;\n  entryTo: Trace.Types.Events.Event|undefined;\n  entryFromIsSource: boolean;\n  entryToIsSource: boolean;\n}\n\nexport class EventReferenceClick extends Event {\n  static readonly eventName = 'eventreferenceclick';\n\n  constructor(public event: Trace.Types.Events.Event) {\n    super(EventReferenceClick.eventName, {bubbles: true, composed: true});\n  }\n}\n\n/**\n * This class manages all the overlays that get drawn onto the performance\n * timeline. Overlays are DOM and are drawn above the network and main flame\n * chart.\n *\n * For more documentation, see `timeline/README.md` which has a section on overlays.\n */\nexport class Overlays extends EventTarget {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #overlaysToElements = new Map<Trace.Types.Overlays.Overlay, HTMLElement|null>();\n\n  #singletonOverlays = new Map<SingletonOverlay['type'], Trace.Types.Overlays.Overlay>();\n\n  // When the Entries Link Annotation is created, the arrow needs to follow the mouse.\n  // Update the mouse coordinates while it is being created.\n  #lastMouseOffsetX: number|null = null;\n  #lastMouseOffsetY: number|null = null;\n  // `entriesLinkInProgress` is the entries link Overlay that has not yet been fully created\n  // and only has the entry that the link starts from set.\n  // We save it as a separate variable because when the second entry of the link is not chosen yet,\n  // the arrow follows the mouse. To achieve that, update the coordinates of `entriesLinkInProgress`\n  // on mousemove. There can only be one link in the process on being created so the mousemove\n  // only needs to update `entriesLinkInProgress` link overlay.\n  #entriesLinkInProgress: Trace.Types.Overlays.EntriesLink|null;\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * To calculate the Y pixel value for an event we need access to the chart\n   * and data provider in order to find out what level the event is on, and from\n   * there calculate the pixel value for that level.\n   */\n  #charts: TimelineCharts;\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement;\n\n  // Setting that specified if the annotations overlays need to be visible.\n  // It is switched on/off from the annotations tab in the sidebar.\n  readonly #annotationsHiddenSetting: Common.Settings.Setting<boolean>;\n\n  /**\n   * The OverlaysManager sometimes needs to find out if an entry is visible or\n   * not, and if not, why not - for example, if the user has collapsed its\n   * parent. We define these query functions that must be supplied in order to\n   * answer these questions.\n   */\n  #queries: OverlayEntryQueries;\n\n  constructor(init: {\n    container: HTMLElement,\n    flameChartsContainers: {\n      main: HTMLElement,\n      network: HTMLElement,\n    },\n    charts: TimelineCharts,\n    entryQueries: OverlayEntryQueries,\n  }) {\n    super();\n    this.#overlaysContainer = init.container;\n    this.#charts = init.charts;\n    this.#queries = init.entryQueries;\n    this.#entriesLinkInProgress = null;\n    this.#annotationsHiddenSetting = Common.Settings.Settings.instance().moduleSetting('annotations-hidden');\n    this.#annotationsHiddenSetting.addChangeListener(this.update.bind(this));\n\n    // HTMLElements of both Flamecharts. They are used to get the mouse position over the Flamecharts.\n    init.flameChartsContainers.main.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'main'));\n    init.flameChartsContainers.network.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'network'));\n  }\n\n  // Toggle display of the whole OverlaysContainer.\n  // This function is used to hide all overlays when the Flamechart is in the 'reorder tracks' state.\n  // If the tracks are being reordered, they are collapsed and we do not want to display\n  // anything except the tracks reordering interface.\n  //\n  // Do not change individual overlays visibility with 'setOverlayElementVisibility' since we do not\n  // want to overwrite the overlays visibility state that was set before entering the reordering state.\n  toggleAllOverlaysDisplayed(allOverlaysDisplayed: boolean): void {\n    this.#overlaysContainer.style.display = allOverlaysDisplayed ? 'block' : 'none';\n  }\n\n  // Mousemove event listener to get mouse coordinates and update them for the entries link that is being created.\n  //\n  // The 'mousemove' event is attached to `flameChartsContainers` instead of `overlaysContainer`\n  // because `overlaysContainer` doesn't have events to enable the interaction with the\n  // Flamecharts beneath it.\n  #updateMouseCoordinatesProgressEntriesLink(event: Event, chart: EntryChartLocation): void {\n    if (this.#entriesLinkInProgress?.state !== Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT) {\n      return;\n    }\n    const mouseEvent = (event as MouseEvent);\n    this.#lastMouseOffsetX = mouseEvent.offsetX;\n    this.#lastMouseOffsetY = mouseEvent.offsetY;\n\n    // The Overlays layer coordinates cover both Network and Main Charts, while the mousemove\n    // coordinates are received from the charts individually and start from 0 for each chart.\n    //\n    // To make it work on the overlays, we need to know which chart the entry belongs to and,\n    // if it is on the main chart, add the height of the Network chart to get correct Entry\n    // coordinates on the Overlays layer.\n    const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n    const linkInProgressElement = this.#overlaysToElements.get(this.#entriesLinkInProgress);\n\n    if (linkInProgressElement) {\n      const component = linkInProgressElement.querySelector('devtools-entries-link-overlay') as\n          Components.EntriesLinkOverlay.EntriesLinkOverlay;\n      const yCoordinate = mouseEvent.offsetY + ((chart === 'main') ? networkHeight : 0);\n      component.toEntryCoordinateAndDimensions = {x: mouseEvent.offsetX, y: yCoordinate};\n    }\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  add<T extends Trace.Types.Overlays.Overlay>(newOverlay: T): T {\n    if (this.#overlaysToElements.has(newOverlay)) {\n      return newOverlay;\n    }\n\n    /**\n     * If the overlay type is a singleton, and we already have one, we update\n     * the existing one, rather than create a new one. This ensures you can only\n     * ever have one instance of the overlay type.\n     */\n    if (overlayIsSingleton(newOverlay)) {\n      const existing = this.#singletonOverlays.get(newOverlay.type);\n      if (existing) {\n        this.updateExisting(existing, newOverlay);\n        return existing as T;  // The is a safe cast, thanks to `type` above.\n      }\n\n      this.#singletonOverlays.set(newOverlay.type, newOverlay);\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#overlaysToElements.set(newOverlay, null);\n    return newOverlay;\n  }\n\n  /**\n   * Update an existing overlay without destroying and recreating its\n   * associated DOM.\n   *\n   * This is useful if you need to rapidly update an overlay's data - e.g.\n   * dragging to create time ranges - without the thrashing of destroying the\n   * old overlay and re-creating the new one.\n   */\n  updateExisting<T extends Trace.Types.Overlays.Overlay>(existingOverlay: T, newData: Partial<T>): void {\n    if (!this.#overlaysToElements.has(existingOverlay)) {\n      console.error('Trying to update an overlay that does not exist.');\n      return;\n    }\n\n    for (const [key, value] of Object.entries(newData)) {\n      // newData is of type Partial<T>, so each key must exist in T, but\n      // Object.entries doesn't carry that information.\n      const k = key as keyof T;\n      existingOverlay[k] = value;\n    }\n  }\n\n  enterLabelEditMode(overlay: Trace.Types.Overlays.EntryLabel): void {\n    // Entry edit state can be triggered from outside the label component by clicking on the\n    // Entry that already has a label. Instead of creating a new label, set the existing entry\n    // label into an editable state.\n    const element = this.#overlaysToElements.get(overlay);\n    const component = element?.querySelector('devtools-entry-label-overlay');\n    if (component) {\n      component.setLabelEditabilityAndRemoveEmptyLabel(true);\n    }\n  }\n\n  bringLabelForward(overlay: Trace.Types.Overlays.EntryLabel): void {\n    // Before bringing the element forward, remove the 'bring-forward' class from all the other elements\n    for (const element of this.#overlaysToElements.values()) {\n      element?.classList.remove('bring-forward');\n    }\n\n    const element = this.#overlaysToElements.get(overlay);\n    element?.classList.add('bring-forward');\n  }\n\n  /**\n   * @returns the list of overlays associated with a given entry.\n   */\n  overlaysForEntry(entry: Trace.Types.Overlays.OverlayEntry): Trace.Types.Overlays.Overlay[] {\n    const matches: Trace.Types.Overlays.Overlay[] = [];\n    for (const [overlay] of this.#overlaysToElements) {\n      if ('entry' in overlay && overlay.entry === entry) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Used for debugging and testing. Do not mutate the element directly using\n   * this method.\n   */\n  elementForOverlay(overlay: Trace.Types.Overlays.Overlay): HTMLElement|null {\n    return this.#overlaysToElements.get(overlay) ?? null;\n  }\n\n  /**\n   * Removes any active overlays that match the provided type.\n   * @returns the number of overlays that were removed.\n   */\n  removeOverlaysOfType(type: Trace.Types.Overlays.Overlay['type']): number {\n    if (overlayTypeIsSingleton(type)) {\n      const singleton = this.#singletonOverlays.get(type);\n      if (singleton) {\n        this.remove(singleton);\n        return 1;\n      }\n\n      return 0;\n    }\n\n    const overlaysToRemove = Array.from(this.#overlaysToElements.keys()).filter(overlay => {\n      return overlay.type === type;\n    });\n    for (const overlay of overlaysToRemove) {\n      this.remove(overlay);\n    }\n    return overlaysToRemove.length;\n  }\n\n  /**\n   * @returns all overlays that match the provided type.\n   */\n  overlaysOfType<T extends Trace.Types.Overlays.Overlay>(type: T['type']): Array<NoInfer<T>> {\n    if (overlayTypeIsSingleton(type)) {\n      const singleton = this.#singletonOverlays.get(type);\n      if (singleton) {\n        return [singleton as T];\n      }\n\n      return [];\n    }\n\n    const matches: T[] = [];\n\n    function overlayIsOfType(overlay: Trace.Types.Overlays.Overlay): overlay is T {\n      return overlay.type === type;\n    }\n\n    for (const [overlay] of this.#overlaysToElements) {\n      if (overlayIsOfType(overlay)) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * @returns all overlays.\n   */\n  allOverlays(): Trace.Types.Overlays.Overlay[] {\n    return [...this.#overlaysToElements.keys()];\n  }\n\n  /**\n   * Removes the provided overlay from the list of overlays and destroys any\n   * DOM associated with it.\n   */\n  remove(overlay: Trace.Types.Overlays.Overlay): void {\n    const htmlElement = this.#overlaysToElements.get(overlay);\n    if (htmlElement && this.#overlaysContainer) {\n      this.#overlaysContainer.removeChild(htmlElement);\n    }\n    this.#overlaysToElements.delete(overlay);\n    if (overlayIsSingleton(overlay)) {\n      this.#singletonOverlays.delete(overlay.type);\n    }\n  }\n\n  /**\n   * Update the dimensions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: EntryChartLocation, dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: Trace.Types.Timing.TraceWindowMicro): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the previous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#overlaysToElements.clear();\n    this.#singletonOverlays.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  /**\n   * Updates the Overlays UI: new overlays will be rendered onto the view, and\n   * existing overlays will have their positions changed to ensure they are\n   * rendered in the right place.\n   */\n  async update(): Promise<void> {\n    const timeRangeOverlays: Trace.Types.Overlays.TimeRangeLabel[] = [];\n\n    for (const [overlay, existingElement] of this.#overlaysToElements) {\n      const element = existingElement || this.#createElementForNewOverlay(overlay);\n      if (!existingElement) {\n        // This is a new overlay, so we have to store the element and add it to the DOM.\n        this.#overlaysToElements.set(overlay, element);\n        this.#overlaysContainer.appendChild(element);\n      }\n\n      // A chance to update the overlay before we re-position it. If an\n      // overlay's data changed, this is where we can pass that data into the\n      // overlay's component so it has the latest data.\n      this.#updateOverlayBeforePositioning(overlay, element);\n\n      // Now we position the overlay on the timeline.\n      this.#positionOverlay(overlay, element);\n\n      // And now we give every overlay a chance to react to its new position,\n      // if it needs to\n      this.#updateOverlayAfterPositioning(overlay, element);\n\n      if (overlay.type === 'TIME_RANGE') {\n        timeRangeOverlays.push(overlay);\n      }\n    }\n\n    if (timeRangeOverlays.length > 1) {  // If there are 0 or 1 overlays, they can't overlap\n      this.#positionOverlappingTimeRangeLabels(timeRangeOverlays);\n    }\n  }\n\n  /**\n   * If any time-range overlays overlap, we try to adjust their horizontal\n   * position in order to make sure you can distinguish them and that the labels\n   * do not entirely overlap.\n   * This is very much minimal best effort, and does not guarantee that all\n   * labels will remain readable.\n   */\n  #positionOverlappingTimeRangeLabels(overlays: readonly Trace.Types.Overlays.TimeRangeLabel[]): void {\n    const overlaysSorted = overlays.toSorted((o1, o2) => {\n      return o1.bounds.min - o2.bounds.min;\n    });\n\n    // Track the overlays which overlap other overlays.\n    // This isn't bi-directional: if we find that O2 overlaps O1, we will\n    // store O1 => [O2]. We will not then also store O2 => [O1], because we\n    // only need to deal with the overlap once.\n    const overlapsByOverlay = new Map<Trace.Types.Overlays.TimeRangeLabel, Trace.Types.Overlays.TimeRangeLabel[]>();\n\n    for (let i = 0; i < overlaysSorted.length; i++) {\n      const current = overlaysSorted[i];\n      const overlaps: Trace.Types.Overlays.TimeRangeLabel[] = [];\n\n      // Walk through subsequent overlays and find stop when you find the next one that does not overlap.\n      for (let j = i + 1; j < overlaysSorted.length; j++) {\n        const next = overlaysSorted[j];\n        const currentAndNextOverlap = Trace.Helpers.Timing.boundsIncludeTimeRange({\n          bounds: current.bounds,\n          timeRange: next.bounds,\n        });\n        if (currentAndNextOverlap) {\n          overlaps.push(next);\n        } else {\n          // Overlays are sorted by time, if this one does not overlap, the next one will not, so we can break.\n          break;\n        }\n      }\n      overlapsByOverlay.set(current, overlaps);\n    }\n    for (const [firstOverlay, overlappingOverlays] of overlapsByOverlay) {\n      const element = this.#overlaysToElements.get(firstOverlay);\n      if (!element) {\n        continue;\n      }\n\n      // If the first overlay is adjusted, we can start back from 0 again\n      // rather than continually increment up.\n      let firstIndexForOverlapClass = 1;\n      if (element.getAttribute('class')?.includes('overlap-')) {\n        firstIndexForOverlapClass = 0;\n      }\n\n      overlappingOverlays.forEach(overlay => {\n        const element = this.#overlaysToElements.get(overlay);\n        element?.classList.add(`overlap-${firstIndexForOverlapClass++}`);\n      });\n    }\n  }\n\n  #positionOverlay(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    const annotationsAreHidden = this.#annotationsHiddenSetting.get();\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED': {\n        const isVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        }\n        break;\n      }\n      case 'ENTRY_OUTLINE': {\n        if (this.entryIsVisibleOnChart(overlay.entry)) {\n          this.#setOverlayElementVisibility(element, true);\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        } else {\n          this.#setOverlayElementVisibility(element, false);\n        }\n        break;\n      }\n\n      case 'TIME_RANGE': {\n        // The time range annotation can also be used to measure a selection in the timeline and is not saved if no label is added.\n        // Therefore, we only care about the annotation hidden setting if the time range has a label.\n        if (overlay.label.length) {\n          this.#setOverlayElementVisibility(element, !annotationsAreHidden);\n        }\n        this.#positionTimeRangeOverlay(overlay, element);\n        break;\n      }\n      case 'ENTRY_LABEL': {\n        const entryVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, entryVisible && !annotationsAreHidden);\n        if (entryVisible) {\n          const entryLabelVisibleHeight = this.#positionEntryLabelOverlay(overlay, element);\n          const component = element.querySelector('devtools-entry-label-overlay');\n          if (component && entryLabelVisibleHeight) {\n            component.entryLabelVisibleHeight = entryLabelVisibleHeight;\n          }\n        }\n        break;\n      }\n      case 'ENTRIES_LINK': {\n        // The exact entries that are linked to could be collapsed in a flame\n        // chart, so we figure out the best visible entry pairs to draw\n        // between.\n        const entriesToConnect = this.#calculateFromAndToForEntriesLink(overlay);\n        const isVisible = entriesToConnect !== null && !annotationsAreHidden;\n        this.#setOverlayElementVisibility(element, isVisible);\n\n        if (isVisible) {\n          this.#positionEntriesLinkOverlay(overlay, element, entriesToConnect);\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        this.#positionTimespanBreakdownOverlay(overlay, element);\n        // TODO: Have the timespan squeeze instead.\n        if (overlay.entry) {\n          const {visibleWindow} = this.#dimensions.trace;\n          const isVisible = Boolean(\n              visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n                  Trace.Helpers.Timing.boundsIncludeTimeRange({\n                    bounds: visibleWindow,\n                    timeRange: overlay.sections[0].bounds,\n                  }),\n          );\n          this.#setOverlayElementVisibility(element, isVisible);\n        }\n        break;\n      }\n\n      case 'TIMESTAMP_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // Only update the position if the timestamp of this marker is within\n        // the visible bounds.\n        const isVisible =\n            Boolean(visibleWindow && Trace.Helpers.Timing.timestampIsInBounds(visibleWindow, overlay.timestamp));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      case 'CANDY_STRIPED_TIME_RANGE': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // If the bounds of this overlay are not within the visible bounds, we\n        // can skip updating its position and just hide it.\n\n        const isVisible = Boolean(\n            visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n            Trace.Helpers.Timing.boundsIncludeTimeRange({\n              bounds: visibleWindow,\n              timeRange: overlay.bounds,\n            }));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionCandyStripedTimeRange(overlay, element);\n        }\n        break;\n      }\n\n      case 'TIMINGS_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // All the entries have the same ts, so can use the first.\n        const isVisible = Boolean(visibleWindow && this.#entryIsHorizontallyVisibleOnChart(overlay.entries[0]));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      case 'BOTTOM_INFO_BAR': {\n        this.#positionInfoBarBanner(overlay, element);\n        break;\n      }\n\n      default: {\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unknown overlay: ${JSON.stringify(overlay)}`);\n      }\n    }\n  }\n\n  #positionInfoBarBanner(\n      overlay: Trace.Types.Overlays.BottomInfoBar,\n      element: HTMLElement,\n      ): void {\n    const mainChart = this.#dimensions.charts.main;\n    if (!mainChart) {\n      this.#setOverlayElementVisibility(element, false);\n      return;\n    }\n\n    /*\n     * This calculation determines how many pixels of the bottom-positioned element\n     * (the banner) are visible within a scrollable container.\n\n     * The logic works by first calculating the number of pixels that are hidden\n     * below the current scroll position, and then subtracting that value from\n     * the total height of the banner.\n\n     * 1. totalHeight - (mainChart.scrollOffsetPixels + mainChart.heightPixels):\n     *    Calculates the number of pixels of content that are hidden below the\n     *    bottom of the viewport.\n\n     * 2. defaultBannerHeight - (hidden pixels):\n     *    Subtracts the hidden pixels from the banner's total height to find\n     *    the remaining, visible portion.\n     */\n\n    // By default an Infobar is 40px high. But when it comes to rendering it\n    // might be higher if the infobar is wrapped; so we adjust the actual\n    // number of visible pixels later on.\n    // We can't use the real value in the calculation because when its hidden\n    // it has a height of 0, which means we'd never calculate the right values.\n    const defaultBannerHeight = 40;\n    const totalHeight = this.#charts.mainChart.totalContentHeight();\n    const pixelsHiddenBelowViewport = totalHeight - (mainChart.scrollOffsetPixels + mainChart.heightPixels);\n    const visiblePixelsOfBanner = defaultBannerHeight - pixelsHiddenBelowViewport;\n\n    if (visiblePixelsOfBanner <= 0) {\n      this.#setOverlayElementVisibility(element, false);\n      return;\n    }\n\n    this.#setOverlayElementVisibility(element, true);\n\n    // Now we adjust our calculation based on the actual size of the infobar\n    // (it has height as now it's visible on the screen)\n    // We do this by removing the default banner height (to reset our\n    // calculation back to \"0\") and adding the actual height.\n    const actualBannerHeight = overlay.infobar.element.clientHeight;\n    const adjustedVisiblePixels = visiblePixelsOfBanner - defaultBannerHeight + actualBannerHeight;\n    // Use Math.min here to ensure the infobar never grows beyond the size it\n    // needs to be. Without this we make the infobar fill all available space\n    // in the canvas, but we want it to stay the right size and stuck to the\n    // bottom.\n    element.style.height = `${Math.min(adjustedVisiblePixels, actualBannerHeight)}px`;\n\n    // So it doesn't overlap the right scrollbar.\n    if (this.#charts.mainChart.verticalScrollBarVisible()) {\n      element.style.right = '11px';\n    } else {\n      element.style.right = '0';\n    }\n  }\n\n  #positionTimingOverlay(\n      overlay: Trace.Types.Overlays.TimestampMarker|Trace.Types.Overlays.TimingsMarker, element: HTMLElement): void {\n    let left;\n    switch (overlay.type) {\n      case 'TIMINGS_MARKER': {\n        // All the entries have the same ts, so can use the first.\n        const timings = Trace.Helpers.Timing.eventTimingsMicroSeconds(overlay.entries[0]);\n        left = this.#xPixelForMicroSeconds('main', timings.startTime);\n        break;\n      }\n      case 'TIMESTAMP_MARKER': {\n        // Because we are adjusting the x position, we can use either chart here.\n        left = this.#xPixelForMicroSeconds('main', overlay.timestamp);\n        break;\n      }\n    }\n    element.style.left = `${left}px`;\n  }\n\n  #positionTimespanBreakdownOverlay(overlay: Trace.Types.Overlays.TimespanBreakdown, element: HTMLElement): void {\n    if (overlay.sections.length === 0) {\n      return;\n    }\n\n    const component = element.querySelector('devtools-timespan-breakdown-overlay');\n    const elementSections = component?.renderedSections() ?? [];\n\n    // Handle horizontal positioning.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.sections[0].bounds.min);\n    const rightEdgePixel =\n        this.#xPixelForMicroSeconds('main', overlay.sections[overlay.sections.length - 1].bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n\n    if (elementSections.length === 0) {\n      return;\n    }\n\n    let count = 0;\n    for (const section of overlay.sections) {\n      const leftPixel = this.#xPixelForMicroSeconds('main', section.bounds.min);\n      const rightPixel = this.#xPixelForMicroSeconds('main', section.bounds.max);\n      if (leftPixel === null || rightPixel === null) {\n        return;\n      }\n      const rangeWidth = rightPixel - leftPixel;\n      const sectionElement = elementSections[count];\n\n      sectionElement.style.left = `${leftPixel}px`;\n      sectionElement.style.width = `${rangeWidth}px`;\n      count++;\n    }\n\n    // Handle vertical positioning based on the entry's vertical position.\n    if (overlay.entry && (overlay.renderLocation === 'BELOW_EVENT' || overlay.renderLocation === 'ABOVE_EVENT')) {\n      // Max height for the overlay box when attached to an entry.\n      const MAX_BOX_HEIGHT = 50;\n      element.style.maxHeight = `${MAX_BOX_HEIGHT}px`;\n\n      const y = this.yPixelForEventOnChart(overlay.entry);\n      if (y === null) {\n        return;\n      }\n      const eventHeight = this.pixelHeightForEventOnChart(overlay.entry);\n      if (eventHeight === null) {\n        return;\n      }\n\n      if (overlay.renderLocation === 'BELOW_EVENT') {\n        const top = y + eventHeight;\n        element.style.top = `${top}px`;\n      } else {\n        // Some padding so the box hovers just on top.\n        const PADDING = 7;\n\n        // Where the timespan breakdown should sit. Slightly on top of the entry.\n        const bottom = y - PADDING;\n\n        // Available space between the bottom of the overlay and top of the chart.\n        const minSpace = Math.max(bottom, 0);\n        // Constrain height to available space.\n        const height = Math.min(MAX_BOX_HEIGHT, minSpace);\n\n        const top = bottom - height;\n        element.style.top = `${top}px`;\n      }\n    }\n  }\n\n  /**\n   * Positions the arrow between two entries. Takes in the entriesToConnect\n   * because if one of the original entries is hidden in a collapsed main thread\n   * icicle, we use its parent to connect to.\n   */\n  #positionEntriesLinkOverlay(\n      overlay: Trace.Types.Overlays.EntriesLink, element: HTMLElement,\n      entriesToConnect: EntriesLinkVisibleEntries): void {\n    const component = element.querySelector('devtools-entries-link-overlay');\n\n    if (component) {\n      const fromEntryInCollapsedTrack = this.#entryIsInCollapsedTrack(entriesToConnect.entryFrom);\n      const toEntryInCollapsedTrack =\n          entriesToConnect.entryTo && this.#entryIsInCollapsedTrack(entriesToConnect.entryTo);\n\n      const bothEntriesInCollapsedTrack = Boolean(fromEntryInCollapsedTrack && toEntryInCollapsedTrack);\n      // If both entries are in collapsed tracks, we hide the overlay completely.\n      if (bothEntriesInCollapsedTrack) {\n        this.#setOverlayElementVisibility(element, false);\n        return;\n      }\n\n      // If either entry (but not both) is in a track that the user has collapsed, we do not\n      // show the connection at all, but we still show the borders around\n      // the entry. So in this case we mark the overlay as visible, but\n      // tell it to not draw the arrow.\n      const hideArrow = Boolean(fromEntryInCollapsedTrack || toEntryInCollapsedTrack);\n      component.hideArrow = hideArrow;\n\n      const {entryFrom, entryTo, entryFromIsSource, entryToIsSource} = entriesToConnect;\n      const entryFromWrapper = component.entryFromWrapper();\n\n      // Should not happen, the 'from' wrapper should always exist. Something went wrong, return in this case.\n      if (!entryFromWrapper) {\n        return;\n      }\n\n      const entryFromVisibility = this.entryIsVisibleOnChart(entryFrom) && !fromEntryInCollapsedTrack;\n      const entryToVisibility = entryTo ? this.entryIsVisibleOnChart(entryTo) && !toEntryInCollapsedTrack : false;\n\n      // If the entry is not currently visible, draw the arrow to the edge of the screen towards the entry on the Y-axis.\n      let fromEntryX = 0;\n      let fromEntryY = this.#yCoordinateForNotVisibleEntry(entryFrom);\n\n      // If the entry is visible, draw the arrow to the entry.\n      if (entryFromVisibility) {\n        const fromEntryParams = this.#positionEntryBorderOutlineType(entriesToConnect.entryFrom, entryFromWrapper);\n        if (fromEntryParams) {\n          const fromEntryHeight = fromEntryParams?.entryHeight;\n          const fromEntryWidth = fromEntryParams?.entryWidth;\n          const fromCutOffHeight = fromEntryParams?.cutOffHeight;\n          fromEntryX = fromEntryParams?.x;\n          fromEntryY = fromEntryParams?.y;\n\n          component.fromEntryCoordinateAndDimensions =\n              {x: fromEntryX, y: fromEntryY, length: fromEntryWidth, height: fromEntryHeight - fromCutOffHeight};\n        } else {\n          // Something went if the entry is visible and we cannot get its' parameters.\n          return;\n        }\n      }\n\n      // If `fromEntry` is not visible and the link creation is not started yet, meaning that\n      // only the button to create the link is displayed, delete the whole overlay.\n      if (!entryFromVisibility && overlay.state === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n        this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n      }\n\n      // If entryTo exists, pass the coordinates and dimensions of the entry that the arrow snaps to.\n      // If it does not, the event tracking mouse coordinates updates 'to coordinates' so the arrow follows the mouse instead.\n      const entryToWrapper = component.entryToWrapper();\n\n      if (entryTo && entryToWrapper) {\n        let toEntryX = this.xPixelForEventStartOnChart(entryTo) ?? 0;\n        // If the 'to' entry is visible, set the entry Y as an arrow coordinate to point to. If not, get the canvas edge coordate to point the arrow to.\n        let toEntryY = this.#yCoordinateForNotVisibleEntry(entryTo);\n        const toEntryParams = this.#positionEntryBorderOutlineType(entryTo, entryToWrapper);\n\n        if (toEntryParams) {\n          const toEntryHeight = toEntryParams?.entryHeight;\n          const toEntryWidth = toEntryParams?.entryWidth;\n          const toCutOffHeight = toEntryParams?.cutOffHeight;\n          toEntryX = toEntryParams?.x;\n          toEntryY = toEntryParams?.y;\n\n          component.toEntryCoordinateAndDimensions = {\n            x: toEntryX,\n            y: toEntryY,\n            length: toEntryWidth,\n            height: toEntryHeight - toCutOffHeight,\n          };\n        } else {\n          // if the entry exists and we cannot get its' parameters, it is probably loaded and is off screen.\n          // In this case, assign the coordinates so we can draw the arrow in the right direction.\n          component.toEntryCoordinateAndDimensions = {\n            x: toEntryX,\n            y: toEntryY,\n          };\n          return;\n        }\n\n      } else {\n        // If the 'to' entry does not exist, the link is being created.\n        // The second coordinate for in progress link gets updated on mousemove\n        this.#entriesLinkInProgress = overlay;\n      }\n\n      component.fromEntryIsSource = entryFromIsSource;\n      component.toEntryIsSource = entryToIsSource;\n      component.entriesVisibility = {\n        fromEntryVisibility: entryFromVisibility,\n        toEntryVisibility: entryToVisibility,\n      };\n    }\n  }\n\n  /**\n   *  Return Y coordinate for an arrow connecting 2 entries to attach to if the entry is not visible.\n   *  For example, if the entry is scrolled up from the visible area , return the y index of the edge of the track:\n   *  --\n   * |  | - entry off the visible chart\n   *  --\n   *\n   * --Y---------------  -- Y is the returned coordinate that the arrow should point to\n   *\n   * flamechart data     -- visible flamechart data between the 2 lines\n   * ------------------\n   *\n   * On the contrary, if the entry is scrolled off the bottom, get the coordinate of the top of the visible canvas.\n   */\n  #yCoordinateForNotVisibleEntry(entry: Trace.Types.Overlays.OverlayEntry): number {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return 0;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return 0;\n      }\n\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position is less than 0. If it, the entry is off the top of the track canvas.\n      // In that case, return the height of network track, which is also the top of main track.\n      if (yWithoutNetwork < 0) {\n        return this.networkChartOffsetHeight();\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        return 0;\n      }\n\n      // The event is off the bottom of the network chart. In this case return the bottom of the network chart.\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        return this.#dimensions.charts.network.heightPixels;\n      }\n    }\n\n    // In other cases, return the y of the entry\n    return y;\n  }\n\n  #positionTimeRangeOverlay(overlay: Trace.Types.Overlays.TimeRangeLabel, element: HTMLElement): void {\n    // Time ranges span both charts, it doesn't matter which one we pass here.\n    // It's used to get the width of the container, and both charts have the\n    // same width.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.min);\n    const rightEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n  }\n\n  /**\n   * @param overlay the EntrySelected overlay that we need to position.\n   * @param element the DOM element representing the overlay\n   */\n  #positionEntryLabelOverlay(overlay: Trace.Types.Overlays.EntryLabel, element: HTMLElement): number|null {\n    // Because the entry outline is a common Overlay pattern, get the wrapper of the entry\n    // that comes with the Trace.Types.Overlays.EntryLabel Overlay and pass it into the `positionEntryBorderOutlineType`\n    // to draw and position it. The other parts of Trace.Types.Overlays.EntryLabel are drawn by the `EntryLabelOverlay` class.\n    const component = element.querySelector('devtools-entry-label-overlay');\n    if (!component) {\n      return null;\n    }\n    const entryWrapper = component.entryHighlightWrapper();\n    const inputField = component.shadowRoot?.querySelector<HTMLElement>('.input-field');\n\n    if (!entryWrapper) {\n      return null;\n    }\n\n    const {entryHeight, entryWidth, cutOffHeight = 0, x, y} =\n        this.#positionEntryBorderOutlineType(overlay.entry, entryWrapper) || {};\n\n    if (!entryHeight || !entryWidth || x === null || !y) {\n      return null;\n    }\n\n    // Use the actual inputfield height to position the overlay, with a default value in case the element has not yet been rendered.\n    const inputFieldHeight = inputField?.offsetHeight ?? 25;\n    // Position the start of label overlay at the start of the entry + length of connector + length of the label element\n    element.style.top =\n        `${y - Components.EntryLabelOverlay.EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT - inputFieldHeight}px`;\n    element.style.left = `${x}px`;\n    element.style.width = `${entryWidth}px`;\n\n    return entryHeight - cutOffHeight;\n  }\n\n  #positionCandyStripedTimeRange(overlay: Trace.Types.Overlays.CandyStripedTimeRange, element: HTMLElement): void {\n    const chartName = chartForEntry(overlay.entry);\n\n    const startX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.min);\n    const endX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.max);\n    if (startX === null || endX === null) {\n      return;\n    }\n\n    const widthPixels = endX - startX;\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n    element.style.left = `${startX}px`;\n\n    let y = this.yPixelForEventOnChart(overlay.entry);\n    if (y === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overlay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the event going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      const cutOffTop = y > networkHeight;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n  }\n\n  /**\n   * Draw and position borders around an entry. Multiple overlays either fully consist\n   * of a border around an entry of have an entry border as a part of the overlay.\n   * Positions an EntrySelected or EntryOutline overlay and a part of the Trace.Types.Overlays.EntryLabel.\n   * @param overlay the EntrySelected/EntryOutline/Trace.Types.Overlays.EntryLabel overlay that we need to position.\n   * @param element the DOM element representing the overlay\n   */\n  #positionEntryBorderOutlineType(entry: Trace.Types.Overlays.OverlayEntry, element: HTMLElement):\n      {entryHeight: number, entryWidth: number, cutOffHeight: number, x: number, y: number}|null {\n    const chartName = chartForEntry(entry);\n    let x = this.xPixelForEventStartOnChart(entry);\n    let y = this.yPixelForEventOnChart(entry);\n    const chartWidth = (chartName === 'main') ? this.#dimensions.charts.main?.widthPixels :\n                                                this.#dimensions.charts.network?.widthPixels;\n\n    if (x === null || y === null || !chartWidth) {\n      return null;\n    }\n\n    const {endTime} = timingsForOverlayEntry(entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    if (endX === null) {\n      return null;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return null;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    let widthPixels = endX - x;\n\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const index = provider.indexForEvent?.(entry);\n    const customPos = chart.getCustomDrawnPositionForEntryIndex(index ?? -1);\n    if (customPos) {\n      // Some events like markers and layout shifts define their exact coordinates explicitly.\n      // If this is one of those events we should change the overlay coordinates to match.\n      x = customPos.x;\n      widthPixels = customPos.width;\n    }\n\n    // Calculate the visible overlay width by subtracting the entry width that is outside of the flamechart width\n    const cutOffRight = (x + widthPixels > chartWidth) ? (x + widthPixels) - chartWidth : null;\n    const cutOffLeft = (x < 0) ? Math.abs(x) : null;\n    element.classList.toggle('cut-off-right', cutOffRight !== null);\n\n    if (cutOffRight) {\n      widthPixels = widthPixels - cutOffRight;\n    }\n\n    if (cutOffLeft) {\n      // If the entry is cut off from the left, move its beginning to the left most part of the flamechart\n      x = 0;\n      widthPixels = widthPixels - cutOffLeft;\n    }\n\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overlay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${x}px`;\n\n    return {entryHeight: totalHeight, entryWidth: finalWidth, cutOffHeight: totalHeight - height, x, y};\n  }\n\n  /**\n   * We draw an arrow between connected entries but this can get complicated\n   * depending on if the entries are visible or not. For example, the user might\n   * draw a connection to an entry in the main thread but then collapse the\n   * parent of that entry. In this case the entry we want to draw to is the\n   * first visible parent of that entry rather than the (invisible) entry.\n   */\n  #calculateFromAndToForEntriesLink(overlay: Trace.Types.Overlays.EntriesLink): EntriesLinkVisibleEntries|null {\n    if (!overlay.entryTo) {\n      // This case is where the user has clicked on the first entry and needs\n      // to pick a second. In this case they can only pick from visible\n      // entries, so we don't need to do any checks and can just return.\n      return {\n        entryFrom: overlay.entryFrom,\n        entryTo: overlay.entryTo,\n        entryFromIsSource: true,\n        entryToIsSource: true,\n      };\n    }\n\n    let entryFrom: Trace.Types.Overlays.OverlayEntry|null = overlay.entryFrom;\n    let entryTo: Trace.Types.Overlays.OverlayEntry|null = overlay.entryTo ?? null;\n\n    if (this.#queries.isEntryCollapsedByUser(overlay.entryFrom)) {\n      entryFrom = this.#queries.firstVisibleParentForEntry(overlay.entryFrom);\n    }\n    if (overlay.entryTo && this.#queries.isEntryCollapsedByUser(overlay.entryTo)) {\n      entryTo = this.#queries.firstVisibleParentForEntry(overlay.entryTo);\n    }\n\n    if (entryFrom === null || entryTo === null) {\n      // We cannot draw this overlay; so return null;\n      // The only valid case of entryTo being null/undefined has been dealt\n      // with already at the start of this function.\n      return null;\n    }\n\n    return {\n      entryFrom,\n      entryFromIsSource: entryFrom === overlay.entryFrom,\n      entryTo,\n      entryToIsSource: entryTo === overlay.entryTo,\n    };\n  }\n\n  // Dimms all label annotations except the one that is hovered over in the timeline or sidebar.\n  // The highlighter annotation is brought forward.\n  highlightOverlay(overlay: Trace.Types.Overlays.EntryLabel): void {\n    const allLabelOverlays = this.overlaysOfType('ENTRY_LABEL');\n    for (const otherOverlay of allLabelOverlays) {\n      const element = this.elementForOverlay(otherOverlay);\n      const component = element?.querySelector('devtools-entry-label-overlay');\n      if (element && !component?.hasAttribute('data-user-editing-label')) {\n        if (otherOverlay === overlay) {\n          element.style.opacity = '1';\n          element.style.zIndex = '3';\n        } else {\n          element.style.opacity = '0.5';\n          element.style.zIndex = '2';\n        }\n      }\n    }\n  }\n\n  undimAllEntryLabels(): void {\n    const allLabelOverlays = this.overlaysOfType('ENTRY_LABEL');\n    for (const otherOverlay of allLabelOverlays) {\n      const element = this.elementForOverlay(otherOverlay);\n      if (element) {\n        element.style.opacity = '1';\n        element.style.zIndex = '2';\n      }\n    }\n  }\n\n  #createElementForNewOverlay(overlay: Trace.Types.Overlays.Overlay): HTMLElement {\n    const overlayElement = document.createElement('div');\n    overlayElement.classList.add('overlay-item', `overlay-type-${overlay.type}`);\n\n    const jslogContext = jsLogContext(overlay);\n    if (jslogContext) {\n      overlayElement.setAttribute('jslog', `${VisualLogging.item(jslogContext)}`);\n    }\n\n    switch (overlay.type) {\n      case 'ENTRY_LABEL': {\n        const shouldDrawLabelBelowEntry = Trace.Types.Events.isLegacyTimelineFrame(overlay.entry);\n        const component = new Components.EntryLabelOverlay.EntryLabelOverlay(overlay.label, shouldDrawLabelBelowEntry);\n        // Generate the AI Call Tree for the AI Auto-Annotation feature.\n        const parsedTrace = this.#queries.parsedTrace();\n        const callTree = parsedTrace ? Utils.AICallTree.AICallTree.fromEvent(overlay.entry, parsedTrace) : null;\n        component.callTree = callTree;\n\n        component.addEventListener(\n            Components.EntryLabelOverlay.LabelAnnotationsConsentDialogVisibilityChange.eventName, e => {\n              const event = e as Components.EntryLabelOverlay.LabelAnnotationsConsentDialogVisibilityChange;\n              this.dispatchEvent(new ConsentDialogVisibilityChange(event.isVisible));\n            });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.EntryLabelOverlay.EntryLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        overlayElement.addEventListener('mouseover', () => {\n          this.highlightOverlay(overlay);\n        });\n        overlayElement.addEventListener('mouseout', () => {\n          this.undimAllEntryLabels();\n        });\n        overlayElement.appendChild(component);\n        overlayElement.addEventListener('click', event => {\n          event.preventDefault();\n          event.stopPropagation();\n          this.dispatchEvent(new EntryLabelMouseClick(overlay));\n        });\n        return overlayElement;\n      }\n      case 'ENTRIES_LINK': {\n        const entries = this.#calculateFromAndToForEntriesLink(overlay);\n        if (entries === null) {\n          // For some reason, we don't have two entries we can draw between\n          // (can happen if the user has collapsed an icicle in the flame\n          // chart, or a track), so just draw an empty div.\n          return overlayElement;\n        }\n        const entryEndX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartY = (this.yPixelForEventOnChart(entries.entryFrom) ?? 0);\n        const entryWidth = entryEndX - entryStartX;\n        const entryHeight = this.pixelHeightForEventOnChart(entries.entryFrom) ?? 0;\n\n        const component = new Components.EntriesLinkOverlay.EntriesLinkOverlay(\n            {x: entryEndX, y: entryStartY, width: entryWidth, height: entryHeight}, overlay.state);\n\n        component.addEventListener(Components.EntriesLinkOverlay.EntryLinkStartCreating.eventName, () => {\n          overlay.state = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'ENTRY_OUTLINE': {\n        overlayElement.classList.add(`outline-reason-${overlay.outlineReason}`);\n        return overlayElement;\n      }\n      case 'TIME_RANGE': {\n        const component = new Components.TimeRangeOverlay.TimeRangeOverlay(overlay.label);\n        component.duration = overlay.showDuration ? overlay.bounds.range : null;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.TimeRangeOverlay.TimeRangeLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener('mouseover', () => {\n          this.dispatchEvent(new TimeRangeMouseOverEvent(overlay));\n        });\n        component.addEventListener('mouseout', () => {\n          this.dispatchEvent(new TimeRangeMouseOutEvent());\n        });\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = new Components.TimespanBreakdownOverlay.TimespanBreakdownOverlay();\n        component.sections = overlay.sections;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.isBelowEntry = overlay.renderLocation === 'BELOW_EVENT';\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'TIMINGS_MARKER': {\n        const {color} = Trace.Styles.markerDetailsForEvent(overlay.entries[0]);\n        const markersComponent = this.#createTimingsMarkerElement(overlay);\n        overlayElement.appendChild(markersComponent);\n        overlayElement.style.backgroundColor = color;\n        return overlayElement;\n      }\n      default: {\n        return overlayElement;\n      }\n    }\n  }\n\n  #clickEvent(event: Trace.Types.Events.Event): void {\n    this.dispatchEvent(new EventReferenceClick(event));\n  }\n\n  #createOverlayPopover(\n      adjustedTimestamp: Trace.Types.Timing.Micro, name: string,\n      fieldResult: Trace.Types.Overlays.TimingsMarkerFieldResult|undefined): HTMLElement {\n    const popoverElement = document.createElement('div');\n    const popoverContents = popoverElement.createChild('div', 'overlay-popover');\n    popoverContents.createChild('span', 'overlay-popover-time').textContent =\n        i18n.TimeUtilities.formatMicroSecondsTime(adjustedTimestamp);\n    popoverContents.createChild('span', 'overlay-popover-title').textContent =\n        fieldResult ? i18nString(UIStrings.fieldMetricMarkerLocal, {PH1: name}) : name;\n\n    // If there's field data, make another row.\n    if (fieldResult) {\n      const popoverContents = popoverElement.createChild('div', 'overlay-popover');\n      popoverContents.createChild('span', 'overlay-popover-time').textContent =\n          i18n.TimeUtilities.formatMicroSecondsTime(fieldResult.value);\n      let scope: string = fieldResult.pageScope;\n      if (fieldResult.pageScope === 'url') {\n        scope = i18nString(UIStrings.urlOption);\n      } else if (fieldResult.pageScope === 'origin') {\n        scope = i18nString(UIStrings.originOption);\n      }\n      popoverContents.createChild('span', 'overlay-popover-title').textContent =\n          i18nString(UIStrings.fieldMetricMarkerField, {\n            PH1: name,\n            PH2: scope,\n          });\n    }\n\n    return popoverElement;\n  }\n\n  #mouseMoveOverlay(\n      e: MouseEvent, event: Trace.Types.Events.PageLoadEvent, name: string, overlay: Trace.Types.Overlays.TimingsMarker,\n      markers: HTMLElement, marker: HTMLElement): void {\n    const fieldResult = overlay.entryToFieldResult.get(event);\n    const popoverElement = this.#createOverlayPopover(overlay.adjustedTimestamp, name, fieldResult);\n    this.#lastMouseOffsetX = e.offsetX + (markers.offsetLeft || 0) + (marker.offsetLeft || 0);\n    this.#lastMouseOffsetY = e.offsetY + markers.offsetTop || 0;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.updatePopoverContents(popoverElement);\n  }\n\n  #mouseOutOverlay(): void {\n    this.#lastMouseOffsetX = -1;\n    this.#lastMouseOffsetY = -1;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.hideHighlight();\n  }\n\n  #createTimingsMarkerElement(overlay: Trace.Types.Overlays.TimingsMarker): HTMLElement {\n    const markers = document.createElement('div');\n    markers.classList.add('markers');\n    for (const entry of overlay.entries) {\n      const {color, title} = Trace.Styles.markerDetailsForEvent(entry);\n      const marker = document.createElement('div');\n      marker.classList.add('marker-title');\n      marker.textContent = title;\n      marker.style.backgroundColor = color;\n      markers.appendChild(marker);\n\n      marker.addEventListener('click', () => this.#clickEvent(entry));\n      // Popover.\n      marker.addEventListener('mousemove', e => this.#mouseMoveOverlay(e, entry, title, overlay, markers, marker));\n      marker.addEventListener('mouseout', () => this.#mouseOutOverlay());\n    }\n    return markers;\n  }\n\n  /**\n   * Some overlays store data in their components that needs to be updated\n   * before we position an overlay. Else, we might position an overlay based on\n   * stale data. This method is used to update an overlay BEFORE it is then\n   * positioned onto the canvas. It is the right place to ensure an overlay has\n   * the latest data it needs.\n   */\n  #updateOverlayBeforePositioning(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.duration = overlay.showDuration ? overlay.bounds.range : null;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'ENTRY_LABEL':\n      case 'ENTRY_OUTLINE':\n      case 'ENTRIES_LINK': {\n        const component = element.querySelector('devtools-entries-link-overlay');\n        if (component) {\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        if (component) {\n          component.sections = overlay.sections;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      case 'BOTTOM_INFO_BAR': {\n        if (element.contains(overlay.infobar.element)) {\n          return;\n        }\n\n        // This overlay is a singleton; this means it could be updated with a\n        // different info bar. So we need to clear out the existing contents\n        // before appending the infobar, just in case.\n        element.innerHTML = '';\n        element.appendChild(overlay.infobar.element);\n      }\n\n      break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n  /**\n   * Some overlays have custom logic within them to manage visibility of\n   * labels/etc that can be impacted if the positioning or size of the overlay\n   * has changed. This method can be used to run code after an overlay has\n   * been updated + repositioned on the timeline.\n   */\n  #updateOverlayAfterPositioning(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        component?.updateLabelPositioning();\n        break;\n      }\n      case 'ENTRY_LABEL':\n        break;\n      case 'ENTRY_OUTLINE':\n        break;\n      case 'ENTRIES_LINK':\n        break;\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        component?.checkSectionLabelPositioning();\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      case 'BOTTOM_INFO_BAR':\n        break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n\n  /**\n   * @returns true if the entry is visible on chart, which means that both\n   * horizontally and vertically it is at least partially in view.\n   */\n  entryIsVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const verticallyVisible = this.#entryIsVerticallyVisibleOnChart(entry);\n    const horiziontallyVisible = this.#entryIsHorizontallyVisibleOnChart(entry);\n    return verticallyVisible && horiziontallyVisible;\n  }\n\n  /**\n   * Calculates if an entry is visible horizontally. This is easy because we\n   * don't have to consider any pixels and can instead check that its start and\n   * end times intersect with the visible window.\n   */\n  #entryIsHorizontallyVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      return false;\n    }\n    const {startTime, endTime} = timingsForOverlayEntry(entry);\n\n    const entryTimeRange = Trace.Helpers.Timing.traceWindowFromMicroSeconds(startTime, endTime);\n\n    return Trace.Helpers.Timing.boundsIncludeTimeRange({\n      bounds: this.#dimensions.trace.visibleWindow,\n      timeRange: entryTimeRange,\n    });\n  }\n\n  #entryIsInCollapsedTrack(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const entryIndex = provider.indexForEvent?.(entry) ?? null;\n    if (entryIndex === null) {\n      return false;\n    }\n\n    const group = provider.groupForEvent?.(entryIndex) ?? null;\n    if (!group) {\n      return false;\n    }\n\n    return Boolean(group.expanded) === false;\n  }\n\n  /**\n   * Calculate if an entry is visible vertically on the chart. A bit fiddly as\n   * we have to figure out its pixel offset and go on that. Unlike horizontal\n   * visibility, we can't work solely from its microsecond values.\n   */\n  #entryIsVerticallyVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return false;\n    }\n\n    const eventHeight = this.pixelHeightForEventOnChart(entry);\n    if (!eventHeight) {\n      return false;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return false;\n      }\n\n      // The yPixelForEventOnChart method returns the y pixel including an adjustment for the network track.\n      // To see if an entry on the main flame chart is visible, we can check\n      // its y value without the network track adjustment. If it is < 0, then\n      // it's off the top of the screen.\n      //\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position + the height is less than 0. We add height so\n      // that we correctly consider an event only partially scrolled off to be\n      // visible.\n      if (yWithoutNetwork + eventHeight < 0) {\n        return false;\n      }\n\n      if (yWithoutNetwork > this.#dimensions.charts.main.heightPixels) {\n        // The event is off the bottom of the screen.\n        return false;\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        // The network chart can be hidden if there are no requests in the trace.\n        return false;\n      }\n      if (y <= -14) {\n        // Weird value, but the network chart has the header row with\n        // timestamps on it: events stay visible behind those timestamps, so we\n        // want any overlays to treat themselves as visible too.\n        return false;\n      }\n\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        // The event is off the bottom of the network chart.\n        return false;\n      }\n    }\n    // If we got here, none of the conditions to mark an event as invisible got\n    // triggered, so the event must be visible.\n    return true;\n  }\n\n  /**\n   * Calculate the X pixel position for an event start on the timeline.\n   * @param chartName the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   * @param event the trace event you want to get the pixel position of\n   */\n  xPixelForEventStartOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {startTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, startTime);\n  }\n\n  /**\n   * Calculate the X pixel position for an event end on the timeline.\n   * @param chartName the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   * @param event the trace event you want to get the pixel position of\n   */\n  xPixelForEventEndOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {endTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, endTime);\n  }\n\n  /**\n   * Calculate the xPixel for a given timestamp. To do this we calculate how\n   * far in microseconds from the left of the visible window an event is, and\n   * divide that by the total time span. This gives us a fraction representing\n   * how far along the timeline the event is. We can then multiply that by the\n   * width of the canvas to get its pixel position.\n   */\n  #xPixelForMicroSeconds(chart: EntryChartLocation, timestamp: Trace.Types.Timing.Micro): number|null {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      console.error('Cannot calculate xPixel without visible trace window.');\n      return null;\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (canvasWidthPixels === null) {\n      console.error(`Cannot calculate xPixel without ${chart} dimensions.`);\n      return null;\n    }\n\n    const timeFromLeft = timestamp - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n\n  /**\n   * Calculate the Y pixel position for the event on the timeline relative to\n   * the entire window.\n   * This means if the event is in the main flame chart and below the network,\n   * we add the height of the network chart to the Y value to position it\n   * correctly.\n   * This can return null if any data was missing, or if the event is not\n   * visible (if the level it's on is hidden because the track is collapsed,\n   * for example)\n   */\n  yPixelForEventOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n\n    if (!chart.levelIsVisible(level)) {\n      return null;\n    }\n\n    const pixelOffsetForLevel = chart.levelToOffset(level);\n    // Now we have the offset for the level, we need to adjust it by the user's scroll offset.\n    let pixelAdjustedForScroll = pixelOffsetForLevel - (this.#dimensions.charts[chartName]?.scrollOffsetPixels ?? 0);\n\n    // Now if the event is in the main chart, we need to pad its Y position\n    // down by the height of the network chart + the network resize element.\n    if (chartName === 'main') {\n      pixelAdjustedForScroll += this.networkChartOffsetHeight();\n    }\n\n    return pixelAdjustedForScroll;\n  }\n\n  /**\n   * Calculate the height of the event on the timeline.\n   */\n  pixelHeightForEventOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n    return chart.levelHeight(level);\n  }\n\n  /**\n   * Calculate the height of the network chart. If the network chart has\n   * height, we also allow for the size of the resize handle shown between the\n   * two charts.\n   *\n   * Note that it is possible for the chart to have 0 height if the user is\n   * looking at a trace with no network requests.\n   */\n  networkChartOffsetHeight(): number {\n    if (this.#dimensions.charts.network === null) {\n      return 0;\n    }\n\n    if (this.#dimensions.charts.network.heightPixels === 0) {\n      return 0;\n    }\n\n    // At this point we know the network track exists and has height. But we\n    // need to check if it is collapsed, because if it is collapsed there is no\n    // resizer shown.\n    if (this.#dimensions.charts.network.allGroupsCollapsed) {\n      return this.#dimensions.charts.network.heightPixels;\n    }\n\n    return this.#dimensions.charts.network.heightPixels + NETWORK_RESIZE_ELEM_HEIGHT_PX;\n  }\n\n  /**\n   * Hides or shows an element. We used to use visibility rather than display,\n   * but a child of an element with visibility: hidden may still be visible if\n   * its own `display` property is set.\n   */\n  #setOverlayElementVisibility(element: HTMLElement, isVisible: boolean): void {\n    element.style.display = isVisible ? 'block' : 'none';\n  }\n}\n\n/**\n * Because entries can be a TimelineFrame, which is not a trace event, this\n * helper exists to return a consistent set of timings regardless of the type\n * of entry.\n */\nexport function timingsForOverlayEntry(entry: Trace.Types.Overlays.OverlayEntry):\n    Trace.Helpers.Timing.EventTimingsData<Trace.Types.Timing.Micro> {\n  if (Trace.Types.Events.isLegacyTimelineFrame(entry)) {\n    return {\n      startTime: entry.startTime,\n      endTime: entry.endTime,\n      duration: entry.duration,\n    };\n  }\n  return Trace.Helpers.Timing.eventTimingsMicroSeconds(entry);\n}\n\n/**\n * Defines if the overlay container `div` should have a jslog context attached.\n * Note that despite some of the overlays being used currently exclusively\n * for annotations, we log here with `overlays` to be generic as overlays can\n * be used for insights, annotations or in the future, who knows...\n */\nexport function jsLogContext(overlay: Trace.Types.Overlays.Overlay): string|null {\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      // No jslog for this; it would be very noisy and not very useful.\n      return null;\n    }\n    case 'ENTRY_OUTLINE': {\n      return `timeline.overlays.entry-outline-${Platform.StringUtilities.toKebabCase(overlay.outlineReason)}`;\n    }\n    case 'ENTRY_LABEL': {\n      return 'timeline.overlays.entry-label';\n    }\n    case 'ENTRIES_LINK': {\n      // do not log impressions for incomplete entry links\n      if (overlay.state !== Trace.Types.File.EntriesLinkState.CONNECTED) {\n        return null;\n      }\n      return 'timeline.overlays.entries-link';\n    }\n    case 'TIME_RANGE': {\n      return 'timeline.overlays.time-range';\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      return 'timeline.overlays.timespan-breakdown';\n    }\n    case 'TIMESTAMP_MARKER': {\n      return 'timeline.overlays.cursor-timestamp-marker';\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      return 'timeline.overlays.candy-striped-time-range';\n    }\n    case 'TIMINGS_MARKER': {\n      return 'timeline.overlays.timings-marker';\n    }\n    case 'BOTTOM_INFO_BAR':\n      return 'timeline.overlays.info-bar';\n    default:\n      Platform.assertNever(overlay, 'Unknown overlay type');\n  }\n}\n"],
  "mappings": "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",
  "names": ["element", "rangeWidth", "popoverContents"]
}
