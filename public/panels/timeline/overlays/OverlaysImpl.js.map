{"version":3,"file":"OverlaysImpl.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/overlays/OverlaysImpl.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as TraceEngine from '../../../models/trace/trace.js';\nimport type * as PerfUI from '../../../ui/legacy/components/perf_ui/perf_ui.js';\n\nimport * as Components from './components/components.js';\n\n// Bit of a hack: LayoutShifts are instant events, so have no duration. But\n// OPP doesn't do well at making tiny events easy to spot and click. So we\n// set it to a small duration so that the user is able to see and click\n// them more easily. Long term we will explore a better UI solution to\n// allow us to do this properly and not hack around it.\nexport const LAYOUT_SHIFT_SYNTHETIC_DURATION = TraceEngine.Types.Timing.MicroSeconds(5_000);\n\n/**\n * Below the network track there is a resize bar the user can click and drag.\n */\nconst NETWORK_RESIZE_ELEM_HEIGHT_PX = 8;\n\n/**\n * Represents which flamechart an entry is rendered in.\n * We need to know this because when we place an overlay for an entry we need\n * to adjust its Y value if it's in the main chart which is drawn below the\n * network chart\n */\nexport type EntryChartLocation = 'main'|'network';\n\n/**\n * You can add overlays to trace events, but also right now frames are drawn on\n * the timeline but they are not trace events, so we need to allow for that.\n * In the future when the frames track has been migrated to be powered by\n * animation frames (crbug.com/345144583), we can remove the requirement to\n * support TimelineFrame instances (which themselves will be removed from the\n * codebase.)\n */\nexport type OverlayEntry =\n    TraceEngine.Types.TraceEvents.TraceEventData|TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame;\n\n/**\n * Represents when a user has selected an entry in the timeline\n */\nexport interface EntrySelected {\n  type: 'ENTRY_SELECTED';\n  entry: OverlayEntry;\n}\n\n/**\n * Drawn around an entry when we want to highlight it to the user.\n */\nexport interface EntryOutline {\n  type: 'ENTRY_OUTLINE';\n  entry: OverlayEntry;\n  // Currently the only supported use-case is highlighting errors, but we may\n  // want to expand this in the future and have the outline appear differently.\n  outlineReason: 'ERROR';\n}\n\n/**\n * Represents an object created when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabel {\n  type: 'ENTRY_LABEL';\n  entry: OverlayEntry;\n  label: string;\n}\n\n/**\n * Represents a time range on the trace. Also used when the user shift+clicks\n * and drags to create a time range.\n */\nexport interface TimeRangeLabel {\n  type: 'TIME_RANGE';\n  bounds: TraceEngine.Types.Timing.TraceWindowMicroSeconds;\n  label: string;\n  showDuration: boolean;\n}\n\n/**\n * Used to highlight with a red-candy stripe a time range. It takes an entry\n * because this entry is the row that will be used to place the candy stripe,\n * and its height will be set to the height of that row.\n */\nexport interface CandyStripedTimeRange {\n  type: 'CANDY_STRIPED_TIME_RANGE';\n  bounds: TraceEngine.Types.Timing.TraceWindowMicroSeconds;\n  entry: TraceEngine.Types.TraceEvents.TraceEventData;\n}\n\n/**\n * Represents a timespan on a trace broken down into parts. Each part has a label to it.\n */\nexport interface TimespanBreakdown {\n  type: 'TIMESPAN_BREAKDOWN';\n  sections: Array<Components.TimespanBreakdownOverlay.EntryBreakdown>;\n}\n\nexport interface CursorTimestampMarker {\n  type: 'CURSOR_TIMESTAMP_MARKER';\n  timestamp: TraceEngine.Types.Timing.MicroSeconds;\n}\n\n/**\n * All supported overlay types. Expected to grow in time!\n */\nexport type TimelineOverlay =\n    EntrySelected|EntryOutline|TimeRangeLabel|EntryLabel|TimespanBreakdown|CursorTimestampMarker|CandyStripedTimeRange;\n\n/**\n * Denotes overlays that are singletons; only one of these will be allowed to\n * exist at any given time. If one exists and the add() method is called, the\n * new overlay will replace the existing one.\n */\ntype SingletonOverlay = EntrySelected|CursorTimestampMarker;\nexport function overlayIsSingleton(overlay: TimelineOverlay): overlay is SingletonOverlay {\n  return overlay.type === 'CURSOR_TIMESTAMP_MARKER' || overlay.type === 'ENTRY_SELECTED';\n}\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n * Note that we can't use the visible trace window from the TraceBounds\n * service as that can get out of sync with rapid FlameChart draws. To ensure\n * we draw overlays smoothly as the FlameChart renders we use the latest values\n * provided to us from the FlameChart. In `FlameChart#draw` we dispatch an\n * event containing the latest dimensions, and those are passed into the\n * Overlays system via TimelineFlameChartView.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\n/**\n * The dimensions each flame chart reports. Note that in the current UI they\n * will always have the same width, so theoretically we could only gather that\n * from one chart, but we gather it from both for simplicity and to cover us in\n * the future should the UI change and the charts have different widths.\n */\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n  // If every single group (e.g. track) within the chart is collapsed or not.\n  // This matters because in the network track if every group (there is only\n  // one) is collapsed, there is no resizer bar shown, which impacts our pixel\n  // calculations for overlay positioning.\n  allGroupsCollapsed: boolean;\n}\n\nexport interface TimelineCharts {\n  mainChart: PerfUI.FlameChart.FlameChart;\n  mainProvider: PerfUI.FlameChart.FlameChartDataProvider;\n  networkChart: PerfUI.FlameChart.FlameChart;\n  networkProvider: PerfUI.FlameChart.FlameChartDataProvider;\n}\n\n// An event dispatched when one of the Annotation Overlays (overlay created by the user,\n// ex. EntryLabel) is removed or updated. When one of the Annotation Overlays is removed or updated,\n// ModificationsManager listens to this event and updates the current annotations.\nexport type UpdateAction = 'Remove'|'Update';\nexport class AnnotationOverlayActionEvent extends Event {\n  static readonly eventName = 'annotationoverlayactionsevent';\n\n  constructor(public overlay: TimelineOverlay, public action: UpdateAction) {\n    super(AnnotationOverlayActionEvent.eventName);\n  }\n}\n\n/**\n * This class manages all the overlays that get drawn onto the performance\n * timeline. Overlays are DOM and are drawn above the network and main flame\n * chart.\n *\n * For more documentation, see `timeline/README.md` which has a section on overlays.\n */\nexport class Overlays extends EventTarget {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #overlaysToElements: Map<TimelineOverlay, HTMLElement|null> = new Map();\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * To calculate the Y pixel value for an event we need access to the chart\n   * and data provider in order to find out what level the event is on, and from\n   * there calculate the pixel value for that level.\n   */\n  #charts: TimelineCharts;\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement;\n\n  constructor(init: {\n    container: HTMLElement,\n    charts: TimelineCharts,\n  }) {\n    super();\n    this.#overlaysContainer = init.container;\n    this.#charts = init.charts;\n  }\n\n  /**\n   * Because entries can be a TimelineFrame, which is not a trace event, this\n   * helper exists to return a consistent set of timings regardless of the type\n   * of entry.\n   */\n  #timingsForOverlayEntry(entry: OverlayEntry):\n      TraceEngine.Helpers.Timing.EventTimingsData<TraceEngine.Types.Timing.MicroSeconds> {\n    if (entry instanceof TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame) {\n      return {\n        startTime: entry.startTime,\n        endTime: entry.endTime,\n        duration: entry.duration,\n        selfTime: TraceEngine.Types.Timing.MicroSeconds(0),\n      };\n    }\n    if (TraceEngine.Types.TraceEvents.isSyntheticLayoutShift(entry)) {\n      const endTime = TraceEngine.Types.Timing.MicroSeconds(entry.ts + LAYOUT_SHIFT_SYNTHETIC_DURATION);\n      return {\n        endTime,\n        duration: LAYOUT_SHIFT_SYNTHETIC_DURATION,\n        startTime: entry.ts,\n        selfTime: TraceEngine.Types.Timing.MicroSeconds(0),\n      };\n    }\n    return TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n  }\n\n  #chartForOverlayEntry(entry: OverlayEntry): EntryChartLocation {\n    if (entry instanceof TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame) {\n      return 'main';\n    }\n    if (TraceEngine.Types.TraceEvents.isNetworkTrackEntry(entry)) {\n      return 'network';\n    }\n\n    return 'main';\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  add<T extends TimelineOverlay>(newOverlay: T): T {\n    if (this.#overlaysToElements.has(newOverlay)) {\n      return newOverlay;\n    }\n\n    /**\n     * If the overlay type is a singleton, and we already have one, we update\n     * the existing one, rather than create a new one. This ensures you can only\n     * ever have one instance of the overlay type.\n     */\n    const existing = this.overlaysOfType<T>(newOverlay.type);\n    if (overlayIsSingleton(newOverlay) && existing[0]) {\n      this.updateExisting(existing[0], newOverlay);\n      return existing[0];\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#overlaysToElements.set(newOverlay, null);\n    return newOverlay;\n  }\n\n  /**\n   * Update an existing overlay without destroying and recreating its\n   * associated DOM.\n   *\n   * This is useful if you need to rapidly update an overlay's data - e.g.\n   * dragging to create time ranges - without the thrashing of destroying the\n   * old overlay and re-creating the new one.\n   */\n  updateExisting<T extends TimelineOverlay>(existingOverlay: T, newData: Partial<T>): void {\n    if (!this.#overlaysToElements.has(existingOverlay)) {\n      console.error('Trying to update an overlay that does not exist.');\n      return;\n    }\n\n    for (const [key, value] of Object.entries(newData)) {\n      // newData is of type Partial<T>, so each key must exist in T, but\n      // Object.entries doesn't carry that information.\n      const k = key as keyof T;\n      existingOverlay[k] = value;\n    }\n  }\n\n  /**\n   * @returns the list of overlays associated with a given entry.\n   */\n  overlaysForEntry(entry: OverlayEntry): TimelineOverlay[] {\n    const matches: TimelineOverlay[] = [];\n    for (const [overlay] of this.#overlaysToElements) {\n      if ('entry' in overlay && overlay.entry === entry) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Removes any active overlays that match the provided type.\n   * @returns the number of overlays that were removed.\n   */\n  removeOverlaysOfType(type: TimelineOverlay['type']): number {\n    const overlaysToRemove = Array.from(this.#overlaysToElements.keys()).filter(overlay => {\n      return overlay.type === type;\n    });\n    for (const overlay of overlaysToRemove) {\n      this.remove(overlay);\n    }\n    return overlaysToRemove.length;\n  }\n\n  /**\n   * @returns all overlays that match the provided type.\n   */\n  overlaysOfType<T extends TimelineOverlay>(type: T['type']): NoInfer<T>[] {\n    const matches: T[] = [];\n\n    function overlayIsOfType(overlay: TimelineOverlay): overlay is T {\n      return overlay.type === type;\n    }\n\n    for (const [overlay] of this.#overlaysToElements) {\n      if (overlayIsOfType(overlay)) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Removes the provided overlay from the list of overlays and destroys any\n   * DOM associated with it.\n   */\n  remove(overlay: TimelineOverlay): void {\n    const htmlElement = this.#overlaysToElements.get(overlay);\n    if (htmlElement && this.#overlaysContainer) {\n      this.#overlaysContainer.removeChild(htmlElement);\n    }\n    this.#overlaysToElements.delete(overlay);\n  }\n\n  /**\n   * Update the dimenions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: EntryChartLocation, dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the preivous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#overlaysToElements.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  /**\n   * Updates the Overlays UI: new overlays will be rendered onto the view, and\n   * existing overlays will have their positions changed to ensure they are\n   * rendered in the right place.\n   */\n  update(): void {\n    const timeRangeOverlays: TimeRangeLabel[] = [];\n    for (const [overlay, existingElement] of this.#overlaysToElements) {\n      const element = existingElement || this.#createElementForNewOverlay(overlay);\n      if (existingElement) {\n        this.#updateOverlayElementIfRequired(overlay, element);\n      } else {\n        // This is a new overlay, so we have to store the element and add it to the DOM.\n        this.#overlaysToElements.set(overlay, element);\n        this.#overlaysContainer.appendChild(element);\n      }\n      this.#positionOverlay(overlay, element);\n      if (overlay.type === 'TIME_RANGE') {\n        timeRangeOverlays.push(overlay);\n      }\n    }\n\n    if (timeRangeOverlays.length > 1) {  // If there are 0 or 1 overlays, they can't overlap\n      this.#positionOverlappingTimeRangeLabels(timeRangeOverlays);\n    }\n  }\n\n  /**\n   * If any time-range overlays overlap, we try to adjust their horizontal\n   * position in order to make sure you can distinguish them and that the labels\n   * do not entirely overlap.\n   * This is very much minimal best effort, and does not guarantee that all\n   * labels will remain readable.\n   */\n  #positionOverlappingTimeRangeLabels(overlays: readonly TimeRangeLabel[]): void {\n    const overlaysSorted = overlays.toSorted((o1, o2) => {\n      return o1.bounds.min - o2.bounds.min;\n    });\n\n    // Track the overlays which overlap other overlays.\n    // This isn't bi-directional: if we find that O2 overlaps O1, we will\n    // store O1 => [O2]. We will not then also store O2 => [O1], because we\n    // only need to deal with the overlap once.\n    const overlapsByOverlay: Map<TimeRangeLabel, TimeRangeLabel[]> = new Map();\n\n    for (let i = 0; i < overlaysSorted.length; i++) {\n      const current = overlaysSorted[i];\n      const overlaps: TimeRangeLabel[] = [];\n\n      // Walk through subsequent overlays and find stop when you find the next one that does not overlap.\n      for (let j = i + 1; j < overlaysSorted.length; j++) {\n        const next = overlaysSorted[j];\n        const currentAndNextOverlap = TraceEngine.Helpers.Timing.boundsIncludeTimeRange({\n          bounds: current.bounds,\n          timeRange: next.bounds,\n        });\n        if (currentAndNextOverlap) {\n          overlaps.push(next);\n        } else {\n          // Overlays are sorted by time, if this one does not overlap, the next one will not, so we can break.\n          break;\n        }\n      }\n      overlapsByOverlay.set(current, overlaps);\n    }\n    for (const [firstOverlay, overlappingOverlays] of overlapsByOverlay) {\n      const element = this.#overlaysToElements.get(firstOverlay);\n      if (!element) {\n        continue;\n      }\n\n      // If the first overlay is adjusted, we can start back from 0 again\n      // rather than continually increment up.\n      let firstIndexForOverlapClass = 1;\n      if (element.getAttribute('class')?.includes('overlap-')) {\n        firstIndexForOverlapClass = 0;\n      }\n\n      overlappingOverlays.forEach(overlay => {\n        const element = this.#overlaysToElements.get(overlay);\n        element?.classList.add(`overlap-${firstIndexForOverlapClass++}`);\n      });\n    }\n  }\n\n  #positionOverlay(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED': {\n        if (this.entryIsVisibleOnChart(overlay.entry)) {\n          element.style.visibility = 'visible';\n          this.#positionEntryBorderOutlineType(overlay, element);\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n      case 'ENTRY_OUTLINE': {\n        const selectedOverlay = this.overlaysOfType<EntrySelected>('ENTRY_SELECTED')?.at(0);\n        // Check if this entry has also been selected by the user. If it has,\n        // do not show the outline, but only show the selected outline.\n        const outlinedEntryIsSelected = Boolean(selectedOverlay && selectedOverlay.entry === overlay.entry);\n        if (!outlinedEntryIsSelected && this.entryIsVisibleOnChart(overlay.entry)) {\n          element.style.visibility = 'visible';\n          this.#positionEntryBorderOutlineType(overlay, element);\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n\n      case 'TIME_RANGE': {\n        this.#positionTimeRangeOverlay(overlay, element);\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.afterOverlayUpdate();\n        }\n        break;\n      }\n      case 'ENTRY_LABEL': {\n        if (this.entryIsVisibleOnChart(overlay.entry)) {\n          element.style.visibility = 'visible';\n          const entryLabelParams = this.#positionEntryLabelOverlay(overlay, element);\n          const component = element.querySelector('devtools-entry-label-overlay');\n          if (component && entryLabelParams) {\n            component.entryLabelParams = entryLabelParams;\n          } else {\n            element.style.visibility = 'hidden';\n            console.error('Cannot calculate entry width and height values required to draw a label overlay.');\n          }\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        this.#positionTimespanBreakdownOverlay(overlay, element);\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        if (component) {\n          component.afterOverlayUpdate();\n        }\n        break;\n      }\n\n      case 'CURSOR_TIMESTAMP_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // Only update the position if the timestamp of this marker is within\n        // the visible bounds.\n        if (visibleWindow && TraceEngine.Helpers.Timing.timestampIsInBounds(visibleWindow, overlay.timestamp)) {\n          element.style.visibility = 'visible';\n          this.#positionTimestampMarker(overlay, element);\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n\n      case 'CANDY_STRIPED_TIME_RANGE': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // If the bounds of this overlay are not within the visible bounds, we\n        // can skip updating its position and just hide it.\n        if (visibleWindow && TraceEngine.Helpers.Timing.boundsIncludeTimeRange({\n              bounds: visibleWindow,\n              timeRange: overlay.bounds,\n            })) {\n          element.style.visibility = 'visible';\n          this.#positionCandyStripedTimeRange(overlay, element);\n\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n\n      default: {\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unknown overlay: ${JSON.stringify(overlay)}`);\n      }\n    }\n  }\n\n  #positionTimestampMarker(overlay: CursorTimestampMarker, element: HTMLElement): void {\n    // Because we are adjusting the x position, we can use either chart here.\n    const x = this.#xPixelForMicroSeconds('main', overlay.timestamp);\n    element.style.left = `${x}px`;\n  }\n\n  #positionTimespanBreakdownOverlay(overlay: TimespanBreakdown, element: HTMLElement): void {\n    const component = element.querySelector<HTMLElement>('devtools-timespan-breakdown-overlay');\n    const shadow = component?.shadowRoot;\n    const elementSections = shadow?.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n\n    if (overlay.sections.length === 0) {\n      return;\n    }\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.sections[0].bounds.min);\n    const rightEdgePixel =\n        this.#xPixelForMicroSeconds('main', overlay.sections[overlay.sections.length - 1].bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n    element.style.bottom = '0px';\n\n    if (elementSections?.length === overlay.sections.length) {\n      let count = 0;\n      for (const section of overlay.sections) {\n        const leftPixel = this.#xPixelForMicroSeconds('main', section.bounds.min);\n        const rightPixel = this.#xPixelForMicroSeconds('main', section.bounds.max);\n        if (leftPixel === null || rightPixel === null) {\n          return;\n        }\n        const rangeWidth = rightPixel - leftPixel;\n        const sectionElement = elementSections[count];\n\n        sectionElement.style.left = `${leftPixel}px`;\n        sectionElement.style.width = `${rangeWidth}px`;\n        count++;\n      }\n    }\n  }\n\n  #positionTimeRangeOverlay(overlay: TimeRangeLabel, element: HTMLElement): void {\n    // Time ranges span both charts, it doesn't matter which one we pass here.\n    // It's used to get the width of the container, and both charts have the\n    // same width.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.min);\n    const rightEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n  }\n\n  /**\n   * Positions an EntryLabel overlay\n   * @param overlay - the EntrySelected overlay that we need to position.\n   * @param element - the DOM element representing the overlay\n   */\n  #positionEntryLabelOverlay(overlay: EntryLabel, element: HTMLElement):\n      {height: number, width: number, cutOffEntryHeight: number, chart: string}|null {\n    const chartName = this.#chartForOverlayEntry(overlay.entry);\n    const x = this.xPixelForEventOnChart(overlay.entry);\n    const y = this.yPixelForEventOnChart(overlay.entry);\n    const {endTime} = this.#timingsForOverlayEntry(overlay.entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    const entryHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    if (x === null || y === null || endX === null) {\n      return null;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    const widthPixels = endX - x;\n    // The part of the overlay that draws a box around an entry is always at least 2px wide.\n    const entryWidth = Math.max(2, widthPixels);\n    const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n\n    // Find the part of the entry that is covered by resizer to not draw it over the resizer.\n    // If the entry is in the main flamechart, find the part of the entry that is covered from the top.\n    // If it is in the network track, find the part covered by the resizer from the bottom.\n    const entryHiddenTop = this.networkChartOffsetHeight() - y;\n    const entryHiddenBottom = entryHeight + y - networkHeight;\n    // If the covered part is negative, the entry is fully visible and the cut off part is 0.\n    const cutOffEntryHeight = Math.max((chartName === 'main') ? entryHiddenTop : entryHiddenBottom, 0);\n\n    let topOffset = y - Components.EntryLabelOverlay.EntryLabelOverlay.LABEL_AND_CONNECTOR_HEIGHT;\n    // If part of the entry height is not visible in the main flamechart, take that into the account in the top offset.\n    if (chartName === 'main') {\n      topOffset += cutOffEntryHeight;\n    }\n\n    // Position the start of label overlay at the start of the entry + length of connector + legth of the label element\n    element.style.top = `${topOffset}px`;\n    // Position the start of the entry label overlay in the the middle of the entry.\n    element.style.left = `${x + entryWidth / 2}px`;\n\n    return {height: entryHeight, width: entryWidth, cutOffEntryHeight, chart: chartName};\n  }\n\n  #positionCandyStripedTimeRange(overlay: CandyStripedTimeRange, element: HTMLElement): void {\n    const chartName = this.#chartForOverlayEntry(overlay.entry);\n\n    const startX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.min);\n    const endX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.max);\n    if (startX === null || endX === null) {\n      return;\n    }\n\n    let y = this.yPixelForEventOnChart(overlay.entry);\n    if (y === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n    const widthPixels = endX - startX;\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${startX}px`;\n  }\n\n  /**\n   * Positions an EntrySelected or EntryOutline overlay. These share the same\n   * method as they are both borders around an entry.\n   * @param overlay - the EntrySelected/EntryOutline overlay that we need to position.\n   * @param element - the DOM element representing the overlay\n   */\n  #positionEntryBorderOutlineType(overlay: EntrySelected|EntryOutline, element: HTMLElement): void {\n    const chartName = this.#chartForOverlayEntry(overlay.entry);\n    let x = this.xPixelForEventOnChart(overlay.entry);\n    let y = this.yPixelForEventOnChart(overlay.entry);\n\n    if (x === null || y === null) {\n      return;\n    }\n\n    const {endTime, duration} = this.#timingsForOverlayEntry(overlay.entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    if (endX === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    let widthPixels = endX - x;\n\n    if (!duration) {\n      // No duration = instant event, so we check in case it's a marker.\n      const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n      const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n      // It could be a marker event, in which case we need to know the\n      // exact position the marker was rendered. This is because markers\n      // which have the same timestamp are rendered next to each other, so\n      // the timestamp is not necessarily exactly where the marker was\n      // rendered.\n      const index = provider.indexForEvent?.(overlay.entry);\n      const markerPixels = chart.getMarkerPixelsForEntryIndex(index ?? -1);\n      if (markerPixels) {\n        x = markerPixels.x;\n        widthPixels = markerPixels.width;\n      }\n    }\n\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${x}px`;\n  }\n\n  #createElementForNewOverlay(overlay: TimelineOverlay): HTMLElement {\n    const div = document.createElement('div');\n    div.classList.add('overlay-item', `overlay-type-${overlay.type}`);\n    switch (overlay.type) {\n      case 'ENTRY_LABEL': {\n        const component = new Components.EntryLabelOverlay.EntryLabelOverlay(\n            overlay.label, this.#chartForOverlayEntry(overlay.entry) === 'main');\n        component.addEventListener(Components.EntryLabelOverlay.EmptyEntryLabelRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.EntryLabelOverlay.EntryLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        div.appendChild(component);\n        return div;\n      }\n      case 'ENTRY_OUTLINE': {\n        div.classList.add(`outline-reason-${overlay.outlineReason}`);\n        return div;\n      }\n      case 'TIME_RANGE': {\n        const component = new Components.TimeRangeOverlay.TimeRangeOverlay(overlay.label);\n        component.duration = overlay.showDuration ? overlay.bounds.range : null;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        div.appendChild(component);\n        return div;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = new Components.TimespanBreakdownOverlay.TimespanBreakdownOverlay();\n        component.sections = overlay.sections;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        div.appendChild(component);\n        return div;\n      }\n      default: {\n        return div;\n      }\n    }\n  }\n\n  /**\n   * Some of the HTML elements for overlays might need updating between each render\n   * (for example, if a time range has changed, we update its duration text)\n   */\n  #updateOverlayElementIfRequired(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        // Nothing to do here.\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.duration = overlay.showDuration ? overlay.bounds.range : null;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'ENTRY_OUTLINE':\n        break;\n      case 'ENTRY_LABEL': {\n        // TODO: update if the label changes\n        // Nothing to do here.\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        if (component) {\n          component.sections = overlay.sections;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'CURSOR_TIMESTAMP_MARKER':\n        // No contents within this that need updating.\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n\n  /**\n   * @returns true if the entry is visible on chart, which means that both\n   * horizontally and vertically it is at least partially in view.\n   */\n  entryIsVisibleOnChart(entry: OverlayEntry): boolean {\n    const verticallyVisible = this.#entryIsVerticallyVisibleOnChart(entry);\n    const horiziontallyVisible = this.#entryIsHorizontallyVisibleOnChart(entry);\n    return verticallyVisible && horiziontallyVisible;\n  }\n\n  /**\n   * Calculates if an entry is visible horizontally. This is easy because we\n   * don't have to consider any pixels and can instead check that its start and\n   * end times intersect with the visible window.\n   */\n  #entryIsHorizontallyVisibleOnChart(entry: OverlayEntry): boolean {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      return false;\n    }\n    const {startTime, endTime} = this.#timingsForOverlayEntry(entry);\n\n    const entryTimeRange = TraceEngine.Helpers.Timing.traceWindowFromMicroSeconds(startTime, endTime);\n\n    return TraceEngine.Helpers.Timing.boundsIncludeTimeRange({\n      bounds: this.#dimensions.trace.visibleWindow,\n      timeRange: entryTimeRange,\n    });\n  }\n\n  /**\n   * Calculate if an entry is visible vertically on the chart. A bit fiddly as\n   * we have to figure out its pixel offset and go on that. Unlike horizontal\n   * visibility, we can't work soley from its microsecond values.\n   */\n  #entryIsVerticallyVisibleOnChart(entry: OverlayEntry): boolean {\n    const chartName = this.#chartForOverlayEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return false;\n    }\n\n    const eventHeight = this.pixelHeightForEventOnChart(entry);\n    if (!eventHeight) {\n      return false;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return false;\n      }\n\n      // The yPixelForEventOnChart method returns the y pixel including an adjustment for the network track.\n      // To see if an entry on the main flame chart is visible, we can check\n      // its y value without the network track adjustment. If it is < 0, then\n      // it's off the top of the screen.\n      //\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position + the height is less than 0. We add height so\n      // that we correctly consider an event only partially scrolled off to be\n      // visible.\n      if (yWithoutNetwork + eventHeight < 0) {\n        return false;\n      }\n\n      if (yWithoutNetwork > this.#dimensions.charts.main.heightPixels) {\n        // The event is off the bottom of the screen.\n        return false;\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        // The network chart can be hidden if there are no requests in the trace.\n        return false;\n      }\n      if (y <= -14) {\n        // Weird value, but the network chart has the header row with\n        // timestamps on it: events stay visible behind those timestamps, so we\n        // want any overlays to treat themselves as visible too.\n        return false;\n      }\n\n      if (y > this.#dimensions.charts.network.heightPixels ?? 0) {\n        // The event is off the bottom of the network chart.\n        return false;\n      }\n    }\n    // If we got here, none of the conditions to mark an event as invisible got\n    // triggered, so the event must be visible.\n    return true;\n  }\n\n  /**\n   * Calculate the X pixel position for an event on the timeline.\n   * @param chartName - the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   *\n   * @param event - the trace event you want to get the pixel position of\n   */\n  xPixelForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const {startTime} = this.#timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, startTime);\n  }\n\n  /**\n   * Calculate the xPixel for a given timestamp. To do this we calculate how\n   * far in microseconds from the left of the visible window an event is, and\n   * divide that by the total time span. This gives us a fraction representing\n   * how far along the timeline the event is. We can then multiply that by the\n   * width of the canvas to get its pixel position.\n   */\n  #xPixelForMicroSeconds(chart: EntryChartLocation, timestamp: TraceEngine.Types.Timing.MicroSeconds): number|null {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      console.error('Cannot calculate xPixel without visible trace window.');\n      return null;\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (canvasWidthPixels === null) {\n      console.error(`Cannot calculate xPixel without ${chart} dimensions.`);\n      return null;\n    }\n\n    const timeFromLeft = timestamp - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n\n  /**\n   * Calculate the Y pixel position for the event on the timeline relative to\n   * the entire window.\n   * This means if the event is in the main flame chart and below the network,\n   * we add the height of the network chart to the Y value to position it\n   * correctly.\n   * This can return null if any data waas missing, or if the event is not\n   * visible (if the level it's on is hidden because the track is collapsed,\n   * for example)\n   */\n  yPixelForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n\n    if (!chart.levelIsVisible(level)) {\n      return null;\n    }\n\n    const pixelOffsetForLevel = chart.levelToOffset(level);\n    // Now we have the offset for the level, we need to adjust it by the user's scroll offset.\n    let pixelAdjustedForScroll = pixelOffsetForLevel - (this.#dimensions.charts[chartName]?.scrollOffsetPixels ?? 0);\n\n    // Now if the event is in the main chart, we need to pad its Y position\n    // down by the height of the network chart + the network resize element.\n    if (chartName === 'main') {\n      pixelAdjustedForScroll += this.networkChartOffsetHeight();\n    }\n\n    return pixelAdjustedForScroll;\n  }\n\n  /**\n   * Calculate the height of the event on the timeline.\n   */\n  pixelHeightForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n    return chart.levelHeight(level);\n  }\n\n  /**\n   * Calculate the height of the network chart. If the network chart has\n   * height, we also allow for the size of the resize handle shown between the\n   * two charts.\n   *\n   * Note that it is possible for the chart to have 0 height if the user is\n   * looking at a trace with no network requests.\n   */\n  networkChartOffsetHeight(): number {\n    if (this.#dimensions.charts.network === null) {\n      return 0;\n    }\n\n    if (this.#dimensions.charts.network.heightPixels === 0) {\n      return 0;\n    }\n\n    // At this point we know the network track exists and has height. But we\n    // need to check if it is collapsed, because if it is collapsed there is no\n    // resizer shown.\n    if (this.#dimensions.charts.network.allGroupsCollapsed) {\n      return this.#dimensions.charts.network.heightPixels;\n    }\n\n    return this.#dimensions.charts.network.heightPixels + NETWORK_RESIZE_ELEM_HEIGHT_PX;\n  }\n}\n"]}