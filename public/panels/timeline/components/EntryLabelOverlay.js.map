{"version":3,"file":"EntryLabelOverlay.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/components/EntryLabelOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as ComponentHelpers from '../../../ui/components/helpers/helpers.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\n\nimport styles from './entryLabelOverlay.css.js';\n\nexport class EntryLabelOverlay extends HTMLElement {\n  // The label is angled on the left from the centre of the entry it belongs to.\n  // `LABEL_AND_CONNECTOR_SHIFT_LENGTH` specifies how many pixels to the left it is shifted.\n  static readonly LABEL_AND_CONNECTOR_SHIFT_LENGTH = 4;\n  // Length of the line that connects the label to the entry.\n  static readonly LABEL_CONNECTOR_HEIGHT = 6;\n  static readonly LABEL_HEIGHT = 17;\n  static readonly LABEL_PADDING = 4;\n  static readonly LABEL_AND_CONNECTOR_HEIGHT =\n      EntryLabelOverlay.LABEL_HEIGHT + EntryLabelOverlay.LABEL_PADDING * 2 + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n\n  static readonly litTagName = LitHtml.literal`devtools-entry-label-overlay`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n  #label = '';\n  // The label is set to editable when it is double clicked. If the user clicks away from the label box\n  // element, the lable is set to not editable until it double clicked.\n  #isLabelEditable: boolean = true;\n  #entryDimensions: {height: number, width: number}|null = null;\n\n  /*\nThe entry label overlay consists of 3 parts - the label part with the label string inside,\nthe line connecting the label to the entry, and a black box around an entry to highlight the entry with a label.\n________\n|_label__|                <-- label part with the label string inside\n    \\\n     \\                   <-- line connecting the label to the entry\n      \\\n________________\n|_____entry______|         <--- box around an entry\n\n`drawLabel` method below draws the first part.\n`drawConnector` method below draws the second part - the connector line and the svg container for it.\n`drawEntryHighlightWrapper` draws the third part.\nWe only rerender the first part if the label changes and the third part if the size of the entry changes.\nThe connector shape never changes so we only draw the second part when the component is created.\n\nOtherwise, the entry label overlay object only gets repositioned.\n*/\n\n  constructor() {\n    super();\n    this.#render();\n    this.#drawLabel();\n    this.#drawConnector();\n  }\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  set label(label: string) {\n    if (label === this.#label) {\n      return;\n    }\n    this.#label = label;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n    // We need to redraw the label only when the label is set to a new one\n    this.#drawLabel();\n\n    // If the label is not empty, it was loaded from the trace file.\n    // In that case, do not make just created label editable.\n    this.#setLabelEditability(false);\n  }\n\n  set entryDimensions(entryDimensions: {height: number, width: number}) {\n    if (entryDimensions.height === this.#entryDimensions?.height &&\n        entryDimensions.width === this.#entryDimensions?.width) {\n      return;\n    }\n\n    this.#entryDimensions = entryDimensions;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n    // We need to redraw the entry wrapper only if the entry dimensions change\n    this.#drawEntryHighlightWrapper();\n  }\n\n  #drawConnector(): void {\n    const labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    const connectorLineContainer = labelPartsWrapper?.querySelector('#connectorContainer') as SVGAElement;\n    const connector = connectorLineContainer.querySelector('line');\n    const entryHighlightWrapper = labelPartsWrapper?.querySelector('.entry-highlight-wrapper') as HTMLElement;\n    if (!connectorLineContainer || !entryHighlightWrapper || !connector) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n    // PART 2: draw the connector from label to the entry\n    // Set the width of the canvas that draws the connector to be equal to the length of the shift multiplied by two.\n    // That way, we can draw the connector from its corner to its middle. Since all elements are alligned in the middle, the connector\n    // will end in the middle of the entry.\n    connectorLineContainer.setAttribute('width', (EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * 2).toString());\n    connectorLineContainer.setAttribute('height', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    // Start drawing the top right corner.\n    connector.setAttribute('x1', '0');\n    connector.setAttribute('y1', '0');\n    // Finish drawing in middle of the connector container.\n    connector.setAttribute('x2', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    connector.setAttribute('y2', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    connector.setAttribute('stroke', 'black');\n    connector.setAttribute('stroke-width', '2');\n  }\n\n  #drawLabel(): void {\n    const labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    const labelBox = labelPartsWrapper?.querySelector<HTMLElement>('.label-box');\n    const connectorLineContainer = labelPartsWrapper?.querySelector('#connectorContainer') as SVGAElement;\n    const connector = connectorLineContainer.querySelector('line');\n    const entryHighlightWrapper = labelPartsWrapper?.querySelector('.entry-highlight-wrapper') as HTMLElement;\n\n    if (!labelBox || !connectorLineContainer || !entryHighlightWrapper || !connector) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n\n    // PART 1: draw the label box\n    // Set label height to the entry height\n    labelBox.style.height = `${EntryLabelOverlay.LABEL_HEIGHT}px`;\n    labelBox.style.padding = `${EntryLabelOverlay.LABEL_PADDING}px`;\n    labelBox.style.transform = `translateX(-${EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH}px)`;\n  }\n\n  #drawEntryHighlightWrapper(): void {\n    const labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    const entryHighlightWrapper = labelPartsWrapper?.querySelector('.entry-highlight-wrapper') as HTMLElement;\n\n    if (!entryHighlightWrapper) {\n      console.error('`entryHighlightWrapper` element is missing.');\n      return;\n    }\n\n    // PART 3: draw the box that highlights the entry with a label\n    entryHighlightWrapper.style.height = `${this.#entryDimensions?.height}px`;\n    entryHighlightWrapper.style.width = `${this.#entryDimensions?.width}px`;\n\n    // If the label is editable, focus cursor on it.\n    // This method needs to be called after rendering the wrapper because it is the last label overlay element to render.\n    // By doing this, the cursor focuses when the label is created.\n    if (this.#isLabelEditable) {\n      this.#focusInputBox();\n    }\n  }\n\n  #focusInputBox(): void {\n    const labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    const labelBox = labelPartsWrapper?.querySelector<HTMLElement>('.label-box');\n    if (!labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    labelBox.focus();\n  }\n\n  #setLabelEditability(editable: boolean): void {\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n  }\n\n  #render(): void {\n    // clang-format off\n    LitHtml.render(\n        LitHtml.html`\n        <span class=\"label-parts-wrapper\">\n          <span \n            class=\"label-box\" @dblclick=${() => this.#setLabelEditability(true)}\n            @blur=${() => this.#setLabelEditability(false)} \n            contenteditable=${this.#isLabelEditable} \n            .innerText=${this.#label}>\n          </span>\n          <svg id=\"connectorContainer\">\n            <line/>\n          </svg>\n          <div class=\"entry-highlight-wrapper\"/>\n        </span>`,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\ncustomElements.define('devtools-entry-label-overlay', EntryLabelOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entry-label-overlay': EntryLabelOverlay;\n  }\n}\n"]}