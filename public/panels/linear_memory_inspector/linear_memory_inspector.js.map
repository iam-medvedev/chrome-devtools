{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/linear_memory_inspector/LinearMemoryInspectorController.ts", "../../../../../../front_end/panels/linear_memory_inspector/LinearMemoryInspectorPane.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport type * as ObjectUI from '../../ui/legacy/components/object_ui/object_ui.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport * as LinearMemoryInspectorComponents from './components/components.js';\nimport {Events as LmiEvents, LinearMemoryInspectorPane} from './LinearMemoryInspectorPane.js';\n\nconst UIStrings = {\n  /**\n   *@description Error message that shows up in the console if a buffer to be opened in the linear memory inspector cannot be found.\n   */\n  couldNotOpenLinearMemory: 'Could not open linear memory inspector: failed locating buffer.',\n  /**\n   *@description A context menu item in the Scope View of the Sources Panel\n   */\n  openInMemoryInspectorPanel: 'Open in Memory inspector panel',\n} as const;\nconst str_ =\n    i18n.i18n.registerUIStrings('panels/linear_memory_inspector/LinearMemoryInspectorController.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst LINEAR_MEMORY_INSPECTOR_OBJECT_GROUP = 'linear-memory-inspector';\nconst MEMORY_TRANSFER_MIN_CHUNK_SIZE = 1000;\n\nlet controllerInstance: LinearMemoryInspectorController;\n\nexport interface LazyUint8Array {\n  getRange(start: number, end: number): Promise<Uint8Array<ArrayBuffer>>;\n  length(): number;\n}\n\nexport class RemoteArrayBufferWrapper implements LazyUint8Array {\n  #remoteArrayBuffer: SDK.RemoteObject.RemoteArrayBuffer;\n\n  constructor(arrayBuffer: SDK.RemoteObject.RemoteArrayBuffer) {\n    this.#remoteArrayBuffer = arrayBuffer;\n  }\n\n  length(): number {\n    return this.#remoteArrayBuffer.byteLength();\n  }\n\n  async getRange(start: number, end: number): Promise<Uint8Array<ArrayBuffer>> {\n    const newEnd = Math.min(end, this.length());\n    if (start < 0 || start > newEnd) {\n      console.error(`Requesting invalid range of memory: (${start}, ${end})`);\n      return new Uint8Array(0);\n    }\n    const array = await this.#remoteArrayBuffer.bytes(start, newEnd);\n\n    return new Uint8Array(array ?? []);\n  }\n}\n\nasync function getBufferFromObject(obj: SDK.RemoteObject.RemoteObject): Promise<SDK.RemoteObject.RemoteArrayBuffer> {\n  const response = await obj.runtimeModel().agent.invoke_callFunctionOn({\n    objectId: obj.objectId,\n    functionDeclaration:\n        'function() { return this instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \\'undefined\\' && this instanceof SharedArrayBuffer) ? this : this.buffer; }',\n    silent: true,\n    // Set object group in order to bind the object lifetime to the linear memory inspector.\n    objectGroup: LINEAR_MEMORY_INSPECTOR_OBJECT_GROUP,\n  });\n\n  const error = response.getError();\n  if (error) {\n    throw new Error(`Remote object representing ArrayBuffer could not be retrieved: ${error}`);\n  }\n  obj = obj.runtimeModel().createRemoteObject(response.result);\n  return new SDK.RemoteObject.RemoteArrayBuffer(obj);\n}\n\ninterface SerializableSettings {\n  valueTypes: LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType[];\n  valueTypeModes: Array<[\n    LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType,\n    LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueTypeMode,\n  ]>;\n  endianness: LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness;\n}\n\nexport class LinearMemoryInspectorController extends SDK.TargetManager.SDKModelObserver<SDK.RuntimeModel.RuntimeModel>\n    implements Common.Revealer.Revealer<SDK.RemoteObject.LinearMemoryInspectable>,\n               UI.ContextMenu.Provider<ObjectUI.ObjectPropertiesSection.ObjectPropertyTreeElement> {\n  #paneInstance = LinearMemoryInspectorPane.instance();\n  #bufferIdToRemoteObject = new Map<string, SDK.RemoteObject.RemoteObject>();\n  #bufferIdToHighlightInfo = new Map<string, LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo>();\n  #settings: Common.Settings.Setting<SerializableSettings>;\n\n  private constructor() {\n    super();\n    SDK.TargetManager.TargetManager.instance().observeModels(SDK.RuntimeModel.RuntimeModel, this);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.GlobalObjectCleared, this.#onGlobalObjectClear, this);\n    this.#paneInstance.addEventListener(LmiEvents.VIEW_CLOSED, this.#viewClosed.bind(this));\n\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerPaused, this.#onDebuggerPause, this);\n\n    const defaultValueTypeModes =\n        LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.getDefaultValueTypeMapping();\n    const defaultSettings: SerializableSettings = {\n      valueTypes: Array.from(defaultValueTypeModes.keys()),\n      valueTypeModes: Array.from(defaultValueTypeModes),\n      endianness: LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.LITTLE,\n    };\n    this.#settings = Common.Settings.Settings.instance().createSetting('lmi-interpreter-settings', defaultSettings);\n  }\n\n  static instance(): LinearMemoryInspectorController {\n    if (controllerInstance) {\n      return controllerInstance;\n    }\n    controllerInstance = new LinearMemoryInspectorController();\n    return controllerInstance;\n  }\n\n  static async getMemoryForAddress(memoryWrapper: LazyUint8Array, address: number):\n      Promise<{memory: Uint8Array<ArrayBuffer>, offset: number}> {\n    // Provide a chunk of memory that covers the address to show and some before and after\n    // as 1. the address shown is not necessarily at the beginning of a page and\n    // 2. to allow for fewer memory requests.\n    const memoryChunkStart = Math.max(0, address - MEMORY_TRANSFER_MIN_CHUNK_SIZE / 2);\n    const memoryChunkEnd = memoryChunkStart + MEMORY_TRANSFER_MIN_CHUNK_SIZE;\n    const memory = await memoryWrapper.getRange(memoryChunkStart, memoryChunkEnd);\n    return {memory, offset: memoryChunkStart};\n  }\n\n  static async getMemoryRange(memoryWrapper: LazyUint8Array, start: number, end: number):\n      Promise<Uint8Array<ArrayBuffer>> {\n    // Check that the requested start is within bounds.\n    // If the requested end is larger than the actual\n    // memory, it will be automatically capped when\n    // requesting the range.\n    if (start < 0 || start > end || start >= memoryWrapper.length()) {\n      throw new Error('Requested range is out of bounds.');\n    }\n    const chunkEnd = Math.max(end, start + MEMORY_TRANSFER_MIN_CHUNK_SIZE);\n    return await memoryWrapper.getRange(start, chunkEnd);\n  }\n\n  async evaluateExpression(callFrame: SDK.DebuggerModel.CallFrame, expressionName: string):\n      Promise<SDK.RemoteObject.RemoteObject|undefined> {\n    const result = await callFrame.evaluate({expression: expressionName});\n    if ('error' in result) {\n      console.error(`Tried to evaluate the expression '${expressionName}' but got an error: ${result.error}`);\n      return undefined;\n    }\n    if ('exceptionDetails' in result && result?.exceptionDetails?.text) {\n      console.error(\n          `Tried to evaluate the expression '${expressionName}' but got an exception: ${result.exceptionDetails.text}`);\n      return undefined;\n    }\n    return result.object;\n  }\n\n  saveSettings(data: LinearMemoryInspectorComponents.LinearMemoryInspector.Settings): void {\n    const valueTypes = Array.from(data.valueTypes);\n    const modes = [...data.modes];\n    this.#settings.set({valueTypes, valueTypeModes: modes, endianness: data.endianness});\n  }\n\n  loadSettings(): LinearMemoryInspectorComponents.LinearMemoryInspector.Settings {\n    const settings = this.#settings.get();\n    return {\n      valueTypes: new Set(settings.valueTypes),\n      modes: new Map(settings.valueTypeModes),\n      endianness: settings.endianness,\n    };\n  }\n\n  getHighlightInfo(bufferId: string): LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo|undefined {\n    return this.#bufferIdToHighlightInfo.get(bufferId);\n  }\n\n  removeHighlight(\n      bufferId: string, highlightInfo: LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo): void {\n    const currentHighlight = this.getHighlightInfo(bufferId);\n    if (currentHighlight === highlightInfo) {\n      this.#bufferIdToHighlightInfo.delete(bufferId);\n    }\n  }\n\n  setHighlightInfo(\n      bufferId: string, highlightInfo: LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo): void {\n    this.#bufferIdToHighlightInfo.set(bufferId, highlightInfo);\n  }\n\n  #resetHighlightInfo(bufferId: string): void {\n    this.#bufferIdToHighlightInfo.delete(bufferId);\n  }\n\n  static async retrieveDWARFMemoryObjectAndAddress(obj: SDK.RemoteObject.RemoteObject):\n      Promise<{obj: SDK.RemoteObject.RemoteObject, address: number}|undefined> {\n    if (!(obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject)) {\n      return undefined;\n    }\n    const valueNode = obj;\n    const address = obj.linearMemoryAddress;\n    if (address === undefined) {\n      return undefined;\n    }\n    const callFrame = valueNode.callFrame;\n    const response = await obj.debuggerModel().agent.invoke_evaluateOnCallFrame({\n      callFrameId: callFrame.id,\n      expression: 'memories[0]',\n    });\n    const error = response.getError();\n    if (error) {\n      console.error(error);\n      Common.Console.Console.instance().error(i18nString(UIStrings.couldNotOpenLinearMemory));\n    }\n    const runtimeModel = obj.debuggerModel().runtimeModel();\n    return {obj: runtimeModel.createRemoteObject(response.result), address};\n  }\n\n  // This function returns the size of the source language value represented by the ValueNode or ExtensionRemoteObject.\n  // If the value is a pointer, the function returns the size of the pointed-to value. If the pointed-to value is also a\n  // pointer, it returns the size of the pointer (usually 4 bytes). This is the convention taken by the DWARF extension.\n  // > double x = 42.0;\n  // > double *ptr = &x;\n  // > double **dblptr = &ptr;\n  //\n  // retrieveObjectSize(ptr_ValueNode) -> 8, the size of a double\n  // retrieveObjectSize(dblptr_ValueNode) -> 4, the size of a pointer\n  static extractObjectSize(obj: Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject): number {\n    return obj.linearMemorySize ?? 0;\n  }\n\n  // The object type description corresponds to the type of the highlighted memory\n  // that the user sees in the memory inspector. For pointers, we highlight the pointed to object.\n  //\n  // Example: The variable `x` has the type `int *`. Assume that `x` points to the value 3.\n  // -> The memory inspector will jump to the address where 3 is stored.\n  // -> The memory inspector will highlight the bytes that represent the 3.\n  // -> The object type description of what we show will thus be `int` and not `int *`.\n  static extractObjectTypeDescription(obj: SDK.RemoteObject.RemoteObject): string {\n    const objType = obj.description;\n    if (!objType) {\n      return '';\n    }\n    const lastChar = objType.charAt(objType.length - 1);\n    const secondToLastChar = objType.charAt(objType.length - 2);\n    const isPointerType = lastChar === '*' || lastChar === '&';\n    const isOneLevelPointer = secondToLastChar === ' ';\n    if (!isPointerType) {\n      return objType;\n    }\n    if (isOneLevelPointer) {\n      // For example, 'int *'and 'int &' become 'int'.\n      return objType.slice(0, objType.length - 2);\n    }\n    // For example, 'int **' becomes 'int *'.\n    return objType.slice(0, objType.length - 1);\n  }\n\n  // When inspecting a pointer variable, we indicate that we display the pointed-to object in the viewer\n  // by prepending an asterisk to the pointer expression's name (mimicking C++ dereferencing).\n  // If the object isn't a pointer, we return the expression unchanged.\n  //\n  // Examples:\n  // (int *) myNumber -> (int) *myNumber\n  // (int[]) numbers -> (int[]) numbers\n  static extractObjectName(obj: SDK.RemoteObject.RemoteObject, expression: string): string {\n    const lastChar = obj.description?.charAt(obj.description.length - 1);\n    const isPointerType = lastChar === '*';\n    if (isPointerType) {\n      return '*' + expression;\n    }\n    return expression;\n  }\n\n  async reveal({object, expression}: SDK.RemoteObject.LinearMemoryInspectable, omitFocus?: boolean|undefined):\n      Promise<void> {\n    const response = await LinearMemoryInspectorController.retrieveDWARFMemoryObjectAndAddress(object);\n    let memoryObject = object;\n    let memoryAddress = undefined;\n    if (response !== undefined) {\n      memoryAddress = response.address;\n      memoryObject = response.obj;\n    }\n\n    const buffer = await getBufferFromObject(memoryObject);\n    const {internalProperties} = await buffer.object().getOwnProperties(false);\n    const idProperty = internalProperties?.find(({name}) => name === '[[ArrayBufferData]]');\n    const id = idProperty?.value?.value;\n    if (!id) {\n      throw new Error('Unable to find backing store id for array buffer');\n    }\n    const memoryProperty = internalProperties?.find(({name}) => name === '[[WebAssemblyMemory]]');\n    const memory = memoryProperty?.value;\n    const highlightInfo = LinearMemoryInspectorController.extractHighlightInfo(object, expression);\n    if (highlightInfo) {\n      this.setHighlightInfo(id, highlightInfo);\n    } else {\n      this.#resetHighlightInfo(id);\n    }\n    if (this.#bufferIdToRemoteObject.has(id)) {\n      this.#paneInstance.reveal(id, memoryAddress);\n      void UI.ViewManager.ViewManager.instance().showView('linear-memory-inspector', omitFocus);\n      return;\n    }\n\n    const title = String(memory ? memory.description : buffer.object().description);\n    this.#bufferIdToRemoteObject.set(id, buffer.object());\n    const arrayBufferWrapper = new RemoteArrayBufferWrapper(buffer);\n\n    this.#paneInstance.create(id, title, arrayBufferWrapper, memoryAddress);\n    void UI.ViewManager.ViewManager.instance().showView('linear-memory-inspector', omitFocus);\n  }\n\n  appendApplicableItems(\n      _event: Event, contextMenu: UI.ContextMenu.ContextMenu,\n      target: ObjectUI.ObjectPropertiesSection.ObjectPropertyTreeElement): void {\n    if (target.property.value?.isLinearMemoryInspectable()) {\n      const expression = target.path();\n      const object = target.property.value;\n      contextMenu.debugSection().appendItem(\n          i18nString(UIStrings.openInMemoryInspectorPanel),\n          this.reveal.bind(this, new SDK.RemoteObject.LinearMemoryInspectable(object, expression)),\n          {jslogContext: 'reveal-in-memory-inspector'});\n    }\n  }\n  static extractHighlightInfo(obj: SDK.RemoteObject.RemoteObject, expression?: string):\n      LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo|undefined {\n    if (!(obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject)) {\n      return undefined;\n    }\n\n    const startAddress = obj.linearMemoryAddress ?? 0;\n\n    let highlightInfo;\n    try {\n      highlightInfo = {\n        startAddress,\n        size: LinearMemoryInspectorController.extractObjectSize(obj),\n        name: expression ? LinearMemoryInspectorController.extractObjectName(obj, expression) : expression,\n        type: LinearMemoryInspectorController.extractObjectTypeDescription(obj),\n      };\n    } catch {\n      highlightInfo = undefined;\n    }\n    return highlightInfo;\n  }\n\n  override modelRemoved(model: SDK.RuntimeModel.RuntimeModel): void {\n    for (const [bufferId, remoteObject] of this.#bufferIdToRemoteObject) {\n      if (model === remoteObject.runtimeModel()) {\n        this.#bufferIdToRemoteObject.delete(bufferId);\n        this.#resetHighlightInfo(bufferId);\n        this.#paneInstance.close(bufferId);\n      }\n    }\n  }\n\n  #onDebuggerPause(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    for (const [bufferId, remoteObject] of this.#bufferIdToRemoteObject) {\n      if (debuggerModel.runtimeModel() === remoteObject.runtimeModel()) {\n        const topCallFrame = debuggerModel.debuggerPausedDetails()?.callFrames[0];\n        if (topCallFrame) {\n          void this\n              .updateHighlightedMemory(bufferId, topCallFrame)\n              // Need to call refreshView in the callback to trigger re-render.\n              .then(() => this.#paneInstance.refreshView(bufferId));\n        } else {\n          this.#resetHighlightInfo(bufferId);\n          this.#paneInstance.refreshView(bufferId);\n        }\n      }\n    }\n  }\n\n  #onGlobalObjectClear(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    this.modelRemoved(event.data.runtimeModel());\n  }\n\n  #viewClosed({data: bufferId}: Common.EventTarget.EventTargetEvent<string>): void {\n    const remoteObj = this.#bufferIdToRemoteObject.get(bufferId);\n    if (remoteObj) {\n      remoteObj.release();\n    }\n    this.#bufferIdToRemoteObject.delete(bufferId);\n    this.#resetHighlightInfo(bufferId);\n  }\n\n  async updateHighlightedMemory(bufferId: string, callFrame: SDK.DebuggerModel.CallFrame): Promise<void> {\n    const oldHighlightInfo = this.getHighlightInfo(bufferId);\n    const expressionName = oldHighlightInfo?.name;\n    if (!oldHighlightInfo || !expressionName) {\n      this.#resetHighlightInfo(bufferId);\n      return;\n    }\n    const obj = await this.evaluateExpression(callFrame, expressionName);\n    if (!obj) {\n      this.#resetHighlightInfo(bufferId);\n      return;\n    }\n\n    const newHighlightInfo = LinearMemoryInspectorController.extractHighlightInfo(obj, expressionName);\n    if (!newHighlightInfo || !this.#pointToSameMemoryObject(newHighlightInfo, oldHighlightInfo)) {\n      this.#resetHighlightInfo(bufferId);\n    } else {\n      this.setHighlightInfo(bufferId, newHighlightInfo);\n    }\n  }\n\n  #pointToSameMemoryObject(\n      highlightInfoA: LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo,\n      highlightInfoB: LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo): boolean {\n    return highlightInfoA.type === highlightInfoB.type && highlightInfoA.startAddress === highlightInfoB.startAddress;\n  }\n}\n", "// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as VisualLogging from '../../ui/visual_logging/visual_logging.js';\n\nimport * as LinearMemoryInspectorComponents from './components/components.js';\nimport {type LazyUint8Array, LinearMemoryInspectorController} from './LinearMemoryInspectorController.js';\n\nconst UIStrings = {\n  /**\n   *@description Label in the Linear Memory inspector tool that serves as a placeholder if no inspections are open (i.e. nothing to see here).\n   *             Inspection hereby refers to viewing, navigating and understanding the memory through this tool.\n   */\n  noOpenInspections: 'No open inspections',\n  /**\n   *@description Label in the Linear Memory inspector tool that serves as a placeholder if no inspections are open (i.e. nothing to see here).\n   *             Inspection hereby refers to viewing, navigating and understanding the memory through this tool.\n   */\n  memoryInspectorExplanation: 'On this page you can inspect binary data.',\n  /**\n   *@description Label in the Linear Memory inspector tool for a link.\n   */\n  learnMore: 'Learn more',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/linear_memory_inspector/LinearMemoryInspectorPane.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nlet inspectorInstance: LinearMemoryInspectorPane;\n\nconst MEMORY_INSPECTOR_EXPLANATION_URL =\n    'https://developer.chrome.com/docs/devtools/memory-inspector' as Platform.DevToolsPath.UrlString;\n\nexport class LinearMemoryInspectorPane extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(\n    UI.Widget.VBox) {\n  readonly #tabbedPane: UI.TabbedPane.TabbedPane;\n\n  constructor() {\n    super();\n    this.element.setAttribute('jslog', `${VisualLogging.panel('linear-memory-inspector').track({resize: true})}`);\n    this.#tabbedPane = new UI.TabbedPane.TabbedPane();\n    this.#tabbedPane.setPlaceholderElement(this.createPlaceholder());\n    this.#tabbedPane.setCloseableTabs(true);\n    this.#tabbedPane.setAllowTabReorder(true, true);\n    this.#tabbedPane.addEventListener(UI.TabbedPane.Events.TabClosed, this.#tabClosed, this);\n    this.#tabbedPane.show(this.contentElement);\n    this.#tabbedPane.headerElement().setAttribute(\n        'jslog', `${VisualLogging.toolbar().track({keydown: 'ArrowUp|ArrowLeft|ArrowDown|ArrowRight|Enter|Space'})}`);\n  }\n\n  createPlaceholder(): HTMLElement {\n    const placeholder = document.createElement('div');\n    placeholder.classList.add('empty-state');\n\n    placeholder.createChild('span', 'empty-state-header').textContent = i18nString(UIStrings.noOpenInspections);\n\n    const description = placeholder.createChild('div', 'empty-state-description');\n    description.createChild('span').textContent = i18nString(UIStrings.memoryInspectorExplanation);\n    const link = UI.XLink.XLink.create(\n        MEMORY_INSPECTOR_EXPLANATION_URL, i18nString(UIStrings.learnMore), undefined, undefined, 'learn-more');\n    description.appendChild(link);\n\n    return placeholder;\n  }\n\n  static instance(): LinearMemoryInspectorPane {\n    if (!inspectorInstance) {\n      inspectorInstance = new LinearMemoryInspectorPane();\n    }\n    return inspectorInstance;\n  }\n\n  #tabView(tabId: string): LinearMemoryInspectorView {\n    const view = this.#tabbedPane.tabView(tabId);\n    if (view === null) {\n      throw new Error(`No linear memory inspector view for the given tab id: ${tabId}`);\n    }\n    return view as LinearMemoryInspectorView;\n  }\n\n  create(tabId: string, title: string, arrayWrapper: LazyUint8Array, address?: number): void {\n    const inspectorView = new LinearMemoryInspectorView(arrayWrapper, address, tabId);\n    this.#tabbedPane.appendTab(tabId, title, inspectorView, undefined, false, true);\n    this.#tabbedPane.selectTab(tabId);\n  }\n\n  close(tabId: string): void {\n    this.#tabbedPane.closeTab(tabId, false);\n  }\n\n  reveal(tabId: string, address?: number): void {\n    const view = this.#tabView(tabId);\n\n    if (address !== undefined) {\n      view.updateAddress(address);\n    }\n    this.refreshView(tabId);\n    this.#tabbedPane.selectTab(tabId);\n  }\n\n  refreshView(tabId: string): void {\n    const view = this.#tabView(tabId);\n    view.refreshData();\n  }\n\n  #tabClosed(event: Common.EventTarget.EventTargetEvent<UI.TabbedPane.EventData>): void {\n    const {tabId} = event.data;\n    this.dispatchEventToListeners(Events.VIEW_CLOSED, tabId);\n  }\n}\n\nexport const enum Events {\n  VIEW_CLOSED = 'ViewClosed',\n}\n\nexport interface EventTypes {\n  [Events.VIEW_CLOSED]: string;\n}\n\nexport class LinearMemoryInspectorView extends UI.Widget.VBox {\n  #memoryWrapper: LazyUint8Array;\n  #address: number;\n  #tabId: string;\n  #inspector: LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector;\n  firstTimeOpen: boolean;\n  readonly #hideValueInspector: boolean;\n\n  constructor(\n      memoryWrapper: LazyUint8Array, address: number|undefined = 0, tabId: string, hideValueInspector?: boolean) {\n    super();\n\n    if (address < 0 || address >= memoryWrapper.length()) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    this.#memoryWrapper = memoryWrapper;\n    this.#address = address;\n    this.#tabId = tabId;\n    this.#hideValueInspector = Boolean(hideValueInspector);\n    this.#inspector = new LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector();\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent.eventName,\n        (event: LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent) => {\n          this.#memoryRequested(event);\n        });\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.AddressChangedEvent.eventName,\n        (event: LinearMemoryInspectorComponents.LinearMemoryInspector.AddressChangedEvent) => {\n          this.updateAddress(event.data);\n        });\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.SettingsChangedEvent.eventName,\n        (event: LinearMemoryInspectorComponents.LinearMemoryInspector.SettingsChangedEvent) => {\n          // Stop event from bubbling up, since no element further up needs the event.\n          event.stopPropagation();\n          this.saveSettings(event.data);\n        });\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryHighlightChipList.DeleteMemoryHighlightEvent.eventName,\n        (event: LinearMemoryInspectorComponents.LinearMemoryHighlightChipList.DeleteMemoryHighlightEvent) => {\n          LinearMemoryInspectorController.instance().removeHighlight(this.#tabId, event.data);\n          this.refreshData();\n        });\n    this.contentElement.appendChild(this.#inspector);\n    this.firstTimeOpen = true;\n  }\n\n  override wasShown(): void {\n    this.refreshData();\n  }\n\n  saveSettings(settings: LinearMemoryInspectorComponents.LinearMemoryInspector.Settings): void {\n    LinearMemoryInspectorController.instance().saveSettings(settings);\n  }\n\n  updateAddress(address: number): void {\n    if (address < 0 || address >= this.#memoryWrapper.length()) {\n      throw new Error('Requested address is out of bounds.');\n    }\n    this.#address = address;\n  }\n\n  refreshData(): void {\n    void LinearMemoryInspectorController.getMemoryForAddress(this.#memoryWrapper, this.#address).then(({\n                                                                                                        memory,\n                                                                                                        offset,\n                                                                                                      }) => {\n      let valueTypes;\n      let valueTypeModes;\n      let endianness;\n      if (this.firstTimeOpen) {\n        const settings = LinearMemoryInspectorController.instance().loadSettings();\n        valueTypes = settings.valueTypes;\n        valueTypeModes = settings.modes;\n        endianness = settings.endianness;\n        this.firstTimeOpen = false;\n      }\n      this.#inspector.data = {\n        memory,\n        address: this.#address,\n        memoryOffset: offset,\n        outerMemoryLength: this.#memoryWrapper.length(),\n        valueTypes,\n        valueTypeModes,\n        endianness,\n        highlightInfo: this.#getHighlightInfo(),\n        hideValueInspector: this.#hideValueInspector,\n      };\n    });\n  }\n\n  #memoryRequested(event: LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent): void {\n    const {start, end, address} = event.data;\n    if (address < start || address >= end) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    void LinearMemoryInspectorController.getMemoryRange(this.#memoryWrapper, start, end).then(memory => {\n      this.#inspector.data = {\n        memory,\n        address,\n        memoryOffset: start,\n        outerMemoryLength: this.#memoryWrapper.length(),\n        highlightInfo: this.#getHighlightInfo(),\n        hideValueInspector: this.#hideValueInspector,\n      };\n    });\n  }\n\n  #getHighlightInfo(): LinearMemoryInspectorComponents.LinearMemoryViewerUtils.HighlightInfo|undefined {\n    const highlightInfo = LinearMemoryInspectorController.instance().getHighlightInfo(this.#tabId);\n    if (highlightInfo !== undefined) {\n      if (highlightInfo.startAddress < 0 || highlightInfo.startAddress >= this.#memoryWrapper.length()) {\n        throw new Error('HighlightInfo start address is out of bounds.');\n      }\n      if (highlightInfo.size <= 0) {\n        throw new Error('Highlight size must be a positive number.');\n      }\n    }\n    return highlightInfo;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Common", "i18n", "UI", "LinearMemoryInspectorComponents", "UIStrings", "str_", "i18nString"]
}
