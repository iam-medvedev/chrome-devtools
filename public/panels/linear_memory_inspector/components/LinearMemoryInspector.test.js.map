{"version":3,"file":"LinearMemoryInspector.test.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/linear_memory_inspector/components/LinearMemoryInspector.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  assertScreenshot,\n  renderElementIntoDOM,\n} from '../../../testing/DOMHelpers.js';\nimport {describeWithLocale} from '../../../testing/LocaleHelpers.js';\nimport {\n  createViewFunctionStub,\n  type ViewFunctionStub,\n} from '../../../testing/ViewFunctionHelpers.js';\n\nimport * as LinearMemoryInspectorComponents from './components.js';\n\nconst LinearMemoryInspector = LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector;\n\ndescribeWithLocale('LinearMemoryInspector', () => {\n  it('renders the inspector', async () => {\n    const target = document.createElement('div');\n    target.style.width = 'var(--sys-size-40)';\n    target.style.height = 'var(--sys-size-30)';\n    renderElementIntoDOM(target);\n    const array = [];\n    const string = 'Hello this is a string from the memory buffer!';\n\n    for (let i = 0; i < string.length; ++i) {\n      array.push(string.charCodeAt(i));\n    }\n\n    for (let i = -1000; i < 1000; ++i) {\n      array.push(i);\n    }\n\n    const memory = new Uint8Array(array);\n    const valueTypes = new Set([\n      LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.FLOAT32,\n      LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.INT32,\n      LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.POINTER32\n    ]);\n    const valueTypeModes = new Map();\n\n    LinearMemoryInspectorComponents.LinearMemoryInspector.DEFAULT_VIEW(\n        {\n          memory: new Uint8Array(memory),\n          address: 0,\n          memoryOffset: 0,\n          valueTypes,\n          outerMemoryLength: memory.length,\n          valueTypeModes,\n          endianness: LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.LITTLE,\n          highlightInfo: undefined,\n          hideValueInspector: false,\n          currentNavigatorMode: LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.SUBMITTED,\n          currentNavigatorAddressLine: '0',\n          canGoBackInHistory: false,\n          canGoForwardInHistory: false,\n          onRefreshRequest: () => {},\n          onAddressChange: () => {},\n          onNavigatePage: () => {},\n          onNavigateHistory: () => false,\n          onJumpToAddress: () => {},\n          onDeleteMemoryHighlight: () => {},\n          onByteSelected: () => {},\n          onResize: () => {},\n          onValueTypeToggled: () => {},\n          onValueTypeModeChanged: () => {},\n          onEndiannessChanged: () => {},\n          memorySlice: new Uint8Array(memory),\n          viewerStart: 0,\n        },\n        {},\n        target,\n    );\n    await assertScreenshot('linear_memory_inspector/lmi.png');\n  });\n});\n\ndescribeWithLocale('LinearMemoryInspector', () => {\n  let component: LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector;\n  let view: ViewFunctionStub<typeof LinearMemoryInspector>;\n\n  beforeEach(async () => {\n    view = createViewFunctionStub(LinearMemoryInspector);\n    component = new LinearMemoryInspector(undefined, view);\n\n    const size = 1000;\n    const memory = [];\n    for (let i = 0; i < size; ++i) {\n      memory[i] = i;\n    }\n    component.memory = new Uint8Array(memory);\n    component.address = 20;\n    component.memoryOffset = 0;\n    component.outerMemoryLength = memory.length;\n    component.endianness = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.LITTLE;\n    component.valueTypes = new Set<LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType>(\n        LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.getDefaultValueTypeMapping().keys());\n\n    component.markAsRoot();\n    renderElementIntoDOM(component);\n    await view.nextInput;\n  });\n\n  it('only saves history entries if addresses differ', async () => {\n    // Set the address to zero to avoid the LMI to jump around in terms of addresses\n    // before the LMI is completely rendered (it requires two rendering processes,\n    // meanwhile our test might have already started).\n    component.address = 0;\n    await view.nextInput;\n\n    const byteIndices = [2, 1, 1, 2];\n    const expectedHistory = [2, 1, 2];\n\n    for (const index of byteIndices) {\n      view.input.onByteSelected(new LinearMemoryInspectorComponents.LinearMemoryViewer.ByteSelectedEvent(index));\n      await view.nextInput;\n    }\n\n    for (const index of expectedHistory) {\n      assert.strictEqual(view.input.address, index);\n      view.input.onNavigateHistory(new LinearMemoryInspectorComponents.LinearMemoryNavigator.HistoryNavigationEvent(\n          LinearMemoryInspectorComponents.LinearMemoryNavigator.Navigation.BACKWARD));\n      await view.nextInput;\n    }\n  });\n\n  it('can navigate addresses back and forth in history', async () => {\n    const visitedByteValue = [view.input.address];\n    const historyLength = 10;\n\n    for (let i = 1; i < historyLength; ++i) {\n      view.input.onByteSelected(new LinearMemoryInspectorComponents.LinearMemoryViewer.ByteSelectedEvent(i));\n      const newAddress = (await view.nextInput).address;\n      visitedByteValue.push(newAddress);\n    }\n\n    for (let i = historyLength - 1; i > 0; --i) {\n      assert.strictEqual(view.input.address, visitedByteValue[i]);\n      view.input.onNavigateHistory(new LinearMemoryInspectorComponents.LinearMemoryNavigator.HistoryNavigationEvent(\n          LinearMemoryInspectorComponents.LinearMemoryNavigator.Navigation.BACKWARD));\n      await view.nextInput;\n    }\n    assert.strictEqual(view.input.address, visitedByteValue[0]);\n\n    for (let i = 0; i < historyLength - 1; ++i) {\n      assert.strictEqual(view.input.address, visitedByteValue[i]);\n      view.input.onNavigateHistory(new LinearMemoryInspectorComponents.LinearMemoryNavigator.HistoryNavigationEvent(\n          LinearMemoryInspectorComponents.LinearMemoryNavigator.Navigation.FORWARD));\n      await view.nextInput;\n    }\n    assert.strictEqual(view.input.address, visitedByteValue[historyLength - 1]);\n  });\n\n  it('can turn the page back and forth', async () => {\n    const addressBefore = view.input.address;\n    const numBytesPerPage = view.input.memorySlice.length;\n\n    view.input.onNavigatePage(new LinearMemoryInspectorComponents.LinearMemoryNavigator.PageNavigationEvent(\n        LinearMemoryInspectorComponents.LinearMemoryNavigator.Navigation.FORWARD));\n    let addressAfter = (await view.nextInput).address;\n    let expectedAddressAfter = addressBefore + numBytesPerPage;\n    assert.strictEqual(addressAfter, expectedAddressAfter);\n\n    view.input.onNavigatePage(new LinearMemoryInspectorComponents.LinearMemoryNavigator.PageNavigationEvent(\n        LinearMemoryInspectorComponents.LinearMemoryNavigator.Navigation.BACKWARD));\n    addressAfter = (await view.nextInput).address;\n    expectedAddressAfter -= numBytesPerPage;\n    assert.strictEqual(addressAfter, Math.max(0, expectedAddressAfter));\n  });\n\n  it('synchronizes selected addresses in navigator and viewer', async () => {\n    const expectedByteValue = view.input.memory[view.input.address];\n    assert.strictEqual(view.input.address, expectedByteValue);\n  });\n\n  it('can change endianness settings on event', async () => {\n    assert.deepEqual(\n        view.input.endianness, LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.LITTLE);\n\n    const endianSetting = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.BIG;\n    const event =\n        new LinearMemoryInspectorComponents.LinearMemoryValueInterpreter.EndiannessChangedEvent(endianSetting);\n    view.input.onEndiannessChanged(event);\n\n    const newViewInput = await view.nextInput;\n    assert.deepEqual(newViewInput.endianness, event.data);\n  });\n\n  it('updates current address if user triggers a jumptopointeraddress event', async () => {\n    const memory = new Uint8Array([2, 0, 0, 0]);\n    component.valueTypes = new Set([LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.POINTER32]);\n    component.memory = memory;\n    component.outerMemoryLength = memory.length;\n    component.address = 0;\n    component.endianness = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.LITTLE;\n    await view.nextInput;\n\n    const event = new LinearMemoryInspectorComponents.ValueInterpreterDisplay.JumpToPointerAddressEvent(2);\n    view.input.onJumpToAddress(event);\n    const newViewInput = await view.nextInput;\n\n    const expectedSelectedByte = new DataView(memory.buffer).getUint32(0, true);\n    assert.strictEqual(newViewInput.address, expectedSelectedByte);\n  });\n\n  it('leaves the navigator address as inputted by user on edit event', async () => {\n    const event = new LinearMemoryInspectorComponents.LinearMemoryNavigator.AddressInputChangedEvent(\n        '2', LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.EDIT);\n    view.input.onAddressChange(event);\n    const newViewInput = await view.nextInput;\n    assert.strictEqual(newViewInput.currentNavigatorAddressLine, '2');\n    assert.strictEqual(\n        newViewInput.currentNavigatorMode, LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.EDIT);\n  });\n\n  it('leaves the navigator address as inputted by user on invalid edit event', async () => {\n    const event = new LinearMemoryInspectorComponents.LinearMemoryNavigator.AddressInputChangedEvent(\n        '-2', LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.EDIT);\n    view.input.onAddressChange(event);\n    const newViewInput = await view.nextInput;\n    assert.strictEqual(newViewInput.currentNavigatorAddressLine, '-2');\n    assert.strictEqual(\n        newViewInput.currentNavigatorMode, LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.EDIT);\n  });\n\n  it('leaves the navigator address as inputted by user on invalid submit event', async () => {\n    const event = new LinearMemoryInspectorComponents.LinearMemoryNavigator.AddressInputChangedEvent(\n        '-2', LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.SUBMITTED);\n    view.input.onAddressChange(event);\n    const newViewInput = await view.nextInput;\n    assert.strictEqual(newViewInput.currentNavigatorAddressLine, '-2');\n    assert.strictEqual(\n        newViewInput.currentNavigatorMode, LinearMemoryInspectorComponents.LinearMemoryNavigator.Mode.INVALID_SUBMIT);\n  });\n\n  it('triggers MemoryRequestEvent on refresh', async () => {\n    const memoryRequestPromise =\n        component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.MEMORY_REQUEST);\n\n    view.input.onRefreshRequest();\n    const {start, end, address} = await memoryRequestPromise;\n\n    assert.strictEqual(address, view.input.address);\n    assert.isAbove(end, start);\n    assert.strictEqual(view.input.memorySlice.length, end - start);\n  });\n\n  it('triggers event on address change when byte is selected', async () => {\n    const addressPromise = component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.ADDRESS_CHANGED);\n\n    const numBytesPerPage = view.input.memorySlice.length;\n    const pageNumber = view.input.address / numBytesPerPage;\n    const addressOfFirstByte = pageNumber * numBytesPerPage + 1;\n    view.input.onByteSelected(\n        new LinearMemoryInspectorComponents.LinearMemoryViewer.ByteSelectedEvent(addressOfFirstByte));\n    const address = await addressPromise;\n    assert.strictEqual(address, addressOfFirstByte);\n  });\n\n  it('triggers event on address change when data is set', async () => {\n    const addressPromise = component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.ADDRESS_CHANGED);\n    component.address = 10;\n    const address = await addressPromise;\n    assert.strictEqual(address, 10);\n  });\n\n  it('triggers event on settings changed when value type is changed', async () => {\n    const settingsPromise =\n        component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.SETTINGS_CHANGED);\n\n    const valueType = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.INT16;\n    view.input.onValueTypeToggled(\n        new LinearMemoryInspectorComponents.LinearMemoryValueInterpreter.ValueTypeToggledEvent(valueType, false));\n    const {valueTypes} = await settingsPromise;\n    assert.isTrue(valueTypes.size > 1);\n    assert.isFalse(valueTypes.has(valueType));\n  });\n\n  it('triggers event on settings changed when value type mode is changed', async () => {\n    const settingsPromise =\n        component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.SETTINGS_CHANGED);\n    const valueType = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueType.INT16;\n    const valueTypeMode = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.ValueTypeMode.HEXADECIMAL;\n    view.input.onValueTypeModeChanged(\n        new LinearMemoryInspectorComponents.ValueInterpreterDisplay.ValueTypeModeChangedEvent(\n            valueType, valueTypeMode));\n    const {valueTypes, modes} = await settingsPromise;\n    assert.isTrue(valueTypes.has(valueType));\n    assert.strictEqual(modes.get(valueType), valueTypeMode);\n  });\n\n  it('triggers event on settings changed when endianness is changed', async () => {\n    const settingsPromise =\n        component.once(LinearMemoryInspectorComponents.LinearMemoryInspector.Events.SETTINGS_CHANGED);\n    const endianness = LinearMemoryInspectorComponents.ValueInterpreterDisplayUtils.Endianness.BIG;\n    view.input.onEndiannessChanged(\n        new LinearMemoryInspectorComponents.LinearMemoryValueInterpreter.EndiannessChangedEvent(endianness));\n    const event = await settingsPromise;\n    assert.strictEqual(event.endianness, endianness);\n  });\n\n  it('formats a hexadecimal number', () => {\n    const number = 23;\n    assert.strictEqual(\n        LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.toHexString({number, pad: 0, prefix: false}), '17');\n  });\n\n  it('formats a hexadecimal number and adds padding', () => {\n    const number = 23;\n    assert.strictEqual(\n        LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.toHexString({number, pad: 5, prefix: false}),\n        '00017');\n  });\n\n  it('formats a hexadecimal number and adds prefix', () => {\n    const number = 23;\n    assert.strictEqual(\n        LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.toHexString({number, pad: 5, prefix: true}),\n        '0x00017');\n  });\n\n  it('can parse a valid hexadecimal address', () => {\n    const address = '0xa';\n    const parsedAddress = LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.parseAddress(address);\n    assert.strictEqual(parsedAddress, 10);\n  });\n\n  it('can parse a valid decimal address', () => {\n    const address = '20';\n    const parsedAddress = LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.parseAddress(address);\n    assert.strictEqual(parsedAddress, 20);\n  });\n\n  it('returns undefined on parsing invalid address', () => {\n    const address = '20a';\n    const parsedAddress = LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.parseAddress(address);\n    assert.isUndefined(parsedAddress);\n  });\n\n  it('returns undefined on parsing negative address', () => {\n    const address = '-20';\n    const parsedAddress = LinearMemoryInspectorComponents.LinearMemoryInspectorUtils.parseAddress(address);\n    assert.isUndefined(parsedAddress);\n  });\n\n  it('can hide the value inspector', async () => {\n    component.hideValueInspector = true;\n    const newInput = await view.nextInput;\n    assert.isTrue(newInput.hideValueInspector);\n  });\n});\n"]}