{"version":3,"file":"PropertyParser.js","sourceRoot":"","sources":["../../../../../../front_end/panels/elements/PropertyParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as CodeMirror from '../../third_party/codemirror.next/codemirror.next.js';\nimport * as InlineEditor from '../../ui/legacy/components/inline_editor/inline_editor.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nconst cssParser = CodeMirror.css.cssLanguage.parser;\n\nfunction nodeText(node: CodeMirror.SyntaxNode, text: string): string {\n  return nodeTextRange(node, node, text);\n}\nfunction nodeTextRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode, text: string): string {\n  return text.substring(from.from, to.to);\n}\n\nexport class SyntaxTree {\n  readonly propertyValue: string;\n  readonly rule: string;\n  readonly tree: CodeMirror.SyntaxNode;\n  readonly trailingNodes: CodeMirror.SyntaxNode[];\n  readonly propertyName: string|undefined;\n  constructor(\n      propertyValue: string, rule: string, tree: CodeMirror.SyntaxNode, propertyName?: string,\n      trailingNodes: CodeMirror.SyntaxNode[] = []) {\n    this.propertyName = propertyName;\n    this.propertyValue = propertyValue;\n    this.rule = rule;\n    this.tree = tree;\n    this.trailingNodes = trailingNodes;\n  }\n\n  text(node?: CodeMirror.SyntaxNode|null): string {\n    if (node === null) {\n      return '';\n    }\n    return nodeText(node ?? this.tree, this.rule);\n  }\n\n  textRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): string {\n    return nodeTextRange(from, to, this.rule);\n  }\n\n  subtree(node: CodeMirror.SyntaxNode): SyntaxTree {\n    return new SyntaxTree(this.propertyValue, this.rule, node);\n  }\n}\n\nexport interface SyntaxNodeRef {\n  node: CodeMirror.SyntaxNode;\n}\n\nexport abstract class TreeWalker {\n  readonly ast: SyntaxTree;\n  constructor(ast: SyntaxTree) {\n    this.ast = ast;\n  }\n  static walkExcludingSuccessors<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterateExcludingSuccessors(propertyValue.tree);\n    }\n    return instance;\n  }\n  static walk<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterate(propertyValue.tree);\n    }\n    return instance;\n  }\n\n  iterateDeclaration(tree: CodeMirror.SyntaxNode): void {\n    if (tree.name !== 'Declaration') {\n      return;\n    }\n    if (this.enter(tree)) {\n      ASTUtils.declValue(tree)?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n    }\n    this.leave(tree);\n  }\n\n  protected iterate(tree: CodeMirror.SyntaxNode): void {\n    tree.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n  }\n\n  protected iterateExcludingSuccessors(tree: CodeMirror.SyntaxNode): void {\n    // Customize the first step to avoid visiting siblings of `tree`\n    if (this.enter(tree)) {\n      tree.firstChild?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n    }\n    this.leave(tree);\n  }\n\n  protected enter(_node: SyntaxNodeRef): boolean {\n    return true;\n  }\n\n  protected leave(_node: SyntaxNodeRef): void {\n  }\n}\n\nexport class RenderingContext {\n  constructor(\n      readonly ast: SyntaxTree, readonly matchedResult: BottomUpTreeMatching, readonly cssControls?: CSSControlMap,\n      readonly options: {readonly: boolean} = {readonly: false}) {\n  }\n  addControl(cssType: string, control: HTMLElement): void {\n    if (this.cssControls) {\n      const controls = this.cssControls.get(cssType);\n      if (!controls) {\n        this.cssControls.set(cssType, [control]);\n      } else {\n        controls.push(control);\n      }\n    }\n  }\n}\n\nexport interface Match {\n  readonly text: string;\n  readonly type: string;\n  render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n  computedText?(): string|null;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Constructor = (abstract new (...args: any[]) => any)|(new (...args: any[]) => any);\nexport type MatchFactory<MatchT extends Constructor> = (...args: ConstructorParameters<MatchT>) => InstanceType<MatchT>;\n\nexport interface Matcher {\n  accepts(propertyName: string): boolean;\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null;\n}\n\nexport abstract class MatcherBase<MatchT extends Constructor> implements Matcher {\n  constructor(readonly createMatch: MatchFactory<MatchT>) {\n  }\n\n  accepts(_propertyName: string): boolean {\n    return true;\n  }\n\n  abstract matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null;\n}\n\ntype MatchKey = Platform.Brand.Brand<string, 'MatchKey'>;\nexport class BottomUpTreeMatching extends TreeWalker {\n  #matchers: Matcher[] = [];\n  #matchedNodes = new Map<MatchKey, Match>();\n  readonly computedText: ComputedText;\n\n  #key(node: CodeMirror.SyntaxNode): MatchKey {\n    return `${node.from}:${node.to}` as MatchKey;\n  }\n\n  constructor(ast: SyntaxTree, matchers: Matcher[]) {\n    super(ast);\n    this.computedText = new ComputedText(ast.rule.substring(ast.tree.from));\n    this.#matchers.push(...matchers.filter(m => !ast.propertyName || m.accepts(ast.propertyName)));\n    this.#matchers.push(new TextMatcher());\n  }\n\n  protected override leave({node}: SyntaxNodeRef): void {\n    for (const matcher of this.#matchers) {\n      const match = matcher.matches(node, this);\n      if (match) {\n        this.computedText.push(match, node.from - this.ast.tree.from);\n        this.#matchedNodes.set(this.#key(node), match);\n        break;\n      }\n    }\n  }\n\n  matchText(node: CodeMirror.SyntaxNode): void {\n    const matchers = this.#matchers.splice(0);\n    this.#matchers.push(new TextMatcher());\n    this.iterateExcludingSuccessors(node);\n    this.#matchers.push(...matchers);\n  }\n\n  getMatch(node: CodeMirror.SyntaxNode): Match|undefined {\n    return this.#matchedNodes.get(this.#key(node));\n  }\n\n  hasUnresolvedVars(node: CodeMirror.SyntaxNode): boolean {\n    return this.hasUnresolvedVarsRange(node, node);\n  }\n\n  hasUnresolvedVarsRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): boolean {\n    return this.computedText.hasUnresolvedVars(from.from - this.ast.tree.from, to.to - this.ast.tree.from);\n  }\n\n  getComputedText(node: CodeMirror.SyntaxNode): string {\n    return this.getComputedTextRange(node, node);\n  }\n\n  getComputedTextRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): string {\n    return this.computedText.get(from.from - this.ast.tree.from, to.to - this.ast.tree.from);\n  }\n}\n\ntype MatchWithComputedText = Match&{computedText: NonNullable<Match['computedText']>};\nclass ComputedTextChunk {\n  #cachedComputedText: string|null = null;\n  constructor(readonly match: MatchWithComputedText, readonly offset: number) {\n  }\n\n  get end(): number {\n    return this.offset + this.length;\n  }\n\n  get length(): number {\n    return this.match.text.length;\n  }\n\n  get computedText(): string|null {\n    if (this.#cachedComputedText === null) {\n      this.#cachedComputedText = this.match.computedText();\n    }\n    return this.#cachedComputedText;\n  }\n}\n\n// This class constructs the \"computed\" text from the input property text, i.e., it will strip comments and substitute\n// var() functions if possible. It's intended for use during the bottom-up tree matching process. The original text is\n// not modified. Instead, computed text slices are produced on the fly. During bottom-up matching, the sequence of\n// top-level comments and var() matches will be recorded. This produces an ordered sequence of text pieces that need to\n// be substituted into the original text. When a computed text slice is requested, it is generated by piecing together\n// original and computed slices as required.\nexport class ComputedText {\n  readonly #chunks: ComputedTextChunk[] = [];\n  readonly text: string;\n  #sorted: boolean = true;\n  constructor(text: string) {\n    this.text = text;\n  }\n\n  clear(): void {\n    this.#chunks.splice(0);\n  }\n\n  get chunkCount(): number {\n    return this.#chunks.length;\n  }\n\n  #sortIfNecessary(): void {\n    if (this.#sorted) {\n      return;\n    }\n    // Sort intervals by offset, with longer intervals first if the offset is identical.\n    this.#chunks.sort((a, b) => {\n      if (a.offset < b.offset) {\n        return -1;\n      }\n      if (b.offset < a.offset) {\n        return 1;\n      }\n      if (a.end > b.end) {\n        return -1;\n      }\n      if (a.end < b.end) {\n        return 1;\n      }\n      return 0;\n    });\n    this.#sorted = true;\n  }\n\n  // Add another substitutable match. The match will either be appended to the list of existing matches or it will\n  // be substituted for the last match(es) if it encompasses them.\n  push(match: Match, offset: number): void {\n    function hasComputedText(match: Match): match is MatchWithComputedText {\n      return Boolean(match.computedText);\n    }\n    if (!hasComputedText(match) || offset < 0 || offset >= this.text.length) {\n      return;\n    }\n    const chunk = new ComputedTextChunk(match, offset);\n    if (chunk.end > this.text.length) {\n      return;\n    }\n    this.#sorted = false;\n    this.#chunks.push(chunk);\n  }\n\n  * #range(begin: number, end: number): Generator<ComputedTextChunk> {\n    this.#sortIfNecessary();\n    let i = this.#chunks.findIndex(c => c.offset >= begin);\n    while (i >= 0 && i < this.#chunks.length && this.#chunks[i].end > begin && begin < end) {\n      if (this.#chunks[i].end > end) {\n        i++;\n        continue;\n      }\n      yield this.#chunks[i];\n      begin = this.#chunks[i].end;\n      while (begin < end && i < this.#chunks.length && this.#chunks[i].offset < begin) {\n        i++;\n      }\n    }\n  }\n\n  hasUnresolvedVars(begin: number, end: number): boolean {\n    for (const chunk of this.#range(begin, end)) {\n      if (chunk.computedText === null) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Get a slice of the computed text corresponding to the property text in the range [begin, end). The slice may not\n  // start within a substitution chunk, e.g., it's invalid to request the computed text for the property value text\n  // slice \"1px var(--\".\n  get(begin: number, end: number): string {\n    const pieces: string[] = [];\n    const push = (text: string): void => {\n      if (text.length === 0) {\n        return;\n      }\n      if (pieces.length > 0 && requiresSpace(pieces[pieces.length - 1], text)) {\n        pieces.push(' ');\n      }\n      pieces.push(text);\n    };\n\n    for (const chunk of this.#range(begin, end)) {\n      const piece = this.text.substring(begin, Math.min(chunk.offset, end));\n\n      push(piece);\n      if (end >= chunk.end) {\n        push(chunk.computedText ?? chunk.match.text);\n      }\n\n      begin = chunk.end;\n    }\n    if (begin < end) {\n      const piece = this.text.substring(begin, end);\n      push(piece);\n    }\n    return pieces.join('');\n  }\n}\n\n// This function determines whether concatenating two pieces of text requires any spacing inbetween. For example, there\n// shouldn't be any space between 'var' and '(', but there should be a space between '1px' and 'solid'. The node\n// sequences that make up the pieces of text may contain non-text nodes/trees. Any such element inbetween the texts is\n// ignored for the spacing requirement.\nexport function requiresSpace(a: string, b: string): boolean;\nexport function requiresSpace(a: Node[], b: Node[]): boolean;\nexport function requiresSpace(a: Node[]|string|undefined, b: Node[]|string|undefined): boolean {\n  const tail = Array.isArray(a) ? a.findLast(node => node.textContent)?.textContent : a;\n  const head = Array.isArray(b) ? b.find(node => node.textContent)?.textContent : b;\n  const trailingChar = tail ? tail[tail.length - 1] : '';\n  const leadingChar = head ? head[0] : '';\n\n  const noSpaceAfter = ['', '(', '{', '}', ';'];\n  const noSpaceBefore = ['', '(', ')', ',', ':', '*', '{', ';'];\n  return !/\\s/.test(trailingChar) && !/\\s/.test(leadingChar) && !noSpaceAfter.includes(trailingChar) &&\n      !noSpaceBefore.includes(leadingChar);\n}\n\nexport const CSSControlMap = Map<string, HTMLElement[]>;\nexport type CSSControlMap = Map<string, HTMLElement[]>;\n\nfunction mergeWithSpacing(nodes: Node[], merge: Node[]): Node[] {\n  const result = [...nodes];\n  if (requiresSpace(nodes, merge)) {\n    result.push(document.createTextNode(' '));\n  }\n  result.push(...merge);\n  return result;\n}\n\nexport class Renderer extends TreeWalker {\n  readonly #matchedResult: BottomUpTreeMatching;\n  #output: Node[] = [];\n  readonly #context: RenderingContext;\n\n  constructor(ast: SyntaxTree, matchedResult: BottomUpTreeMatching, cssControls: CSSControlMap, options: {\n    readonly: boolean,\n  }) {\n    super(ast);\n    this.#matchedResult = matchedResult;\n    this.#context = new RenderingContext(this.ast, this.#matchedResult, cssControls, options);\n  }\n\n  static render(nodeOrNodes: CodeMirror.SyntaxNode|CodeMirror.SyntaxNode[], context: RenderingContext):\n      {nodes: Node[], cssControls: CSSControlMap} {\n    if (!Array.isArray(nodeOrNodes)) {\n      return this.render([nodeOrNodes], context);\n    }\n    const cssControls = new CSSControlMap();\n    const renderers = nodeOrNodes.map(\n        node => this.walkExcludingSuccessors(\n            context.ast.subtree(node), context.matchedResult, cssControls, context.options));\n    const nodes = renderers.map(node => node.#output).reduce(mergeWithSpacing);\n    return {nodes, cssControls};\n  }\n\n  static renderInto(\n      nodeOrNodes: CodeMirror.SyntaxNode|CodeMirror.SyntaxNode[], context: RenderingContext,\n      parent: Node): {nodes: Node[], cssControls: CSSControlMap} {\n    const {nodes, cssControls} = this.render(nodeOrNodes, context);\n    if (parent.lastChild && requiresSpace([parent.lastChild], nodes)) {\n      parent.appendChild(document.createTextNode(' '));\n    }\n    nodes.map(n => parent.appendChild(n));\n    return {nodes, cssControls};\n  }\n\n  renderedMatchForTest(_nodes: Node[], _match: Match): void {\n  }\n\n  protected override enter({node}: SyntaxNodeRef): boolean {\n    const match = this.#matchedResult.getMatch(node);\n    if (match) {\n      const output = match.render(node, this.#context);\n      this.renderedMatchForTest(output, match);\n      this.#output = mergeWithSpacing(this.#output, output);\n      return false;\n    }\n\n    return true;\n  }\n}\n\nexport namespace ASTUtils {\n  export function siblings(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    const result = [];\n    while (node) {\n      result.push(node);\n      node = node.nextSibling;\n    }\n    return result;\n  }\n\n  export function children(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    return siblings(node?.firstChild ?? null);\n  }\n\n  export function declValue(node: CodeMirror.SyntaxNode): CodeMirror.SyntaxNode|null {\n    if (node.name !== 'Declaration') {\n      return null;\n    }\n    return children(node).find(node => node.name === ':')?.nextSibling ?? null;\n  }\n\n  export function* stripComments(nodes: CodeMirror.SyntaxNode[]): Generator<CodeMirror.SyntaxNode> {\n    for (const node of nodes) {\n      if (node.type.name !== 'Comment') {\n        yield node;\n      }\n    }\n  }\n\n  export function split(nodes: CodeMirror.SyntaxNode[]): CodeMirror.SyntaxNode[][] {\n    const result = [];\n    let current = [];\n    for (const node of nodes) {\n      if (node.name === ',') {\n        result.push(current);\n        current = [];\n      } else {\n        current.push(node);\n      }\n    }\n    result.push(current);\n    return result;\n  }\n\n  export function callArgs(node: CodeMirror.SyntaxNode): CodeMirror.SyntaxNode[][] {\n    const args = children(node.getChild('ArgList'));\n    const openParen = args.splice(0, 1)[0];\n    const closingParen = args.pop();\n\n    if (openParen?.name !== '(' || closingParen?.name !== ')') {\n      return [];\n    }\n\n    return split(args);\n  }\n}\n\nexport abstract class AngleMatch implements Match {\n  readonly type: string = 'angle';\n  constructor(readonly text: string) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class AngleMatcher extends MatcherBase<typeof AngleMatch> {\n  override accepts(propertyName: string): boolean {\n    return SDK.CSSMetadata.cssMetadata().isAngleAwareProperty(propertyName);\n  }\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (node.name !== 'NumberLiteral') {\n      return null;\n    }\n    const unit = node.getChild('Unit');\n    // TODO(crbug/1138628) handle unitless 0\n    if (!unit || !['deg', 'grad', 'rad', 'turn'].includes(matching.ast.text(unit))) {\n      return null;\n    }\n\n    return this.createMatch(matching.ast.text(node));\n  }\n}\n\nfunction literalToNumber(node: CodeMirror.SyntaxNode, ast: SyntaxTree): number|null {\n  if (node.type.name !== 'NumberLiteral') {\n    return null;\n  }\n  const text = ast.text(node);\n\n  return Number(text.substring(0, text.length - ast.text(node.getChild('Unit')).length));\n}\n\nexport abstract class ColorMixMatch implements Match {\n  readonly type = 'color-mix';\n  constructor(\n      readonly text: string, readonly space: CodeMirror.SyntaxNode[], readonly color1: CodeMirror.SyntaxNode[],\n      readonly color2: CodeMirror.SyntaxNode[]) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class ColorMixMatcher extends MatcherBase<typeof ColorMixMatch> {\n  override accepts(propertyName: string): boolean {\n    return SDK.CSSMetadata.cssMetadata().isColorAwareProperty(propertyName);\n  }\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (node.name !== 'CallExpression' || matching.ast.text(node.getChild('Callee')) !== 'color-mix') {\n      return null;\n    }\n\n    const computedValueTree = tokenizeDeclaration('--property', matching.getComputedText(node));\n    if (!computedValueTree) {\n      return null;\n    }\n\n    const value = ASTUtils.declValue(computedValueTree.tree);\n    if (!value) {\n      return null;\n    }\n    const computedValueArgs = ASTUtils.callArgs(value);\n    if (computedValueArgs.length !== 3) {\n      return null;\n    }\n\n    const [space, color1, color2] = computedValueArgs;\n    // Verify that all arguments are there, and that the space starts with a literal `in`.\n    if (space.length < 2 || computedValueTree.text(ASTUtils.stripComments(space).next().value) !== 'in' ||\n        color1.length < 1 || color2.length < 1) {\n      return null;\n    }\n\n    // Verify there's at most one percentage value for each color.\n    const p1 =\n        color1.filter(n => n.type.name === 'NumberLiteral' && computedValueTree.text(n.getChild('Unit')) === '%');\n    const p2 =\n        color2.filter(n => n.type.name === 'NumberLiteral' && computedValueTree.text(n.getChild('Unit')) === '%');\n    if (p1.length > 1 || p2.length > 1) {\n      return null;\n    }\n\n    // Verify that if both colors carry percentages, they aren't both zero (which is an invalid property value).\n    if (p1[0] && p2[0] && (literalToNumber(p1[0], computedValueTree) ?? 0) === 0 &&\n        (literalToNumber(p2[0], computedValueTree) ?? 0) === 0) {\n      return null;\n    }\n\n    const args = ASTUtils.callArgs(node);\n    if (args.length !== 3) {\n      return null;\n    }\n    return this.createMatch(matching.ast.text(node), args[0], args[1], args[2]);\n  }\n}\n\nexport abstract class VariableMatch implements Match {\n  readonly type: string = 'var';\n  constructor(\n      readonly text: string, readonly name: string, readonly fallback: CodeMirror.SyntaxNode[],\n      protected readonly matching: BottomUpTreeMatching) {\n  }\n\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class VariableMatcher extends MatcherBase<typeof VariableMatch> {\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const callee = node.getChild('Callee');\n    const args = node.getChild('ArgList');\n    if (node.name !== 'CallExpression' || !callee || (matching.ast.text(callee) !== 'var') || !args) {\n      return null;\n    }\n\n    const [lparenNode, nameNode, ...fallbackOrRParenNodes] = ASTUtils.children(args);\n\n    if (lparenNode?.name !== '(' || nameNode?.name !== 'VariableName') {\n      return null;\n    }\n\n    if (fallbackOrRParenNodes.length <= 1 && fallbackOrRParenNodes[0]?.name !== ')') {\n      return null;\n    }\n\n    let fallback: CodeMirror.SyntaxNode[] = [];\n    if (fallbackOrRParenNodes.length > 1) {\n      if (fallbackOrRParenNodes.shift()?.name !== ',') {\n        return null;\n      }\n      if (fallbackOrRParenNodes.pop()?.name !== ')') {\n        return null;\n      }\n      fallback = fallbackOrRParenNodes;\n      if (fallback.length === 0) {\n        return null;\n      }\n      if (fallback.some(n => n.name === ',')) {\n        return null;\n      }\n    }\n\n    const varName = matching.ast.text(nameNode);\n    if (!varName.startsWith('--')) {\n      return null;\n    }\n\n    return this.createMatch(matching.ast.text(node), varName, fallback, matching);\n  }\n}\n\nexport abstract class URLMatch implements Match {\n  readonly type = 'url';\n  constructor(readonly url: Platform.DevToolsPath.UrlString, readonly text: string) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class URLMatcher extends MatcherBase<typeof URLMatch> {\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (node.name !== 'CallLiteral') {\n      return null;\n    }\n    const callee = node.getChild('CallTag');\n    if (!callee || matching.ast.text(callee) !== 'url') {\n      return null;\n    }\n    const [, lparenNode, urlNode, rparenNode] = ASTUtils.siblings(callee);\n    if (matching.ast.text(lparenNode) !== '(' ||\n        (urlNode.name !== 'ParenthesizedContent' && urlNode.name !== 'StringLiteral') ||\n        matching.ast.text(rparenNode) !== ')') {\n      return null;\n    }\n\n    const text = matching.ast.text(urlNode);\n    const url = (urlNode.name === 'StringLiteral' ? text.substr(1, text.length - 2) : text.trim()) as\n        Platform.DevToolsPath.UrlString;\n    return this.createMatch(url, matching.ast.text(node));\n  }\n}\n\nexport abstract class ColorMatch implements Match {\n  readonly type = 'color';\n  constructor(readonly text: string) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class ColorMatcher extends MatcherBase<typeof ColorMatch> {\n  override accepts(propertyName: string): boolean {\n    return SDK.CSSMetadata.cssMetadata().isColorAwareProperty(propertyName);\n  }\n\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const text = matching.ast.text(node);\n    if (node.name === 'ColorLiteral') {\n      return this.createMatch(text);\n    }\n    if (node.name === 'ValueName' && Common.Color.Nicknames.has(text)) {\n      return this.createMatch(text);\n    }\n    if (node.name === 'CallExpression') {\n      const callee = node.getChild('Callee');\n      if (callee && matching.ast.text(callee).match(/^(rgba?|hsla?|hwba?|lab|lch|oklab|oklch|color)$/)) {\n        return this.createMatch(text);\n      }\n    }\n    return null;\n  }\n}\n\nexport const enum LinkableNameProperties {\n  Animation = 'animation',\n  AnimationName = 'animation-name',\n  FontPalette = 'font-palette',\n  PositionFallback = 'position-fallback',\n}\n\nconst enum AnimationLonghandPart {\n  Direction = 'direction',\n  FillMode = 'fill-mode',\n  PlayState = 'play-state',\n  IterationCount = 'iteration-count',\n  EasingFunction = 'easing-function',\n}\n\nexport abstract class LinkableNameMatch implements Match {\n  readonly type = 'linkable-name';\n  constructor(readonly text: string, readonly properyName: LinkableNameProperties) {\n  }\n\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class LinkableNameMatcher extends MatcherBase<typeof LinkableNameMatch> {\n  private static isLinkableNameProperty(propertyName: string): propertyName is LinkableNameProperties {\n    const names: string[] = [\n      LinkableNameProperties.Animation,\n      LinkableNameProperties.AnimationName,\n      LinkableNameProperties.FontPalette,\n      LinkableNameProperties.PositionFallback,\n    ];\n    return names.includes(propertyName);\n  }\n\n  static readonly identifierAnimationLonghandMap: Map<string, AnimationLonghandPart> = new Map(\n      Object.entries({\n        'normal': AnimationLonghandPart.Direction,\n        'alternate': AnimationLonghandPart.Direction,\n        'reverse': AnimationLonghandPart.Direction,\n        'alternate-reverse': AnimationLonghandPart.Direction,\n        'none': AnimationLonghandPart.FillMode,\n        'forwards': AnimationLonghandPart.FillMode,\n        'backwards': AnimationLonghandPart.FillMode,\n        'both': AnimationLonghandPart.FillMode,\n        'running': AnimationLonghandPart.PlayState,\n        'paused': AnimationLonghandPart.PlayState,\n        'infinite': AnimationLonghandPart.IterationCount,\n        'linear': AnimationLonghandPart.EasingFunction,\n        'ease': AnimationLonghandPart.EasingFunction,\n        'ease-in': AnimationLonghandPart.EasingFunction,\n        'ease-out': AnimationLonghandPart.EasingFunction,\n        'ease-in-out': AnimationLonghandPart.EasingFunction,\n      }),\n  );\n\n  private matchAnimationNameInShorthand(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    // Order is important within each animation definition for distinguishing <keyframes-name> values from other keywords.\n    // When parsing, keywords that are valid for properties other than animation-name\n    // whose values were not found earlier in the shorthand must be accepted for those properties rather than for animation-name.\n    // See the details in: https://w3c.github.io/csswg-drafts/css-animations/#animation.\n    const text = matching.ast.text(node);\n    // This is not a known identifier, so return it as `animation-name`.\n    if (!LinkableNameMatcher.identifierAnimationLonghandMap.has(text)) {\n      return this.createMatch(text, LinkableNameProperties.Animation);\n    }\n    // There can be multiple `animation` declarations splitted by a comma.\n    // So, we find the declaration nodes that are related to the node argument.\n    const declarations = ASTUtils.split(ASTUtils.siblings(ASTUtils.declValue(matching.ast.tree)));\n    const currentDeclarationNodes = declarations.find(\n        declaration => declaration[0].from <= node.from && declaration[declaration.length - 1].to >= node.to);\n    if (!currentDeclarationNodes) {\n      return null;\n    }\n\n    // We reparse here until the node argument since a variable might be\n    // providing a meaningful value such as a timing keyword,\n    // that might change the meaning of the node.\n    const computedText = matching.getComputedTextRange(currentDeclarationNodes[0], node);\n    const tokenized = tokenizeDeclaration('--p', computedText);\n    if (!tokenized) {\n      return null;\n    }\n\n    const identifierCategory =\n        LinkableNameMatcher.identifierAnimationLonghandMap.get(text);  // The category of the node argument\n    for (let itNode: typeof tokenized.tree|null = ASTUtils.declValue(tokenized.tree); itNode?.nextSibling;\n         itNode = itNode.nextSibling) {\n      // Run through all the nodes that come before node argument\n      // and check whether a value in the same category is found.\n      // if so, it means our identifier is an `animation-name` keyword.\n      if (itNode.name === 'ValueName') {\n        const categoryValue = LinkableNameMatcher.identifierAnimationLonghandMap.get(tokenized.text(itNode));\n        if (categoryValue && categoryValue === identifierCategory) {\n          return this.createMatch(text, LinkableNameProperties.Animation);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  override accepts(propertyName: string): boolean {\n    return LinkableNameMatcher.isLinkableNameProperty(propertyName);\n  }\n\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const {propertyName} = matching.ast;\n    const text = matching.ast.text(node);\n    const parentNode = node.parent;\n    if (!parentNode) {\n      return null;\n    }\n\n    const isParentADeclaration = parentNode.name === 'Declaration';\n    const isInsideVarCall = parentNode.name === 'ArgList' && parentNode.prevSibling?.name === 'Callee' &&\n        matching.ast.text(parentNode.prevSibling) === 'var';\n    const isAParentDeclarationOrVarCall = isParentADeclaration || isInsideVarCall;\n    // We only mark top level nodes or nodes that are inside `var()` expressions as linkable names.\n    if (!propertyName || (node.name !== 'ValueName' && node.name !== 'VariableName') ||\n        !isAParentDeclarationOrVarCall) {\n      return null;\n    }\n\n    if (propertyName === 'animation') {\n      return this.matchAnimationNameInShorthand(node, matching);\n    }\n\n    // The assertion here is safe since this matcher only runs for\n    // properties with names inside `LinkableNameProperties` (See the `accepts` function.)\n    return this.createMatch(text, propertyName as LinkableNameProperties);\n  }\n}\n\nexport abstract class BezierMatch implements Match {\n  readonly type: string = 'bezier';\n  constructor(readonly text: string) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class BezierMatcher extends MatcherBase<typeof BezierMatch> {\n  override accepts(propertyName: string): boolean {\n    return SDK.CSSMetadata.cssMetadata().isBezierAwareProperty(propertyName);\n  }\n\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const text = matching.ast.text(node);\n\n    const isCubicBezierKeyword = node.name === 'ValueName' && UI.Geometry.CubicBezier.KeywordValues.has(text);\n    const isCubicBezierOrLinearFunction = node.name === 'CallExpression' &&\n        ['cubic-bezier', 'linear'].includes(matching.ast.text(node.getChild('Callee')));\n\n    if (!isCubicBezierKeyword && !isCubicBezierOrLinearFunction) {\n      return null;\n    }\n\n    if (!InlineEditor.AnimationTimingModel.AnimationTimingModel.parse(text)) {\n      return null;\n    }\n    return this.createMatch(text);\n  }\n}\n\nexport abstract class StringMatch implements Match {\n  readonly type: string = 'string';\n  constructor(readonly text: string) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class StringMatcher extends MatcherBase<typeof StringMatch> {\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    return node.name === 'StringLiteral' ? this.createMatch(matching.ast.text(node)) : null;\n  }\n}\n\nexport const enum ShadowType {\n  BoxShadow = 'boxShadow',\n  TextShadow = 'textShadow',\n}\nexport abstract class ShadowMatch implements Match {\n  readonly type: string = 'shadow';\n  constructor(readonly text: string, readonly shadowType: ShadowType) {\n  }\n  abstract render(node: CodeMirror.SyntaxNode, context: RenderingContext): Node[];\n}\n\nexport class ShadowMatcher extends MatcherBase<typeof ShadowMatch> {\n  override accepts(propertyName: string): boolean {\n    return SDK.CSSMetadata.cssMetadata().isShadowProperty(propertyName);\n  }\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (node.name !== 'Declaration') {\n      return null;\n    }\n    const text = matching.ast.text(node);\n    return this.createMatch(\n        text, matching.ast.propertyName === 'text-shadow' ? ShadowType.TextShadow : ShadowType.BoxShadow);\n  }\n}\n\ntype LegacyRegexHandler = (text: string, readonly: boolean) => Node|null;\n\nclass LegacyRegexMatch implements Match {\n  readonly processor: LegacyRegexHandler;\n  readonly #matchedText: string;\n  readonly #suffix: string;\n  get text(): string {\n    return this.#matchedText + this.#suffix;\n  }\n  get type(): string {\n    return `${this.processor}`;\n  }\n  constructor(matchedText: string, suffix: string, processor: LegacyRegexHandler) {\n    this.#matchedText = matchedText;\n    this.#suffix = suffix;\n    this.processor = processor;\n  }\n  render(_node: CodeMirror.SyntaxNode, context: RenderingContext): Node[] {\n    const rendered = this.processor(this.#matchedText, context.options.readonly);\n    return rendered ? [rendered, document.createTextNode(this.#suffix)] : [];\n  }\n}\n\nexport class LegacyRegexMatcher implements Matcher {\n  readonly regexp: RegExp;\n  readonly processor: LegacyRegexHandler;\n  constructor(regexp: RegExp, processor: LegacyRegexHandler) {\n    this.regexp = new RegExp(regexp);\n    this.processor = processor;\n  }\n  accepts(): boolean {\n    return true;\n  }\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const text = matching.ast.text(node);\n    this.regexp.lastIndex = 0;\n    const match = this.regexp.exec(text);\n    if (!match || match.index !== 0) {\n      return null;\n    }\n    // Some of the legacy regex matching relies on matching prefixes of the text, e.g., for var()s. That particular\n    // matcher can't be extended for a full-text match, because that runs into problems matching the correct closing\n    // parenthesis (with fallbacks, specifically). At the same time we can't rely on prefix matching here because it\n    // has false positives for some subexpressions, such as 'var() + var()'. We compromise by accepting prefix matches\n    // where the remaining suffix is exclusively closing parentheses and whitespace, specifically to handle the existing\n    // prefix matchers like that for var().\n    const suffix = text.substring(match[0].length);\n    if (!suffix.match(/^[\\s)]*$/)) {\n      return null;\n    }\n    return new LegacyRegexMatch(match[0], suffix, this.processor);\n  }\n}\n\nexport class TextMatch implements Match {\n  readonly type = 'text';\n  computedText?: () => string;\n  constructor(readonly text: string, readonly isComment: boolean) {\n    if (isComment) {\n      this.computedText = () => '';\n    }\n  }\n  render(): Node[] {\n    return [document.createTextNode(this.text)];\n  }\n}\n\nclass TextMatcher implements Matcher {\n  accepts(): boolean {\n    return true;\n  }\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (!node.firstChild || node.name === 'NumberLiteral' /* may have a Unit child */) {\n      // Leaf node, just emit text\n      const text = matching.ast.text(node);\n      if (text.length) {\n        return new TextMatch(text, node.name === 'Comment');\n      }\n    }\n    return null;\n  }\n}\n\nfunction declaration(rule: string): CodeMirror.SyntaxNode|null {\n  return cssParser.parse(rule).topNode.getChild('RuleSet')?.getChild('Block')?.getChild('Declaration') ?? null;\n}\n\nexport function tokenizeDeclaration(propertyName: string, propertyValue: string): SyntaxTree|null {\n  const name = tokenizePropertyName(propertyName);\n  if (!name) {\n    return null;\n  }\n  const rule = `*{${name}: ${propertyValue};}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const childNodes = ASTUtils.children(decl);\n  if (childNodes.length < 3) {\n    return null;\n  }\n  const [varName, colon, tree] = childNodes;\n  if (!varName || varName.type.isError || !colon || colon.type.isError || !tree || tree.type.isError) {\n    return null;\n  }\n\n  // It's possible that there are nodes following the declaration when there are comments or syntax errors. We want to\n  // render any comments, so pick up any trailing nodes following the declaration excluding the final semicolon and\n  // brace.\n  const trailingNodes = ASTUtils.siblings(decl).slice(1);\n  const [semicolon, brace] = trailingNodes.splice(trailingNodes.length - 2, 2);\n  if (semicolon?.name !== ';' && brace?.name !== '}') {\n    return null;\n  }\n\n  const ast = new SyntaxTree(propertyValue, rule, decl, name, trailingNodes);\n  if (ast.text(varName) !== name || colon.name !== ':') {\n    return null;\n  }\n  return ast;\n}\n\nexport function tokenizePropertyName(name: string): string|null {\n  const rule = `*{${name}: inherit;}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const propertyName = decl.getChild('PropertyName') ?? decl.getChild('VariableName');\n  if (!propertyName) {\n    return null;\n  }\n\n  return nodeText(propertyName, rule);\n}\n\n// This function renders a property value as HTML, customizing the presentation with a set of given AST matchers. This\n// comprises the following steps:\n// 1. Build an AST of the property.\n// 2. Apply tree matchers during bottom up traversal.\n// 3. Render the value from left to right into HTML, deferring rendering of matched subtrees to the matchers\n//\n// More general, longer matches take precedence over shorter, more specific matches. Whitespaces are normalized, for\n// unmatched text and around rendered matching results.\nexport function renderPropertyValue(propertyName: string, propertyValue: string, matchers: Matcher[]): Node[] {\n  const ast = tokenizeDeclaration(propertyName, propertyValue);\n  if (!ast) {\n    return [document.createTextNode(propertyValue)];\n  }\n  const matchedResult = BottomUpTreeMatching.walk(ast, matchers);\n  ast.trailingNodes.forEach(n => matchedResult.matchText(n));\n  const context = new RenderingContext(ast, matchedResult);\n  return Renderer.render([ast.tree, ...ast.trailingNodes], context).nodes;\n}\n"]}