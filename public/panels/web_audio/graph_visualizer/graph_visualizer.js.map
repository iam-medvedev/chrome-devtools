{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/web_audio/graph_visualizer/EdgeView.ts", "../../../../../../../front_end/panels/web_audio/graph_visualizer/NodeView.ts", "../../../../../../../front_end/panels/web_audio/graph_visualizer/GraphStyle.ts", "../../../../../../../front_end/panels/web_audio/graph_visualizer/NodeRendererUtility.ts", "../../../../../../../front_end/panels/web_audio/graph_visualizer/GraphManager.ts", "../../../../../../../front_end/panels/web_audio/graph_visualizer/GraphView.ts"],
  "sourcesContent": ["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {NodeParamConnectionData, NodesConnectionData} from './GraphStyle.js';\nimport {generateInputPortId, generateOutputPortId, generateParamPortId} from './NodeView.js';\n\n// A class that represents an edge of a graph, including node-to-node connection,\n// and node-to-param connection.\nexport class EdgeView {\n  id: string;\n  type: EdgeTypes;\n  sourceId: string;\n  destinationId: string;\n  sourcePortId: string;\n  destinationPortId: string;\n\n  constructor(data: NodesConnectionData|NodeParamConnectionData, type: EdgeTypes) {\n    const edgePortsIds = generateEdgePortIdsByData(data, type);\n    if (!edgePortsIds) {\n      throw new Error('Unable to generate edge port IDs');\n    }\n\n    const {edgeId, sourcePortId, destinationPortId} = edgePortsIds;\n\n    this.id = edgeId;\n    this.type = type;\n    this.sourceId = data.sourceId;\n    this.destinationId = data.destinationId;\n    this.sourcePortId = sourcePortId;\n    this.destinationPortId = destinationPortId;\n  }\n}\n\n/**\n * Generates the edge id and source/destination portId using edge data and type.\n */\nexport const generateEdgePortIdsByData = (data: NodesConnectionData|NodeParamConnectionData, type: EdgeTypes): {\n  edgeId: string,\n  sourcePortId: string,\n  destinationPortId: string,\n}|null => {\n  if (!data.sourceId || !data.destinationId) {\n    console.error(`Undefined node message: ${JSON.stringify(data)}`);\n    return null;\n  }\n\n  const sourcePortId = generateOutputPortId(data.sourceId, data.sourceOutputIndex);\n  const destinationPortId = getDestinationPortId(data, type);\n\n  return {\n    edgeId: `${sourcePortId}->${destinationPortId}`,\n    sourcePortId,\n    destinationPortId,\n  };\n\n  /**\n   * Get the destination portId based on connection type.\n   */\n  function getDestinationPortId(data: NodesConnectionData|NodeParamConnectionData, type: EdgeTypes): string {\n    if (type === EdgeTypes.NODE_TO_NODE) {\n      const portData = (data as NodesConnectionData);\n      return generateInputPortId(data.destinationId, portData.destinationInputIndex);\n    }\n    if (type === EdgeTypes.NODE_TO_PARAM) {\n      const portData = (data as NodeParamConnectionData);\n      return generateParamPortId(data.destinationId, portData.destinationParamId);\n    }\n    console.error(`Unknown edge type: ${type}`);\n    return '';\n  }\n};\n\n/**\n * Supported edge types.\n */\nexport const enum EdgeTypes {\n  NODE_TO_NODE = 'NodeToNode',\n  NODE_TO_PARAM = 'NodeToParam',\n}\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as UI from '../../../ui/legacy/legacy.js';\n\nimport {\n  BottomPaddingWithoutParam,\n  BottomPaddingWithParam,\n  LeftMarginOfText,\n  LeftSideTopPadding,\n  NodeLabelFontStyle,\n  ParamLabelFontStyle,\n  PortTypes,\n  RightMarginOfText,\n  TotalInputPortHeight,\n  TotalOutputPortHeight,\n  TotalParamPortHeight,\n  type NodeCreationData,\n  type NodeLayout,\n  type Port,\n} from './GraphStyle.js';\nimport {calculateInputPortXY, calculateOutputPortXY, calculateParamPortXY} from './NodeRendererUtility.js';\n\n// A class that represents a node of a graph, consisting of the information needed to layout the\n// node and display the node. Each node has zero or more ports, including input, output, and param ports.\nexport class NodeView {\n  id: string;\n  type: string;\n  numberOfInputs: number;\n  numberOfOutputs: number;\n  label: string;\n  size: {\n    width: number,\n    height: number,\n  };\n  position: Object|null;\n  private layout: NodeLayout;\n  ports: Map<string, Port>;\n  constructor(data: NodeCreationData, label: string) {\n    this.id = data.nodeId;\n    this.type = data.nodeType;\n    this.numberOfInputs = data.numberOfInputs;\n    this.numberOfOutputs = data.numberOfOutputs;\n    this.label = label;\n\n    this.size = {width: 0, height: 0};\n    // Position of the center. If null, it means the graph layout has not been computed\n    // and this node should not be rendered. It will be set after layouting.\n    this.position = null;\n\n    this.layout = {\n      inputPortSectionHeight: 0,\n      outputPortSectionHeight: 0,\n      maxTextLength: 0,\n      totalHeight: 0,\n    };\n    this.ports = new Map();\n\n    this.initialize(data);\n  }\n\n  private initialize(data: NodeCreationData): void {\n    this.updateNodeLayoutAfterAddingNode(data);\n    this.setupInputPorts();\n    this.setupOutputPorts();\n  }\n\n  /**\n   * Add an AudioParam to this node.\n   * Note for @method removeParamPort: removeParamPort is not necessary because it will only happen\n   * when the parent NodeView is destroyed. So there is no need to remove port individually\n   * when the whole NodeView will be gone.\n   */\n  addParamPort(paramId: string, paramType: string): void {\n    const paramPorts = this.getPortsByType(PortTypes.PARAM);\n    const numberOfParams = paramPorts.length;\n\n    const {x, y} = calculateParamPortXY(numberOfParams, this.layout.inputPortSectionHeight);\n    this.addPort({\n      id: generateParamPortId(this.id, paramId),\n      type: PortTypes.PARAM,\n      label: paramType,\n      x,\n      y,\n    });\n\n    this.updateNodeLayoutAfterAddingParam(numberOfParams + 1, paramType);\n\n    // The position of output ports may be changed if adding a param increases the total height.\n    this.setupOutputPorts();\n  }\n\n  getPortsByType(type: PortTypes): Port[] {\n    const result: Port[] = [];\n    this.ports.forEach(port => {\n      if (port.type === type) {\n        result.push(port);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Use number of inputs and outputs to compute the layout\n   * for text and ports.\n   * Credit: This function is mostly borrowed from Audion/\n   *      `audion.entryPoints.handleNodeCreated_()`.\n   *      https://github.com/google/audion/blob/master/js/entry-points/panel.js\n   */\n  private updateNodeLayoutAfterAddingNode(data: NodeCreationData): void {\n    // Even if there are no input ports, leave room for the node label.\n    const inputPortSectionHeight = TotalInputPortHeight * Math.max(1, data.numberOfInputs) + LeftSideTopPadding;\n    this.layout.inputPortSectionHeight = inputPortSectionHeight;\n    this.layout.outputPortSectionHeight = TotalOutputPortHeight * data.numberOfOutputs;\n\n    // Use the max of the left and right side heights as the total height.\n    // Include a little padding on the left.\n    this.layout.totalHeight =\n        Math.max(inputPortSectionHeight + BottomPaddingWithoutParam, this.layout.outputPortSectionHeight);\n\n    // Update max length with node label.\n    const nodeLabelLength = measureTextWidth(this.label, NodeLabelFontStyle);\n    this.layout.maxTextLength = Math.max(this.layout.maxTextLength, nodeLabelLength);\n\n    this.updateNodeSize();\n  }\n\n  /**\n   * After adding a param port, update the node layout based on the y value\n   * and label length.\n   */\n  private updateNodeLayoutAfterAddingParam(numberOfParams: number, paramType: string): void {\n    // The height after adding param ports and input ports.\n    // Include a little padding on the left.\n    const leftSideMaxHeight =\n        this.layout.inputPortSectionHeight + numberOfParams * TotalParamPortHeight + BottomPaddingWithParam;\n\n    // Use the max of the left and right side heights as the total height.\n    this.layout.totalHeight = Math.max(leftSideMaxHeight, this.layout.outputPortSectionHeight);\n\n    // Update max length with param label.\n    const paramLabelLength = measureTextWidth(paramType, ParamLabelFontStyle);\n    this.layout.maxTextLength = Math.max(this.layout.maxTextLength, paramLabelLength);\n\n    this.updateNodeSize();\n  }\n\n  private updateNodeSize(): void {\n    this.size = {\n      width: Math.ceil(LeftMarginOfText + this.layout.maxTextLength + RightMarginOfText),\n      height: this.layout.totalHeight,\n    };\n  }\n\n  // Setup the properties of each input port.\n  private setupInputPorts(): void {\n    for (let i = 0; i < this.numberOfInputs; i++) {\n      const {x, y} = calculateInputPortXY(i);\n      this.addPort({id: generateInputPortId(this.id, i), type: PortTypes.IN, x, y, label: undefined});\n    }\n  }\n\n  // Setup the properties of each output port.\n  private setupOutputPorts(): void {\n    for (let i = 0; i < this.numberOfOutputs; i++) {\n      const portId = generateOutputPortId(this.id, i);\n      const {x, y} = calculateOutputPortXY(i, this.size, this.numberOfOutputs);\n      if (this.ports.has(portId)) {\n        // Update y value of an existing output port.\n        const port = this.ports.get(portId);\n        if (!port) {\n          throw new Error(`Unable to find port with id ${portId}`);\n        }\n\n        port.x = x;\n        port.y = y;\n      } else {\n        this.addPort({id: portId, type: PortTypes.OUT, x, y, label: undefined});\n      }\n    }\n  }\n\n  private addPort(port: Port): void {\n    this.ports.set(port.id, port);\n  }\n}\n\n/**\n * Generates the port id for the input of node.\n */\nexport const generateInputPortId = (nodeId: string, inputIndex: number|undefined): string => {\n  return `${nodeId}-input-${inputIndex || 0}`;\n};\n\n/**\n * Generates the port id for the output of node.\n */\nexport const generateOutputPortId = (nodeId: string, outputIndex: number|undefined): string => {\n  return `${nodeId}-output-${outputIndex || 0}`;\n};\n\n/**\n * Generates the port id for the param of node.\n */\nexport const generateParamPortId = (nodeId: string, paramId: string): string => {\n  return `${nodeId}-param-${paramId}`;\n};\n\n// A label generator to convert UUID of node to shorter label to display.\n// Each graph should have its own generator since the node count starts from 0.\nexport class NodeLabelGenerator {\n  private totalNumberOfNodes: number;\n  constructor() {\n    this.totalNumberOfNodes = 0;\n  }\n\n  /**\n   * Generates the label for a node of a graph.\n   */\n  generateLabel(nodeType: string): string {\n    // To make the label concise, remove the suffix \"Node\" from the nodeType.\n    if (nodeType.endsWith('Node')) {\n      nodeType = nodeType.slice(0, nodeType.length - 4);\n    }\n\n    // Also, use an integer to replace the long UUID.\n    this.totalNumberOfNodes += 1;\n    const label = `${nodeType} ${this.totalNumberOfNodes}`;\n    return label;\n  }\n}\n\nlet contextForFontTextMeasuring: CanvasRenderingContext2D;\n\n/**\n * Get the text width using given font style.\n */\nexport const measureTextWidth = (text: string, fontStyle: string|null): number => {\n  if (!contextForFontTextMeasuring) {\n    const context = document.createElement('canvas').getContext('2d');\n    if (!context) {\n      throw new Error('Unable to create canvas context.');\n    }\n\n    contextForFontTextMeasuring = context;\n  }\n\n  const context = contextForFontTextMeasuring;\n  context.save();\n  if (fontStyle) {\n    context.font = fontStyle;\n  }\n\n  const width = UI.UIUtils.measureTextWidth(context, text);\n  context.restore();\n  return width;\n};\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const PortPadding = 4;\nexport const InputPortRadius = 10;\nexport const AudioParamRadius = 5;\nexport const LeftMarginOfText = 12;\nexport const RightMarginOfText = 30;\nexport const LeftSideTopPadding = 5;\nexport const BottomPaddingWithoutParam = 6;\nexport const BottomPaddingWithParam = 8;\nexport const ArrowHeadSize = 12;\n\n// GraphPadding is used to add extra space for the graph layout.\nexport const GraphPadding = 20;\nexport const GraphMargin = 20;\n\nexport const TotalInputPortHeight = InputPortRadius * 2 + PortPadding;\nexport const TotalOutputPortHeight = TotalInputPortHeight;\nexport const TotalParamPortHeight = AudioParamRadius * 2 + PortPadding;\n\nexport const NodeLabelFontStyle = '14px Segoe UI, Arial';\nexport const ParamLabelFontStyle = '12px Segoe UI, Arial';\n\n/**\n * Supported port types.\n */\nexport const enum PortTypes {\n  IN = 'In',\n  OUT = 'Out',\n  PARAM = 'Param',\n}\n\nexport interface Size {\n  width: number;\n  height: number;\n}\nexport interface Point {\n  x: number;\n  y: number;\n}\nexport interface NodeLayout {\n  inputPortSectionHeight: number;\n  outputPortSectionHeight: number;\n  maxTextLength: number;\n  totalHeight: number;\n}\nexport interface Port {\n  id: string;\n  type: PortTypes;\n  label?: string;\n  x: number;\n  y: number;\n}\nexport interface NodeCreationData {\n  nodeId: string;\n  nodeType: string;\n  numberOfInputs: number;\n  numberOfOutputs: number;\n}\nexport interface ParamCreationData {\n  paramId: string;\n  paramType: string;\n  nodeId: string;\n}\nexport interface NodesConnectionData {\n  sourceId: string;\n  destinationId: string;\n  sourceOutputIndex?: number;\n  destinationInputIndex?: number;\n}\nexport interface NodesDisconnectionData {\n  sourceId: string;\n  destinationId?: string|null;\n  sourceOutputIndex?: number;\n  destinationInputIndex?: number;\n}\nexport interface NodesDisconnectionDataWithDestination {\n  sourceId: string;\n  destinationId: string;\n  sourceOutputIndex?: number;\n  destinationInputIndex?: number;\n}\nexport interface NodeParamConnectionData {\n  sourceId: string;\n  destinationId: string;\n  sourceOutputIndex?: number;\n  destinationParamId: string;\n}\nexport interface NodeParamDisconnectionData {\n  sourceId: string;\n  destinationId: string;\n  sourceOutputIndex?: number;\n  destinationParamId: string;\n}\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  AudioParamRadius,\n  InputPortRadius,\n  LeftSideTopPadding,\n  TotalInputPortHeight,\n  TotalOutputPortHeight,\n  TotalParamPortHeight,\n  type Point,\n  type Size,\n} from './GraphStyle.js';\n\n/**\n * Calculate the x, y value of input port.\n * Input ports are placed near the top of the left-side border.\n */\nexport const calculateInputPortXY = (portIndex: number): Point => {\n  const y = InputPortRadius + LeftSideTopPadding + portIndex * TotalInputPortHeight;\n  return {x: 0, y};\n};\n\n/**\n * Calculate the x, y value of output port.\n * Output ports are placed near the center of the right-side border.\n */\nexport const calculateOutputPortXY = (portIndex: number, nodeSize: Size, numberOfOutputs: number): Point => {\n  const {width, height} = nodeSize;\n  const outputPortY = (height / 2) + (2 * portIndex - numberOfOutputs + 1) * TotalOutputPortHeight / 2;\n\n  return {x: width, y: outputPortY};\n};\n\n/**\n * Calculate the x, y value of param port.\n * Param ports are placed near the bottom of the left-side border.\n */\nexport const calculateParamPortXY = (portIndex: number, offsetY: number): Point => {\n  const paramPortY = offsetY + TotalParamPortHeight * (portIndex + 1) - AudioParamRadius;\n  return {x: 0, y: paramPortY};\n};\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {GraphView} from './GraphView.js';\n\n// A class that maps each context to its corresponding graph.\n// It controls which graph to render when the context is switched or updated.\nexport class GraphManager {\n  private readonly graphMapByContextId = new Map<string, GraphView>();\n\n  createContext(contextId: string): void {\n    const graph = new GraphView(contextId);\n    this.graphMapByContextId.set(contextId, graph);\n  }\n\n  destroyContext(contextId: string): void {\n    if (!this.graphMapByContextId.has(contextId)) {\n      return;\n    }\n\n    const graph = this.graphMapByContextId.get(contextId);\n    if (!graph) {\n      return;\n    }\n\n    this.graphMapByContextId.delete(contextId);\n  }\n\n  hasContext(contextId: string): boolean {\n    return this.graphMapByContextId.has(contextId);\n  }\n\n  clearGraphs(): void {\n    this.graphMapByContextId.clear();\n  }\n\n  /**\n   * Get graph by contextId.\n   * If the user starts listening for WebAudio events after the page has been running a context for awhile,\n   * the graph might be undefined.\n   */\n  getGraph(contextId: string): GraphView|null {\n    return this.graphMapByContextId.get(contextId) || null;\n  }\n}\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nimport {EdgeTypes, EdgeView, generateEdgePortIdsByData} from './EdgeView.js';\nimport type {\n  NodeCreationData, NodeParamConnectionData, NodeParamDisconnectionData, NodesConnectionData, NodesDisconnectionData,\n  NodesDisconnectionDataWithDestination, ParamCreationData} from './GraphStyle.js';\nimport {NodeLabelGenerator, NodeView} from './NodeView.js';\n\n// A class that tracks all the nodes and edges of an audio graph.\nexport class GraphView extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  contextId: string;\n  private readonly nodes = new Map<string, NodeView>();\n  private readonly edges = new Map<string, EdgeView>();\n  /**\n   * For each node ID, keep a set of all out-bound edge IDs.\n   */\n  private readonly outboundEdgeMap = new Platform.MapUtilities.Multimap<string, string>();\n  /**\n   * For each node ID, keep a set of all in-bound edge IDs.\n   */\n  private readonly inboundEdgeMap = new Platform.MapUtilities.Multimap<string, string>();\n  /**\n   * Use concise node label to replace the long UUID.\n   * Each graph has its own label generator so that the label starts from 0.\n   */\n  private readonly nodeLabelGenerator = new NodeLabelGenerator();\n  /**\n   * For each param ID, save its corresponding node Id.\n   */\n  private readonly paramIdToNodeIdMap = new Map<string, string>();\n  constructor(contextId: string) {\n    super();\n\n    this.contextId = contextId;\n  }\n\n  /**\n   * Add a node to the graph.\n   */\n  addNode(data: NodeCreationData): void {\n    const label = this.nodeLabelGenerator.generateLabel(data.nodeType);\n    const node = new NodeView(data, label);\n    this.nodes.set(data.nodeId, node);\n    this.notifyShouldRedraw();\n  }\n\n  /**\n   * Remove a node by id and all related edges.\n   */\n  removeNode(nodeId: string): void {\n    this.outboundEdgeMap.get(nodeId).forEach(edgeId => this.removeEdge(edgeId));\n    this.inboundEdgeMap.get(nodeId).forEach(edgeId => this.removeEdge(edgeId));\n    this.nodes.delete(nodeId);\n    this.notifyShouldRedraw();\n  }\n\n  /**\n   * Add a param to the node.\n   */\n  addParam(data: ParamCreationData): void {\n    const node = this.getNodeById(data.nodeId);\n    if (!node) {\n      console.error('AudioNode should be added before AudioParam');\n      return;\n    }\n    node.addParamPort(data.paramId, data.paramType);\n    this.paramIdToNodeIdMap.set(data.paramId, data.nodeId);\n    this.notifyShouldRedraw();\n  }\n\n  /**\n   * Remove a param.\n   */\n  removeParam(paramId: string): void {\n    // Only need to delete the entry from the param id to node id map.\n    this.paramIdToNodeIdMap.delete(paramId);\n    // No need to remove the param port from the node because removeParam will always happen with\n    // removeNode(). Since the whole Node will be gone, there is no need to remove port individually.\n  }\n\n  /**\n   * Add a Node-to-Node connection to the graph.\n   */\n  addNodeToNodeConnection(edgeData: NodesConnectionData): void {\n    const edge = new EdgeView(edgeData, EdgeTypes.NODE_TO_NODE);\n    this.addEdge(edge);\n  }\n\n  /**\n   * Remove a Node-to-Node connection from the graph.\n   */\n  removeNodeToNodeConnection(edgeData: NodesDisconnectionData): void {\n    if (edgeData.destinationId) {\n      // Remove a single edge if destinationId is specified.\n      const edgePortIds =\n          generateEdgePortIdsByData((edgeData as NodesDisconnectionDataWithDestination), EdgeTypes.NODE_TO_NODE);\n\n      if (!edgePortIds) {\n        throw new Error('Unable to generate edge port IDs');\n      }\n      const {edgeId} = edgePortIds;\n\n      this.removeEdge(edgeId);\n    } else {\n      // Otherwise, remove all outgoing edges from source node.\n      this.outboundEdgeMap.get(edgeData.sourceId).forEach(edgeId => this.removeEdge(edgeId));\n    }\n  }\n\n  /**\n   * Add a Node-to-Param connection to the graph.\n   */\n  addNodeToParamConnection(edgeData: NodeParamConnectionData): void {\n    const edge = new EdgeView(edgeData, EdgeTypes.NODE_TO_PARAM);\n    this.addEdge(edge);\n  }\n\n  /**\n   * Remove a Node-to-Param connection from the graph.\n   */\n  removeNodeToParamConnection(edgeData: NodeParamDisconnectionData): void {\n    const edgePortIds = generateEdgePortIdsByData(edgeData, EdgeTypes.NODE_TO_PARAM);\n    if (!edgePortIds) {\n      throw new Error('Unable to generate edge port IDs');\n    }\n\n    const {edgeId} = edgePortIds;\n    this.removeEdge(edgeId);\n  }\n\n  getNodeById(nodeId: string): NodeView|null {\n    return this.nodes.get(nodeId) || null;\n  }\n\n  getNodes(): Map<string, NodeView> {\n    return this.nodes;\n  }\n\n  getEdges(): Map<string, EdgeView> {\n    return this.edges;\n  }\n\n  getNodeIdByParamId(paramId: string): string|null {\n    return this.paramIdToNodeIdMap.get(paramId) || null;\n  }\n\n  /**\n   * Add an edge to the graph.\n   */\n  private addEdge(edge: EdgeView): void {\n    const sourceId = edge.sourceId;\n    // Do nothing if the edge already exists.\n    if (this.outboundEdgeMap.hasValue(sourceId, edge.id)) {\n      return;\n    }\n\n    this.edges.set(edge.id, edge);\n    this.outboundEdgeMap.set(sourceId, edge.id);\n    this.inboundEdgeMap.set(edge.destinationId, edge.id);\n\n    this.notifyShouldRedraw();\n  }\n\n  /**\n   * Given an edge id, remove the edge from the graph.\n   * Also remove the edge from inbound and outbound edge maps.\n   */\n  private removeEdge(edgeId: string): void {\n    const edge = this.edges.get(edgeId);\n    if (!edge) {\n      return;\n    }\n\n    this.outboundEdgeMap.delete(edge.sourceId, edgeId);\n    this.inboundEdgeMap.delete(edge.destinationId, edgeId);\n\n    this.edges.delete(edgeId);\n    this.notifyShouldRedraw();\n  }\n\n  private notifyShouldRedraw(): void {\n    this.dispatchEventToListeners(Events.SHOULD_REDRAW, this);\n  }\n}\n\nexport const enum Events {\n  SHOULD_REDRAW = 'ShouldRedraw',\n}\n\nexport interface EventTypes {\n  [Events.SHOULD_REDRAW]: GraphView;\n}\n"],
  "mappings": "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",
  "names": ["context", "data", "type"]
}
