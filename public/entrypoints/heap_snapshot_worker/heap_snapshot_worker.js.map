{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/heap_snapshot_worker/AllocationProfile.ts", "../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts", "../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshotLoader.ts", "../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshotWorkerDispatcher.ts"],
  "sourcesContent": ["// Copyright 2013 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport type {LiveObjects, Profile} from './HeapSnapshot.js';\n\nexport class AllocationProfile {\n  readonly #strings: string[];\n  #nextNodeId: number;\n  #functionInfos: FunctionAllocationInfo[];\n  #idToNode: Record<number, BottomUpAllocationNode|null>;\n  readonly #idToTopDownNode: Record<number, TopDownAllocationNode>;\n  #collapsedTopNodeIdToFunctionInfo: Record<number, FunctionAllocationInfo>;\n  #traceTops: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[]|null;\n\n  constructor(profile: Profile, liveObjectStats: LiveObjects) {\n    this.#strings = profile.strings;\n\n    this.#nextNodeId = 1;\n    this.#functionInfos = [];\n\n    this.#idToNode = {};\n\n    this.#idToTopDownNode = {};\n\n    this.#collapsedTopNodeIdToFunctionInfo = {};\n\n    this.#traceTops = null;\n\n    this.#buildFunctionAllocationInfos(profile);\n    this.#buildAllocationTree(profile, liveObjectStats);\n  }\n\n  #buildFunctionAllocationInfos(profile: Profile): void {\n    const strings = this.#strings;\n\n    const functionInfoFields = profile.snapshot.meta.trace_function_info_fields;\n    const functionNameOffset = functionInfoFields.indexOf('name');\n    const scriptNameOffset = functionInfoFields.indexOf('script_name');\n    const scriptIdOffset = functionInfoFields.indexOf('script_id');\n    const lineOffset = functionInfoFields.indexOf('line');\n    const columnOffset = functionInfoFields.indexOf('column');\n    const functionInfoFieldCount = functionInfoFields.length;\n\n    const rawInfos = profile.trace_function_infos;\n    const infoLength = rawInfos.length;\n    const functionInfos = this.#functionInfos = new Array(infoLength / functionInfoFieldCount);\n    let index = 0;\n    for (let i = 0; i < infoLength; i += functionInfoFieldCount) {\n      functionInfos[index++] = new FunctionAllocationInfo(\n          strings[rawInfos[i + functionNameOffset]], strings[rawInfos[i + scriptNameOffset]],\n          rawInfos[i + scriptIdOffset], rawInfos[i + lineOffset], rawInfos[i + columnOffset]);\n    }\n  }\n\n  #buildAllocationTree(profile: Profile, liveObjectStats: LiveObjects): TopDownAllocationNode {\n    const traceTreeRaw = profile.trace_tree;\n    const functionInfos = this.#functionInfos;\n    const idToTopDownNode = this.#idToTopDownNode;\n\n    const traceNodeFields = profile.snapshot.meta.trace_node_fields;\n    const nodeIdOffset = traceNodeFields.indexOf('id');\n    const functionInfoIndexOffset = traceNodeFields.indexOf('function_info_index');\n    const allocationCountOffset = traceNodeFields.indexOf('count');\n    const allocationSizeOffset = traceNodeFields.indexOf('size');\n    const childrenOffset = traceNodeFields.indexOf('children');\n    const nodeFieldCount = traceNodeFields.length;\n\n    function traverseNode(\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        rawNodeArray: any, nodeOffset: any, parent: TopDownAllocationNode|null): TopDownAllocationNode {\n      const functionInfo = functionInfos[rawNodeArray[nodeOffset + functionInfoIndexOffset]];\n      const id = rawNodeArray[nodeOffset + nodeIdOffset];\n      const stats = liveObjectStats[id];\n      const liveCount = stats ? stats.count : 0;\n      const liveSize = stats ? stats.size : 0;\n      const result = new TopDownAllocationNode(\n          id, functionInfo, rawNodeArray[nodeOffset + allocationCountOffset],\n          rawNodeArray[nodeOffset + allocationSizeOffset], liveCount, liveSize, parent);\n      idToTopDownNode[id] = result;\n      functionInfo.addTraceTopNode(result);\n\n      const rawChildren = rawNodeArray[nodeOffset + childrenOffset];\n      for (let i = 0; i < rawChildren.length; i += nodeFieldCount) {\n        result.children.push(traverseNode(rawChildren, i, result));\n      }\n\n      return result;\n    }\n\n    return traverseNode(traceTreeRaw, 0, null);\n  }\n\n  serializeTraceTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    if (this.#traceTops) {\n      return this.#traceTops;\n    }\n\n    const result: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] = this.#traceTops = [];\n    const functionInfos = this.#functionInfos;\n    for (let i = 0; i < functionInfos.length; i++) {\n      const info = functionInfos[i];\n      if (info.totalCount === 0) {\n        continue;\n      }\n      const nodeId = this.#nextNodeId++;\n      const isRoot = i === 0;\n      result.push(this.#serializeNode(\n          nodeId, info, info.totalCount, info.totalSize, info.totalLiveCount, info.totalLiveSize, !isRoot));\n      this.#collapsedTopNodeIdToFunctionInfo[nodeId] = info;\n    }\n    result.sort(function(a, b) {\n      return b.size - a.size;\n    });\n    return result;\n  }\n\n  serializeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    let node = this.#ensureBottomUpNode(nodeId);\n    const nodesWithSingleCaller = [];\n    while (node.callers().length === 1) {\n      node = node.callers()[0];\n      nodesWithSingleCaller.push(this.#serializeCaller(node));\n    }\n\n    const branchingCallers = [];\n    const callers = node.callers();\n    for (let i = 0; i < callers.length; i++) {\n      branchingCallers.push(this.#serializeCaller(callers[i]));\n    }\n\n    return new HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers(nodesWithSingleCaller, branchingCallers);\n  }\n\n  serializeAllocationStack(traceNodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[] {\n    let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#idToTopDownNode[traceNodeId];\n    const result = [];\n    while (node) {\n      const functionInfo = node.functionInfo;\n      result.push(new HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame(\n          functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n          functionInfo.column));\n      node = node.parent;\n    }\n    return result;\n  }\n\n  traceIds(allocationNodeId: number): number[] {\n    return this.#ensureBottomUpNode(allocationNodeId).traceTopIds;\n  }\n\n  #ensureBottomUpNode(nodeId: number): BottomUpAllocationNode {\n    let node = this.#idToNode[nodeId];\n    if (!node) {\n      const functionInfo = this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      node = functionInfo.bottomUpRoot();\n      delete this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      this.#idToNode[nodeId] = node;\n    }\n    return node as BottomUpAllocationNode;\n  }\n\n  #serializeCaller(node: BottomUpAllocationNode): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    const callerId = this.#nextNodeId++;\n    this.#idToNode[callerId] = node;\n    return this.#serializeNode(\n        callerId, node.functionInfo, node.allocationCount, node.allocationSize, node.liveCount, node.liveSize,\n        node.hasCallers());\n  }\n\n  #serializeNode(\n      nodeId: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, hasChildren: boolean): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    return new HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode(\n        nodeId, functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n        functionInfo.column, count, size, liveCount, liveSize, hasChildren);\n  }\n}\n\nexport class TopDownAllocationNode {\n  id: number;\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  parent: TopDownAllocationNode|null;\n  children: TopDownAllocationNode[];\n  constructor(\n      id: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, parent: TopDownAllocationNode|null) {\n    this.id = id;\n    this.functionInfo = functionInfo;\n    this.allocationCount = count;\n    this.allocationSize = size;\n    this.liveCount = liveCount;\n    this.liveSize = liveSize;\n    this.parent = parent;\n\n    this.children = [];\n  }\n}\n\nexport class BottomUpAllocationNode {\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  traceTopIds: number[];\n  readonly #callers: BottomUpAllocationNode[];\n  constructor(functionInfo: FunctionAllocationInfo) {\n    this.functionInfo = functionInfo;\n    this.allocationCount = 0;\n    this.allocationSize = 0;\n    this.liveCount = 0;\n    this.liveSize = 0;\n\n    this.traceTopIds = [];\n\n    this.#callers = [];\n  }\n\n  addCaller(traceNode: TopDownAllocationNode): BottomUpAllocationNode {\n    const functionInfo = traceNode.functionInfo;\n    let result;\n    for (let i = 0; i < this.#callers.length; i++) {\n      const caller = this.#callers[i];\n      if (caller.functionInfo === functionInfo) {\n        result = caller;\n        break;\n      }\n    }\n    if (!result) {\n      result = new BottomUpAllocationNode(functionInfo);\n      this.#callers.push(result);\n    }\n    return result;\n  }\n\n  callers(): BottomUpAllocationNode[] {\n    return this.#callers;\n  }\n\n  hasCallers(): boolean {\n    return this.#callers.length > 0;\n  }\n}\n\nexport class FunctionAllocationInfo {\n  functionName: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  totalCount: number;\n  totalSize: number;\n  totalLiveCount: number;\n  totalLiveSize: number;\n  #traceTops: TopDownAllocationNode[];\n  #bottomUpTree?: BottomUpAllocationNode;\n  constructor(functionName: string, scriptName: string, scriptId: number, line: number, column: number) {\n    this.functionName = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n    this.totalCount = 0;\n    this.totalSize = 0;\n    this.totalLiveCount = 0;\n    this.totalLiveSize = 0;\n\n    this.#traceTops = [];\n  }\n\n  addTraceTopNode(node: TopDownAllocationNode): void {\n    if (node.allocationCount === 0) {\n      return;\n    }\n    this.#traceTops.push(node);\n    this.totalCount += node.allocationCount;\n    this.totalSize += node.allocationSize;\n    this.totalLiveCount += node.liveCount;\n    this.totalLiveSize += node.liveSize;\n  }\n\n  bottomUpRoot(): BottomUpAllocationNode|null {\n    if (!this.#traceTops.length) {\n      return null;\n    }\n    if (!this.#bottomUpTree) {\n      this.#buildAllocationTraceTree();\n    }\n    return this.#bottomUpTree as BottomUpAllocationNode;\n  }\n\n  #buildAllocationTraceTree(): void {\n    this.#bottomUpTree = new BottomUpAllocationNode(this);\n\n    for (let i = 0; i < this.#traceTops.length; i++) {\n      let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#traceTops[i];\n      let bottomUpNode: BottomUpAllocationNode = this.#bottomUpTree;\n      const count = node.allocationCount;\n      const size = node.allocationSize;\n      const liveCount = node.liveCount;\n      const liveSize = node.liveSize;\n      const traceId = node.id;\n      while (true) {\n        bottomUpNode.allocationCount += count;\n        bottomUpNode.allocationSize += size;\n        bottomUpNode.liveCount += liveCount;\n        bottomUpNode.liveSize += liveSize;\n        bottomUpNode.traceTopIds.push(traceId);\n        node = node.parent;\n        if (node === null) {\n          break;\n        }\n\n        bottomUpNode = bottomUpNode.addCaller(node);\n      }\n    }\n  }\n}\n", "// Copyright 2011 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable rulesdir/prefer-private-class-members */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  protected readonly edges: Platform.TypedArrayUtilities.BigUint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this.snapshot = snapshot;\n    this.edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this.snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this.snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this.snapshot.edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeToNodeOffset);\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this.snapshot.edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this.snapshot.edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  isInternal(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  getValueForSorting(_fieldName: string): number {\n    throw new Error('Not implemented');\n  }\n\n  nameIndex(): number {\n    throw new Error('Not implemented');\n  }\n}\n\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this.#node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this.#node.nodeIndex = index;\n    return this.#node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this.#edge.edgeIndex = index;\n    return this.#edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  readonly #retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this.#retainerEdge.setRetainerIndex(index);\n    return this.#retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this.#sourceNode = node;\n    this.edge = node.snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this.#sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge.snapshot.edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge.snapshot.edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  protected snapshot: HeapSnapshot;\n  #retainerIndex!: number;\n  #globalEdgeIndex!: number;\n  #retainingNodeIndex?: number;\n  #edgeInstance?: JSHeapSnapshotEdge|null;\n  #nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this.snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this.snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this.edge().hasStringName();\n  }\n\n  name(): string {\n    return this.edge().name();\n  }\n\n  nameIndex(): number {\n    return this.edge().nameIndex();\n  }\n\n  node(): HeapSnapshotNode {\n    return this.#node();\n  }\n\n  nodeIndex(): number {\n    if (typeof this.#retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this.#retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this.#retainerIndex;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this.#retainerIndex) {\n      return;\n    }\n\n    if (!this.snapshot.retainingEdges || !this.snapshot.retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this.#retainerIndex = retainerIndex;\n    this.#globalEdgeIndex = this.snapshot.retainingEdges[retainerIndex];\n    this.#retainingNodeIndex = this.snapshot.retainingNodes[retainerIndex];\n    this.#edgeInstance = null;\n    this.#nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  #node(): HeapSnapshotNode {\n    if (!this.#nodeInstance) {\n      this.#nodeInstance = this.snapshot.createNode(this.#retainingNodeIndex);\n    }\n    return this.#nodeInstance;\n  }\n\n  protected edge(): JSHeapSnapshotEdge {\n    if (!this.#edgeInstance) {\n      this.#edgeInstance = this.snapshot.createEdge(this.#globalEdgeIndex);\n    }\n    return this.#edgeInstance;\n  }\n\n  toString(): string {\n    return this.edge().toString();\n  }\n\n  itemIndex(): number {\n    return this.#retainerIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    const node = this.node();\n    const serializedNode = node.serialize();\n    serializedNode.distance = this.#distance();\n    serializedNode.ignored = this.snapshot.isNodeIgnoredInRetainersView(node.nodeIndex);\n\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), serializedNode, this.type(), this.#globalEdgeIndex);\n  }\n\n  type(): string {\n    return this.edge().type();\n  }\n\n  isInternal(): boolean {\n    return this.edge().isInternal();\n  }\n\n  getValueForSorting(fieldName: string): number {\n    if (fieldName === '!edgeDistance') {\n      return this.#distance();\n    }\n    throw new Error('Invalid field name');\n  }\n\n  #distance(): number {\n    if (this.snapshot.isEdgeIgnoredInRetainersView(this.#globalEdgeIndex)) {\n      return HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return this.node().distanceForRetainersView();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode.snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot.firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot.firstRetainerIndex[retainedNodeOrdinal];\n    this.#retainersEnd = snapshot.firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this.#retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this.snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this.snapshot.nodeDistances[this.nodeIndex / this.snapshot.nodeFieldCount];\n  }\n\n  distanceForRetainersView(): number {\n    return this.snapshot.getDistanceForRetainersView(this.nodeIndex);\n  }\n\n  className(): string {\n    return this.snapshot.strings[this.classIndex()];\n  }\n\n  classIndex(): number {\n    return this.#detachednessAndClassIndex() >>> SHIFT_FOR_CLASS_INDEX;\n  }\n\n  // Returns a key which can uniquely describe both the class name for this node\n  // and its Location, if relevant. These keys are meant to be cheap to produce,\n  // so that building aggregates is fast. These keys are NOT the same as the\n  // keys exposed to the frontend by functions such as aggregatesWithFilter and\n  // aggregatesForDiff.\n  classKeyInternal(): string|number {\n    // It is common for multiple JavaScript constructors to have the same\n    // name, so the class key includes the location if available for nodes of\n    // type 'object'.\n    //\n    // JavaScript Functions (node type 'closure') also have locations, but it\n    // would not be helpful to split them into categories by location because\n    // many of those categories would have only one instance.\n    if (this.rawType() !== this.snapshot.nodeObjectType) {\n      return this.classIndex();\n    }\n    const location = this.snapshot.getLocation(this.nodeIndex);\n    return location ? `${location.scriptId},${location.lineNumber},${location.columnNumber},${this.className()}` :\n                      this.classIndex();\n  }\n\n  setClassIndex(index: number): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= BITMASK_FOR_DOM_LINK_STATE;        // Clear previous class index.\n    value |= (index << SHIFT_FOR_CLASS_INDEX);  // Set new class index.\n    this.#setDetachednessAndClassIndex(value);\n    if (this.classIndex() !== index) {\n      throw new Error('String index overflow');\n    }\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this.snapshot.nodeFieldCount;\n    return this.snapshot.dominatorsTree[this.nodeIndex / this.snapshot.nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this.snapshot.edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    return this.snapshot.strings[this.rawNameIndex()];\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this.snapshot.rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isSynthetic(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this.rawName();\n  }\n\n  retainedSize(): number {\n    return this.snapshot.retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this.snapshot;\n    const ordinal = this.ordinal();\n    return snapshot.firstRetainerIndex[ordinal + 1] - snapshot.firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeSelfSizeOffset);\n  }\n\n  type(): string {\n    return this.snapshot.nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTraceNodeIdOffset);\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  rawNameIndex(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeNameOffset);\n  }\n\n  edgeIndexesStart(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this.snapshot.nodeFieldCount;\n  }\n\n  nextNodeIndex(): number {\n    return this.nodeIndex + this.snapshot.nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTypeOffset);\n  }\n\n  isFlatConsString(): boolean {\n    if (this.rawType() !== this.snapshot.nodeConsStringType) {\n      return false;\n    }\n    for (let iter = this.edges(); iter.hasNext(); iter.next()) {\n      const edge = iter.edge;\n      if (!edge.isInternal()) {\n        continue;\n      }\n      const edgeName = edge.name();\n      if ((edgeName === 'first' || edgeName === 'second') && edge.node().name() === '') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  #detachednessAndClassIndex(): number {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    return nodeDetachednessAndClassIndexOffset !== -1 ?\n        snapshot.nodes.getValue(nodeIndex + nodeDetachednessAndClassIndexOffset) :\n        (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount];\n  }\n\n  #setDetachednessAndClassIndex(value: number): void {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    if (nodeDetachednessAndClassIndexOffset !== -1) {\n      snapshot.nodes.setValue(nodeIndex + nodeDetachednessAndClassIndexOffset, value);\n    } else {\n      (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount] = value;\n    }\n  }\n\n  detachedness(): DOMLinkState {\n    return this.#detachednessAndClassIndex() & BITMASK_FOR_DOM_LINK_STATE;\n  }\n\n  setDetachedness(detachedness: DOMLinkState): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= ~BITMASK_FOR_DOM_LINK_STATE;  // Clear the old bits.\n    value |= detachedness;                 // Set the new bits.\n    this.#setDetachednessAndClassIndex(value);\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  readonly #nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this.#nodesLength = node.snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this.#nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node.nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  readonly #itemProvider: HeapSnapshotItemIndexProvider;\n  readonly #indexes: number[]|Uint32Array;\n  #position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this.#itemProvider = itemProvider;\n    this.#indexes = indexes;\n    this.#position = 0;\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this.#indexes[this.#position];\n    return this.#itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this.#position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  #iterator: HeapSnapshotItemIterator;\n  #filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this.#iterator = iterator;\n    this.#filter = filter;\n    this.skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this.#iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this.#iterator.item();\n  }\n\n  next(): void {\n    this.#iterator.next();\n    this.skipFilteredItems();\n  }\n\n  private skipFilteredItems(): void {\n    while (this.#iterator.hasNext() && this.#filter && !this.#filter(this.#iterator.item())) {\n      this.#iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  readonly #dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this.#dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  private sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\n// An \"interface\" to be used when classifying plain JS objects in the snapshot.\n// An object matches the interface if it contains every listed property (even\n// if it also contains extra properties).\ninterface InterfaceDefinition {\n  name: string;\n  properties: string[];\n}\n\ntype HeapSnapshotProblemReport = Array<string|number>;\nfunction appendToProblemReport(report: HeapSnapshotProblemReport, messageOrNodeIndex: string|number): void {\n  if (report.length > 100) {\n    return;\n  }\n  report.push(messageOrNodeIndex);\n}\nfunction formatProblemReport(snapshot: HeapSnapshot, report: HeapSnapshotProblemReport): string {\n  const node = snapshot.rootNode();\n  return report\n      .map(messageOrNodeIndex => {\n        if (typeof messageOrNodeIndex === 'string') {\n          return messageOrNodeIndex;\n        }\n        node.nodeIndex = messageOrNodeIndex;\n        return `${node.name()} @${node.id()}`;\n      })\n      .join('\\n  ');\n}\nfunction reportProblemToPrimaryWorker(problemReport: HeapSnapshotProblemReport, port: MessagePort): void {\n  port.postMessage({problemReport});\n}\n\nexport interface Profile {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  root_index: number;\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  edges: Platform.TypedArrayUtilities.BigUint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  trace_function_infos: Uint32Array;\n  trace_tree: Object;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport type LiveObjects = Record<number, {count: number, size: number, ids: number[]}>;\n\n// The first batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep1 {\n  // For each edge ordinal, this array contains the ordinal of the pointed-to node.\n  edgeToNodeOrdinals: Uint32Array;\n  // A copy of HeapSnapshot.firstEdgeIndexes. For each node ordinal, this array\n  // contains the edge index of the first outgoing edge.\n  firstEdgeIndexes: Uint32Array;\n  nodeCount: number;\n  edgeFieldsCount: number;\n  nodeFieldCount: number;\n}\n\n// The second batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep2 {\n  rootNodeOrdinal: number;\n  // An array with one bit per edge, where each bit indicates whether the edge\n  // should be used when computing dominators.\n  essentialEdgesBuffer: ArrayBuffer;\n}\n\n// The third batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep3 {\n  // For each node ordinal, this array contains the node's shallow size.\n  nodeSelfSizes: Uint32Array;\n}\n\ntype ArgumentsToBuildRetainers = SecondaryInitArgumentsStep1;\n\ninterface Retainers {\n  // For each node ordinal, this array contains the index of the first retaining edge\n  // in the retainingEdges and retainingNodes arrays.\n  firstRetainerIndex: Uint32Array;\n  // For each retaining edge, this array contains the \"from\" node's index.\n  retainingNodes: Uint32Array;\n  // For each retaining edge, this array contains the index in containmentEdges\n  // where you can find other info about the edge, such as its type and name.\n  retainingEdges: Uint32Array;\n}\n\ninterface ArgumentsToComputeDominatorsAndRetainedSizes extends SecondaryInitArgumentsStep1, Retainers,\n                                                               SecondaryInitArgumentsStep2 {\n  // For each edge ordinal, this bit vector contains whether the edge\n  // should be used when computing dominators.\n  essentialEdges: Platform.TypedArrayUtilities.BitVector;\n  // A message port for reporting problems to the primary worker.\n  port: MessagePort;\n  // For each node ordinal, this array will contain the node's shallow size.\n  nodeSelfSizesPromise: Promise<Uint32Array>;\n}\n\ninterface DominatorsAndRetainedSizes {\n  // For each node ordinal, this array contains the ordinal of its immediate dominating node.\n  dominatorsTree: Uint32Array;\n  // For each node ordinal, this array contains the size of the subgraph it dominates, including its own size.\n  retainedSizes: Float64Array;\n}\n\ninterface ArgumentsToBuildDominatedNodes extends ArgumentsToComputeDominatorsAndRetainedSizes,\n                                                 DominatorsAndRetainedSizes {}\n\ninterface DominatedNodes {\n  // For each node ordinal, the index of its first child node in dominatedNodes.\n  // Together with dominatedNodes, this allows traversing down the dominators tree,\n  // whereas dominatorsTree allows upward traversal.\n  firstDominatedNodeIndex: Uint32Array;\n  // Node indexes of child nodes in the dominator tree.\n  dominatedNodes: Uint32Array;\n}\n\n// The data transferred from the secondary worker to the primary.\ninterface ResultsFromSecondWorker extends Retainers, DominatorsAndRetainedSizes, DominatedNodes {}\n\n// Initialization work is split into two threads. This class is the entry point\n// for work done by the second thread.\nexport class SecondaryInitManager {\n  argsStep1: Promise<SecondaryInitArgumentsStep1>;\n  argsStep2: Promise<SecondaryInitArgumentsStep2>;\n  argsStep3: Promise<SecondaryInitArgumentsStep3>;\n  constructor(port: MessagePort) {\n    const {promise: argsStep1, resolve: resolveArgsStep1} = Promise.withResolvers<SecondaryInitArgumentsStep1>();\n    this.argsStep1 = argsStep1;\n    const {promise: argsStep2, resolve: resolveArgsStep2} = Promise.withResolvers<SecondaryInitArgumentsStep2>();\n    this.argsStep2 = argsStep2;\n    const {promise: argsStep3, resolve: resolveArgsStep3} = Promise.withResolvers<SecondaryInitArgumentsStep3>();\n    this.argsStep3 = argsStep3;\n    port.onmessage = e => {\n      const data = e.data;\n      switch (data.step) {\n        case 1:\n          resolveArgsStep1(data.args);\n          break;\n        case 2:\n          resolveArgsStep2(data.args);\n          break;\n        case 3:\n          resolveArgsStep3(data.args);\n          break;\n      }\n    };\n    void this.initialize(port);\n  }\n\n  private async getNodeSelfSizes(): Promise<Uint32Array> {\n    return (await this.argsStep3).nodeSelfSizes;\n  }\n\n  private async initialize(port: MessagePort): Promise<void> {\n    try {\n      const argsStep1 = await this.argsStep1;\n      const retainers = HeapSnapshot.buildRetainers(argsStep1);\n      const argsStep2 = await this.argsStep2;\n      const args = {\n        ...argsStep2,\n        ...argsStep1,\n        ...retainers,\n        essentialEdges: Platform.TypedArrayUtilities.createBitVector(argsStep2.essentialEdgesBuffer),\n        port,\n        nodeSelfSizesPromise: this.getNodeSelfSizes()\n      };\n      const dominatorsAndRetainedSizes = await HeapSnapshot.calculateDominatorsAndRetainedSizes(args);\n      const dominatedNodesOutputs = HeapSnapshot.buildDominatedNodes({...args, ...dominatorsAndRetainedSizes});\n      const results: ResultsFromSecondWorker = {\n        ...retainers,\n        ...dominatorsAndRetainedSizes,\n        ...dominatedNodesOutputs,\n      };\n      port.postMessage({resultsFromSecondWorker: results}, {\n        transfer: [\n          results.dominatorsTree.buffer,\n          results.firstRetainerIndex.buffer,\n          results.retainedSizes.buffer,\n          results.retainingEdges.buffer,\n          results.retainingNodes.buffer,\n          results.dominatedNodes.buffer,\n          results.firstDominatedNodeIndex.buffer,\n        ]\n      });\n    } catch (e) {\n      port.postMessage({error: e + '\\n' + e?.stack});\n    }\n  }\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  UNKNOWN = 0,\n  ATTACHED = 1,\n  DETACHED = 2,\n}\nconst BITMASK_FOR_DOM_LINK_STATE = 3;\n\n// The class index is stored in the upper 30 bits of the detachedness field.\nconst SHIFT_FOR_CLASS_INDEX = 2;\n\n// After this many properties, inferInterfaceDefinitions can stop adding more\n// properties to an interface definition if the name is getting too long.\nconst MIN_INTERFACE_PROPERTY_COUNT = 1;\n\n// The maximum length of an interface name produced by inferInterfaceDefinitions.\n// This limit can be exceeded if the first MIN_INTERFACE_PROPERTY_COUNT property\n// names are long.\nconst MAX_INTERFACE_NAME_LENGTH = 120;\n\n// Each interface definition produced by inferInterfaceDefinitions will match at\n// least this many objects. There's no point in defining interfaces which match\n// only a single object.\nconst MIN_OBJECT_COUNT_PER_INTERFACE = 2;\n\n// Each interface definition produced by inferInterfaceDefinitions should\n// match at least 1 out of 1000 Objects in the heap. Otherwise, we end up with a\n// long tail of unpopular interfaces that don't help analysis.\nconst MIN_OBJECT_PROPORTION_PER_INTERFACE = 1000;\n\nexport abstract class HeapSnapshot {\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  containmentEdges: Platform.TypedArrayUtilities.BigUint32Array;\n  readonly #metaNode: HeapSnapshotMetaInfo;\n  readonly #rawSamples: number[];\n  #samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null = null;\n  strings: string[];\n  readonly #locations: number[];\n  readonly #progress: HeapSnapshotProgress;\n  readonly #noDistance = -5;\n  rootNodeIndexInternal = 0;\n  #snapshotDiffs: Record<string, Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff>> = {};\n  #aggregatesForDiff?: {\n    interfaceDefinitions: string,\n    aggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>,\n  };\n  #aggregates: Record<string, Record<string, AggregatedInfo>> = {};\n  #aggregatesSortedFlags: Record<string, boolean> = {};\n  profile: Profile;\n  nodeTypeOffset!: number;\n  nodeNameOffset!: number;\n  nodeIdOffset!: number;\n  nodeSelfSizeOffset!: number;\n  #nodeEdgeCountOffset!: number;\n  nodeTraceNodeIdOffset!: number;\n  nodeFieldCount!: number;\n  nodeTypes!: string[];\n  nodeArrayType!: number;\n  nodeHiddenType!: number;\n  nodeObjectType!: number;\n  nodeNativeType!: number;\n  nodeStringType!: number;\n  nodeConsStringType!: number;\n  nodeSlicedStringType!: number;\n  nodeCodeType!: number;\n  nodeSyntheticType!: number;\n  nodeClosureType!: number;\n  nodeRegExpType!: number;\n  edgeFieldsCount!: number;\n  edgeTypeOffset!: number;\n  edgeNameOffset!: number;\n  edgeToNodeOffset!: number;\n  edgeTypes!: string[];\n  edgeElementType!: number;\n  edgeHiddenType!: number;\n  edgeInternalType!: number;\n  edgeShortcutType!: number;\n  edgeWeakType!: number;\n  edgeInvisibleType!: number;\n  edgePropertyType!: number;\n  #locationIndexOffset!: number;\n  #locationScriptIdOffset!: number;\n  #locationLineOffset!: number;\n  #locationColumnOffset!: number;\n  #locationFieldCount!: number;\n  nodeCount!: number;\n  #edgeCount!: number;\n  retainedSizes!: Float64Array;\n  firstEdgeIndexes!: Uint32Array;\n  retainingNodes!: Uint32Array;\n  retainingEdges!: Uint32Array;\n  firstRetainerIndex!: Uint32Array;\n  nodeDistances!: Int32Array;\n  firstDominatedNodeIndex!: Uint32Array;\n  dominatedNodes!: Uint32Array;\n  dominatorsTree!: Uint32Array;\n  #allocationProfile!: AllocationProfile;\n  nodeDetachednessAndClassIndexOffset!: number;\n  #locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  #ignoredNodesInRetainersView = new Set<number>();\n  #ignoredEdgesInRetainersView = new Set<number>();\n  #nodeDistancesForRetainersView: Int32Array|undefined;\n  #edgeNamesThatAreNotWeakMaps: Platform.TypedArrayUtilities.BitVector;\n  detachednessAndClassIndexArray?: Uint32Array;\n  #interfaceNames = new Map<string, number>();\n  #interfaceDefinitions?: InterfaceDefinition[];\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this.#metaNode = profile.snapshot.meta;\n    this.#rawSamples = profile.samples;\n    this.strings = profile.strings;\n    this.#locations = profile.locations;\n    this.#progress = progress;\n\n    if (profile.snapshot.root_index) {\n      this.rootNodeIndexInternal = profile.snapshot.root_index;\n    }\n\n    this.profile = profile;\n    this.#edgeNamesThatAreNotWeakMaps = Platform.TypedArrayUtilities.createBitVector(this.strings.length);\n  }\n\n  async initialize(secondWorker: MessagePort): Promise<void> {\n    const meta = this.#metaNode;\n\n    this.nodeTypeOffset = meta.node_fields.indexOf('type');\n    this.nodeNameOffset = meta.node_fields.indexOf('name');\n    this.nodeIdOffset = meta.node_fields.indexOf('id');\n    this.nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this.#nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this.nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this.nodeDetachednessAndClassIndexOffset = meta.node_fields.indexOf('detachedness');\n    this.nodeFieldCount = meta.node_fields.length;\n\n    this.nodeTypes = meta.node_types[this.nodeTypeOffset];\n    this.nodeArrayType = this.nodeTypes.indexOf('array');\n    this.nodeHiddenType = this.nodeTypes.indexOf('hidden');\n    this.nodeObjectType = this.nodeTypes.indexOf('object');\n    this.nodeNativeType = this.nodeTypes.indexOf('native');\n    this.nodeStringType = this.nodeTypes.indexOf('string');\n    this.nodeConsStringType = this.nodeTypes.indexOf('concatenated string');\n    this.nodeSlicedStringType = this.nodeTypes.indexOf('sliced string');\n    this.nodeCodeType = this.nodeTypes.indexOf('code');\n    this.nodeSyntheticType = this.nodeTypes.indexOf('synthetic');\n    this.nodeClosureType = this.nodeTypes.indexOf('closure');\n    this.nodeRegExpType = this.nodeTypes.indexOf('regexp');\n\n    this.edgeFieldsCount = meta.edge_fields.length;\n    this.edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this.edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this.edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this.edgeTypes = meta.edge_types[this.edgeTypeOffset];\n    this.edgeTypes.push('invisible');\n    this.edgeElementType = this.edgeTypes.indexOf('element');\n    this.edgeHiddenType = this.edgeTypes.indexOf('hidden');\n    this.edgeInternalType = this.edgeTypes.indexOf('internal');\n    this.edgeShortcutType = this.edgeTypes.indexOf('shortcut');\n    this.edgeWeakType = this.edgeTypes.indexOf('weak');\n    this.edgeInvisibleType = this.edgeTypes.indexOf('invisible');\n    this.edgePropertyType = this.edgeTypes.indexOf('property');\n\n    const locationFields = meta.location_fields || [];\n\n    this.#locationIndexOffset = locationFields.indexOf('object_index');\n    this.#locationScriptIdOffset = locationFields.indexOf('script_id');\n    this.#locationLineOffset = locationFields.indexOf('line');\n    this.#locationColumnOffset = locationFields.indexOf('column');\n    this.#locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this.nodeFieldCount;\n    this.#edgeCount = this.containmentEdges.length / this.edgeFieldsCount;\n\n    this.#progress.updateStatus('Building edge indexes…');\n    this.firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this.buildEdgeIndexes();\n    this.#progress.updateStatus('Building retainers…');\n    const resultsFromSecondWorker = this.startInitStep1InSecondThread(secondWorker);\n    this.#progress.updateStatus('Propagating DOM state…');\n    this.propagateDOMState();\n    this.#progress.updateStatus('Calculating node flags…');\n    this.calculateFlags();\n    this.#progress.updateStatus('Building dominated nodes…');\n    this.startInitStep2InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating shallow sizes…');\n    this.calculateShallowSizes();\n    this.#progress.updateStatus('Calculating retained sizes…');\n    this.startInitStep3InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating distances…');\n    this.nodeDistances = new Int32Array(this.nodeCount);\n    this.calculateDistances(/* isForRetainersView=*/ false);\n    this.#progress.updateStatus('Calculating object names…');\n    this.calculateObjectNames();\n    this.applyInterfaceDefinitions(this.inferInterfaceDefinitions());\n    this.#progress.updateStatus('Calculating samples…');\n    this.buildSamples();\n    this.#progress.updateStatus('Building locations…');\n    this.buildLocationMap();\n    this.#progress.updateStatus('Calculating retained sizes…');\n    await this.installResultsFromSecondThread(resultsFromSecondWorker);\n    this.#progress.updateStatus('Calculating statistics…');\n    this.calculateStatistics();\n\n    if (this.profile.snapshot.trace_function_count) {\n      this.#progress.updateStatus('Building allocation statistics…');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this.nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: LiveObjects = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this.#allocationProfile = new AllocationProfile(this.profile, liveObjects);\n    }\n\n    this.#progress.updateStatus('Finished processing.');\n  }\n\n  private startInitStep1InSecondThread(secondWorker: MessagePort): Promise<ResultsFromSecondWorker> {\n    const resultsFromSecondWorker = new Promise<ResultsFromSecondWorker>((resolve, reject) => {\n      secondWorker.onmessage = (event: MessageEvent) => {\n        const data = event.data;\n        if (data?.problemReport) {\n          const problemReport: HeapSnapshotProblemReport = data.problemReport;\n          console.warn(formatProblemReport(this, problemReport));\n        } else if (data?.resultsFromSecondWorker) {\n          const resultsFromSecondWorker: ResultsFromSecondWorker = data.resultsFromSecondWorker;\n          resolve(resultsFromSecondWorker);\n        } else if (data?.error) {\n          reject(data.error);\n        }\n      };\n    });\n    const edgeCount = this.#edgeCount;\n    const {containmentEdges, edgeToNodeOffset, edgeFieldsCount, nodeFieldCount} = this;\n    const edgeToNodeOrdinals = new Uint32Array(edgeCount);\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeIndex = containmentEdges.getValue(edgeOrdinal * edgeFieldsCount + edgeToNodeOffset);\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      edgeToNodeOrdinals[edgeOrdinal] = toNodeIndex / nodeFieldCount;\n    }\n    const args: SecondaryInitArgumentsStep1 = {\n      edgeToNodeOrdinals,\n      firstEdgeIndexes: this.firstEdgeIndexes,\n      nodeCount: this.nodeCount,\n      edgeFieldsCount: this.edgeFieldsCount,\n      nodeFieldCount: this.nodeFieldCount,\n    };\n    // Note that firstEdgeIndexes is not transferred; each thread needs its own copy.\n    secondWorker.postMessage({step: 1, args}, [edgeToNodeOrdinals.buffer]);\n    return resultsFromSecondWorker;\n  }\n\n  private startInitStep2InSecondThread(secondWorker: MessagePort): void {\n    const rootNodeOrdinal = this.rootNodeIndexInternal / this.nodeFieldCount;\n    const essentialEdges = this.initEssentialEdges();\n    const args: SecondaryInitArgumentsStep2 = {rootNodeOrdinal, essentialEdgesBuffer: essentialEdges.buffer};\n    secondWorker.postMessage({step: 2, args}, [essentialEdges.buffer]);\n  }\n\n  private startInitStep3InSecondThread(secondWorker: MessagePort): void {\n    const {nodes, nodeFieldCount, nodeSelfSizeOffset, nodeCount} = this;\n    const nodeSelfSizes = new Uint32Array(nodeCount);\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      nodeSelfSizes[nodeOrdinal] = nodes.getValue(nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset);\n    }\n    const args: SecondaryInitArgumentsStep3 = {nodeSelfSizes};\n    secondWorker.postMessage({step: 3, args}, [nodeSelfSizes.buffer]);\n  }\n\n  private async installResultsFromSecondThread(resultsFromSecondWorker: Promise<ResultsFromSecondWorker>):\n      Promise<void> {\n    const results = await resultsFromSecondWorker;\n    this.dominatedNodes = results.dominatedNodes;\n    this.dominatorsTree = results.dominatorsTree;\n    this.firstDominatedNodeIndex = results.firstDominatedNodeIndex;\n    this.firstRetainerIndex = results.firstRetainerIndex;\n    this.retainedSizes = results.retainedSizes;\n    this.retainingEdges = results.retainingEdges;\n    this.retainingNodes = results.retainingNodes;\n  }\n\n  private buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeEdgeCountOffset = this.#nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes.getValue(nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset) * edgeFieldsCount;\n    }\n  }\n\n  static buildRetainers(inputs: ArgumentsToBuildRetainers): Retainers {\n    const {edgeToNodeOrdinals, firstEdgeIndexes, nodeCount, edgeFieldsCount, nodeFieldCount} = inputs;\n    const edgeCount = edgeToNodeOrdinals.length;\n    const retainingNodes = new Uint32Array(edgeCount);\n    const retainingEdges = new Uint32Array(edgeCount);\n    const firstRetainerIndex = new Uint32Array(nodeCount + 1);\n\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeOrdinal = edgeToNodeOrdinals[edgeOrdinal];\n      ++firstRetainerIndex[toNodeOrdinal];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeOrdinal];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n\n    return {\n      retainingNodes,\n      retainingEdges,\n      firstRetainerIndex,\n    };\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  private allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this.rootNodeIndexInternal);\n  }\n\n  get rootNodeIndex(): number {\n    return this.rootNodeIndexInternal;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize() + (this.profile.snapshot.extra_native_bytes ?? 0);\n  }\n\n  private createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const {minNodeId, maxNodeId, allocationNodeId, filterName} = nodeFilter;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this.createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this.createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    } else if (filterName !== undefined) {\n      filter = this.createNamedFilter(filterName);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NamedFilter: ' + filterName;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp =\n        searchConfig.isRegex ? new RegExp(query) : Platform.StringUtilities.createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const useRegExp = searchConfig.isRegex || !searchConfig.caseSensitive;\n    const stringFilter = useRegExp ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    const filter = this.createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this.nodeNameOffset;\n    const nodeIdOffset = this.nodeIdOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (node.selfSize() === 0) {\n        // Nodes with size zero are omitted in the data grid, so avoid returning\n        // search results that can't be navigated to.\n        continue;\n      }\n      const name = node.name();\n      if (name === node.rawName()) {\n        // If the string displayed to the user matches the raw name from the\n        // snapshot, then we can use the Set computed above. This avoids\n        // repeated work when multiple nodes have the same name.\n        if (stringIndexes.has(nodes.getValue(nodeIndex + nodeNameOffset))) {\n          nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n        }\n        // If the node is displaying a customized name, then we must perform the\n        // full string search within that name here.\n      } else if (useRegExp ? regexp.test(name) : (name.indexOf(query) !== -1)) {\n        nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate> {\n    const filter = this.createFilter(nodeFilter);\n    // @ts-expect-error key is added in createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.getAggregatesByClassKey(false, key, filter);\n  }\n\n  private createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  private createAllocationStackFilter(bottomUpAllocationNodeId: number):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this.#allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this.#allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: Record<number, boolean> = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  private createNamedFilter(filterName: string): (node: HeapSnapshotNode) => boolean {\n    // Allocate an array with a single bit per node, which can be used by each\n    // specific filter implemented below.\n    const bitmap = Platform.TypedArrayUtilities.createBitVector(this.nodeCount);\n    const getBit = (node: HeapSnapshotNode): boolean => {\n      const ordinal = node.nodeIndex / this.nodeFieldCount;\n      return bitmap.getBit(ordinal);\n    };\n\n    // Traverses the graph in breadth-first order with the given filter, and\n    // sets the bit in `bitmap` for every visited node.\n    const traverse = (filter: (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => boolean): void => {\n      const distances = new Int32Array(this.nodeCount);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        distances[i] = this.#noDistance;\n      }\n      const nodesToVisit = new Uint32Array(this.nodeCount);\n      distances[this.rootNode().ordinal()] = 0;\n      nodesToVisit[0] = this.rootNode().nodeIndex;\n      const nodesToVisitLength = 1;\n      this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (distances[i] !== this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    const markUnreachableNodes = (): void => {\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (this.nodeDistances[i] === this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    switch (filterName) {\n      case 'objectsRetainedByDetachedDomNodes':\n        // Traverse the graph, avoiding detached nodes.\n        traverse((_node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return edge.node().detachedness() !== DOMLinkState.DETACHED;\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'objectsRetainedByConsole':\n        // Traverse the graph, avoiding edges that represent globals owned by\n        // the DevTools console.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return !(node.isSynthetic() && edge.hasStringName() && edge.name().endsWith(' / DevTools console'));\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'duplicatedStrings': {\n        const stringToNodeIndexMap = new Map<string, number>();\n        const node = this.createNode(0);\n        for (let i = 0; i < this.nodeCount; ++i) {\n          node.nodeIndex = i * this.nodeFieldCount;\n          const rawType = node.rawType();\n          if (rawType === this.nodeStringType || rawType === this.nodeConsStringType) {\n            // Check whether the cons string is already \"flattened\", meaning\n            // that one of its two parts is the empty string. If so, we should\n            // skip it. We don't help anyone by reporting a flattened cons\n            // string as a duplicate with its own content, since V8 controls\n            // that behavior internally.\n            if (node.isFlatConsString()) {\n              continue;\n            }\n            const name = node.name();\n            const alreadyVisitedNodeIndex = stringToNodeIndexMap.get(name);\n            if (alreadyVisitedNodeIndex === undefined) {\n              stringToNodeIndexMap.set(name, node.nodeIndex);\n            } else {\n              bitmap.setBit(alreadyVisitedNodeIndex / this.nodeFieldCount);\n              bitmap.setBit(node.nodeIndex / this.nodeFieldCount);\n            }\n          }\n        }\n        return getBit;\n      }\n    }\n    throw new Error('Invalid filter name');\n  }\n\n  getAggregatesByClassKey(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate> {\n    let aggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate>;\n    if (key && this.#aggregates[key]) {\n      aggregates = this.#aggregates[key];\n    } else {\n      const aggregatesMap = this.buildAggregates(filter);\n      this.calculateClassesRetainedSize(aggregatesMap, filter);\n\n      // In the two previous steps, we used class keys that were simple and\n      // could be produced quickly. For many objects, this meant using the index\n      // of the string containing its class name. However, string indices are\n      // not consistent across snapshots, and this aggregate data might end up\n      // being used in a comparison, so here we convert to a more durable format\n      // for class keys.\n      aggregates = Object.create(null);\n      for (const [classKey, aggregate] of aggregatesMap.entries()) {\n        const newKey = this.#classKeyFromClassKey(classKey);\n        aggregates[newKey] = aggregate;\n      }\n      if (key) {\n        this.#aggregates[key] = aggregates;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this.#aggregatesSortedFlags[key])) {\n      this.sortAggregateIndexes(aggregates);\n      if (key) {\n        this.#aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregates as Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate>;\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this.#allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this.#allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this.#allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(interfaceDefinitions: string):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff> {\n    if (this.#aggregatesForDiff?.interfaceDefinitions === interfaceDefinitions) {\n      return this.#aggregatesForDiff.aggregates;\n    }\n\n    // Temporarily apply the interface definitions from the other snapshot.\n    const originalInterfaceDefinitions = this.#interfaceDefinitions;\n    this.applyInterfaceDefinitions(JSON.parse(interfaceDefinitions) as InterfaceDefinition[]);\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    this.applyInterfaceDefinitions(originalInterfaceDefinitions ?? []);\n    const result: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff> = {};\n\n    const node = this.createNode();\n    for (const classKey in aggregates) {\n      const aggregate = aggregates[classKey];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      result[classKey] = {name: node.className(), indexes, ids, selfSizes};\n    }\n\n    this.#aggregatesForDiff = {interfaceDefinitions, aggregates: result};\n    return result;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateShallowSizes(): void {\n  }\n\n  calculateDistances(\n      isForRetainersView: boolean, filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n\n    if (isForRetainersView) {\n      const originalFilter = filter;\n      filter = (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n        return !this.#ignoredNodesInRetainersView.has(edge.nodeIndex()) &&\n            (!originalFilter || originalFilter(node, edge));\n      };\n      if (this.#nodeDistancesForRetainersView === undefined) {\n        this.#nodeDistancesForRetainersView = new Int32Array(nodeCount);\n      }\n    }\n\n    const distances = isForRetainersView ? (this.#nodeDistancesForRetainersView as Int32Array) : this.nodeDistances;\n    const noDistance = this.#noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  private bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this.edgeWeakType;\n    const noDistance = this.#noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  private buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)): Map<string|number, AggregatedInfo> {\n    const aggregates = new Map<string|number, AggregatedInfo>();\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const selfSizeOffset = this.nodeSelfSizeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this.nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes.getValue(nodeIndex + selfSizeOffset);\n      if (!selfSize) {\n        continue;\n      }\n      const classKey = node.classKeyInternal();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      let aggregate = aggregates.get(classKey);\n      if (!aggregate) {\n        aggregate = {\n          count: 1,\n          distance,\n          self: selfSize,\n          maxRet: 0,\n          name: node.className(),\n          idxs: [nodeIndex],\n        };\n        aggregates.set(classKey, aggregate);\n      } else {\n        aggregate.distance = Math.min(aggregate.distance, distance);\n        ++aggregate.count;\n        aggregate.self += selfSize;\n        aggregate.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (const aggregate of aggregates.values()) {\n      aggregate.idxs = aggregate.idxs.slice();\n    }\n\n    return aggregates;\n  }\n\n  private calculateClassesRetainedSize(\n      aggregates: Map<string|number, AggregatedInfo>, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this.rootNodeIndexInternal;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classKeys: Array<string|number> = [];\n\n    const seenClassKeys = new Map<string|number, boolean>();\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatedNodes = this.dominatedNodes;\n    const firstDominatedNodeIndex = this.firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classKey = node.classKeyInternal();\n      const seen = Boolean(seenClassKeys.get(classKey));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) && node.selfSize()) {\n        (aggregates.get(classKey) as AggregatedInfo).maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassKeys.set(classKey, true);\n          sizes.push(list.length);\n          classKeys.push(classKey);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classKey = (classKeys.pop() as string);\n        seenClassKeys.set(classKey, false);\n      }\n    }\n  }\n\n  private sortAggregateIndexes(aggregates: Record<string, AggregatedInfo>): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  tryParseWeakMapEdgeName(edgeNameIndex: number): {duplicatedPart: string, tableId: string}|undefined {\n    const previousResult = this.#edgeNamesThatAreNotWeakMaps.getBit(edgeNameIndex);\n    if (previousResult) {\n      return undefined;\n    }\n    const edgeName = this.strings[edgeNameIndex];\n    const ephemeronNameRegex =\n        /^\\d+(?<duplicatedPart> \\/ part of key \\(.*? @\\d+\\) -> value \\(.*? @\\d+\\) pair in WeakMap \\(table @(?<tableId>\\d+)\\))$/;\n    const match = edgeName.match(ephemeronNameRegex);\n    if (!match) {\n      this.#edgeNamesThatAreNotWeakMaps.setBit(edgeNameIndex);\n      return undefined;\n    }\n    return match.groups as {duplicatedPart: string, tableId: string};\n  }\n\n  private computeIsEssentialEdge(\n      nodeIndex: number, edgeIndex: number, userObjectsMapAndFlag: {map: Uint8Array, flag: number}|null): boolean {\n    const edgeType = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n\n    // Values in WeakMaps are retained by the key and table together. Removing\n    // either the key or the table would be sufficient to remove the edge from\n    // the other one, so we needn't use both of those edges when computing\n    // dominators. We've found that the edge from the key generally produces\n    // more useful results, so here we skip the edge from the table.\n    if (edgeType === this.edgeInternalType) {\n      const edgeNameIndex = this.containmentEdges.getValue(edgeIndex + this.edgeNameOffset);\n      const match = this.tryParseWeakMapEdgeName(edgeNameIndex);\n      if (match) {\n        const nodeId = this.nodes.getValue(nodeIndex + this.nodeIdOffset);\n        if (nodeId === parseInt(match.tableId, 10)) {\n          return false;\n        }\n      }\n    }\n\n    // Weak edges never retain anything.\n    if (edgeType === this.edgeWeakType) {\n      return false;\n    }\n\n    const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n    // Ignore self edges.\n    if (nodeIndex === childNodeIndex) {\n      return false;\n    }\n\n    if (nodeIndex !== this.rootNodeIndex) {\n      // Shortcuts at the root node have special meaning of marking user global objects.\n      if (edgeType === this.edgeShortcutType) {\n        return false;\n      }\n\n      const flags = userObjectsMapAndFlag ? userObjectsMapAndFlag.map : null;\n      const userObjectFlag = userObjectsMapAndFlag ? userObjectsMapAndFlag.flag : 0;\n      const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const nodeFlag = !flags || (flags[nodeOrdinal] & userObjectFlag);\n      const childNodeFlag = !flags || (flags[childNodeOrdinal] & userObjectFlag);\n      // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n      // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n      if (childNodeFlag && !nodeFlag) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Returns a bitmap indicating whether each edge should be considered when building the dominator tree.\n  private initEssentialEdges(): Platform.TypedArrayUtilities.BitVector {\n    const essentialEdges = Platform.TypedArrayUtilities.createBitVector(this.#edgeCount);\n    const {nodes, nodeFieldCount, edgeFieldsCount} = this;\n    const userObjectsMapAndFlag = this.userObjectsMapAndFlag();\n    const endNodeIndex = nodes.length;\n    const node = this.createNode(0);\n    for (let nodeIndex = 0; nodeIndex < endNodeIndex; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      const edgeIndexesEnd = node.edgeIndexesEnd();\n      for (let edgeIndex = node.edgeIndexesStart(); edgeIndex < edgeIndexesEnd; edgeIndex += edgeFieldsCount) {\n        if (this.computeIsEssentialEdge(nodeIndex, edgeIndex, userObjectsMapAndFlag)) {\n          essentialEdges.setBit(edgeIndex / edgeFieldsCount);\n        }\n      }\n    }\n    return essentialEdges;\n  }\n\n  static hasOnlyWeakRetainers(inputs: ArgumentsToComputeDominatorsAndRetainedSizes, nodeOrdinal: number): boolean {\n    const {retainingEdges, edgeFieldsCount, firstRetainerIndex, essentialEdges} = inputs;\n    const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      if (essentialEdges.getBit(retainerEdgeIndex / edgeFieldsCount)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm for building the dominator tree is from the paper:\n  // Thomas Lengauer and Robert Endre Tarjan. 1979. A fast algorithm for finding dominators in a flowgraph.\n  // ACM Trans. Program. Lang. Syst. 1, 1 (July 1979), 121–141. https://doi.org/10.1145/357062.357071\n  static async calculateDominatorsAndRetainedSizes(inputs: ArgumentsToComputeDominatorsAndRetainedSizes):\n      Promise<DominatorsAndRetainedSizes> {\n    // Preload fields into local variables for better performance.\n    const {\n      nodeCount,\n      firstEdgeIndexes,\n      edgeFieldsCount,\n      nodeFieldCount,\n      firstRetainerIndex,\n      retainingEdges,\n      retainingNodes,\n      edgeToNodeOrdinals,\n      rootNodeOrdinal,\n      essentialEdges,\n      nodeSelfSizesPromise,\n      port\n    } = inputs;\n    function isEssentialEdge(edgeIndex: number): boolean {\n      return essentialEdges.getBit(edgeIndex / edgeFieldsCount);\n    }\n\n    // The Lengauer-Tarjan algorithm expects vectors to be numbered from 1 to n\n    // and uses 0 as an invalid value, so use 1-indexing for all the arrays.\n    // Convert between ordinals and vertex numbers by adding/subtracting 1.\n    const arrayLength = nodeCount + 1;\n    const parent = new Uint32Array(arrayLength);\n    const ancestor = new Uint32Array(arrayLength);\n    const vertex = new Uint32Array(arrayLength);\n    const label = new Uint32Array(arrayLength);\n    const semi = new Uint32Array(arrayLength);\n    const bucket = new Array<Set<number>>(arrayLength);\n    let n = 0;\n\n    // Iterative DFS since the recursive version can cause stack overflows.\n    // Use an array to keep track of the next edge index to be examined for each node.\n    const nextEdgeIndex = new Uint32Array(arrayLength);\n    const dfs = (root: number): void => {\n      const rootOrdinal = root - 1;\n      nextEdgeIndex[rootOrdinal] = firstEdgeIndexes[rootOrdinal];\n      let v = root;\n      while (v !== 0) {\n        // First process v if not done already.\n        if (semi[v] === 0) {\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n\n        // The next node to process is the first unprocessed successor w of v,\n        // or parent[v] if all of v's successors have already been processed.\n        let vNext = parent[v];\n        const vOrdinal = v - 1;\n        for (; nextEdgeIndex[vOrdinal] < firstEdgeIndexes[vOrdinal + 1]; nextEdgeIndex[vOrdinal] += edgeFieldsCount) {\n          const edgeIndex = nextEdgeIndex[vOrdinal];\n          if (!isEssentialEdge(edgeIndex)) {\n            continue;\n          }\n          const wOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n          const w = wOrdinal + 1;\n          if (semi[w] === 0) {\n            parent[w] = v;\n            nextEdgeIndex[wOrdinal] = firstEdgeIndexes[wOrdinal];\n            vNext = w;\n            break;\n          }\n        }\n        v = vNext;\n      }\n    };\n\n    // Iterative version since the recursive version can cause stack overflows.\n    // Preallocate a stack since compress() is called several times.\n    // The stack cannot grow larger than the number of nodes since we walk up\n    // the tree represented by the ancestor array.\n    const compressionStack = new Uint32Array(arrayLength);\n    const compress = (v: number): void => {\n      let stackPointer = 0;\n      while (ancestor[ancestor[v]] !== 0) {\n        compressionStack[++stackPointer] = v;\n        v = ancestor[v];\n      }\n      while (stackPointer > 0) {\n        const w = compressionStack[stackPointer--];\n        if (semi[label[ancestor[w]]] < semi[label[w]]) {\n          label[w] = label[ancestor[w]];\n        }\n        ancestor[w] = ancestor[ancestor[w]];\n      }\n    };\n\n    // Simple versions of eval and link from the paper.\n    const evaluate = (v: number): number => {\n      if (ancestor[v] === 0) {\n        return v;\n      }\n      compress(v);\n      return label[v];\n    };\n\n    const link = (v: number, w: number): void => {\n      ancestor[w] = v;\n    };\n\n    // Algorithm begins here. The variable names are as per the paper.\n    const r = rootNodeOrdinal + 1;\n    n = 0;\n    const dom = new Uint32Array(arrayLength);\n\n    // First perform DFS from the root.\n    dfs(r);\n\n    // Then perform DFS from orphan nodes (ones with only weak retainers) if any.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport =\n          [`Heap snapshot: ${nodeCount - n} nodes are unreachable from the root.`];\n      appendToProblemReport(errors, 'The following nodes have only weak retainers:');\n      for (let v = 1; v <= nodeCount; v++) {\n        const vOrdinal = v - 1;\n        if (semi[v] === 0 && HeapSnapshot.hasOnlyWeakRetainers(inputs, vOrdinal)) {\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          dfs(v);\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // If there are unreachable nodes still, visit them individually from the root.\n    // This can happen when there is a clique of nodes retained by one another.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport = [`Heap snapshot: Still found ${nodeCount - n} unreachable nodes:`];\n      for (let v = 1; v <= nodeCount; v++) {\n        if (semi[v] === 0) {\n          const vOrdinal = v - 1;\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // Main loop. Process the vertices in decreasing order by DFS number.\n    for (let i = n; i >= 2; --i) {\n      const w = vertex[i];\n      // Iterate over all predecessors v of w.\n      const wOrdinal = w - 1;\n      let isOrphanNode = true;\n      for (let retainerIndex = firstRetainerIndex[wOrdinal]; retainerIndex < firstRetainerIndex[wOrdinal + 1];\n           retainerIndex++) {\n        if (!isEssentialEdge(retainingEdges[retainerIndex])) {\n          continue;\n        }\n        isOrphanNode = false;\n        const vOrdinal = retainingNodes[retainerIndex] / nodeFieldCount;\n        const v = vOrdinal + 1;\n        const u = evaluate(v);\n        if (semi[u] < semi[w]) {\n          semi[w] = semi[u];\n        }\n      }\n      if (isOrphanNode) {\n        // We treat orphan nodes as having a single predecessor - the root.\n        // semi[r] is always less than any semi[w] so set it unconditionally.\n        semi[w] = semi[r];\n      }\n\n      if (bucket[vertex[semi[w]]] === undefined) {\n        bucket[vertex[semi[w]]] = new Set<number>();\n      }\n      bucket[vertex[semi[w]]].add(w);\n      link(parent[w], w);\n\n      // Process all vertices v in bucket(parent(w)).\n      if (bucket[parent[w]] !== undefined) {\n        for (const v of bucket[parent[w]]) {\n          const u = evaluate(v);\n          dom[v] = semi[u] < semi[v] ? u : parent[w];\n        }\n        bucket[parent[w]].clear();\n      }\n    }\n\n    // Final step. Fill in the immediate dominators not explicitly computed above.\n    // Unlike the paper, we consider the root to be its own dominator and\n    // set dom[0] to r to propagate the root as the dominator of unreachable nodes.\n    dom[0] = dom[r] = r;\n    for (let i = 2; i <= n; i++) {\n      const w = vertex[i];\n      if (dom[w] !== vertex[semi[w]]) {\n        dom[w] = dom[dom[w]];\n      }\n    }\n    // Algorithm ends here.\n\n    // Transform the dominators into an ordinal-indexed array and populate the self sizes.\n    const dominatorsTree = new Uint32Array(nodeCount);\n    const retainedSizes = new Float64Array(nodeCount);\n    const nodeSelfSizes = await nodeSelfSizesPromise;\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; nodeOrdinal++) {\n      dominatorsTree[nodeOrdinal] = dom[nodeOrdinal + 1] - 1;\n      retainedSizes[nodeOrdinal] = nodeSelfSizes[nodeOrdinal];\n    }\n\n    // Then propagate up the retained sizes for each traversed node excluding the root.\n    for (let i = n; i > 1; i--) {\n      const nodeOrdinal = vertex[i] - 1;\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n\n    return {dominatorsTree, retainedSizes};\n  }\n\n  static buildDominatedNodes(inputs: ArgumentsToBuildDominatedNodes): DominatedNodes {\n    const {nodeCount, dominatorsTree, rootNodeOrdinal, nodeFieldCount} = inputs;\n\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = new Uint32Array(nodeCount + 1);\n    // All nodes except the root have dominators.\n    const dominatedNodes = new Uint32Array(nodeCount - 1);\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = nodeCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n\n    return {firstDominatedNodeIndex: indexArray, dominatedNodes};\n  }\n\n  private calculateObjectNames(): void {\n    const {\n      nodes,\n      nodeCount,\n      nodeNameOffset,\n      nodeNativeType,\n      nodeHiddenType,\n      nodeObjectType,\n      nodeCodeType,\n      nodeClosureType,\n      nodeRegExpType,\n    } = this;\n\n    // If the snapshot doesn't contain a detachedness field in each node, then\n    // allocate a separate array so there is somewhere to store the class index.\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      this.detachednessAndClassIndexArray = new Uint32Array(nodeCount);\n    }\n\n    // We'll add some new values to the `strings` array during the processing below.\n    // This map lets us easily find the index for each added string.\n    const stringTable = new Map<string, number>();\n    const getIndexForString = (s: string): number => {\n      let index = stringTable.get(s);\n      if (index === undefined) {\n        index = this.addString(s);\n        stringTable.set(s, index);\n      }\n      return index;\n    };\n\n    const hiddenClassIndex = getIndexForString('(system)');\n    const codeClassIndex = getIndexForString('(compiled code)');\n    const functionClassIndex = getIndexForString('Function');\n    const regExpClassIndex = getIndexForString('RegExp');\n\n    function getNodeClassIndex(node: HeapSnapshotNode): number {\n      switch (node.rawType()) {\n        case nodeHiddenType:\n          return hiddenClassIndex;\n        case nodeObjectType:\n        case nodeNativeType: {\n          let name = node.rawName();\n\n          // If the node name is (for example) '<div id=\"a\">', then the class\n          // name should be just '<div>'. If the node name is already short\n          // enough, like '<div>', we must still call getIndexForString on that\n          // name, because the names added by getIndexForString are not\n          // deduplicated with preexisting strings, and we want all objects with\n          // class name '<div>' to refer to that class name via the same index.\n          // Otherwise, object categorization doesn't work.\n          if (name.startsWith('<')) {\n            const firstSpace = name.indexOf(' ');\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n          if (name.startsWith('Detached <')) {\n            const firstSpace = name.indexOf(' ', 10);\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n\n          // Avoid getIndexForString here; the class name index should match the name index.\n          return nodes.getValue(node.nodeIndex + nodeNameOffset);\n        }\n        case nodeCodeType:\n          return codeClassIndex;\n        case nodeClosureType:\n          return functionClassIndex;\n        case nodeRegExpType:\n          return regExpClassIndex;\n        default:\n          return getIndexForString('(' + node.type() + ')');\n      }\n    }\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      node.setClassIndex(getNodeClassIndex(node));\n      node.nodeIndex = node.nextNodeIndex();\n    }\n  }\n\n  interfaceDefinitions(): string {\n    return JSON.stringify(this.#interfaceDefinitions ?? []);\n  }\n\n  private isPlainJSObject(node: HeapSnapshotNode): boolean {\n    return node.rawType() === this.nodeObjectType && node.rawName() === 'Object';\n  }\n\n  private inferInterfaceDefinitions(): InterfaceDefinition[] {\n    const {edgePropertyType} = this;\n\n    // First, produce a set of candidate definitions by iterating the properties\n    // on every plain JS Object in the snapshot.\n    interface InterfaceDefinitionCandidate extends InterfaceDefinition {\n      // How many objects start with these properties in this order.\n      count: number;\n    }\n    // A map from interface names to their definitions.\n    const candidates = new Map<string, InterfaceDefinitionCandidate>();\n    let totalObjectCount = 0;\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n      ++totalObjectCount;\n      let interfaceName = '{';\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        const edgeName = edge.name();\n        if (edge.rawType() !== edgePropertyType || edgeName === '__proto__') {\n          continue;\n        }\n        const formattedEdgeName = JSHeapSnapshotNode.formatPropertyName(edgeName);\n        if (interfaceName.length > MIN_INTERFACE_PROPERTY_COUNT &&\n            interfaceName.length + formattedEdgeName.length > MAX_INTERFACE_NAME_LENGTH) {\n          break;  // The interface name is getting too long.\n        }\n        if (interfaceName.length !== 1) {\n          interfaceName += ', ';\n        }\n        interfaceName += formattedEdgeName;\n        properties.push(edgeName);\n      }\n      // The empty interface is not very meaningful, and can be sort of misleading\n      // since someone might incorrectly interpret it as objects with no properties.\n      if (properties.length === 0) {\n        continue;\n      }\n      interfaceName += '}';\n      const candidate = candidates.get(interfaceName);\n      if (candidate) {\n        ++candidate.count;\n      } else {\n        candidates.set(interfaceName, {name: interfaceName, properties, count: 1});\n      }\n    }\n\n    // Next, sort the candidates and select the most popular ones. It's possible that\n    // some candidates represent the same properties in different orders, but that's\n    // okay: by sorting here, we ensure that the most popular ordering appears first\n    // in the result list, and the rules for applying interface definitions will prefer\n    // the first matching definition if multiple matches contain the same properties.\n    const sortedCandidates = Array.from(candidates.values());\n    sortedCandidates.sort((a, b) => b.count - a.count);\n    const result: InterfaceDefinition[] = [];\n    const minCount = Math.max(MIN_OBJECT_COUNT_PER_INTERFACE, totalObjectCount / MIN_OBJECT_PROPORTION_PER_INTERFACE);\n    for (let i = 0; i < sortedCandidates.length; ++i) {\n      const candidate = sortedCandidates[i];\n      if (candidate.count < minCount) {\n        break;\n      }\n      result.push(candidate);\n    }\n\n    return result;\n  }\n\n  private applyInterfaceDefinitions(definitions: InterfaceDefinition[]): void {\n    const {edgePropertyType} = this;\n    this.#interfaceDefinitions = definitions;\n\n    // Any computed aggregate data will be wrong after recategorization, so clear it.\n    this.#aggregates = {};\n    this.#aggregatesSortedFlags = {};\n\n    // Information about a named interface.\n    interface MatchInfo {\n      name: string;\n      // The number of properties listed in the interface definition.\n      propertyCount: number;\n      // The position of the interface definition in the list of definitions.\n      index: number;\n    }\n\n    function selectBetterMatch(a: MatchInfo, b: MatchInfo|null): MatchInfo {\n      if (!b || a.propertyCount > b.propertyCount) {\n        return a;\n      }\n      if (b.propertyCount > a.propertyCount) {\n        return b;\n      }\n      return a.index <= b.index ? a : b;\n    }\n\n    // A node in the tree which allows us to search for interfaces matching an object.\n    // Each edge in this tree represents adding a property, starting from an empty\n    // object. Properties must be iterated in sorted order.\n    interface PropertyTreeNode {\n      // All possible successors from this node. Keys are property names.\n      next: Map<string, PropertyTreeNode>;\n      // If this node corresponds to a named interface, then matchInfo contains that name.\n      matchInfo: MatchInfo|null;\n      // The maximum of all keys in `next`. This helps determine when no further transitions\n      // are possible from this node.\n      greatestNext: string|null;\n    }\n\n    // The root node of the tree.\n    const propertyTree: PropertyTreeNode = {\n      next: new Map(),\n      matchInfo: null,\n      greatestNext: null,\n    };\n\n    // Build up the property tree.\n    for (let interfaceIndex = 0; interfaceIndex < definitions.length; ++interfaceIndex) {\n      const definition = definitions[interfaceIndex];\n      const properties = definition.properties.toSorted();\n      let currentNode = propertyTree;\n      for (const property of properties) {\n        const nextMap = currentNode.next;\n        let nextNode = nextMap.get(property);\n        if (!nextNode) {\n          nextNode = {\n            next: new Map(),\n            matchInfo: null,\n            greatestNext: null,\n          };\n          nextMap.set(property, nextNode);\n          if (currentNode.greatestNext === null || currentNode.greatestNext < property) {\n            currentNode.greatestNext = property;\n          }\n        }\n        currentNode = nextNode;\n      }\n      // Only set matchInfo on this node if it wasn't already set, to ensure that\n      // interfaces defined earlier in the list have priority.\n      if (!currentNode.matchInfo) {\n        currentNode.matchInfo = {\n          name: definition.name,\n          propertyCount: properties.length,\n          index: interfaceIndex,\n        };\n      }\n    }\n\n    // The fallback match for objects which don't match any defined interface.\n    const initialMatch: MatchInfo = {\n      name: 'Object',\n      propertyCount: 0,\n      index: Infinity,\n    };\n\n    // Iterate all nodes and check whether they match a named interface, using\n    // the tree constructed above. Then update the class name for each node.\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n\n      // Collect and sort the properties of this object.\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        if (edge.rawType() === edgePropertyType) {\n          properties.push(edge.name());\n        }\n      }\n      properties.sort();\n\n      // We may explore multiple possible paths through the tree, so this set tracks\n      // all states that match with the properties iterated thus far.\n      const states = new Set<PropertyTreeNode>();\n      states.add(propertyTree);\n\n      // This variable represents the best match found thus far. We start by checking\n      // whether there is an interface definition for the empty object.\n      let match = selectBetterMatch(initialMatch, propertyTree.matchInfo);\n\n      // Traverse the tree to find any matches.\n      for (const property of properties) {\n        // Iterate only the states that already exist, not the ones added during the loop below.\n        for (const currentState of Array.from(states.keys())) {\n          if (currentState.greatestNext === null || property >= currentState.greatestNext) {\n            // No further transitions are possible from this state.\n            states.delete(currentState);\n          }\n          const nextState = currentState.next.get(property);\n          if (nextState) {\n            states.add(nextState);\n            match = selectBetterMatch(match, nextState.matchInfo);\n          }\n        }\n      }\n\n      // Update the node's class name accordingly.\n      let classIndex = match === initialMatch ? node.rawNameIndex() : this.#interfaceNames.get(match.name);\n      if (classIndex === undefined) {\n        classIndex = this.addString(match.name);\n        this.#interfaceNames.set(match.name, classIndex);\n      }\n      node.setClassIndex(classIndex);\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  private iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this.firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this.firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this.edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const type = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  private addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n   * The phase propagates whether a node is attached or detached through the\n   * graph and adjusts the low-level representation of nodes.\n   *\n   * State propagation:\n   * 1. Any object reachable from an attached object is itself attached.\n   * 2. Any object reachable from a detached object that is not already\n   *    attached is considered detached.\n   *\n   * Representation:\n   * - Name of any detached node is changed from \"<Name>\"\" to\n   *   \"Detached <Name>\".\n   */\n  private propagateDOMState(): void {\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n    const node = this.createNode(0);\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes.getValue(nodeIndex + snapshot.nodeNameOffset);\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot.addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes.setValue(nodeIndex + snapshot.nodeNameOffset, newStringIndex);\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot.nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes.getValue(nodeIndex + snapshot.nodeTypeOffset) !== snapshot.nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      node.nodeIndex = nodeIndex;\n      node.setDetachedness(newState);\n\n      if (newState === DOMLinkState.ATTACHED) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.DETACHED) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot.iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType => ![snapshot.edgeHiddenType, snapshot.edgeInvisibleType, snapshot.edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const state = node.detachedness();\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.UNKNOWN) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.ATTACHED);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const nodeState = node.detachedness();\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.ATTACHED) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.DETACHED);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  private buildSamples(): void {\n    const samples = this.#rawSamples;\n    if (!samples?.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this.#metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this.#metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this.#samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  private buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this.#locations;\n\n    for (let i = 0; i < locations.length; i += this.#locationFieldCount) {\n      const nodeIndex = locations[i + this.#locationIndexOffset];\n      const scriptId = locations[i + this.#locationScriptIdOffset];\n      const line = locations[i + this.#locationLineOffset];\n      const col = locations[i + this.#locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this.#locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this.#locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this.#samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff> {\n    let snapshotDiff: Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff> = this.#snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff>);\n\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    for (const classKey in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[classKey];\n      const diff = this.calculateDiffForClass(baseAggregate, aggregates[classKey]);\n      if (diff) {\n        snapshotDiff[classKey] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const classKey in aggregates) {\n      if (classKey in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this.calculateDiffForClass(emptyBaseAggregate, aggregates[classKey]);\n      if (classDiff) {\n        snapshotDiff[classKey] = classDiff;\n      }\n    }\n\n    this.#snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  private calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate?: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff(aggregate ? aggregate.name : baseAggregate.name);\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  private nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  // Converts an internal class key, suitable for categorizing within this\n  // snapshot, to a public class key, which can be used in comparisons\n  // between multiple snapshots.\n  #classKeyFromClassKey(key: string|number): string {\n    return typeof key === 'number' ? (',' + this.strings[key]) : key;\n  }\n\n  nodeClassKey(snapshotObjectId: number): string|null {\n    const node = this.nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return this.#classKeyFromClassKey(node.classKeyInternal());\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, classKey: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this.#snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[classKey];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(classKey: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[classKey].idxs);\n  }\n\n  private maxJsNodeId(): number {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this.nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes.getValue(nodeIndex);\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this.rootNodeIndexInternal, this.totalSize, this.maxJsNodeId());\n  }\n\n  ignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.add(nodeIndex);\n    this.calculateDistances(/* isForRetainersView=*/ true);\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.delete(nodeIndex);\n    if (this.#ignoredNodesInRetainersView.size === 0) {\n      this.#nodeDistancesForRetainersView = undefined;\n    } else {\n      this.calculateDistances(/* isForRetainersView=*/ true);\n    }\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreAllNodesInRetainersView(): void {\n    this.#ignoredNodesInRetainersView.clear();\n    this.#nodeDistancesForRetainersView = undefined;\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  #updateIgnoredEdgesInRetainersView(): void {\n    const distances = this.#nodeDistancesForRetainersView;\n    this.#ignoredEdgesInRetainersView.clear();\n    if (distances === undefined) {\n      return;\n    }\n\n    // To retain a value in a WeakMap, both the WeakMap and the corresponding\n    // key must stay alive. If one of those two retainers is unreachable due to\n    // the user ignoring some nodes, then the other retainer edge should also be\n    // shown as unreachable, since it would be insufficient on its own to retain\n    // the value.\n    const unreachableWeakMapEdges = new Platform.MapUtilities.Multimap<number, string>();\n    const noDistance = this.#noDistance;\n    const {nodeCount, nodeFieldCount} = this;\n    const node = this.createNode(0);\n\n    // Populate unreachableWeakMapEdges.\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      if (distances[nodeOrdinal] !== noDistance) {\n        continue;\n      }\n      node.nodeIndex = nodeOrdinal * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (!edge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          unreachableWeakMapEdges.set(edge.nodeIndex(), match.duplicatedPart);\n        }\n      }\n    }\n\n    // Iterate the retaining edges for the target nodes found in the previous\n    // step and mark any relevant WeakMap edges as ignored.\n    for (const targetNodeIndex of unreachableWeakMapEdges.keys()) {\n      node.nodeIndex = targetNodeIndex;\n      for (let it = node.retainers(); it.hasNext(); it.next()) {\n        const reverseEdge = it.item();\n        if (!reverseEdge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(reverseEdge.nameIndex());\n        if (match && unreachableWeakMapEdges.hasValue(targetNodeIndex, match.duplicatedPart)) {\n          const forwardEdgeIndex = this.retainingEdges[reverseEdge.itemIndex()];\n          this.#ignoredEdgesInRetainersView.add(forwardEdgeIndex);\n        }\n      }\n    }\n  }\n\n  areNodesIgnoredInRetainersView(): boolean {\n    return this.#ignoredNodesInRetainersView.size > 0;\n  }\n\n  getDistanceForRetainersView(nodeIndex: number): number {\n    const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n    const distances = this.#nodeDistancesForRetainersView ?? this.nodeDistances;\n    const distance = distances[nodeOrdinal];\n    if (distance === this.#noDistance) {\n      // An unreachable node should be sorted to the end, not the beginning.\n      // To give such nodes a reasonable sorting order, we add a very large\n      // number to the original distance computed without ignoring any nodes.\n      return Math.max(0, this.nodeDistances[nodeOrdinal]) + HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return distance;\n  }\n\n  isNodeIgnoredInRetainersView(nodeIndex: number): boolean {\n    return this.#ignoredNodesInRetainersView.has(nodeIndex);\n  }\n\n  isEdgeIgnoredInRetainersView(edgeIndex: number): boolean {\n    return this.#ignoredEdgesInRetainersView.has(edgeIndex);\n  }\n}\n\ninterface HeapSnapshotMetaInfo {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  location_fields: string[];\n  node_fields: string[];\n  node_types: string[][];\n  edge_fields: string[];\n  edge_types: string[][];\n  trace_function_info_fields: string[];\n  trace_node_fields: string[];\n  sample_fields: string[];\n  type_strings: Record<string, string>;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface HeapSnapshotHeader {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  title: string;\n  meta: HeapSnapshotMetaInfo;\n  node_count: number;\n  edge_count: number;\n  trace_function_count: number;\n  root_index: number;\n  extra_native_bytes?: number;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  protected readonly iterator: HeapSnapshotItemIterator;\n  readonly #indexProvider: HeapSnapshotItemIndexProvider;\n  readonly #isEmpty: boolean;\n  protected iterationOrder: number[]|null;\n  protected currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  #sortedPrefixLength: number;\n  #sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this.iterator = iterator;\n    this.#indexProvider = indexProvider;\n    this.#isEmpty = !iterator.hasNext();\n    this.iterationOrder = null;\n    this.currentComparator = null;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  protected createIterationOrder(): void {\n    if (this.iterationOrder) {\n      return;\n    }\n    this.iterationOrder = [];\n    for (let iterator = this.iterator; iterator.hasNext(); iterator.next()) {\n      this.iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.#isEmpty;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this.createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this.iterationOrder.length) {\n      end = this.iterationOrder.length;\n    }\n    if (this.#sortedPrefixLength < end && begin < this.iterationOrder.length - this.#sortedSuffixLength &&\n        this.currentComparator) {\n      const currentComparator = this.currentComparator;\n      this.sort(\n          currentComparator, this.#sortedPrefixLength, this.iterationOrder.length - 1 - this.#sortedSuffixLength, begin,\n          end - 1);\n      if (begin <= this.#sortedPrefixLength) {\n        this.#sortedPrefixLength = end;\n      }\n      if (end >= this.iterationOrder.length - this.#sortedSuffixLength) {\n        this.#sortedSuffixLength = this.iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this.iterationOrder[position++];\n      const item = this.#indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this.iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this.currentComparator = comparator;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this.iterator.item() as HeapSnapshotEdge | HeapSnapshotRetainerEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      let result = 0;\n      if (fieldName === '!edgeName') {\n        if (edgeB.name() === '__proto__') {\n          return -1;\n        }\n        if (edgeA.name() === '__proto__') {\n          return 1;\n        }\n        result = edgeA.hasStringName() === edgeB.hasStringName() ?\n            (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n            (edgeA.hasStringName() ? -1 : 1);\n      } else {\n        result = edgeA.getValueForSorting(fieldName) - edgeB.getValueForSorting(fieldName);\n      }\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndEdge(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    function isEdgeFieldName(fieldName: string): boolean {\n      return fieldName.startsWith('!edge');\n    }\n\n    if (isEdgeFieldName(fieldName1)) {\n      if (isEdgeFieldName(fieldName2)) {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n      } else {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n      }\n    } else if (isEdgeFieldName(fieldName2)) {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this.createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this.iterationOrder.length; i++) {\n      node.nodeIndex = this.iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this.iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this.iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this.currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this.buildCompareFunction(currentComparator);\n    for (let i = 0; i < this.iterationOrder.length; i++) {\n      if (compare(this.iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  private buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    function sortByNodeField(fieldAccessor: () => void, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this.iterationOrder, this.buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  readonly nodeFlags: {\n    // bit flags in 8-bit value\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  private flags!: Uint8Array;\n  #statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    super(profile, progress);\n    this.nodeFlags = {\n      // bit flags in 8-bit value\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  override containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  override retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  override calculateFlags(): void {\n    this.flags = new Uint8Array(this.nodeCount);\n    this.markDetachedDOMTreeNodes();\n    this.markQueriableHeapObjects();\n    this.markPageOwnedNodes();\n  }\n\n  #hasUserRoots(): boolean {\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (this.isUserRoot(iter.edge.node())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Updates the shallow sizes for \"owned\" objects of types kArray or kHidden to\n  // zero, and add their sizes to the \"owner\" object instead.\n  override calculateShallowSizes(): void {\n    // If there are no user roots, then that means the snapshot was produced with\n    // the \"expose internals\" option enabled. In that case, we should faithfully\n    // represent the actual memory allocations rather than attempting to make the\n    // output more understandable to web developers.\n    if (!this.#hasUserRoots()) {\n      return;\n    }\n\n    const {nodeCount, nodes, nodeFieldCount, nodeSelfSizeOffset} = this;\n\n    const kUnvisited = 0xffffffff;\n    const kHasMultipleOwners = 0xfffffffe;\n    if (nodeCount >= kHasMultipleOwners) {\n      throw new Error('Too many nodes for calculateShallowSizes');\n    }\n    // For each node in order, `owners` will contain the index of the owning\n    // node or one of the two values kUnvisited or kHasMultipleOwners. The\n    // indexes in this array are NOT already multiplied by nodeFieldCount.\n    const owners = new Uint32Array(nodeCount);\n    // The worklist contains the indexes of nodes which should be visited during\n    // the second loop below. The order of visiting doesn't matter. The indexes\n    // in this array are NOT already multiplied by nodeFieldCount.\n    const worklist: number[] = [];\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      if (node.isHidden() || node.isArray() || (node.isNative() && node.rawName() === 'system / ExternalStringData')) {\n        owners[i] = kUnvisited;\n      } else {\n        // The node owns itself.\n        owners[i] = i;\n        worklist.push(i);\n      }\n      node.nodeIndex = node.nextNodeIndex();\n    }\n\n    while (worklist.length !== 0) {\n      const id = worklist.pop() as number;\n      const owner = owners[id];\n      node.nodeIndex = id * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (edge.isWeak()) {\n          continue;\n        }\n        const targetId = edge.nodeIndex() / nodeFieldCount;\n        switch (owners[targetId]) {\n          case kUnvisited:\n            owners[targetId] = owner;\n            worklist.push(targetId);\n            break;\n          case targetId:\n          case owner:\n          case kHasMultipleOwners:\n            // There is no change necessary if the target is already marked as:\n            // * owned by itself,\n            // * owned by the owner of the current source node, or\n            // * owned by multiple nodes.\n            break;\n          default:\n            owners[targetId] = kHasMultipleOwners;\n            // It is possible that this node is already in the worklist\n            // somewhere, but visiting it an extra time is not harmful. The\n            // iteration is guaranteed to complete because each node can only be\n            // added twice to the worklist: once when changing from kUnvisited\n            // to a specific owner, and a second time when changing from that\n            // owner to kHasMultipleOwners.\n            worklist.push(targetId);\n            break;\n        }\n      }\n    }\n\n    for (let i = 0; i < nodeCount; ++i) {\n      const ownerId = owners[i];\n      switch (ownerId) {\n        case kUnvisited:\n        case kHasMultipleOwners:\n        case i:\n          break;\n        default: {\n          const ownedNodeIndex = i * nodeFieldCount;\n          const ownerNodeIndex = ownerId * nodeFieldCount;\n          node.nodeIndex = ownerNodeIndex;\n          if (node.isSynthetic() || node.isRoot()) {\n            // Adding shallow size to synthetic or root nodes is not useful.\n            break;\n          }\n          const sizeToTransfer = nodes.getValue(ownedNodeIndex + nodeSelfSizeOffset);\n          nodes.setValue(ownedNodeIndex + nodeSelfSizeOffset, 0);\n          nodes.setValue(\n              ownerNodeIndex + nodeSelfSizeOffset,\n              nodes.getValue(ownerNodeIndex + nodeSelfSizeOffset) + sizeToTransfer);\n          break;\n        }\n      }\n    }\n  }\n\n  override calculateDistances(isForRetainersView: boolean): void {\n    const pendingEphemeronEdges = new Set<string>();\n    const snapshot = this;\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden() && edge.name() === 'sloppy_function_map' && node.rawName() === 'system / NativeContext') {\n        return false;\n      }\n      if (node.isArray() && node.rawName() === '(map descriptors)') {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      if (edge.isInternal()) {\n        // Snapshots represent WeakMap values as being referenced by two edges:\n        // one from the WeakMap, and a second from the corresponding key. To\n        // avoid the case described in crbug.com/1290800, we should set the\n        // distance of that value to the greater of (WeakMap+1, key+1). This\n        // part of the filter skips the first edge in the matched pair of edges,\n        // so that the distance gets set based on the second, which should be\n        // greater or equal due to traversal order.\n        const match = snapshot.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          if (!pendingEphemeronEdges.delete(match.duplicatedPart)) {\n            pendingEphemeronEdges.add(match.duplicatedPart);\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    super.calculateDistances(isForRetainersView, filter);\n  }\n\n  override isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  override userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    return {map: this.flags, flag: this.nodeFlags.pageObject};\n  }\n\n  flagsOfNode(node: HeapSnapshotNode): number {\n    return this.flags[node.nodeIndex / this.nodeFieldCount];\n  }\n\n  private markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const flag = this.nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this.flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  private markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to inconsistent state of internal properties of wrappers.\n    const flag = this.nodeFlags.canBeQueried;\n    const hiddenEdgeType = this.edgeHiddenType;\n    const internalEdgeType = this.edgeInternalType;\n    const invisibleEdgeType = this.edgeInvisibleType;\n    const weakEdgeType = this.edgeWeakType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n\n    const flags = this.flags;\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  private markPageOwnedNodes(): void {\n    const edgeShortcutType = this.edgeShortcutType;\n    const edgeElementType = this.edgeElementType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeWeakType = this.edgeWeakType;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = this.flags;\n    const pageObjectFlag = this.nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      const nodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  override calculateStatistics(): void {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeSizeOffset = this.nodeSelfSizeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeCodeType = this.nodeCodeType;\n    const nodeConsStringType = this.nodeConsStringType;\n    const nodeSlicedStringType = this.nodeSlicedStringType;\n    const nodeHiddenType = this.nodeHiddenType;\n    const nodeStringType = this.nodeStringType;\n    let sizeNative = this.profile.snapshot.extra_native_bytes ?? 0;\n    let sizeTypedArrays = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes.getValue(nodeIndex + nodeSizeOffset);\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType === nodeHiddenType) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n        if (node.rawName() === 'system / JSArrayBufferData') {\n          sizeTypedArrays += nodeSize;\n        }\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || nodeType === nodeStringType) {\n        sizeStrings += nodeSize;\n      } else if (node.rawName() === 'Array') {\n        sizeJSArrays += this.calculateArraySize(node);\n      }\n    }\n    this.#statistics = {\n      total: this.totalSize,\n      native: {\n        total: sizeNative,\n        typedArrays: sizeTypedArrays,\n      },\n      v8heap: {\n        total: this.totalSize - sizeNative,\n        code: sizeCode,\n        jsArrays: sizeJSArrays,\n        strings: sizeStrings,\n        system: sizeSystem,\n      }\n    };\n  }\n\n  private calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeNameOffset = this.edgeNameOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeInternalType = this.edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges.getValue(edgeIndex + edgeNameOffset)];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return this.#statistics as HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\n// Creates and initializes a JSHeapSnapshot using only one thread.\nexport async function createJSHeapSnapshotForTesting(profile: Profile): Promise<JSHeapSnapshot> {\n  const result = new JSHeapSnapshot(profile, new HeapSnapshotProgress());\n  const channel = new MessageChannel();\n  new SecondaryInitManager(channel.port2);\n  await result.initialize(channel.port1);\n  return result;\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  canBeQueried(): boolean {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    return Boolean(flags & snapshot.nodeFlags.canBeQueried);\n  }\n\n  override name(): string {\n    const snapshot = this.snapshot;\n    if (this.rawType() === snapshot.nodeConsStringType) {\n      return this.consStringName();\n    }\n    if (this.rawType() === snapshot.nodeObjectType && this.rawName() === 'Object') {\n      return this.#plainObjectName();\n    }\n    return this.rawName();\n  }\n\n  private consStringName(): string {\n    const snapshot = this.snapshot;\n    const consStringType = snapshot.nodeConsStringType;\n    const edgeInternalType = snapshot.edgeInternalType;\n    const edgeFieldsCount = snapshot.edgeFieldsCount;\n    const edgeToNodeOffset = snapshot.edgeToNodeOffset;\n    const edgeTypeOffset = snapshot.edgeTypeOffset;\n    const edgeNameOffset = snapshot.edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot.firstEdgeIndexes;\n    const nodeFieldCount = snapshot.nodeFieldCount;\n    const nodeTypeOffset = snapshot.nodeTypeOffset;\n    const nodeNameOffset = snapshot.nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes.getValue(nodeIndex + nodeTypeOffset) !== consStringType) {\n        name += strings[nodes.getValue(nodeIndex + nodeNameOffset)];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges.getValue(edgeIndex + edgeNameOffset)];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  // Creates a name for plain JS objects, which looks something like\n  // '{propName, otherProp, thirdProp, ..., secondToLastProp, lastProp}'.\n  // A variable number of property names is included, depending on the length\n  // of the property names, so that the result fits nicely in a reasonably\n  // sized DevTools window.\n  #plainObjectName(): string {\n    const snapshot = this.snapshot;\n    const {edgeFieldsCount, edgePropertyType} = snapshot;\n    const edge = snapshot.createEdge(0);\n    let categoryNameStart = '{';\n    let categoryNameEnd = '}';\n    let edgeIndexFromStart = this.edgeIndexesStart();\n    let edgeIndexFromEnd = this.edgeIndexesEnd() - edgeFieldsCount;\n    let nextFromEnd = false;\n    while (edgeIndexFromStart <= edgeIndexFromEnd) {\n      edge.edgeIndex = nextFromEnd ? edgeIndexFromEnd : edgeIndexFromStart;\n\n      // Skip non-property edges and the special __proto__ property.\n      if (edge.rawType() !== edgePropertyType || edge.name() === '__proto__') {\n        if (nextFromEnd) {\n          edgeIndexFromEnd -= edgeFieldsCount;\n        } else {\n          edgeIndexFromStart += edgeFieldsCount;\n        }\n        continue;\n      }\n\n      const formatted = JSHeapSnapshotNode.formatPropertyName(edge.name());\n\n      // Always include at least one property, regardless of its length. Beyond that point,\n      // only include more properties if the name isn't too long.\n      if (categoryNameStart.length > 1 && categoryNameStart.length + categoryNameEnd.length + formatted.length > 100) {\n        break;\n      }\n\n      if (nextFromEnd) {\n        edgeIndexFromEnd -= edgeFieldsCount;\n        if (categoryNameEnd.length > 1) {\n          categoryNameEnd = ', ' + categoryNameEnd;\n        }\n        categoryNameEnd = formatted + categoryNameEnd;\n      } else {\n        edgeIndexFromStart += edgeFieldsCount;\n        if (categoryNameStart.length > 1) {\n          categoryNameStart += ', ';\n        }\n        categoryNameStart += formatted;\n      }\n      nextFromEnd = !nextFromEnd;\n    }\n    if (edgeIndexFromStart <= edgeIndexFromEnd) {\n      categoryNameStart += ', …';\n    }\n    if (categoryNameEnd.length > 1) {\n      categoryNameStart += ', ';\n    }\n    return categoryNameStart + categoryNameEnd;\n  }\n\n  static formatPropertyName(name: string): string {\n    // We don't need a strict test for whether a property name follows the\n    // rules for being a JS identifier, but property names containing commas,\n    // quotation marks, or braces could cause confusion, so we'll escape those.\n    if (/[,'\"{}]/.test(name)) {\n      name = JSON.stringify({[name]: 0});\n      name = name.substring(1, name.length - 3);\n    }\n    return name;\n  }\n\n  override id(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeIdOffset);\n  }\n\n  override isHidden(): boolean {\n    return this.rawType() === this.snapshot.nodeHiddenType;\n  }\n\n  override isArray(): boolean {\n    return this.rawType() === this.snapshot.nodeArrayType;\n  }\n\n  override isSynthetic(): boolean {\n    return this.rawType() === this.snapshot.nodeSyntheticType;\n  }\n\n  isNative(): boolean {\n    return this.rawType() === this.snapshot.nodeNativeType;\n  }\n\n  override isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  override isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.rawName() === '(Document DOM trees)';\n  }\n\n  override serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    if (flags & snapshot.nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot.nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  override clone(): JSHeapSnapshotEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  override hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this.#hasStringName();\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    return isNaN(parseInt(this.#name(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this.snapshot.edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.edgeHiddenType;\n  }\n\n  override isWeak(): boolean {\n    return this.rawType() === this.snapshot.edgeWeakType;\n  }\n\n  override isInternal(): boolean {\n    return this.rawType() === this.snapshot.edgeInternalType;\n  }\n\n  override isInvisible(): boolean {\n    return this.rawType() === this.snapshot.edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this.snapshot.edgeShortcutType;\n  }\n\n  override name(): string {\n    const name = this.#name();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  override toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  #hasStringName(): boolean {\n    const type = this.rawType();\n    const snapshot = this.snapshot;\n    return type !== snapshot.edgeElementType && type !== snapshot.edgeHiddenType;\n  }\n\n  #name(): string|number {\n    return this.#hasStringName() ? this.snapshot.strings[this.nameOrIndex()] : this.nameOrIndex();\n  }\n\n  private nameOrIndex(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeNameOffset);\n  }\n\n  override rawType(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  override nameIndex(): number {\n    if (!this.#hasStringName()) {\n      throw new Error('Edge does not have string name');\n    }\n    return this.nameOrIndex();\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  override clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this.edge().isHidden();\n  }\n\n  isInvisible(): boolean {\n    return this.edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this.edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this.edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string;\n  idxs: number[];\n}\n", "// Copyright 2012 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\n\nimport {type HeapSnapshotHeader, HeapSnapshotProgress, JSHeapSnapshot, type Profile} from './HeapSnapshot.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport class HeapSnapshotLoader {\n  readonly #progress: HeapSnapshotProgress;\n  #buffer: string[];\n  #dataCallback: ((value: string|PromiseLike<string>) => void)|null;\n  #done: boolean;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #snapshot?: Record<string, any>;\n  #array!: Platform.TypedArrayUtilities.BigUint32Array|null;\n  #arrayIndex!: number;\n  #json = '';\n  parsingComplete: Promise<void>;\n  constructor(dispatcher: HeapSnapshotWorkerDispatcher) {\n    this.#reset();\n    this.#progress = new HeapSnapshotProgress(dispatcher);\n    this.#buffer = [];\n    this.#dataCallback = null;\n    this.#done = false;\n    this.parsingComplete = this.#parseInput();\n  }\n\n  dispose(): void {\n    this.#reset();\n  }\n\n  #reset(): void {\n    this.#json = '';\n    this.#snapshot = undefined;\n  }\n\n  close(): void {\n    this.#done = true;\n    if (this.#dataCallback) {\n      this.#dataCallback('');\n    }\n  }\n\n  async buildSnapshot(secondWorker: MessagePort): Promise<JSHeapSnapshot> {\n    this.#snapshot = this.#snapshot || {};\n\n    this.#progress.updateStatus('Processing snapshot…');\n    const result = new JSHeapSnapshot((this.#snapshot as Profile), this.#progress);\n    await result.initialize(secondWorker);\n    this.#reset();\n    return result;\n  }\n\n  #parseUintArray(): boolean {\n    let index = 0;\n    const char0 = '0'.charCodeAt(0);\n    const char9 = '9'.charCodeAt(0);\n    const closingBracket = ']'.charCodeAt(0);\n    const length = this.#json.length;\n    while (true) {\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 <= code && code <= char9) {\n          break;\n        } else if (code === closingBracket) {\n          this.#json = this.#json.slice(index + 1);\n          return false;\n        }\n        ++index;\n      }\n      if (index === length) {\n        this.#json = '';\n        return true;\n      }\n      let nextNumber = 0;\n      const startIndex = index;\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 > code || code > char9) {\n          break;\n        }\n        nextNumber *= 10;\n        nextNumber += (code - char0);\n        ++index;\n      }\n      if (index === length) {\n        this.#json = this.#json.slice(startIndex);\n        return true;\n      }\n      if (!this.#array) {\n        throw new Error('Array not instantiated');\n      }\n      this.#array.setValue(this.#arrayIndex++, nextNumber);\n    }\n  }\n\n  #parseStringsArray(): void {\n    this.#progress.updateStatus('Parsing strings…');\n    const closingBracketIndex = this.#json.lastIndexOf(']');\n    if (closingBracketIndex === -1) {\n      throw new Error('Incomplete JSON');\n    }\n    this.#json = this.#json.slice(0, closingBracketIndex + 1);\n\n    if (!this.#snapshot) {\n      throw new Error('No snapshot in parseStringsArray');\n    }\n    this.#snapshot.strings = JSON.parse(this.#json);\n  }\n\n  write(chunk: string): void {\n    this.#buffer.push(chunk);\n    if (!this.#dataCallback) {\n      return;\n    }\n    this.#dataCallback(this.#buffer.shift() as string);\n    this.#dataCallback = null;\n  }\n\n  #fetchChunk(): Promise<string> {\n    // This method shoudln't be entered more than once since parsing happens\n    // sequentially. This means it's fine to stash away a single #dataCallback\n    // instead of an array of them.\n    if (this.#buffer.length > 0) {\n      return Promise.resolve(this.#buffer.shift() as string);\n    }\n\n    const {promise, resolve} = Promise.withResolvers<string>();\n    this.#dataCallback = resolve;\n    return promise;\n  }\n\n  async #findToken(token: string, startIndex?: number): Promise<number> {\n    while (true) {\n      const pos = this.#json.indexOf(token, startIndex || 0);\n      if (pos !== -1) {\n        return pos;\n      }\n      startIndex = this.#json.length - token.length + 1;\n      this.#json += await this.#fetchChunk();\n    }\n  }\n\n  async #parseArray(name: string, title: string, length?: number):\n      Promise<Platform.TypedArrayUtilities.BigUint32Array> {\n    const nameIndex = await this.#findToken(name);\n    const bracketIndex = await this.#findToken('[', nameIndex);\n    this.#json = this.#json.slice(bracketIndex + 1);\n    this.#array = length === undefined ? Platform.TypedArrayUtilities.createExpandableBigUint32Array() :\n                                         Platform.TypedArrayUtilities.createFixedBigUint32Array(length);\n    this.#arrayIndex = 0;\n    while (this.#parseUintArray()) {\n      if (length) {\n        this.#progress.updateProgress(title, this.#arrayIndex, this.#array.length);\n      } else {\n        this.#progress.updateStatus(title);\n      }\n      this.#json += await this.#fetchChunk();\n    }\n    const result = this.#array;\n    this.#array = null;\n    return result;\n  }\n\n  async #parseInput(): Promise<void> {\n    const snapshotToken = '\"snapshot\"';\n    const snapshotTokenIndex = await this.#findToken(snapshotToken);\n    if (snapshotTokenIndex === -1) {\n      throw new Error('Snapshot token not found');\n    }\n\n    this.#progress.updateStatus('Loading snapshot info…');\n    const json = this.#json.slice(snapshotTokenIndex + snapshotToken.length + 1);\n    let jsonTokenizerDone = false;\n    const jsonTokenizer = new TextUtils.TextUtils.BalancedJSONTokenizer(metaJSON => {\n      this.#json = jsonTokenizer.remainder();\n      jsonTokenizerDone = true;\n\n      this.#snapshot = this.#snapshot || {};\n      this.#snapshot.snapshot = (JSON.parse(metaJSON) as HeapSnapshotHeader);\n    });\n    jsonTokenizer.write(json);\n    while (!jsonTokenizerDone) {\n      jsonTokenizer.write(await this.#fetchChunk());\n    }\n\n    this.#snapshot = this.#snapshot || {};\n    const nodes = await this.#parseArray(\n        '\"nodes\"', 'Loading nodes… {PH1}%',\n        this.#snapshot.snapshot.meta.node_fields.length * this.#snapshot.snapshot.node_count);\n    this.#snapshot.nodes = nodes;\n\n    const edges = await this.#parseArray(\n        '\"edges\"', 'Loading edges… {PH1}%',\n        this.#snapshot.snapshot.meta.edge_fields.length * this.#snapshot.snapshot.edge_count);\n    this.#snapshot.edges = edges;\n\n    if (this.#snapshot.snapshot.trace_function_count) {\n      const traceFunctionInfos = await this.#parseArray(\n          '\"trace_function_infos\"', 'Loading allocation traces… {PH1}%',\n          this.#snapshot.snapshot.meta.trace_function_info_fields.length *\n              this.#snapshot.snapshot.trace_function_count);\n      this.#snapshot.trace_function_infos = traceFunctionInfos.asUint32ArrayOrFail();\n\n      const thisTokenEndIndex = await this.#findToken(':');\n      const nextTokenIndex = await this.#findToken('\"', thisTokenEndIndex);\n      const openBracketIndex = this.#json.indexOf('[');\n      const closeBracketIndex = this.#json.lastIndexOf(']', nextTokenIndex);\n      this.#snapshot.trace_tree = JSON.parse(this.#json.substring(openBracketIndex, closeBracketIndex + 1));\n      this.#json = this.#json.slice(closeBracketIndex + 1);\n    }\n\n    if (this.#snapshot.snapshot.meta.sample_fields) {\n      const samples = await this.#parseArray('\"samples\"', 'Loading samples…');\n      this.#snapshot.samples = samples.asArrayOrFail();\n    }\n\n    if (this.#snapshot.snapshot.meta['location_fields']) {\n      const locations = await this.#parseArray('\"locations\"', 'Loading locations…');\n      this.#snapshot.locations = locations.asArrayOrFail();\n    } else {\n      this.#snapshot.locations = [];\n    }\n\n    this.#progress.updateStatus('Loading strings…');\n    const stringsTokenIndex = await this.#findToken('\"strings\"');\n    const bracketIndex = await this.#findToken('[', stringsTokenIndex);\n    this.#json = this.#json.slice(bracketIndex);\n    while (this.#buffer.length > 0 || !this.#done) {\n      this.#json += await this.#fetchChunk();\n    }\n    this.#parseStringsArray();\n  }\n}\n", "// Copyright 2011 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\n// We mirror what heap_snapshot_worker.ts does, but we can't use it here as we'd have a\n// cyclic GN dependency otherwise.\n\nimport * as AllocationProfile from './AllocationProfile.js';\nimport * as HeapSnapshot from './HeapSnapshot.js';\nimport * as HeapSnapshotLoader from './HeapSnapshotLoader.js';\n\ninterface DispatcherResponse {\n  callId?: number;\n  result: unknown;\n  error?: string;\n  errorCallStack?: Object;\n  errorMethodName?: string;\n}\n\nexport class HeapSnapshotWorkerDispatcher {\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #objects: any[];\n  readonly #postMessage: typeof Window.prototype.postMessage;\n  constructor(postMessage: typeof Window.prototype.postMessage) {\n    this.#objects = [];\n    this.#postMessage = postMessage;\n  }\n\n  sendEvent(name: string, data: unknown): void {\n    this.#postMessage({eventName: name, data});\n  }\n\n  async dispatchMessage({data, ports}:\n                            {data: HeapSnapshotModel.HeapSnapshotModel.WorkerCommand, ports: readonly MessagePort[]}):\n      Promise<void> {\n    const response: DispatcherResponse =\n        {callId: data.callId, result: null, error: undefined, errorCallStack: undefined, errorMethodName: undefined};\n    try {\n      switch (data.disposition) {\n        case 'createLoader':\n          this.#objects[data.objectId] = new HeapSnapshotLoader.HeapSnapshotLoader(this);\n          break;\n        case 'dispose': {\n          delete this.#objects[data.objectId];\n          break;\n        }\n        case 'getter': {\n          const object = this.#objects[data.objectId];\n          const result = object[data.methodName];\n          response.result = result;\n          break;\n        }\n        case 'factory': {\n          const object = this.#objects[data.objectId];\n          const args = data.methodArguments.slice();\n          args.push(...ports);\n          const result = await object[data.methodName].apply(object, args);\n          if (result) {\n            this.#objects[data.newObjectId] = result;\n          }\n          response.result = Boolean(result);\n          break;\n        }\n        case 'method': {\n          const object = this.#objects[data.objectId];\n          response.result = object[data.methodName].apply(object, data.methodArguments);\n          break;\n        }\n        case 'evaluateForTest': {\n          try {\n            // Make 'HeapSnapshotWorker' and 'HeapSnapshotModel' available to web tests. 'eval' can't use 'import'.\n            // @ts-expect-error\n            globalThis.HeapSnapshotWorker = {\n              AllocationProfile,\n              HeapSnapshot,\n              HeapSnapshotLoader,\n            };\n            // @ts-expect-error\n            globalThis.HeapSnapshotModel = HeapSnapshotModel;\n            response.result = await self.eval(data.source);\n          } catch (error) {\n            response.result = error.toString();\n          }\n          break;\n        }\n        case 'setupForSecondaryInit': {\n          this.#objects[data.objectId] = new HeapSnapshot.SecondaryInitManager(ports[0]);\n        }\n      }\n    } catch (error) {\n      response.error = error.toString();\n      response.errorCallStack = error.stack;\n      if (data.methodName) {\n        response.errorMethodName = data.methodName;\n      }\n    }\n    this.#postMessage(response);\n  }\n}\n"],
  "mappings": "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",
  "names": ["HeapSnapshotModel", "resultsFromSecondWorker", "node", "i", "Platform", "HeapSnapshotModel", "HeapSnapshotModel"]
}
