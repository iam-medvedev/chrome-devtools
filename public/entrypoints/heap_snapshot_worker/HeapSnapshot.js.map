{"version":3,"file":"HeapSnapshot.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/prefer-private-class-members */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  protected readonly edges: Platform.TypedArrayUtilities.BigUint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this.snapshot = snapshot;\n    this.edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this.snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this.snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this.snapshot.edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeToNodeOffset);\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this.snapshot.edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this.snapshot.edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  isInternal(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  getValueForSorting(_fieldName: string): number {\n    throw new Error('Not implemented');\n  }\n\n  nameIndex(): number {\n    throw new Error('Not implemented');\n  }\n}\n\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this.#node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this.#node.nodeIndex = index;\n    return this.#node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this.#edge.edgeIndex = index;\n    return this.#edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  readonly #retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this.#retainerEdge.setRetainerIndex(index);\n    return this.#retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this.#sourceNode = node;\n    this.edge = node.snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this.#sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge.snapshot.edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge.snapshot.edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  protected snapshot: HeapSnapshot;\n  #retainerIndexInternal!: number;\n  #globalEdgeIndex!: number;\n  #retainingNodeIndex?: number;\n  #edgeInstance?: JSHeapSnapshotEdge|null;\n  #nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this.snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this.snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this.edge().hasStringName();\n  }\n\n  name(): string {\n    return this.edge().name();\n  }\n\n  nameIndex(): number {\n    return this.edge().nameIndex();\n  }\n\n  node(): HeapSnapshotNode {\n    return this.nodeInternal();\n  }\n\n  nodeIndex(): number {\n    if (typeof this.#retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this.#retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this.#retainerIndexInternal) {\n      return;\n    }\n\n    if (!this.snapshot.retainingEdges || !this.snapshot.retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this.#retainerIndexInternal = retainerIndex;\n    this.#globalEdgeIndex = this.snapshot.retainingEdges[retainerIndex];\n    this.#retainingNodeIndex = this.snapshot.retainingNodes[retainerIndex];\n    this.#edgeInstance = null;\n    this.#nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  private nodeInternal(): HeapSnapshotNode {\n    if (!this.#nodeInstance) {\n      this.#nodeInstance = this.snapshot.createNode(this.#retainingNodeIndex);\n    }\n    return this.#nodeInstance;\n  }\n\n  protected edge(): JSHeapSnapshotEdge {\n    if (!this.#edgeInstance) {\n      this.#edgeInstance = this.snapshot.createEdge(this.#globalEdgeIndex);\n    }\n    return this.#edgeInstance;\n  }\n\n  toString(): string {\n    return this.edge().toString();\n  }\n\n  itemIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    const node = this.node();\n    const serializedNode = node.serialize();\n    serializedNode.distance = this.#distance();\n    serializedNode.ignored = this.snapshot.isNodeIgnoredInRetainersView(node.nodeIndex);\n\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), serializedNode, this.type(), this.#globalEdgeIndex);\n  }\n\n  type(): string {\n    return this.edge().type();\n  }\n\n  isInternal(): boolean {\n    return this.edge().isInternal();\n  }\n\n  getValueForSorting(fieldName: string): number {\n    if (fieldName === '!edgeDistance') {\n      return this.#distance();\n    }\n    throw new Error('Invalid field name');\n  }\n\n  #distance(): number {\n    if (this.snapshot.isEdgeIgnoredInRetainersView(this.#globalEdgeIndex)) {\n      return HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return this.node().distanceForRetainersView();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode.snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot.firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot.firstRetainerIndex[retainedNodeOrdinal];\n    this.#retainersEnd = snapshot.firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this.#retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this.snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this.snapshot.nodeDistances[this.nodeIndex / this.snapshot.nodeFieldCount];\n  }\n\n  distanceForRetainersView(): number {\n    return this.snapshot.getDistanceForRetainersView(this.nodeIndex);\n  }\n\n  className(): string {\n    return this.snapshot.strings[this.classIndex()];\n  }\n\n  classIndex(): number {\n    return this.#detachednessAndClassIndex() >>> SHIFT_FOR_CLASS_INDEX;\n  }\n\n  // Returns a key which can uniquely describe both the class name for this node\n  // and its Location, if relevant. These keys are meant to be cheap to produce,\n  // so that building aggregates is fast. These keys are NOT the same as the\n  // keys exposed to the frontend by functions such as aggregatesWithFilter and\n  // aggregatesForDiff.\n  classKeyInternal(): string|number {\n    // It is common for multiple JavaScript constructors to have the same\n    // name, so the class key includes the location if available for nodes of\n    // type 'object'.\n    //\n    // JavaScript Functions (node type 'closure') also have locations, but it\n    // would not be helpful to split them into categories by location because\n    // many of those categories would have only one instance.\n    if (this.rawType() !== this.snapshot.nodeObjectType) {\n      return this.classIndex();\n    }\n    const location = this.snapshot.getLocation(this.nodeIndex);\n    return location ? `${location.scriptId},${location.lineNumber},${location.columnNumber},${this.className()}` :\n                      this.classIndex();\n  }\n\n  setClassIndex(index: number): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= BITMASK_FOR_DOM_LINK_STATE;        // Clear previous class index.\n    value |= (index << SHIFT_FOR_CLASS_INDEX);  // Set new class index.\n    this.#setDetachednessAndClassIndex(value);\n    if (this.classIndex() !== index) {\n      throw new Error('String index overflow');\n    }\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this.snapshot.nodeFieldCount;\n    return this.snapshot.dominatorsTree[this.nodeIndex / this.snapshot.nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this.snapshot.edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    return this.snapshot.strings[this.rawNameIndex()];\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this.snapshot.rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isSynthetic(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this.rawName();\n  }\n\n  retainedSize(): number {\n    return this.snapshot.retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this.snapshot;\n    const ordinal = this.ordinal();\n    return snapshot.firstRetainerIndex[ordinal + 1] - snapshot.firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeSelfSizeOffset);\n  }\n\n  type(): string {\n    return this.snapshot.nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTraceNodeIdOffset);\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  rawNameIndex(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeNameOffset);\n  }\n\n  edgeIndexesStart(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this.snapshot.nodeFieldCount;\n  }\n\n  nextNodeIndex(): number {\n    return this.nodeIndex + this.snapshot.nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTypeOffset);\n  }\n\n  isFlatConsString(): boolean {\n    if (this.rawType() !== this.snapshot.nodeConsStringType) {\n      return false;\n    }\n    for (let iter = this.edges(); iter.hasNext(); iter.next()) {\n      const edge = iter.edge;\n      if (!edge.isInternal()) {\n        continue;\n      }\n      const edgeName = edge.name();\n      if ((edgeName === 'first' || edgeName === 'second') && edge.node().name() === '') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  #detachednessAndClassIndex(): number {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    return nodeDetachednessAndClassIndexOffset !== -1 ?\n        snapshot.nodes.getValue(nodeIndex + nodeDetachednessAndClassIndexOffset) :\n        (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount];\n  }\n\n  #setDetachednessAndClassIndex(value: number): void {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    if (nodeDetachednessAndClassIndexOffset !== -1) {\n      snapshot.nodes.setValue(nodeIndex + nodeDetachednessAndClassIndexOffset, value);\n    } else {\n      (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount] = value;\n    }\n  }\n\n  detachedness(): DOMLinkState {\n    return this.#detachednessAndClassIndex() & BITMASK_FOR_DOM_LINK_STATE;\n  }\n\n  setDetachedness(detachedness: DOMLinkState): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= ~BITMASK_FOR_DOM_LINK_STATE;  // Clear the old bits.\n    value |= detachedness;                 // Set the new bits.\n    this.#setDetachednessAndClassIndex(value);\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  readonly #nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this.#nodesLength = node.snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this.#nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node.nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  readonly #itemProvider: HeapSnapshotItemIndexProvider;\n  readonly #indexes: number[]|Uint32Array;\n  #position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this.#itemProvider = itemProvider;\n    this.#indexes = indexes;\n    this.#position = 0;\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this.#indexes[this.#position];\n    return this.#itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this.#position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  #iterator: HeapSnapshotItemIterator;\n  #filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this.#iterator = iterator;\n    this.#filter = filter;\n    this.skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this.#iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this.#iterator.item();\n  }\n\n  next(): void {\n    this.#iterator.next();\n    this.skipFilteredItems();\n  }\n\n  private skipFilteredItems(): void {\n    while (this.#iterator.hasNext() && this.#filter && !this.#filter(this.#iterator.item())) {\n      this.#iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  readonly #dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this.#dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  private sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\n// An \"interface\" to be used when classifying plain JS objects in the snapshot.\n// An object matches the interface if it contains every listed property (even\n// if it also contains extra properties).\ninterface InterfaceDefinition {\n  name: string;\n  properties: string[];\n}\n\ntype HeapSnapshotProblemReport = Array<string|number>;\nfunction appendToProblemReport(report: HeapSnapshotProblemReport, messageOrNodeIndex: string|number): void {\n  if (report.length > 100) {\n    return;\n  }\n  report.push(messageOrNodeIndex);\n}\nfunction formatProblemReport(snapshot: HeapSnapshot, report: HeapSnapshotProblemReport): string {\n  const node = snapshot.rootNode();\n  return report\n      .map(messageOrNodeIndex => {\n        if (typeof messageOrNodeIndex === 'string') {\n          return messageOrNodeIndex;\n        }\n        node.nodeIndex = messageOrNodeIndex;\n        return `${node.name()} @${node.id()}`;\n      })\n      .join('\\n  ');\n}\nfunction reportProblemToPrimaryWorker(problemReport: HeapSnapshotProblemReport, port: MessagePort): void {\n  port.postMessage({problemReport});\n}\n\nexport interface Profile {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  root_index: number;\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  edges: Platform.TypedArrayUtilities.BigUint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  trace_function_infos: Uint32Array;\n  trace_tree: Object;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface LiveObjects {\n  [x: number]: {count: number, size: number, ids: number[]};\n}\n\n// The first batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep1 {\n  // For each edge ordinal, this array contains the ordinal of the pointed-to node.\n  edgeToNodeOrdinals: Uint32Array;\n  // A copy of HeapSnapshot.firstEdgeIndexes. For each node ordinal, this array\n  // contains the edge index of the first outgoing edge.\n  firstEdgeIndexes: Uint32Array;\n  nodeCount: number;\n  edgeFieldsCount: number;\n  nodeFieldCount: number;\n}\n\n// The second batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep2 {\n  rootNodeOrdinal: number;\n  // An array with one bit per edge, where each bit indicates whether the edge\n  // should be used when computing dominators.\n  essentialEdgesBuffer: ArrayBuffer;\n}\n\n// The third batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep3 {\n  // For each node ordinal, this array contains the node's shallow size.\n  nodeSelfSizes: Uint32Array;\n}\n\ntype ArgumentsToBuildRetainers = SecondaryInitArgumentsStep1;\n\ninterface Retainers {\n  // For each node ordinal, this array contains the index of the first retaining edge\n  // in the retainingEdges and retainingNodes arrays.\n  firstRetainerIndex: Uint32Array;\n  // For each retaining edge, this array contains the \"from\" node's index.\n  retainingNodes: Uint32Array;\n  // For each retaining edge, this array contains the index in containmentEdges\n  // where you can find other info about the edge, such as its type and name.\n  retainingEdges: Uint32Array;\n}\n\ninterface ArgumentsToComputeDominatorsAndRetainedSizes extends SecondaryInitArgumentsStep1, Retainers,\n                                                               SecondaryInitArgumentsStep2 {\n  // For each edge ordinal, this bit vector contains whether the edge\n  // should be used when computing dominators.\n  essentialEdges: Platform.TypedArrayUtilities.BitVector;\n  // A message port for reporting problems to the primary worker.\n  port: MessagePort;\n  // For each node ordinal, this array will contain the node's shallow size.\n  nodeSelfSizesPromise: Promise<Uint32Array>;\n}\n\ninterface DominatorsAndRetainedSizes {\n  // For each node ordinal, this array contains the ordinal of its immediate dominating node.\n  dominatorsTree: Uint32Array;\n  // For each node ordinal, this array contains the size of the subgraph it dominates, including its own size.\n  retainedSizes: Float64Array;\n}\n\ninterface ArgumentsToBuildDominatedNodes extends ArgumentsToComputeDominatorsAndRetainedSizes,\n                                                 DominatorsAndRetainedSizes {}\n\ninterface DominatedNodes {\n  // For each node ordinal, the index of its first child node in dominatedNodes.\n  // Together with dominatedNodes, this allows traversing down the dominators tree,\n  // whereas dominatorsTree allows upward traversal.\n  firstDominatedNodeIndex: Uint32Array;\n  // Node indexes of child nodes in the dominator tree.\n  dominatedNodes: Uint32Array;\n}\n\n// The data transferred from the secondary worker to the primary.\ninterface ResultsFromSecondWorker extends Retainers, DominatorsAndRetainedSizes, DominatedNodes {}\n\n// Initialization work is split into two threads. This class is the entry point\n// for work done by the second thread.\nexport class SecondaryInitManager {\n  argsStep1: Promise<SecondaryInitArgumentsStep1>;\n  argsStep2: Promise<SecondaryInitArgumentsStep2>;\n  argsStep3: Promise<SecondaryInitArgumentsStep3>;\n  constructor(port: MessagePort) {\n    const {promise: argsStep1, resolve: resolveArgsStep1} = Promise.withResolvers<SecondaryInitArgumentsStep1>();\n    this.argsStep1 = argsStep1;\n    const {promise: argsStep2, resolve: resolveArgsStep2} = Promise.withResolvers<SecondaryInitArgumentsStep2>();\n    this.argsStep2 = argsStep2;\n    const {promise: argsStep3, resolve: resolveArgsStep3} = Promise.withResolvers<SecondaryInitArgumentsStep3>();\n    this.argsStep3 = argsStep3;\n    port.onmessage = e => {\n      const data = e.data;\n      switch (data.step) {\n        case 1:\n          resolveArgsStep1(data.args);\n          break;\n        case 2:\n          resolveArgsStep2(data.args);\n          break;\n        case 3:\n          resolveArgsStep3(data.args);\n          break;\n      }\n    };\n    void this.initialize(port);\n  }\n\n  private async getNodeSelfSizes(): Promise<Uint32Array> {\n    return (await this.argsStep3).nodeSelfSizes;\n  }\n\n  private async initialize(port: MessagePort): Promise<void> {\n    try {\n      const argsStep1 = await this.argsStep1;\n      const retainers = HeapSnapshot.buildRetainers(argsStep1);\n      const argsStep2 = await this.argsStep2;\n      const args = {\n        ...argsStep2,\n        ...argsStep1,\n        ...retainers,\n        essentialEdges: Platform.TypedArrayUtilities.createBitVector(argsStep2.essentialEdgesBuffer),\n        port,\n        nodeSelfSizesPromise: this.getNodeSelfSizes()\n      };\n      const dominatorsAndRetainedSizes = await HeapSnapshot.calculateDominatorsAndRetainedSizes(args);\n      const dominatedNodesOutputs = HeapSnapshot.buildDominatedNodes({...args, ...dominatorsAndRetainedSizes});\n      const results: ResultsFromSecondWorker = {\n        ...retainers,\n        ...dominatorsAndRetainedSizes,\n        ...dominatedNodesOutputs,\n      };\n      port.postMessage({resultsFromSecondWorker: results}, {\n        transfer: [\n          results.dominatorsTree.buffer,\n          results.firstRetainerIndex.buffer,\n          results.retainedSizes.buffer,\n          results.retainingEdges.buffer,\n          results.retainingNodes.buffer,\n          results.dominatedNodes.buffer,\n          results.firstDominatedNodeIndex.buffer,\n        ]\n      });\n    } catch (e) {\n      port.postMessage({error: e + '\\n' + e?.stack});\n    }\n  }\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  UNKNOWN = 0,\n  ATTACHED = 1,\n  DETACHED = 2,\n}\nconst BITMASK_FOR_DOM_LINK_STATE = 3;\n\n// The class index is stored in the upper 30 bits of the detachedness field.\nconst SHIFT_FOR_CLASS_INDEX = 2;\n\n// After this many properties, inferInterfaceDefinitions can stop adding more\n// properties to an interface definition if the name is getting too long.\nconst MIN_INTERFACE_PROPERTY_COUNT = 1;\n\n// The maximum length of an interface name produced by inferInterfaceDefinitions.\n// This limit can be exceeded if the first MIN_INTERFACE_PROPERTY_COUNT property\n// names are long.\nconst MAX_INTERFACE_NAME_LENGTH = 120;\n\n// Each interface definition produced by inferInterfaceDefinitions will match at\n// least this many objects. There's no point in defining interfaces which match\n// only a single object.\nconst MIN_OBJECT_COUNT_PER_INTERFACE = 2;\n\n// Each interface definition produced by inferInterfaceDefinitions should\n// match at least 1 out of 1000 Objects in the heap. Otherwise, we end up with a\n// long tail of unpopular interfaces that don't help analysis.\nconst MIN_OBJECT_PROPORTION_PER_INTERFACE = 1000;\n\nexport abstract class HeapSnapshot {\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  containmentEdges: Platform.TypedArrayUtilities.BigUint32Array;\n  readonly #metaNode: HeapSnapshotMetaInfo;\n  readonly #rawSamples: number[];\n  #samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null = null;\n  strings: string[];\n  readonly #locations: number[];\n  readonly #progress: HeapSnapshotProgress;\n  readonly #noDistance = -5;\n  rootNodeIndexInternal = 0;\n  #snapshotDiffs: {\n    [x: string]: {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    },\n  } = {};\n  #aggregatesForDiffInternal?: {\n    interfaceDefinitions: string,\n    aggregates: {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n    },\n  };\n  #aggregates: {\n    [x: string]: {\n      [x: string]: AggregatedInfo,\n    },\n  } = {};\n  #aggregatesSortedFlags: {\n    [x: string]: boolean,\n  } = {};\n  profile: Profile;\n  nodeTypeOffset!: number;\n  nodeNameOffset!: number;\n  nodeIdOffset!: number;\n  nodeSelfSizeOffset!: number;\n  #nodeEdgeCountOffset!: number;\n  nodeTraceNodeIdOffset!: number;\n  nodeFieldCount!: number;\n  nodeTypes!: string[];\n  nodeArrayType!: number;\n  nodeHiddenType!: number;\n  nodeObjectType!: number;\n  nodeNativeType!: number;\n  nodeStringType!: number;\n  nodeConsStringType!: number;\n  nodeSlicedStringType!: number;\n  nodeCodeType!: number;\n  nodeSyntheticType!: number;\n  nodeClosureType!: number;\n  nodeRegExpType!: number;\n  edgeFieldsCount!: number;\n  edgeTypeOffset!: number;\n  edgeNameOffset!: number;\n  edgeToNodeOffset!: number;\n  edgeTypes!: string[];\n  edgeElementType!: number;\n  edgeHiddenType!: number;\n  edgeInternalType!: number;\n  edgeShortcutType!: number;\n  edgeWeakType!: number;\n  edgeInvisibleType!: number;\n  edgePropertyType!: number;\n  #locationIndexOffset!: number;\n  #locationScriptIdOffset!: number;\n  #locationLineOffset!: number;\n  #locationColumnOffset!: number;\n  #locationFieldCount!: number;\n  nodeCount!: number;\n  #edgeCount!: number;\n  retainedSizes!: Float64Array;\n  firstEdgeIndexes!: Uint32Array;\n  retainingNodes!: Uint32Array;\n  retainingEdges!: Uint32Array;\n  firstRetainerIndex!: Uint32Array;\n  nodeDistances!: Int32Array;\n  firstDominatedNodeIndex!: Uint32Array;\n  dominatedNodes!: Uint32Array;\n  dominatorsTree!: Uint32Array;\n  #allocationProfile!: AllocationProfile;\n  nodeDetachednessAndClassIndexOffset!: number;\n  #locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  #ignoredNodesInRetainersView = new Set<number>();\n  #ignoredEdgesInRetainersView = new Set<number>();\n  #nodeDistancesForRetainersView: Int32Array|undefined;\n  #edgeNamesThatAreNotWeakMaps: Platform.TypedArrayUtilities.BitVector;\n  detachednessAndClassIndexArray?: Uint32Array;\n  #interfaceNames = new Map<string, number>();\n  #interfaceDefinitions?: InterfaceDefinition[];\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this.#metaNode = profile.snapshot.meta;\n    this.#rawSamples = profile.samples;\n    this.strings = profile.strings;\n    this.#locations = profile.locations;\n    this.#progress = progress;\n\n    if (profile.snapshot.root_index) {\n      this.rootNodeIndexInternal = profile.snapshot.root_index;\n    }\n\n    this.profile = profile;\n    this.#edgeNamesThatAreNotWeakMaps = Platform.TypedArrayUtilities.createBitVector(this.strings.length);\n  }\n\n  async initialize(secondWorker: MessagePort): Promise<void> {\n    const meta = this.#metaNode;\n\n    this.nodeTypeOffset = meta.node_fields.indexOf('type');\n    this.nodeNameOffset = meta.node_fields.indexOf('name');\n    this.nodeIdOffset = meta.node_fields.indexOf('id');\n    this.nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this.#nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this.nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this.nodeDetachednessAndClassIndexOffset = meta.node_fields.indexOf('detachedness');\n    this.nodeFieldCount = meta.node_fields.length;\n\n    this.nodeTypes = meta.node_types[this.nodeTypeOffset];\n    this.nodeArrayType = this.nodeTypes.indexOf('array');\n    this.nodeHiddenType = this.nodeTypes.indexOf('hidden');\n    this.nodeObjectType = this.nodeTypes.indexOf('object');\n    this.nodeNativeType = this.nodeTypes.indexOf('native');\n    this.nodeStringType = this.nodeTypes.indexOf('string');\n    this.nodeConsStringType = this.nodeTypes.indexOf('concatenated string');\n    this.nodeSlicedStringType = this.nodeTypes.indexOf('sliced string');\n    this.nodeCodeType = this.nodeTypes.indexOf('code');\n    this.nodeSyntheticType = this.nodeTypes.indexOf('synthetic');\n    this.nodeClosureType = this.nodeTypes.indexOf('closure');\n    this.nodeRegExpType = this.nodeTypes.indexOf('regexp');\n\n    this.edgeFieldsCount = meta.edge_fields.length;\n    this.edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this.edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this.edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this.edgeTypes = meta.edge_types[this.edgeTypeOffset];\n    this.edgeTypes.push('invisible');\n    this.edgeElementType = this.edgeTypes.indexOf('element');\n    this.edgeHiddenType = this.edgeTypes.indexOf('hidden');\n    this.edgeInternalType = this.edgeTypes.indexOf('internal');\n    this.edgeShortcutType = this.edgeTypes.indexOf('shortcut');\n    this.edgeWeakType = this.edgeTypes.indexOf('weak');\n    this.edgeInvisibleType = this.edgeTypes.indexOf('invisible');\n    this.edgePropertyType = this.edgeTypes.indexOf('property');\n\n    const locationFields = meta.location_fields || [];\n\n    this.#locationIndexOffset = locationFields.indexOf('object_index');\n    this.#locationScriptIdOffset = locationFields.indexOf('script_id');\n    this.#locationLineOffset = locationFields.indexOf('line');\n    this.#locationColumnOffset = locationFields.indexOf('column');\n    this.#locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this.nodeFieldCount;\n    this.#edgeCount = this.containmentEdges.length / this.edgeFieldsCount;\n\n    this.#progress.updateStatus('Building edge indexes');\n    this.firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this.buildEdgeIndexes();\n    this.#progress.updateStatus('Building retainers');\n    const resultsFromSecondWorker = this.startInitStep1InSecondThread(secondWorker);\n    this.#progress.updateStatus('Propagating DOM state');\n    this.propagateDOMState();\n    this.#progress.updateStatus('Calculating node flags');\n    this.calculateFlags();\n    this.#progress.updateStatus('Building dominated nodes');\n    this.startInitStep2InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating shallow sizes');\n    this.calculateShallowSizes();\n    this.#progress.updateStatus('Calculating retained sizes');\n    this.startInitStep3InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating distances');\n    this.nodeDistances = new Int32Array(this.nodeCount);\n    this.calculateDistances(/* isForRetainersView=*/ false);\n    this.#progress.updateStatus('Calculating object names');\n    this.calculateObjectNames();\n    this.applyInterfaceDefinitions(this.inferInterfaceDefinitions());\n    this.#progress.updateStatus('Calculating samples');\n    this.buildSamples();\n    this.#progress.updateStatus('Building locations');\n    this.buildLocationMap();\n    this.#progress.updateStatus('Calculating retained sizes');\n    await this.installResultsFromSecondThread(resultsFromSecondWorker);\n    this.#progress.updateStatus('Calculating statistics');\n    this.calculateStatistics();\n\n    if (this.profile.snapshot.trace_function_count) {\n      this.#progress.updateStatus('Building allocation statistics');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this.nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: LiveObjects = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this.#allocationProfile = new AllocationProfile(this.profile, liveObjects);\n    }\n\n    this.#progress.updateStatus('Finished processing.');\n  }\n\n  private startInitStep1InSecondThread(secondWorker: MessagePort): Promise<ResultsFromSecondWorker> {\n    const resultsFromSecondWorker = new Promise<ResultsFromSecondWorker>((resolve, reject) => {\n      secondWorker.onmessage = (event: MessageEvent) => {\n        const data = event.data;\n        if (data?.problemReport) {\n          const problemReport: HeapSnapshotProblemReport = data.problemReport;\n          console.warn(formatProblemReport(this, problemReport));\n        } else if (data?.resultsFromSecondWorker) {\n          const resultsFromSecondWorker: ResultsFromSecondWorker = data.resultsFromSecondWorker;\n          resolve(resultsFromSecondWorker);\n        } else if (data?.error) {\n          reject(data.error);\n        }\n      };\n    });\n    const edgeCount = this.#edgeCount;\n    const {containmentEdges, edgeToNodeOffset, edgeFieldsCount, nodeFieldCount} = this;\n    const edgeToNodeOrdinals = new Uint32Array(edgeCount);\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeIndex = containmentEdges.getValue(edgeOrdinal * edgeFieldsCount + edgeToNodeOffset);\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      edgeToNodeOrdinals[edgeOrdinal] = toNodeIndex / nodeFieldCount;\n    }\n    const args: SecondaryInitArgumentsStep1 = {\n      edgeToNodeOrdinals,\n      firstEdgeIndexes: this.firstEdgeIndexes,\n      nodeCount: this.nodeCount,\n      edgeFieldsCount: this.edgeFieldsCount,\n      nodeFieldCount: this.nodeFieldCount,\n    };\n    // Note that firstEdgeIndexes is not transferred; each thread needs its own copy.\n    secondWorker.postMessage({step: 1, args}, [edgeToNodeOrdinals.buffer]);\n    return resultsFromSecondWorker;\n  }\n\n  private startInitStep2InSecondThread(secondWorker: MessagePort): void {\n    const rootNodeOrdinal = this.rootNodeIndexInternal / this.nodeFieldCount;\n    const essentialEdges = this.initEssentialEdges();\n    const args: SecondaryInitArgumentsStep2 = {rootNodeOrdinal, essentialEdgesBuffer: essentialEdges.buffer};\n    secondWorker.postMessage({step: 2, args}, [essentialEdges.buffer]);\n  }\n\n  private startInitStep3InSecondThread(secondWorker: MessagePort): void {\n    const {nodes, nodeFieldCount, nodeSelfSizeOffset, nodeCount} = this;\n    const nodeSelfSizes = new Uint32Array(nodeCount);\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      nodeSelfSizes[nodeOrdinal] = nodes.getValue(nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset);\n    }\n    const args: SecondaryInitArgumentsStep3 = {nodeSelfSizes};\n    secondWorker.postMessage({step: 3, args}, [nodeSelfSizes.buffer]);\n  }\n\n  private async installResultsFromSecondThread(resultsFromSecondWorker: Promise<ResultsFromSecondWorker>):\n      Promise<void> {\n    const results = await resultsFromSecondWorker;\n    this.dominatedNodes = results.dominatedNodes;\n    this.dominatorsTree = results.dominatorsTree;\n    this.firstDominatedNodeIndex = results.firstDominatedNodeIndex;\n    this.firstRetainerIndex = results.firstRetainerIndex;\n    this.retainedSizes = results.retainedSizes;\n    this.retainingEdges = results.retainingEdges;\n    this.retainingNodes = results.retainingNodes;\n  }\n\n  private buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeEdgeCountOffset = this.#nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes.getValue(nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset) * edgeFieldsCount;\n    }\n  }\n\n  static buildRetainers(inputs: ArgumentsToBuildRetainers): Retainers {\n    const {edgeToNodeOrdinals, firstEdgeIndexes, nodeCount, edgeFieldsCount, nodeFieldCount} = inputs;\n    const edgeCount = edgeToNodeOrdinals.length;\n    const retainingNodes = new Uint32Array(edgeCount);\n    const retainingEdges = new Uint32Array(edgeCount);\n    const firstRetainerIndex = new Uint32Array(nodeCount + 1);\n\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeOrdinal = edgeToNodeOrdinals[edgeOrdinal];\n      ++firstRetainerIndex[toNodeOrdinal];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeOrdinal];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n\n    return {\n      retainingNodes,\n      retainingEdges,\n      firstRetainerIndex,\n    };\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  private allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this.rootNodeIndexInternal);\n  }\n\n  get rootNodeIndex(): number {\n    return this.rootNodeIndexInternal;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize() + (this.profile.snapshot.extra_native_bytes ?? 0);\n  }\n\n  private createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const {minNodeId, maxNodeId, allocationNodeId, filterName} = nodeFilter;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this.createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this.createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    } else if (filterName !== undefined) {\n      filter = this.createNamedFilter(filterName);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NamedFilter: ' + filterName;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp =\n        searchConfig.isRegex ? new RegExp(query) : Platform.StringUtilities.createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const useRegExp = searchConfig.isRegex || !searchConfig.caseSensitive;\n    const stringFilter = useRegExp ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    const filter = this.createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this.nodeNameOffset;\n    const nodeIdOffset = this.nodeIdOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (node.selfSize() === 0) {\n        // Nodes with size zero are omitted in the data grid, so avoid returning\n        // search results that can't be navigated to.\n        continue;\n      }\n      const name = node.name();\n      if (name === node.rawName()) {\n        // If the string displayed to the user matches the raw name from the\n        // snapshot, then we can use the Set computed above. This avoids\n        // repeated work when multiple nodes have the same name.\n        if (stringIndexes.has(nodes.getValue(nodeIndex + nodeNameOffset))) {\n          nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n        }\n        // If the node is displaying a customized name, then we must perform the\n        // full string search within that name here.\n      } else if (useRegExp ? regexp.test(name) : (name.indexOf(query) !== -1)) {\n        nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const filter = this.createFilter(nodeFilter);\n    // @ts-expect-error key is added in createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.getAggregatesByClassKey(false, key, filter);\n  }\n\n  private createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  private createAllocationStackFilter(bottomUpAllocationNodeId: number):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this.#allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this.#allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: {[x: number]: boolean} = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  private createNamedFilter(filterName: string): (node: HeapSnapshotNode) => boolean {\n    // Allocate an array with a single bit per node, which can be used by each\n    // specific filter implemented below.\n    const bitmap = Platform.TypedArrayUtilities.createBitVector(this.nodeCount);\n    const getBit = (node: HeapSnapshotNode): boolean => {\n      const ordinal = node.nodeIndex / this.nodeFieldCount;\n      return bitmap.getBit(ordinal);\n    };\n\n    // Traverses the graph in breadth-first order with the given filter, and\n    // sets the bit in `bitmap` for every visited node.\n    const traverse = (filter: (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => boolean): void => {\n      const distances = new Int32Array(this.nodeCount);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        distances[i] = this.#noDistance;\n      }\n      const nodesToVisit = new Uint32Array(this.nodeCount);\n      distances[this.rootNode().ordinal()] = 0;\n      nodesToVisit[0] = this.rootNode().nodeIndex;\n      const nodesToVisitLength = 1;\n      this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (distances[i] !== this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    const markUnreachableNodes = (): void => {\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (this.nodeDistances[i] === this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    switch (filterName) {\n      case 'objectsRetainedByDetachedDomNodes':\n        // Traverse the graph, avoiding detached nodes.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return edge.node().detachedness() !== DOMLinkState.DETACHED;\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'objectsRetainedByConsole':\n        // Traverse the graph, avoiding edges that represent globals owned by\n        // the DevTools console.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return !(node.isSynthetic() && edge.hasStringName() && edge.name().endsWith(' / DevTools console'));\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'duplicatedStrings': {\n        const stringToNodeIndexMap = new Map<string, number>();\n        const node = this.createNode(0);\n        for (let i = 0; i < this.nodeCount; ++i) {\n          node.nodeIndex = i * this.nodeFieldCount;\n          const rawType = node.rawType();\n          if (rawType === this.nodeStringType || rawType === this.nodeConsStringType) {\n            // Check whether the cons string is already \"flattened\", meaning\n            // that one of its two parts is the empty string. If so, we should\n            // skip it. We don't help anyone by reporting a flattened cons\n            // string as a duplicate with its own content, since V8 controls\n            // that behavior internally.\n            if (node.isFlatConsString()) {\n              continue;\n            }\n            const name = node.name();\n            const alreadyVisitedNodeIndex = stringToNodeIndexMap.get(name);\n            if (alreadyVisitedNodeIndex === undefined) {\n              stringToNodeIndexMap.set(name, node.nodeIndex);\n            } else {\n              bitmap.setBit(alreadyVisitedNodeIndex / this.nodeFieldCount);\n              bitmap.setBit(node.nodeIndex / this.nodeFieldCount);\n            }\n          }\n        }\n        return getBit;\n      }\n    }\n    throw new Error('Invalid filter name');\n  }\n\n  getAggregatesByClassKey(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    let aggregates: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate};\n    if (key && this.#aggregates[key]) {\n      aggregates = this.#aggregates[key];\n    } else {\n      const aggregatesMap = this.buildAggregates(filter);\n      this.calculateClassesRetainedSize(aggregatesMap, filter);\n\n      // In the two previous steps, we used class keys that were simple and\n      // could be produced quickly. For many objects, this meant using the index\n      // of the string containing its class name. However, string indices are\n      // not consistent across snapshots, and this aggregate data might end up\n      // being used in a comparison, so here we convert to a more durable format\n      // for class keys.\n      aggregates = Object.create(null);\n      for (const [classKey, aggregate] of aggregatesMap.entries()) {\n        const newKey = this.classKeyFromClassKeyInternal(classKey);\n        aggregates[newKey] = aggregate;\n      }\n      if (key) {\n        this.#aggregates[key] = aggregates;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this.#aggregatesSortedFlags[key])) {\n      this.sortAggregateIndexes(aggregates);\n      if (key) {\n        this.#aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregates as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n    };\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this.#allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this.#allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this.#allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(interfaceDefinitions: string): {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} {\n    if (this.#aggregatesForDiffInternal?.interfaceDefinitions === interfaceDefinitions) {\n      return this.#aggregatesForDiffInternal.aggregates;\n    }\n\n    // Temporarily apply the interface definitions from the other snapshot.\n    const originalInterfaceDefinitions = this.#interfaceDefinitions;\n    this.applyInterfaceDefinitions(JSON.parse(interfaceDefinitions) as InterfaceDefinition[]);\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    this.applyInterfaceDefinitions(originalInterfaceDefinitions ?? []);\n    const result: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} = {};\n\n    const node = this.createNode();\n    for (const classKey in aggregates) {\n      const aggregate = aggregates[classKey];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      result[classKey] = {name: node.className(), indexes, ids, selfSizes};\n    }\n\n    this.#aggregatesForDiffInternal = {interfaceDefinitions, aggregates: result};\n    return result;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateShallowSizes(): void {\n  }\n\n  calculateDistances(\n      isForRetainersView: boolean, filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n\n    if (isForRetainersView) {\n      const originalFilter = filter;\n      filter = (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n        return !this.#ignoredNodesInRetainersView.has(edge.nodeIndex()) &&\n            (!originalFilter || originalFilter(node, edge));\n      };\n      if (this.#nodeDistancesForRetainersView === undefined) {\n        this.#nodeDistancesForRetainersView = new Int32Array(nodeCount);\n      }\n    }\n\n    const distances = isForRetainersView ? (this.#nodeDistancesForRetainersView as Int32Array) : this.nodeDistances;\n    const noDistance = this.#noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  private bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this.edgeWeakType;\n    const noDistance = this.#noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  private buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)): Map<string|number, AggregatedInfo> {\n    const aggregates = new Map<string|number, AggregatedInfo>();\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const selfSizeOffset = this.nodeSelfSizeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this.nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes.getValue(nodeIndex + selfSizeOffset);\n      if (!selfSize) {\n        continue;\n      }\n      const classKey = node.classKeyInternal();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      let aggregate = aggregates.get(classKey);\n      if (!aggregate) {\n        aggregate = {\n          count: 1,\n          distance,\n          self: selfSize,\n          maxRet: 0,\n          name: node.className(),\n          idxs: [nodeIndex],\n        };\n        aggregates.set(classKey, aggregate);\n      } else {\n        aggregate.distance = Math.min(aggregate.distance, distance);\n        ++aggregate.count;\n        aggregate.self += selfSize;\n        aggregate.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (const aggregate of aggregates.values()) {\n      aggregate.idxs = aggregate.idxs.slice();\n    }\n\n    return aggregates;\n  }\n\n  private calculateClassesRetainedSize(\n      aggregates: Map<string|number, AggregatedInfo>, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this.rootNodeIndexInternal;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classKeys: Array<string|number> = [];\n\n    const seenClassKeys = new Map<string|number, boolean>();\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatedNodes = this.dominatedNodes;\n    const firstDominatedNodeIndex = this.firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classKey = node.classKeyInternal();\n      const seen = Boolean(seenClassKeys.get(classKey));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) && node.selfSize()) {\n        (aggregates.get(classKey) as AggregatedInfo).maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassKeys.set(classKey, true);\n          sizes.push(list.length);\n          classKeys.push(classKey);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classKey = (classKeys.pop() as string);\n        seenClassKeys.set(classKey, false);\n      }\n    }\n  }\n\n  private sortAggregateIndexes(aggregates: {[x: string]: AggregatedInfo}): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  tryParseWeakMapEdgeName(edgeNameIndex: number): {duplicatedPart: string, tableId: string}|undefined {\n    const previousResult = this.#edgeNamesThatAreNotWeakMaps.getBit(edgeNameIndex);\n    if (previousResult) {\n      return undefined;\n    }\n    const edgeName = this.strings[edgeNameIndex];\n    const ephemeronNameRegex =\n        /^\\d+(?<duplicatedPart> \\/ part of key \\(.*? @\\d+\\) -> value \\(.*? @\\d+\\) pair in WeakMap \\(table @(?<tableId>\\d+)\\))$/;\n    const match = edgeName.match(ephemeronNameRegex);\n    if (!match) {\n      this.#edgeNamesThatAreNotWeakMaps.setBit(edgeNameIndex);\n      return undefined;\n    }\n    return match.groups as {duplicatedPart: string, tableId: string};\n  }\n\n  private computeIsEssentialEdge(\n      nodeIndex: number, edgeIndex: number, userObjectsMapAndFlag: {map: Uint8Array, flag: number}|null): boolean {\n    const edgeType = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n\n    // Values in WeakMaps are retained by the key and table together. Removing\n    // either the key or the table would be sufficient to remove the edge from\n    // the other one, so we needn't use both of those edges when computing\n    // dominators. We've found that the edge from the key generally produces\n    // more useful results, so here we skip the edge from the table.\n    if (edgeType === this.edgeInternalType) {\n      const edgeNameIndex = this.containmentEdges.getValue(edgeIndex + this.edgeNameOffset);\n      const match = this.tryParseWeakMapEdgeName(edgeNameIndex);\n      if (match) {\n        const nodeId = this.nodes.getValue(nodeIndex + this.nodeIdOffset);\n        if (nodeId === parseInt(match.tableId, 10)) {\n          return false;\n        }\n      }\n    }\n\n    // Weak edges never retain anything.\n    if (edgeType === this.edgeWeakType) {\n      return false;\n    }\n\n    const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n    // Ignore self edges.\n    if (nodeIndex === childNodeIndex) {\n      return false;\n    }\n\n    if (nodeIndex !== this.rootNodeIndex) {\n      // Shortcuts at the root node have special meaning of marking user global objects.\n      if (edgeType === this.edgeShortcutType) {\n        return false;\n      }\n\n      const flags = userObjectsMapAndFlag ? userObjectsMapAndFlag.map : null;\n      const userObjectFlag = userObjectsMapAndFlag ? userObjectsMapAndFlag.flag : 0;\n      const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const nodeFlag = !flags || (flags[nodeOrdinal] & userObjectFlag);\n      const childNodeFlag = !flags || (flags[childNodeOrdinal] & userObjectFlag);\n      // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n      // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n      if (childNodeFlag && !nodeFlag) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Returns a bitmap indicating whether each edge should be considered when building the dominator tree.\n  private initEssentialEdges(): Platform.TypedArrayUtilities.BitVector {\n    const essentialEdges = Platform.TypedArrayUtilities.createBitVector(this.#edgeCount);\n    const {nodes, nodeFieldCount, edgeFieldsCount} = this;\n    const userObjectsMapAndFlag = this.userObjectsMapAndFlag();\n    const endNodeIndex = nodes.length;\n    const node = this.createNode(0);\n    for (let nodeIndex = 0; nodeIndex < endNodeIndex; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      const edgeIndexesEnd = node.edgeIndexesEnd();\n      for (let edgeIndex = node.edgeIndexesStart(); edgeIndex < edgeIndexesEnd; edgeIndex += edgeFieldsCount) {\n        if (this.computeIsEssentialEdge(nodeIndex, edgeIndex, userObjectsMapAndFlag)) {\n          essentialEdges.setBit(edgeIndex / edgeFieldsCount);\n        }\n      }\n    }\n    return essentialEdges;\n  }\n\n  static hasOnlyWeakRetainers(inputs: ArgumentsToComputeDominatorsAndRetainedSizes, nodeOrdinal: number): boolean {\n    const {retainingEdges, edgeFieldsCount, firstRetainerIndex, essentialEdges} = inputs;\n    const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      if (essentialEdges.getBit(retainerEdgeIndex / edgeFieldsCount)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm for building the dominator tree is from the paper:\n  // Thomas Lengauer and Robert Endre Tarjan. 1979. A fast algorithm for finding dominators in a flowgraph.\n  // ACM Trans. Program. Lang. Syst. 1, 1 (July 1979), 121141. https://doi.org/10.1145/357062.357071\n  static async calculateDominatorsAndRetainedSizes(inputs: ArgumentsToComputeDominatorsAndRetainedSizes):\n      Promise<DominatorsAndRetainedSizes> {\n    // Preload fields into local variables for better performance.\n    const {\n      nodeCount,\n      firstEdgeIndexes,\n      edgeFieldsCount,\n      nodeFieldCount,\n      firstRetainerIndex,\n      retainingEdges,\n      retainingNodes,\n      edgeToNodeOrdinals,\n      rootNodeOrdinal,\n      essentialEdges,\n      nodeSelfSizesPromise,\n      port\n    } = inputs;\n    function isEssentialEdge(edgeIndex: number): boolean {\n      return essentialEdges.getBit(edgeIndex / edgeFieldsCount);\n    }\n\n    // The Lengauer-Tarjan algorithm expects vectors to be numbered from 1 to n\n    // and uses 0 as an invalid value, so use 1-indexing for all the arrays.\n    // Convert between ordinals and vertex numbers by adding/subtracting 1.\n    const arrayLength = nodeCount + 1;\n    const parent = new Uint32Array(arrayLength);\n    const ancestor = new Uint32Array(arrayLength);\n    const vertex = new Uint32Array(arrayLength);\n    const label = new Uint32Array(arrayLength);\n    const semi = new Uint32Array(arrayLength);\n    const bucket = new Array<Set<number>>(arrayLength);\n    let n = 0;\n\n    // Iterative DFS since the recursive version can cause stack overflows.\n    // Use an array to keep track of the next edge index to be examined for each node.\n    const nextEdgeIndex = new Uint32Array(arrayLength);\n    const dfs = (root: number): void => {\n      const rootOrdinal = root - 1;\n      nextEdgeIndex[rootOrdinal] = firstEdgeIndexes[rootOrdinal];\n      let v = root;\n      while (v !== 0) {\n        // First process v if not done already.\n        if (semi[v] === 0) {\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n\n        // The next node to process is the first unprocessed successor w of v,\n        // or parent[v] if all of v's successors have already been processed.\n        let vNext = parent[v];\n        const vOrdinal = v - 1;\n        for (; nextEdgeIndex[vOrdinal] < firstEdgeIndexes[vOrdinal + 1]; nextEdgeIndex[vOrdinal] += edgeFieldsCount) {\n          const edgeIndex = nextEdgeIndex[vOrdinal];\n          if (!isEssentialEdge(edgeIndex)) {\n            continue;\n          }\n          const wOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n          const w = wOrdinal + 1;\n          if (semi[w] === 0) {\n            parent[w] = v;\n            nextEdgeIndex[wOrdinal] = firstEdgeIndexes[wOrdinal];\n            vNext = w;\n            break;\n          }\n        }\n        v = vNext;\n      }\n    };\n\n    // Iterative version since the recursive version can cause stack overflows.\n    // Preallocate a stack since compress() is called several times.\n    // The stack cannot grow larger than the number of nodes since we walk up\n    // the tree represented by the ancestor array.\n    const compressionStack = new Uint32Array(arrayLength);\n    const compress = (v: number): void => {\n      let stackPointer = 0;\n      while (ancestor[ancestor[v]] !== 0) {\n        compressionStack[++stackPointer] = v;\n        v = ancestor[v];\n      }\n      while (stackPointer > 0) {\n        const w = compressionStack[stackPointer--];\n        if (semi[label[ancestor[w]]] < semi[label[w]]) {\n          label[w] = label[ancestor[w]];\n        }\n        ancestor[w] = ancestor[ancestor[w]];\n      }\n    };\n\n    // Simple versions of eval and link from the paper.\n    const evaluate = (v: number): number => {\n      if (ancestor[v] === 0) {\n        return v;\n      }\n      compress(v);\n      return label[v];\n    };\n\n    const link = (v: number, w: number): void => {\n      ancestor[w] = v;\n    };\n\n    // Algorithm begins here. The variable names are as per the paper.\n    const r = rootNodeOrdinal + 1;\n    n = 0;\n    const dom = new Uint32Array(arrayLength);\n\n    // First perform DFS from the root.\n    dfs(r);\n\n    // Then perform DFS from orphan nodes (ones with only weak retainers) if any.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport =\n          [`Heap snapshot: ${nodeCount - n} nodes are unreachable from the root.`];\n      appendToProblemReport(errors, 'The following nodes have only weak retainers:');\n      for (let v = 1; v <= nodeCount; v++) {\n        const vOrdinal = v - 1;\n        if (semi[v] === 0 && HeapSnapshot.hasOnlyWeakRetainers(inputs, vOrdinal)) {\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          dfs(v);\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // If there are unreachable nodes still, visit them individually from the root.\n    // This can happen when there is a clique of nodes retained by one another.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport = [`Heap snapshot: Still found ${nodeCount - n} unreachable nodes:`];\n      for (let v = 1; v <= nodeCount; v++) {\n        if (semi[v] === 0) {\n          const vOrdinal = v - 1;\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // Main loop. Process the vertices in decreasing order by DFS number.\n    for (let i = n; i >= 2; --i) {\n      const w = vertex[i];\n      // Iterate over all predecessors v of w.\n      const wOrdinal = w - 1;\n      let isOrphanNode = true;\n      for (let retainerIndex = firstRetainerIndex[wOrdinal]; retainerIndex < firstRetainerIndex[wOrdinal + 1];\n           retainerIndex++) {\n        if (!isEssentialEdge(retainingEdges[retainerIndex])) {\n          continue;\n        }\n        isOrphanNode = false;\n        const vOrdinal = retainingNodes[retainerIndex] / nodeFieldCount;\n        const v = vOrdinal + 1;\n        const u = evaluate(v);\n        if (semi[u] < semi[w]) {\n          semi[w] = semi[u];\n        }\n      }\n      if (isOrphanNode) {\n        // We treat orphan nodes as having a single predecessor - the root.\n        // semi[r] is always less than any semi[w] so set it unconditionally.\n        semi[w] = semi[r];\n      }\n\n      if (bucket[vertex[semi[w]]] === undefined) {\n        bucket[vertex[semi[w]]] = new Set<number>();\n      }\n      bucket[vertex[semi[w]]].add(w);\n      link(parent[w], w);\n\n      // Process all vertices v in bucket(parent(w)).\n      if (bucket[parent[w]] !== undefined) {\n        for (const v of bucket[parent[w]]) {\n          const u = evaluate(v);\n          dom[v] = semi[u] < semi[v] ? u : parent[w];\n        }\n        bucket[parent[w]].clear();\n      }\n    }\n\n    // Final step. Fill in the immediate dominators not explicitly computed above.\n    // Unlike the paper, we consider the root to be its own dominator and\n    // set dom[0] to r to propagate the root as the dominator of unreachable nodes.\n    dom[0] = dom[r] = r;\n    for (let i = 2; i <= n; i++) {\n      const w = vertex[i];\n      if (dom[w] !== vertex[semi[w]]) {\n        dom[w] = dom[dom[w]];\n      }\n    }\n    // Algorithm ends here.\n\n    // Transform the dominators into an ordinal-indexed array and populate the self sizes.\n    const dominatorsTree = new Uint32Array(nodeCount);\n    const retainedSizes = new Float64Array(nodeCount);\n    const nodeSelfSizes = await nodeSelfSizesPromise;\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; nodeOrdinal++) {\n      dominatorsTree[nodeOrdinal] = dom[nodeOrdinal + 1] - 1;\n      retainedSizes[nodeOrdinal] = nodeSelfSizes[nodeOrdinal];\n    }\n\n    // Then propagate up the retained sizes for each traversed node excluding the root.\n    for (let i = n; i > 1; i--) {\n      const nodeOrdinal = vertex[i] - 1;\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n\n    return {dominatorsTree, retainedSizes};\n  }\n\n  static buildDominatedNodes(inputs: ArgumentsToBuildDominatedNodes): DominatedNodes {\n    const {nodeCount, dominatorsTree, rootNodeOrdinal, nodeFieldCount} = inputs;\n\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = new Uint32Array(nodeCount + 1);\n    // All nodes except the root have dominators.\n    const dominatedNodes = new Uint32Array(nodeCount - 1);\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = nodeCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n\n    return {firstDominatedNodeIndex: indexArray, dominatedNodes};\n  }\n\n  private calculateObjectNames(): void {\n    const {\n      nodes,\n      nodeCount,\n      nodeNameOffset,\n      nodeNativeType,\n      nodeHiddenType,\n      nodeObjectType,\n      nodeCodeType,\n      nodeClosureType,\n      nodeRegExpType,\n    } = this;\n\n    // If the snapshot doesn't contain a detachedness field in each node, then\n    // allocate a separate array so there is somewhere to store the class index.\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      this.detachednessAndClassIndexArray = new Uint32Array(nodeCount);\n    }\n\n    // We'll add some new values to the `strings` array during the processing below.\n    // This map lets us easily find the index for each added string.\n    const stringTable = new Map<string, number>();\n    const getIndexForString = (s: string): number => {\n      let index = stringTable.get(s);\n      if (index === undefined) {\n        index = this.addString(s);\n        stringTable.set(s, index);\n      }\n      return index;\n    };\n\n    const hiddenClassIndex = getIndexForString('(system)');\n    const codeClassIndex = getIndexForString('(compiled code)');\n    const functionClassIndex = getIndexForString('Function');\n    const regExpClassIndex = getIndexForString('RegExp');\n\n    function getNodeClassIndex(node: HeapSnapshotNode): number {\n      switch (node.rawType()) {\n        case nodeHiddenType:\n          return hiddenClassIndex;\n        case nodeObjectType:\n        case nodeNativeType: {\n          let name = node.rawName();\n\n          // If the node name is (for example) '<div id=\"a\">', then the class\n          // name should be just '<div>'. If the node name is already short\n          // enough, like '<div>', we must still call getIndexForString on that\n          // name, because the names added by getIndexForString are not\n          // deduplicated with preexisting strings, and we want all objects with\n          // class name '<div>' to refer to that class name via the same index.\n          // Otherwise, object categorization doesn't work.\n          if (name.startsWith('<')) {\n            const firstSpace = name.indexOf(' ');\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n          if (name.startsWith('Detached <')) {\n            const firstSpace = name.indexOf(' ', 10);\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n\n          // Avoid getIndexForString here; the class name index should match the name index.\n          return nodes.getValue(node.nodeIndex + nodeNameOffset);\n        }\n        case nodeCodeType:\n          return codeClassIndex;\n        case nodeClosureType:\n          return functionClassIndex;\n        case nodeRegExpType:\n          return regExpClassIndex;\n        default:\n          return getIndexForString('(' + node.type() + ')');\n      }\n    }\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      node.setClassIndex(getNodeClassIndex(node));\n      node.nodeIndex = node.nextNodeIndex();\n    }\n  }\n\n  interfaceDefinitions(): string {\n    return JSON.stringify(this.#interfaceDefinitions ?? []);\n  }\n\n  private isPlainJSObject(node: HeapSnapshotNode): boolean {\n    return node.rawType() === this.nodeObjectType && node.rawName() === 'Object';\n  }\n\n  private inferInterfaceDefinitions(): InterfaceDefinition[] {\n    const {edgePropertyType} = this;\n\n    // First, produce a set of candidate definitions by iterating the properties\n    // on every plain JS Object in the snapshot.\n    interface InterfaceDefinitionCandidate extends InterfaceDefinition {\n      // How many objects start with these properties in this order.\n      count: number;\n    }\n    // A map from interface names to their definitions.\n    const candidates = new Map<string, InterfaceDefinitionCandidate>();\n    let totalObjectCount = 0;\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n      ++totalObjectCount;\n      let interfaceName = '{';\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        const edgeName = edge.name();\n        if (edge.rawType() !== edgePropertyType || edgeName === '__proto__') {\n          continue;\n        }\n        const formattedEdgeName = JSHeapSnapshotNode.formatPropertyName(edgeName);\n        if (interfaceName.length > MIN_INTERFACE_PROPERTY_COUNT &&\n            interfaceName.length + formattedEdgeName.length > MAX_INTERFACE_NAME_LENGTH) {\n          break;  // The interface name is getting too long.\n        }\n        if (interfaceName.length !== 1) {\n          interfaceName += ', ';\n        }\n        interfaceName += formattedEdgeName;\n        properties.push(edgeName);\n      }\n      // The empty interface is not very meaningful, and can be sort of misleading\n      // since someone might incorrectly interpret it as objects with no properties.\n      if (properties.length === 0) {\n        continue;\n      }\n      interfaceName += '}';\n      const candidate = candidates.get(interfaceName);\n      if (candidate) {\n        ++candidate.count;\n      } else {\n        candidates.set(interfaceName, {name: interfaceName, properties, count: 1});\n      }\n    }\n\n    // Next, sort the candidates and select the most popular ones. It's possible that\n    // some candidates represent the same properties in different orders, but that's\n    // okay: by sorting here, we ensure that the most popular ordering appears first\n    // in the result list, and the rules for applying interface definitions will prefer\n    // the first matching definition if multiple matches contain the same properties.\n    const sortedCandidates = Array.from(candidates.values());\n    sortedCandidates.sort((a, b) => b.count - a.count);\n    const result: InterfaceDefinition[] = [];\n    const minCount = Math.max(MIN_OBJECT_COUNT_PER_INTERFACE, totalObjectCount / MIN_OBJECT_PROPORTION_PER_INTERFACE);\n    for (let i = 0; i < sortedCandidates.length; ++i) {\n      const candidate = sortedCandidates[i];\n      if (candidate.count < minCount) {\n        break;\n      }\n      result.push(candidate);\n    }\n\n    return result;\n  }\n\n  private applyInterfaceDefinitions(definitions: InterfaceDefinition[]): void {\n    const {edgePropertyType} = this;\n    this.#interfaceDefinitions = definitions;\n\n    // Any computed aggregate data will be wrong after recategorization, so clear it.\n    this.#aggregates = {};\n    this.#aggregatesSortedFlags = {};\n\n    // Information about a named interface.\n    interface MatchInfo {\n      name: string;\n      // The number of properties listed in the interface definition.\n      propertyCount: number;\n      // The position of the interface definition in the list of definitions.\n      index: number;\n    }\n\n    function selectBetterMatch(a: MatchInfo, b: MatchInfo|null): MatchInfo {\n      if (!b || a.propertyCount > b.propertyCount) {\n        return a;\n      }\n      if (b.propertyCount > a.propertyCount) {\n        return b;\n      }\n      return a.index <= b.index ? a : b;\n    }\n\n    // A node in the tree which allows us to search for interfaces matching an object.\n    // Each edge in this tree represents adding a property, starting from an empty\n    // object. Properties must be iterated in sorted order.\n    interface PropertyTreeNode {\n      // All possible successors from this node. Keys are property names.\n      next: Map<string, PropertyTreeNode>;\n      // If this node corresponds to a named interface, then matchInfo contains that name.\n      matchInfo: MatchInfo|null;\n      // The maximum of all keys in `next`. This helps determine when no further transitions\n      // are possible from this node.\n      greatestNext: string|null;\n    }\n\n    // The root node of the tree.\n    const propertyTree: PropertyTreeNode = {\n      next: new Map(),\n      matchInfo: null,\n      greatestNext: null,\n    };\n\n    // Build up the property tree.\n    for (let interfaceIndex = 0; interfaceIndex < definitions.length; ++interfaceIndex) {\n      const definition = definitions[interfaceIndex];\n      const properties = definition.properties.toSorted();\n      let currentNode = propertyTree;\n      for (const property of properties) {\n        const nextMap = currentNode.next;\n        let nextNode = nextMap.get(property);\n        if (!nextNode) {\n          nextNode = {\n            next: new Map(),\n            matchInfo: null,\n            greatestNext: null,\n          };\n          nextMap.set(property, nextNode);\n          if (currentNode.greatestNext === null || currentNode.greatestNext < property) {\n            currentNode.greatestNext = property;\n          }\n        }\n        currentNode = nextNode;\n      }\n      // Only set matchInfo on this node if it wasn't already set, to ensure that\n      // interfaces defined earlier in the list have priority.\n      if (!currentNode.matchInfo) {\n        currentNode.matchInfo = {\n          name: definition.name,\n          propertyCount: properties.length,\n          index: interfaceIndex,\n        };\n      }\n    }\n\n    // The fallback match for objects which don't match any defined interface.\n    const initialMatch: MatchInfo = {\n      name: 'Object',\n      propertyCount: 0,\n      index: Infinity,\n    };\n\n    // Iterate all nodes and check whether they match a named interface, using\n    // the tree constructed above. Then update the class name for each node.\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n\n      // Collect and sort the properties of this object.\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        if (edge.rawType() === edgePropertyType) {\n          properties.push(edge.name());\n        }\n      }\n      properties.sort();\n\n      // We may explore multiple possible paths through the tree, so this set tracks\n      // all states that match with the properties iterated thus far.\n      const states = new Set<PropertyTreeNode>();\n      states.add(propertyTree);\n\n      // This variable represents the best match found thus far. We start by checking\n      // whether there is an interface definition for the empty object.\n      let match = selectBetterMatch(initialMatch, propertyTree.matchInfo);\n\n      // Traverse the tree to find any matches.\n      for (const property of properties) {\n        // Iterate only the states that already exist, not the ones added during the loop below.\n        for (const currentState of Array.from(states.keys())) {\n          if (currentState.greatestNext === null || property >= currentState.greatestNext) {\n            // No further transitions are possible from this state.\n            states.delete(currentState);\n          }\n          const nextState = currentState.next.get(property);\n          if (nextState) {\n            states.add(nextState);\n            match = selectBetterMatch(match, nextState.matchInfo);\n          }\n        }\n      }\n\n      // Update the node's class name accordingly.\n      let classIndex = match === initialMatch ? node.rawNameIndex() : this.#interfaceNames.get(match.name);\n      if (classIndex === undefined) {\n        classIndex = this.addString(match.name);\n        this.#interfaceNames.set(match.name, classIndex);\n      }\n      node.setClassIndex(classIndex);\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  private iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this.firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this.firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this.edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const type = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  private addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n   * The phase propagates whether a node is attached or detached through the\n   * graph and adjusts the low-level representation of nodes.\n   *\n   * State propagation:\n   * 1. Any object reachable from an attached object is itself attached.\n   * 2. Any object reachable from a detached object that is not already\n   *    attached is considered detached.\n   *\n   * Representation:\n   * - Name of any detached node is changed from \"<Name>\"\" to\n   *   \"Detached <Name>\".\n   */\n  private propagateDOMState(): void {\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n    const node = this.createNode(0);\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes.getValue(nodeIndex + snapshot.nodeNameOffset);\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot.addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes.setValue(nodeIndex + snapshot.nodeNameOffset, newStringIndex);\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot.nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes.getValue(nodeIndex + snapshot.nodeTypeOffset) !== snapshot.nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      node.nodeIndex = nodeIndex;\n      node.setDetachedness(newState);\n\n      if (newState === DOMLinkState.ATTACHED) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.DETACHED) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot.iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType => ![snapshot.edgeHiddenType, snapshot.edgeInvisibleType, snapshot.edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const state = node.detachedness();\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.UNKNOWN) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.ATTACHED);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const nodeState = node.detachedness();\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.ATTACHED) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.DETACHED);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  private buildSamples(): void {\n    const samples = this.#rawSamples;\n    if (!samples?.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this.#metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this.#metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this.#samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  private buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this.#locations;\n\n    for (let i = 0; i < locations.length; i += this.#locationFieldCount) {\n      const nodeIndex = locations[i + this.#locationIndexOffset];\n      const scriptId = locations[i + this.#locationScriptIdOffset];\n      const line = locations[i + this.#locationLineOffset];\n      const col = locations[i + this.#locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this.#locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this.#locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this.#samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff}):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff} {\n    let snapshotDiff: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff}|{\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    } = this.#snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    });\n\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    for (const classKey in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[classKey];\n      const diff = this.calculateDiffForClass(baseAggregate, aggregates[classKey]);\n      if (diff) {\n        snapshotDiff[classKey] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const classKey in aggregates) {\n      if (classKey in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this.calculateDiffForClass(emptyBaseAggregate, aggregates[classKey]);\n      if (classDiff) {\n        snapshotDiff[classKey] = classDiff;\n      }\n    }\n\n    this.#snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  private calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate?: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff(aggregate ? aggregate.name : baseAggregate.name);\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  private nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  // Converts an internal class key, suitable for categorizing within this\n  // snapshot, to a public class key, which can be used in comparisons\n  // between multiple snapshots.\n  classKeyFromClassKeyInternal(key: string|number): string {\n    return typeof key === 'number' ? (',' + this.strings[key]) : key;\n  }\n\n  nodeClassKey(snapshotObjectId: number): string|null {\n    const node = this.nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return this.classKeyFromClassKeyInternal(node.classKeyInternal());\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, classKey: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this.#snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[classKey];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(classKey: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[classKey].idxs);\n  }\n\n  private maxJsNodeId(): number {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this.nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes.getValue(nodeIndex);\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this.rootNodeIndexInternal, this.totalSize, this.maxJsNodeId());\n  }\n\n  ignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.add(nodeIndex);\n    this.calculateDistances(/* isForRetainersView=*/ true);\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.delete(nodeIndex);\n    if (this.#ignoredNodesInRetainersView.size === 0) {\n      this.#nodeDistancesForRetainersView = undefined;\n    } else {\n      this.calculateDistances(/* isForRetainersView=*/ true);\n    }\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreAllNodesInRetainersView(): void {\n    this.#ignoredNodesInRetainersView.clear();\n    this.#nodeDistancesForRetainersView = undefined;\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  #updateIgnoredEdgesInRetainersView(): void {\n    const distances = this.#nodeDistancesForRetainersView;\n    this.#ignoredEdgesInRetainersView.clear();\n    if (distances === undefined) {\n      return;\n    }\n\n    // To retain a value in a WeakMap, both the WeakMap and the corresponding\n    // key must stay alive. If one of those two retainers is unreachable due to\n    // the user ignoring some nodes, then the other retainer edge should also be\n    // shown as unreachable, since it would be insufficient on its own to retain\n    // the value.\n    const unreachableWeakMapEdges = new Platform.MapUtilities.Multimap<number, string>();\n    const noDistance = this.#noDistance;\n    const {nodeCount, nodeFieldCount} = this;\n    const node = this.createNode(0);\n\n    // Populate unreachableWeakMapEdges.\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      if (distances[nodeOrdinal] !== noDistance) {\n        continue;\n      }\n      node.nodeIndex = nodeOrdinal * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (!edge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          unreachableWeakMapEdges.set(edge.nodeIndex(), match.duplicatedPart);\n        }\n      }\n    }\n\n    // Iterate the retaining edges for the target nodes found in the previous\n    // step and mark any relevant WeakMap edges as ignored.\n    for (const targetNodeIndex of unreachableWeakMapEdges.keys()) {\n      node.nodeIndex = targetNodeIndex;\n      for (let it = node.retainers(); it.hasNext(); it.next()) {\n        const reverseEdge = it.item();\n        if (!reverseEdge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(reverseEdge.nameIndex());\n        if (match && unreachableWeakMapEdges.hasValue(targetNodeIndex, match.duplicatedPart)) {\n          const forwardEdgeIndex = this.retainingEdges[reverseEdge.itemIndex()];\n          this.#ignoredEdgesInRetainersView.add(forwardEdgeIndex);\n        }\n      }\n    }\n  }\n\n  areNodesIgnoredInRetainersView(): boolean {\n    return this.#ignoredNodesInRetainersView.size > 0;\n  }\n\n  getDistanceForRetainersView(nodeIndex: number): number {\n    const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n    const distances = this.#nodeDistancesForRetainersView ?? this.nodeDistances;\n    const distance = distances[nodeOrdinal];\n    if (distance === this.#noDistance) {\n      // An unreachable node should be sorted to the end, not the beginning.\n      // To give such nodes a reasonable sorting order, we add a very large\n      // number to the original distance computed without ignoring any nodes.\n      return Math.max(0, this.nodeDistances[nodeOrdinal]) + HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return distance;\n  }\n\n  isNodeIgnoredInRetainersView(nodeIndex: number): boolean {\n    return this.#ignoredNodesInRetainersView.has(nodeIndex);\n  }\n\n  isEdgeIgnoredInRetainersView(edgeIndex: number): boolean {\n    return this.#ignoredEdgesInRetainersView.has(edgeIndex);\n  }\n}\n\ninterface HeapSnapshotMetaInfo {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  location_fields: string[];\n  node_fields: string[];\n  node_types: string[][];\n  edge_fields: string[];\n  edge_types: string[][];\n  trace_function_info_fields: string[];\n  trace_node_fields: string[];\n  sample_fields: string[];\n  type_strings: {[key: string]: string};\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface HeapSnapshotHeader {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  title: string;\n  meta: HeapSnapshotMetaInfo;\n  node_count: number;\n  edge_count: number;\n  trace_function_count: number;\n  root_index: number;\n  extra_native_bytes?: number;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  protected readonly iterator: HeapSnapshotItemIterator;\n  readonly #indexProvider: HeapSnapshotItemIndexProvider;\n  readonly #isEmptyInternal: boolean;\n  protected iterationOrder: number[]|null;\n  protected currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  #sortedPrefixLength: number;\n  #sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this.iterator = iterator;\n    this.#indexProvider = indexProvider;\n    this.#isEmptyInternal = !iterator.hasNext();\n    this.iterationOrder = null;\n    this.currentComparator = null;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  protected createIterationOrder(): void {\n    if (this.iterationOrder) {\n      return;\n    }\n    this.iterationOrder = [];\n    for (let iterator = this.iterator; iterator.hasNext(); iterator.next()) {\n      this.iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.#isEmptyInternal;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this.createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this.iterationOrder.length) {\n      end = this.iterationOrder.length;\n    }\n    if (this.#sortedPrefixLength < end && begin < this.iterationOrder.length - this.#sortedSuffixLength &&\n        this.currentComparator) {\n      const currentComparator = this.currentComparator;\n      this.sort(\n          currentComparator, this.#sortedPrefixLength, this.iterationOrder.length - 1 - this.#sortedSuffixLength, begin,\n          end - 1);\n      if (begin <= this.#sortedPrefixLength) {\n        this.#sortedPrefixLength = end;\n      }\n      if (end >= this.iterationOrder.length - this.#sortedSuffixLength) {\n        this.#sortedSuffixLength = this.iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this.iterationOrder[position++];\n      const item = this.#indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this.iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this.currentComparator = comparator;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this.iterator.item() as HeapSnapshotEdge | HeapSnapshotRetainerEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      let result = 0;\n      if (fieldName === '!edgeName') {\n        if (edgeB.name() === '__proto__') {\n          return -1;\n        }\n        if (edgeA.name() === '__proto__') {\n          return 1;\n        }\n        result = edgeA.hasStringName() === edgeB.hasStringName() ?\n            (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n            (edgeA.hasStringName() ? -1 : 1);\n      } else {\n        result = edgeA.getValueForSorting(fieldName) - edgeB.getValueForSorting(fieldName);\n      }\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndEdge(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    function isEdgeFieldName(fieldName: string): boolean {\n      return fieldName.startsWith('!edge');\n    }\n\n    if (isEdgeFieldName(fieldName1)) {\n      if (isEdgeFieldName(fieldName2)) {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n      } else {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n      }\n    } else if (isEdgeFieldName(fieldName2)) {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this.createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this.iterationOrder.length; i++) {\n      node.nodeIndex = this.iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this.iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this.iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this.currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this.buildCompareFunction(currentComparator);\n    for (let i = 0; i < this.iterationOrder.length; i++) {\n      if (compare(this.iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  private buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    function sortByNodeField(fieldAccessor: () => void, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this.iterationOrder, this.buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  readonly nodeFlags: {\n    // bit flags in 8-bit value\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  private flags!: Uint8Array;\n  #statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    super(profile, progress);\n    this.nodeFlags = {\n      // bit flags in 8-bit value\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  override containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  override retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  override calculateFlags(): void {\n    this.flags = new Uint8Array(this.nodeCount);\n    this.markDetachedDOMTreeNodes();\n    this.markQueriableHeapObjects();\n    this.markPageOwnedNodes();\n  }\n\n  #hasUserRoots(): boolean {\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (this.isUserRoot(iter.edge.node())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Updates the shallow sizes for \"owned\" objects of types kArray or kHidden to\n  // zero, and add their sizes to the \"owner\" object instead.\n  override calculateShallowSizes(): void {\n    // If there are no user roots, then that means the snapshot was produced with\n    // the \"expose internals\" option enabled. In that case, we should faithfully\n    // represent the actual memory allocations rather than attempting to make the\n    // output more understandable to web developers.\n    if (!this.#hasUserRoots()) {\n      return;\n    }\n\n    const {nodeCount, nodes, nodeFieldCount, nodeSelfSizeOffset} = this;\n\n    const kUnvisited = 0xffffffff;\n    const kHasMultipleOwners = 0xfffffffe;\n    if (nodeCount >= kHasMultipleOwners) {\n      throw new Error('Too many nodes for calculateShallowSizes');\n    }\n    // For each node in order, `owners` will contain the index of the owning\n    // node or one of the two values kUnvisited or kHasMultipleOwners. The\n    // indexes in this array are NOT already multiplied by nodeFieldCount.\n    const owners = new Uint32Array(nodeCount);\n    // The worklist contains the indexes of nodes which should be visited during\n    // the second loop below. The order of visiting doesn't matter. The indexes\n    // in this array are NOT already multiplied by nodeFieldCount.\n    const worklist: number[] = [];\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      if (node.isHidden() || node.isArray() || (node.isNative() && node.rawName() === 'system / ExternalStringData')) {\n        owners[i] = kUnvisited;\n      } else {\n        // The node owns itself.\n        owners[i] = i;\n        worklist.push(i);\n      }\n      node.nodeIndex = node.nextNodeIndex();\n    }\n\n    while (worklist.length !== 0) {\n      const id = worklist.pop() as number;\n      const owner = owners[id];\n      node.nodeIndex = id * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (edge.isWeak()) {\n          continue;\n        }\n        const targetId = edge.nodeIndex() / nodeFieldCount;\n        switch (owners[targetId]) {\n          case kUnvisited:\n            owners[targetId] = owner;\n            worklist.push(targetId);\n            break;\n          case targetId:\n          case owner:\n          case kHasMultipleOwners:\n            // There is no change necessary if the target is already marked as:\n            // * owned by itself,\n            // * owned by the owner of the current source node, or\n            // * owned by multiple nodes.\n            break;\n          default:\n            owners[targetId] = kHasMultipleOwners;\n            // It is possible that this node is already in the worklist\n            // somewhere, but visiting it an extra time is not harmful. The\n            // iteration is guaranteed to complete because each node can only be\n            // added twice to the worklist: once when changing from kUnvisited\n            // to a specific owner, and a second time when changing from that\n            // owner to kHasMultipleOwners.\n            worklist.push(targetId);\n            break;\n        }\n      }\n    }\n\n    for (let i = 0; i < nodeCount; ++i) {\n      const ownerId = owners[i];\n      switch (ownerId) {\n        case kUnvisited:\n        case kHasMultipleOwners:\n        case i:\n          break;\n        default: {\n          const ownedNodeIndex = i * nodeFieldCount;\n          const ownerNodeIndex = ownerId * nodeFieldCount;\n          node.nodeIndex = ownerNodeIndex;\n          if (node.isSynthetic() || node.isRoot()) {\n            // Adding shallow size to synthetic or root nodes is not useful.\n            break;\n          }\n          const sizeToTransfer = nodes.getValue(ownedNodeIndex + nodeSelfSizeOffset);\n          nodes.setValue(ownedNodeIndex + nodeSelfSizeOffset, 0);\n          nodes.setValue(\n              ownerNodeIndex + nodeSelfSizeOffset,\n              nodes.getValue(ownerNodeIndex + nodeSelfSizeOffset) + sizeToTransfer);\n          break;\n        }\n      }\n    }\n  }\n\n  override calculateDistances(isForRetainersView: boolean): void {\n    const pendingEphemeronEdges = new Set<string>();\n    const snapshot = this;\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden() && edge.name() === 'sloppy_function_map' && node.rawName() === 'system / NativeContext') {\n        return false;\n      }\n      if (node.isArray() && node.rawName() === '(map descriptors)') {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      if (edge.isInternal()) {\n        // Snapshots represent WeakMap values as being referenced by two edges:\n        // one from the WeakMap, and a second from the corresponding key. To\n        // avoid the case described in crbug.com/1290800, we should set the\n        // distance of that value to the greater of (WeakMap+1, key+1). This\n        // part of the filter skips the first edge in the matched pair of edges,\n        // so that the distance gets set based on the second, which should be\n        // greater or equal due to traversal order.\n        const match = snapshot.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          if (!pendingEphemeronEdges.delete(match.duplicatedPart)) {\n            pendingEphemeronEdges.add(match.duplicatedPart);\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    super.calculateDistances(isForRetainersView, filter);\n  }\n\n  override isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  override userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    return {map: this.flags, flag: this.nodeFlags.pageObject};\n  }\n\n  flagsOfNode(node: HeapSnapshotNode): number {\n    return this.flags[node.nodeIndex / this.nodeFieldCount];\n  }\n\n  private markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const flag = this.nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this.flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  private markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to inconsistent state of internal properties of wrappers.\n    const flag = this.nodeFlags.canBeQueried;\n    const hiddenEdgeType = this.edgeHiddenType;\n    const internalEdgeType = this.edgeInternalType;\n    const invisibleEdgeType = this.edgeInvisibleType;\n    const weakEdgeType = this.edgeWeakType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n\n    const flags = this.flags;\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  private markPageOwnedNodes(): void {\n    const edgeShortcutType = this.edgeShortcutType;\n    const edgeElementType = this.edgeElementType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeWeakType = this.edgeWeakType;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = this.flags;\n    const pageObjectFlag = this.nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      const nodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  override calculateStatistics(): void {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeSizeOffset = this.nodeSelfSizeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeCodeType = this.nodeCodeType;\n    const nodeConsStringType = this.nodeConsStringType;\n    const nodeSlicedStringType = this.nodeSlicedStringType;\n    const nodeHiddenType = this.nodeHiddenType;\n    const nodeStringType = this.nodeStringType;\n    let sizeNative = this.profile.snapshot.extra_native_bytes ?? 0;\n    let sizeTypedArrays = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes.getValue(nodeIndex + nodeSizeOffset);\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType === nodeHiddenType) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n        if (node.rawName() === 'system / JSArrayBufferData') {\n          sizeTypedArrays += nodeSize;\n        }\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || nodeType === nodeStringType) {\n        sizeStrings += nodeSize;\n      } else if (node.rawName() === 'Array') {\n        sizeJSArrays += this.calculateArraySize(node);\n      }\n    }\n    this.#statistics = {\n      total: this.totalSize,\n      native: {\n        total: sizeNative,\n        typedArrays: sizeTypedArrays,\n      },\n      v8heap: {\n        total: this.totalSize - sizeNative,\n        code: sizeCode,\n        jsArrays: sizeJSArrays,\n        strings: sizeStrings,\n        system: sizeSystem,\n      }\n    };\n  }\n\n  private calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeNameOffset = this.edgeNameOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeInternalType = this.edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges.getValue(edgeIndex + edgeNameOffset)];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return this.#statistics as HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\n// Creates and initializes a JSHeapSnapshot using only one thread.\nexport async function createJSHeapSnapshotForTesting(profile: Profile): Promise<JSHeapSnapshot> {\n  const result = new JSHeapSnapshot(profile, new HeapSnapshotProgress());\n  const channel = new MessageChannel();\n  new SecondaryInitManager(channel.port2);\n  await result.initialize(channel.port1);\n  return result;\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  constructor(snapshot: JSHeapSnapshot, nodeIndex?: number) {\n    super(snapshot, nodeIndex);\n  }\n\n  canBeQueried(): boolean {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    return Boolean(flags & snapshot.nodeFlags.canBeQueried);\n  }\n\n  override name(): string {\n    const snapshot = this.snapshot;\n    if (this.rawType() === snapshot.nodeConsStringType) {\n      return this.consStringName();\n    }\n    if (this.rawType() === snapshot.nodeObjectType && this.rawName() === 'Object') {\n      return this.#plainObjectName();\n    }\n    return this.rawName();\n  }\n\n  private consStringName(): string {\n    const snapshot = this.snapshot;\n    const consStringType = snapshot.nodeConsStringType;\n    const edgeInternalType = snapshot.edgeInternalType;\n    const edgeFieldsCount = snapshot.edgeFieldsCount;\n    const edgeToNodeOffset = snapshot.edgeToNodeOffset;\n    const edgeTypeOffset = snapshot.edgeTypeOffset;\n    const edgeNameOffset = snapshot.edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot.firstEdgeIndexes;\n    const nodeFieldCount = snapshot.nodeFieldCount;\n    const nodeTypeOffset = snapshot.nodeTypeOffset;\n    const nodeNameOffset = snapshot.nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes.getValue(nodeIndex + nodeTypeOffset) !== consStringType) {\n        name += strings[nodes.getValue(nodeIndex + nodeNameOffset)];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges.getValue(edgeIndex + edgeNameOffset)];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  // Creates a name for plain JS objects, which looks something like\n  // '{propName, otherProp, thirdProp, ..., secondToLastProp, lastProp}'.\n  // A variable number of property names is included, depending on the length\n  // of the property names, so that the result fits nicely in a reasonably\n  // sized DevTools window.\n  #plainObjectName(): string {\n    const snapshot = this.snapshot;\n    const {edgeFieldsCount, edgePropertyType} = snapshot;\n    const edge = snapshot.createEdge(0);\n    let categoryNameStart = '{';\n    let categoryNameEnd = '}';\n    let edgeIndexFromStart = this.edgeIndexesStart();\n    let edgeIndexFromEnd = this.edgeIndexesEnd() - edgeFieldsCount;\n    let nextFromEnd = false;\n    while (edgeIndexFromStart <= edgeIndexFromEnd) {\n      edge.edgeIndex = nextFromEnd ? edgeIndexFromEnd : edgeIndexFromStart;\n\n      // Skip non-property edges and the special __proto__ property.\n      if (edge.rawType() !== edgePropertyType || edge.name() === '__proto__') {\n        if (nextFromEnd) {\n          edgeIndexFromEnd -= edgeFieldsCount;\n        } else {\n          edgeIndexFromStart += edgeFieldsCount;\n        }\n        continue;\n      }\n\n      const formatted = JSHeapSnapshotNode.formatPropertyName(edge.name());\n\n      // Always include at least one property, regardless of its length. Beyond that point,\n      // only include more properties if the name isn't too long.\n      if (categoryNameStart.length > 1 && categoryNameStart.length + categoryNameEnd.length + formatted.length > 100) {\n        break;\n      }\n\n      if (nextFromEnd) {\n        edgeIndexFromEnd -= edgeFieldsCount;\n        if (categoryNameEnd.length > 1) {\n          categoryNameEnd = ', ' + categoryNameEnd;\n        }\n        categoryNameEnd = formatted + categoryNameEnd;\n      } else {\n        edgeIndexFromStart += edgeFieldsCount;\n        if (categoryNameStart.length > 1) {\n          categoryNameStart += ', ';\n        }\n        categoryNameStart += formatted;\n      }\n      nextFromEnd = !nextFromEnd;\n    }\n    if (edgeIndexFromStart <= edgeIndexFromEnd) {\n      categoryNameStart += ', ...';\n    }\n    if (categoryNameEnd.length > 1) {\n      categoryNameStart += ', ';\n    }\n    return categoryNameStart + categoryNameEnd;\n  }\n\n  static formatPropertyName(name: string): string {\n    // We don't need a strict test for whether a property name follows the\n    // rules for being a JS identifier, but property names containing commas,\n    // quotation marks, or braces could cause confusion, so we'll escape those.\n    if (/[,'\"{}]/.test(name)) {\n      name = JSON.stringify({[name]: 0});\n      name = name.substring(1, name.length - 3);\n    }\n    return name;\n  }\n\n  override id(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeIdOffset);\n  }\n\n  override isHidden(): boolean {\n    return this.rawType() === this.snapshot.nodeHiddenType;\n  }\n\n  override isArray(): boolean {\n    return this.rawType() === this.snapshot.nodeArrayType;\n  }\n\n  override isSynthetic(): boolean {\n    return this.rawType() === this.snapshot.nodeSyntheticType;\n  }\n\n  isNative(): boolean {\n    return this.rawType() === this.snapshot.nodeNativeType;\n  }\n\n  override isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  override isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.rawName() === '(Document DOM trees)';\n  }\n\n  override serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    if (flags & snapshot.nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot.nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  constructor(snapshot: JSHeapSnapshot, edgeIndex?: number) {\n    super(snapshot, edgeIndex);\n  }\n\n  override clone(): JSHeapSnapshotEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  override hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this.hasStringNameInternal();\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    return isNaN(parseInt(this.nameInternal(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this.snapshot.edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.edgeHiddenType;\n  }\n\n  override isWeak(): boolean {\n    return this.rawType() === this.snapshot.edgeWeakType;\n  }\n\n  override isInternal(): boolean {\n    return this.rawType() === this.snapshot.edgeInternalType;\n  }\n\n  override isInvisible(): boolean {\n    return this.rawType() === this.snapshot.edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this.snapshot.edgeShortcutType;\n  }\n\n  override name(): string {\n    const name = this.nameInternal();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  override toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  private hasStringNameInternal(): boolean {\n    const type = this.rawType();\n    const snapshot = this.snapshot;\n    return type !== snapshot.edgeElementType && type !== snapshot.edgeHiddenType;\n  }\n\n  private nameInternal(): string|number {\n    return this.hasStringNameInternal() ? this.snapshot.strings[this.nameOrIndex()] : this.nameOrIndex();\n  }\n\n  private nameOrIndex(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeNameOffset);\n  }\n\n  override rawType(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  override nameIndex(): number {\n    if (!this.hasStringNameInternal()) {\n      throw new Error('Edge does not have string name');\n    }\n    return this.nameOrIndex();\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  constructor(snapshot: JSHeapSnapshot, retainerIndex: number) {\n    super(snapshot, retainerIndex);\n  }\n\n  override clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this.edge().isHidden();\n  }\n\n  isInvisible(): boolean {\n    return this.edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this.edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this.edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string;\n  idxs: number[];\n}\n"]}