{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/lighthouse_worker/LighthouseWorkerService.ts", "lighthouse_worker.prebundle.ts"],
  "sourcesContent": ["// Copyright (c) 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Root from '../../core/root/root.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as PuppeteerService from '../../services/puppeteer/puppeteer.js';\nimport * as ThirdPartyWeb from '../../third_party/third-party-web/third-party-web.js';\n\nfunction disableLoggingForTest(): void {\n  console.log = (): void => undefined;  // eslint-disable-line no-console\n}\n\n/**\n * ConnectionProxy is a SDK interface, but the implementation has no knowledge it's a parallelConnection.\n * The CDP traffic is smuggled back and forth by the system described in LighthouseProtocolService\n */\nclass ConnectionProxy implements SDK.Connections.ParallelConnectionInterface {\n  sessionId: string;\n  onMessage: ((arg0: Object) => void)|null;\n  onDisconnect: ((arg0: string) => void)|null;\n\n  constructor(sessionId: string) {\n    this.sessionId = sessionId;\n    this.onMessage = null;\n    this.onDisconnect = null;\n  }\n\n  setOnMessage(onMessage: (arg0: Object|string) => void): void {\n    this.onMessage = onMessage;\n  }\n\n  setOnDisconnect(onDisconnect: (arg0: string) => void): void {\n    this.onDisconnect = onDisconnect;\n  }\n\n  getOnDisconnect(): (((arg0: string) => void)|null) {\n    return this.onDisconnect;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  sendRawMessage(message: string): void {\n    notifyFrontendViaWorkerMessage('sendProtocolMessage', {message});\n  }\n\n  async disconnect(): Promise<void> {\n    this.onDisconnect?.('force disconnect');\n    this.onDisconnect = null;\n    this.onMessage = null;\n  }\n}\n\nlet cdpConnection: ConnectionProxy|undefined;\nlet endTimespan: (() => unknown)|undefined;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function invokeLH(action: string, args: any): Promise<unknown> {\n  if (Root.Runtime.Runtime.queryParam('isUnderTest')) {\n    disableLoggingForTest();\n    args.flags.maxWaitForLoad = 2 * 1000;\n  }\n\n  // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n  self.listenForStatus(message => {\n    notifyFrontendViaWorkerMessage('statusUpdate', {message: message[1]});\n  });\n\n  let puppeteerHandle: Awaited<ReturnType<\n      typeof PuppeteerService.PuppeteerConnection.PuppeteerConnectionHelper['connectPuppeteerToConnectionViaTab']>>|\n      undefined;\n\n  try {\n    // For timespan we only need to perform setup on startTimespan.\n    // Config, flags, locale, etc. should be stored in the closure of endTimespan.\n    if (action === 'endTimespan') {\n      if (!endTimespan) {\n        throw new Error('Cannot end a timespan before starting one');\n      }\n      const result = await endTimespan();\n      endTimespan = undefined;\n      return result;\n    }\n\n    const locale = await fetchLocaleData(args.locales);\n    const flags = args.flags;\n    flags.logLevel = flags.logLevel || 'info';\n    flags.channel = 'devtools';\n    flags.locale = locale;\n\n    // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n    const config = args.config || self.createConfig(args.categoryIDs, flags.formFactor);\n    const url = args.url;\n\n    // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n    self.thirdPartyWeb.provideThirdPartyWeb(ThirdPartyWeb.ThirdPartyWeb);\n\n    const {rootTargetId, mainSessionId} = args;\n    cdpConnection = new ConnectionProxy(mainSessionId);\n    puppeteerHandle =\n        await PuppeteerService.PuppeteerConnection.PuppeteerConnectionHelper.connectPuppeteerToConnectionViaTab({\n          connection: cdpConnection,\n          rootTargetId,\n          // Lighthouse can only audit normal pages.\n          isPageTargetCallback: targetInfo => targetInfo.type === 'page',\n        });\n\n    const {page} = puppeteerHandle;\n    if (!page) {\n      throw new Error('Could not create page handle for the target page');\n    }\n\n    if (action === 'snapshot') {\n      // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n      return await self.snapshot(page, {config, flags});\n    }\n\n    if (action === 'startTimespan') {\n      // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n      const timespan = await self.startTimespan(page, {config, flags});\n      endTimespan = timespan.endTimespan;\n      return;\n    }\n\n    // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n    return await self.navigation(page, url, {config, flags});\n  } catch (err) {\n    return ({\n      fatal: true,\n      message: err.message,\n      stack: err.stack,\n    });\n  } finally {\n    // endTimespan will need to use the same connection as startTimespan.\n    if (action !== 'startTimespan') {\n      await puppeteerHandle?.browser.disconnect();\n    }\n  }\n}\n\n/**\n * Finds a locale supported by Lighthouse from the user's system locales.\n * If no matching locale is found, or if fetching locale data fails, this function returns nothing\n * and Lighthouse will use `en-US` by default.\n */\nasync function fetchLocaleData(locales: string[]): Promise<string|void> {\n  // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n  const locale = self.lookupLocale(locales);\n\n  // If the locale is en-US, no need to fetch locale data.\n  if (locale === 'en-US' || locale === 'en') {\n    return;\n  }\n\n  // Try to load the locale data.\n  try {\n    const remoteBase = Root.Runtime.getRemoteBase();\n    let localeUrl: string;\n    if (remoteBase?.base) {\n      localeUrl = `${remoteBase.base}third_party/lighthouse/locales/${locale}.json`;\n    } else {\n      localeUrl = new URL(`../../third_party/lighthouse/locales/${locale}.json`, import.meta.url).toString();\n    }\n\n    const timeoutPromise =\n        new Promise<never>((_, reject) => setTimeout(() => reject(new Error('timed out fetching locale')), 5000));\n    const localeData = await Promise.race([timeoutPromise, fetch(localeUrl).then(result => result.json())]);\n    // @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\n    self.registerLocaleData(locale, localeData);\n    return locale;\n  } catch (err) {\n    console.error(err);\n  }\n\n  return;\n}\n\n/**\n * `notifyFrontendViaWorkerMessage` and `onFrontendMessage` work with the FE's ProtocolService.\n *\n * onFrontendMessage takes action-wrapped messages and either invoking lighthouse or delivering it CDP traffic.\n * notifyFrontendViaWorkerMessage posts action-wrapped messages to the FE.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction notifyFrontendViaWorkerMessage(action: string, args: any): void {\n  self.postMessage({action, args});\n}\n\nasync function onFrontendMessage(event: MessageEvent): Promise<void> {\n  const messageFromFrontend = event.data;\n  switch (messageFromFrontend.action) {\n    case 'startTimespan':\n    case 'endTimespan':\n    case 'snapshot':\n    case 'navigation': {\n      const result = await invokeLH(messageFromFrontend.action, messageFromFrontend.args);\n      if (result && typeof result === 'object') {\n        // Report isn't used upstream.\n        if ('report' in result) {\n          delete result.report;\n        }\n\n        // Logger PerformanceTiming objects cannot be cloned by this worker's `postMessage` function.\n        if ('artifacts' in result) {\n          // @ts-expect-error\n          result.artifacts.Timing = JSON.parse(JSON.stringify(result.artifacts.Timing));\n        }\n      }\n      self.postMessage({id: messageFromFrontend.id, result});\n      break;\n    }\n    case 'dispatchProtocolMessage': {\n      cdpConnection?.onMessage?.(messageFromFrontend.args.message);\n      break;\n    }\n    default: {\n      throw new Error(`Unknown event: ${event.data}`);\n    }\n  }\n}\n\nself.onmessage = onFrontendMessage;\n\n// Make lighthouse and traceviewer happy.\nglobalThis.global = self;\n// @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\nglobalThis.global.isVinn = true;\n// @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\nglobalThis.global.document = {};\n// @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\nglobalThis.global.document.documentElement = {};\n// @ts-expect-error https://github.com/GoogleChrome/lighthouse/issues/11628\nglobalThis.global.document.documentElement.style = {\n  WebkitAppearance: 'WebkitAppearance',\n};\n", "// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport './LighthouseWorkerService.js';\nimport '../../third_party/lighthouse/lighthouse-dt-bundle.js';\n\nself.postMessage('workerReady');\n"],
  "mappings": "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",
  "names": []
}
