{"version":3,"file":"ServerSentEvents.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/ServerSentEvents.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,EAAC,WAAW,EAAC,MAAM,kBAAkB,CAAC;AAC7C,OAAO,EAAC,cAAc,EAAC,MAAM,qBAAqB,CAAC;AACnD,OAAO,EAAC,MAAM,EAA+C,MAAM,qBAAqB,CAAC;AACzF,OAAO,EAAC,sBAAsB,EAAC,MAAM,+BAA+B,CAAC;AAErE;;;;;;;;;GASG;AACH,MAAM,OAAO,gBAAgB;IAClB,QAAQ,CAAiB;IACzB,OAAO,CAA0B;IAE1C,6FAA6F;IAC7F,6EAA6E;IAC7E,qBAAqB,GAAW,CAAC,CAAC;IAEzB,oBAAoB,GAAyB,EAAE,CAAC;IAEzD,YAAY,OAAuB,EAAE,qBAA8B;QACjE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,mEAAmE;QACnE,IAAI,qBAAqB,EAAE;YACzB,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YACvE,IAAI,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,OAAO,EAAE,IAAI,SAAS,CAAC,CAAC;YAC1G,KAAK,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;gBACvE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;oBACrC,yCAAyC;oBACzC,KAAK,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;iBACvD;YACH,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACnC,CAAC;IAED,4CAA4C;IAC5C,YAAY,CAAC,IAAY,EAAE,IAAY;QACrC,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAChE,KAAK,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED,oDAAoD;IACpD,oCAAoC,CAAC,SAAiB,EAAE,IAAY,EAAE,OAAe,EAAE,IAAY;QACjG,IAAI,CAAC,8BAA8B,CAAC;YAClC,SAAS;YACT,OAAO;YACP,IAAI;YACJ,IAAI;SACL,CAAC,CAAC;IACL,CAAC;IAED,cAAc,CAAC,SAAiB,EAAE,IAAY,EAAE,OAAe;QAC7D,IAAI,CAAC,8BAA8B,CAAC;YAClC,SAAS;YACT,OAAO;YACP,IAAI;YACJ,IAAI,EAAE,IAAI,CAAC,qBAAqB;SACjC,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B,CAAC,OAA2B;QACxD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACxC,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,MAAM,CAAC,uBAAuB,EAAE,OAAO,CAAC,CAAC;IAClF,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {ContentData} from './ContentData.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport {Events, type EventSourceMessage, type NetworkRequest} from './NetworkRequest.js';\nimport {ServerSentEventsParser} from './ServerSentEventsProtocol.js';\n\n/**\n * Server sent events only arrive via CDP (Explicit Network.eventSourceMessageReceived) when\n * the page uses \"EventSource\" in the code.\n *\n * If the page manually uses 'fetch' or XHR we have to do the protocol parsing\n * ourselves.\n *\n * `ServerSentEvents` is a small helper class that manages this distinction for a specific\n * request, stores the event data and sends out \"EventSourceMessageAdded\" events for a request.\n */\nexport class ServerSentEvents {\n  readonly #request: NetworkRequest;\n  readonly #parser?: ServerSentEventsParser;\n\n  // In the case where we parse the events ourselves we use the time of the last 'dataReceived'\n  // event for all the events that come out of the corresponding chunk of data.\n  #lastDataReceivedTime: number = 0;\n\n  readonly #eventSourceMessages: EventSourceMessage[] = [];\n\n  constructor(request: NetworkRequest, parseFromStreamedData: boolean) {\n    this.#request = request;\n\n    // Only setup parsing if we don't get the events over CDP directly.\n    if (parseFromStreamedData) {\n      this.#lastDataReceivedTime = request.pseudoWallTime(request.startTime);\n      this.#parser = new ServerSentEventsParser(this.#onParserEvent.bind(this), request.charset() ?? undefined);\n      void NetworkManager.streamResponseBody(this.#request).then(contentData => {\n        if (!ContentData.isError(contentData)) {\n          // Partial data is always base64 encoded.\n          void this.#parser?.addBase64Chunk(contentData.base64);\n        }\n      });\n    }\n  }\n\n  get eventSourceMessages(): readonly EventSourceMessage[] {\n    return this.#eventSourceMessages;\n  }\n\n  /** Forwarded Network.dataReceived events */\n  dataReceived(data: string, time: number): void {\n    this.#lastDataReceivedTime = this.#request.pseudoWallTime(time);\n    void this.#parser?.addBase64Chunk(data);\n  }\n\n  /** Forwarded Network.eventSourceMessage received */\n  onProtocolEventSourceMessageReceived(eventName: string, data: string, eventId: string, time: number): void {\n    this.#recordMessageAndDispatchEvent({\n      eventName,\n      eventId,\n      data,\n      time,\n    });\n  }\n\n  #onParserEvent(eventName: string, data: string, eventId: string): void {\n    this.#recordMessageAndDispatchEvent({\n      eventName,\n      eventId,\n      data,\n      time: this.#lastDataReceivedTime,\n    });\n  }\n\n  #recordMessageAndDispatchEvent(message: EventSourceMessage): void {\n    this.#eventSourceMessages.push(message);\n    this.#request.dispatchEventToListeners(Events.EventSourceMessageAdded, message);\n  }\n}\n"]}