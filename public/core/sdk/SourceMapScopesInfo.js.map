{"version":3,"file":"SourceMapScopesInfo.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapScopesInfo.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\n\nimport {type CallFrame, type ScopeChainEntry} from './DebuggerModel.js';\nimport {type SourceMap, type SourceMapV3Object} from './SourceMap.js';\nimport {SourceMapScopeChainEntry} from './SourceMapScopeChainEntry.js';\nimport {\n  decodeGeneratedRanges,\n  decodeOriginalScopes,\n  type GeneratedRange,\n  type OriginalPosition,\n  type OriginalScope,\n} from './SourceMapScopes.js';\n\nexport class SourceMapScopesInfo {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #sourceMap: SourceMap;\n  readonly #originalScopes: OriginalScope[];\n  readonly #generatedRanges: GeneratedRange[];\n\n  #cachedVariablesAndBindingsPresent: boolean|null = null;\n\n  constructor(sourceMap: SourceMap, originalScopes: OriginalScope[], generatedRanges: GeneratedRange[]) {\n    this.#sourceMap = sourceMap;\n    this.#originalScopes = originalScopes;\n    this.#generatedRanges = generatedRanges;\n  }\n\n  static parseFromMap(\n      sourceMap: SourceMap,\n      sourceMapJson: Pick<SourceMapV3Object, 'names'|'originalScopes'|'generatedRanges'>): SourceMapScopesInfo {\n    if (!sourceMapJson.originalScopes || !sourceMapJson.generatedRanges) {\n      throw new Error('Cant create SourceMapScopesInfo without encoded scopes');\n    }\n    const scopeTrees = decodeOriginalScopes(sourceMapJson.originalScopes, sourceMapJson.names ?? []);\n    const originalScopes = scopeTrees.map(tree => tree.root);\n    const generatedRanges = decodeGeneratedRanges(sourceMapJson.generatedRanges, scopeTrees, sourceMapJson.names ?? []);\n    return new SourceMapScopesInfo(sourceMap, originalScopes, generatedRanges);\n  }\n\n  /**\n   * Given a generated position, returns the original name of the surrounding function as well as\n   * all the original function names that got inlined into the surrounding generated function and their\n   * respective callsites in the original code (ordered from inner to outer).\n   *\n   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,\n   * except the last function (since the last function didn't get inlined).\n   */\n  findInlinedFunctions(generatedLine: number, generatedColumn: number): {name: string, callsite?: OriginalPosition}[] {\n    const result: {name: string, callsite?: OriginalPosition}[] = [];\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n\n    // Walk the generated ranges from the innermost containing range outwards as long as we don't\n    // encounter a range that is a scope in the generated code and a function scope originally.\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      const range = rangeChain[i];\n      const originalScope = range.originalScope;\n\n      // Record the name if the range corresponds to a function scope in the authored code. And it's either a scope in the\n      // generated code as well or it has a callsite info (which indicates inlining).\n      if (originalScope?.kind === 'function' && (range.isFunctionScope || range.callsite)) {\n        result.push({name: originalScope.name ?? '', callsite: range.callsite});\n\n        if (range.isFunctionScope) {\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Given a generated position, this returns all the surrounding generated ranges from outer\n   * to inner.\n   */\n  #findGeneratedRangeChain(line: number, column: number): GeneratedRange[] {\n    const result: GeneratedRange[] = [];\n\n    (function walkRanges(ranges: GeneratedRange[]) {\n      for (const range of ranges) {\n        if (!contains(range, line, column)) {\n          continue;\n        }\n        result.push(range);\n        walkRanges(range.children);\n      }\n    })(this.#generatedRanges);\n\n    return result;\n  }\n\n  /**\n   * @returns true if we have enough info (i.e. variable and binding expressions) to build\n   * a scope view.\n   */\n  hasVariablesAndBindings(): boolean {\n    if (this.#cachedVariablesAndBindingsPresent === null) {\n      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();\n    }\n    return this.#cachedVariablesAndBindingsPresent;\n  }\n\n  #areVariablesAndBindingsPresent(): boolean {\n    // We check whether any original scope has a non-empty list of variables, and\n    // generated ranges with a non-empty binding list.\n\n    function walkTree(nodes: OriginalScope[]|GeneratedRange[]): boolean {\n      for (const node of nodes) {\n        if ('variables' in node && node.variables.length > 0) {\n          return true;\n        }\n\n        if ('values' in node && node.values.some(v => v !== undefined)) {\n          return true;\n        }\n\n        if (walkTree(node.children)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);\n  }\n\n  /**\n   * Constructs a scope chain based on the CallFrame's paused position.\n   *\n   * The algorithm to obtain the original scope chain is straight-forward:\n   *\n   *   1) Find the inner-most generated range that contains the CallFrame's\n   *      paused position.\n   *\n   *   2) Does the found range have an associated original scope?\n   *\n   *      2a) If no, return null. This is a \"hidden\" range and technically\n   *          we shouldn't be pausing here in the first place. This code doesn't\n   *          correspond to anything in the authored code.\n   *\n   *      2b) If yes, the associated original scope is the inner-most\n   *          original scope in the resulting scope chain.\n   *\n   *   3) Walk the parent chain of the found original scope outwards. This is\n   *      our scope view. For each original scope we also try to find a\n   *      corresponding generated range that contains the CallFrame's\n   *      paused position. We need the generated range to resolve variable\n   *      values.\n   */\n  resolveMappedScopeChain(callFrame: CallFrame): ScopeChainEntry[]|null {\n    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);\n    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;\n    if (innerMostOriginalScope === undefined) {\n      return null;\n    }\n\n    // TODO(crbug.com/40277685): Add a sanity check here where we map the paused position using\n    //         the source map's mappings, find the inner-most original scope with that mapped paused\n    //         position and compare that result with `innerMostOriginalScope`. If they don't match we\n    //         should emit a warning about the broken source map as mappings and scopes are inconsistent\n    //         w.r.t. each other.\n\n    let seenFunctionScope = false;\n    const result: SourceMapScopeChainEntry[] = [];\n    // Walk the original scope chain outwards and try to find the corresponding generated range along the way.\n    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {\n      const range = rangeChain.findLast(r => r.originalScope === originalScope);\n      const isFunctionScope = originalScope.kind === 'function';\n      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;\n      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;\n      result.push(\n          new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? undefined));\n      seenFunctionScope ||= isFunctionScope;\n    }\n\n    // If we are paused on a return statement, we need to drop inner block scopes. This is because V8 only emits a\n    // single return bytecode and \"gotos\" at the functions' end, where we are now paused.\n    if (callFrame.returnValue() !== null) {\n      while (result.length && result[0].type() !== Protocol.Debugger.ScopeType.Local) {\n        result.shift();\n      }\n    }\n\n    return result;\n  }\n\n  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */\n  #findGeneratedRangeChainForFrame(callFrame: CallFrame): GeneratedRange[] {\n    const rangeChain =\n        this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    if (callFrame.inlineFrameIndex === 0) {\n      return rangeChain;\n    }\n\n    // Drop ranges in the chain until we reach our desired inlined range.\n    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex;) {\n      const range = rangeChain.pop();\n      if (range?.callsite) {\n        ++inlineIndex;\n      }\n    }\n\n    return rangeChain;\n  }\n}\n\nexport function contains(range: Pick<GeneratedRange, 'start'|'end'>, line: number, column: number): boolean {\n  if (range.start.line > line || (range.start.line === line && range.start.column > column)) {\n    return false;\n  }\n\n  if (range.end.line < line || (range.end.line === line && range.end.column <= column)) {\n    return false;\n  }\n\n  return true;\n}\n"]}