{"version":3,"file":"SourceMapScopesInfo.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapScopesInfo.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {type SourceMapV3Object} from './SourceMap.js';\nimport {\n  decodeGeneratedRanges,\n  decodeOriginalScopes,\n  type GeneratedRange,\n  type OriginalPosition,\n  type OriginalScope,\n} from './SourceMapScopes.js';\n\nexport class SourceMapScopesInfo {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #originalScopes: OriginalScope[];\n  readonly #generatedRanges: GeneratedRange[];\n\n  constructor(originalScopes: OriginalScope[], generatedRanges: GeneratedRange[]) {\n    this.#originalScopes = originalScopes;\n    this.#generatedRanges = generatedRanges;\n  }\n\n  static parseFromMap(sourceMap: Pick<SourceMapV3Object, 'names'|'originalScopes'|'generatedRanges'>):\n      SourceMapScopesInfo {\n    if (!sourceMap.originalScopes || !sourceMap.generatedRanges) {\n      throw new Error('Cant create SourceMapScopesInfo without encoded scopes');\n    }\n    const scopeTrees = decodeOriginalScopes(sourceMap.originalScopes, sourceMap.names ?? []);\n    const originalScopes = scopeTrees.map(tree => tree.root);\n    const generatedRanges = decodeGeneratedRanges(sourceMap.generatedRanges, scopeTrees, sourceMap.names ?? []);\n    return new SourceMapScopesInfo(originalScopes, generatedRanges);\n  }\n\n  /**\n   * Given a generated position, returns the original name of the surrounding function as well as\n   * all the original function names that got inlined into the surrounding generated function and their\n   * respective callsites in the original code (ordered from inner to outer).\n   *\n   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,\n   * except the last function (since the last function didn't get inlined).\n   */\n  findInlinedFunctions(generatedLine: number, generatedColumn: number): {name: string, callsite?: OriginalPosition}[] {\n    const result: {name: string, callsite?: OriginalPosition}[] = [];\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n\n    // Walk the generated ranges from the innermost containing range outwards as long as we don't\n    // encounter a range that is a scope in the generated code and a function scope originally.\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      const range = rangeChain[i];\n      const originalScope = range.originalScope;\n\n      // Record the name if the range corresponds to a function scope in the authored code. And it's either a scope in the\n      // generated code as well or it has a callsite info (which indicates inlining).\n      if (originalScope?.kind === 'function' && (range.isScope || range.callsite)) {\n        result.push({name: originalScope.name ?? '', callsite: range.callsite});\n\n        if (range.isScope) {\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Given a generated position, this returns all the surrounding generated ranges from outer\n   * to inner.\n   */\n  #findGeneratedRangeChain(line: number, column: number): GeneratedRange[] {\n    const result: GeneratedRange[] = [];\n\n    (function walkRanges(ranges: GeneratedRange[]) {\n      for (const range of ranges) {\n        if (!contains(range, line, column)) {\n          continue;\n        }\n        result.push(range);\n        walkRanges(range.children);\n      }\n    })(this.#generatedRanges);\n\n    return result;\n  }\n}\n\nfunction contains(range: GeneratedRange, line: number, column: number): boolean {\n  if (range.start.line > line || (range.start.line === line && range.start.column > column)) {\n    return false;\n  }\n\n  if (range.end.line < line || (range.end.line === line && range.end.column <= column)) {\n    return false;\n  }\n\n  return true;\n}\n"]}