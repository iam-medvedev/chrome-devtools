{"version":3,"file":"TraceLoader.js","sourceRoot":"","sources":["../../../../../front_end/testing/TraceLoader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../generated/protocol.js';\nimport * as Trace from '../models/trace/trace.js';\nimport * as Timeline from '../panels/timeline/timeline.js';\nimport * as TraceBounds from '../services/trace_bounds/trace_bounds.js';\n\n// We maintain two caches:\n// 1. The file contents JSON.parsed for a given trace file.\n// 2. The trace engine models for a given file (used by the traceEngine function)\n// Both the file contents and the model data are not expected to change during\n// the lifetime of an instance of DevTools, so they are safe to cache and\n// re-use across tests to avoid extra time spent loading and parsing the same\n// inputs.\n// In the future once the data layer migration is complete, we can hopefully\n// simplify this into one method that loads the new engine and none of the old\n// ones.\nconst fileContentsCache = new Map<string, Trace.Types.File.Contents>();\n\n// The new engine cache is a map of maps of:\n// trace file name => trace engine configuration => trace data\n//\n// The first map is a Map of string (which is the name of the trace file) to a\n// new map, where the key is the trace engine configuration stringified.\n// This ensures that we cache as much as we can, but if you load the same trace\n// file with different trace engine configurations, we will not use the cache\n// and will reparse. This is required as some of the settings and experiments\n// change if events are kept and dropped.\nconst traceEngineCache = new Map<string, Map<string, {\n                                   parsedTrace: Trace.Handlers.Types.ParsedTrace,\n                                   insights: Trace.Insights.Types.TraceInsightSets | null,\n                                   metadata: Trace.Types.File.MetaData | null,\n                                   model: Trace.TraceModel.Model,\n                                 }>>();\n\nexport interface TraceEngineLoaderOptions {\n  initTraceBounds: boolean;\n}\n\n/**\n * Loads trace files defined as fixtures in front_end/panels/timeline/fixtures/traces.\n *\n * Will automatically cache the results to save time processing the same trace\n * multiple times in a run of the test suite.\n **/\nexport class TraceLoader {\n  /**\n   * Parsing some trace files easily takes up more than our default Mocha timeout\n   * which is 2seconds. So for most tests that include parsing a trace, we have to\n   * increase the timeout. We use this function to ensure we set a consistent\n   * timeout across all trace model tests.\n   * The context might be null when we only render a component example.\n   **/\n  static setTestTimeout(context: Mocha.Context|Mocha.Suite|null): void {\n    if (!context || context.timeout() >= 10_000) {\n      return;\n    }\n    context?.timeout(10_000);\n  }\n\n  /**\n   * Loads a trace file into memory and returns its contents after\n   * JSON.parse-ing them\n   *\n   **/\n  static async fixtureContents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Trace.Types.File.Contents> {\n    TraceLoader.setTestTimeout(context);\n    const cached = fileContentsCache.get(name);\n    if (cached) {\n      return cached;\n    }\n    // Required URLs differ across the component server and the unit tests, so try both.\n    const urlForTest = new URL(`../panels/timeline/fixtures/traces/${name}`, import.meta.url);\n\n    const contents = await loadTraceFileFromURL(urlForTest);\n    fileContentsCache.set(name, contents);\n    return contents;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   **/\n  static async rawEvents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<readonly Trace.Types.Events.Event[]> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    return events;\n  }\n\n  /**\n   * Load the metadata from a trace file (throws if not present).\n   **/\n  static async metadata(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<Trace.Types.File.MetaData> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const metadata = 'metadata' in contents ? contents.metadata : null;\n    if (!metadata) {\n      throw new Error('expected metadata but found none');\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from Trace Engine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawCPUProfile(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Protocol.Profiler.Profile> {\n    const contents = await TraceLoader.fixtureContents(context, name) as unknown as Protocol.Profiler.Profile;\n    return contents;\n  }\n\n  /**\n   * Executes only the new trace engine on the fixture and returns the resulting parsed data.\n   *\n   * @param context The Mocha test context. |allModelsFromFile| function easily\n   * takes up more than our default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example.\n   *\n   * @param file The name of the trace file to be loaded.\n   * The trace file should be in ../panels/timeline/fixtures/traces folder.\n   *\n   * @param options Additional trace options.\n   * @param options.initTraceBounds (defaults to `true`) after the trace is\n   * loaded, the TraceBounds manager will automatically be initialised using\n   * the bounds from the trace.\n   *\n   * @param config The config the new trace engine should run with. Optional,\n   * will fall back to the Default config if not provided.\n   */\n  static async traceEngine(\n      context: Mocha.Context|Mocha.Suite|null, name: string,\n      config: Trace.Types.Configuration.Configuration = Trace.Types.Configuration.defaults()): Promise<{\n    parsedTrace: Trace.Handlers.Types.ParsedTrace,\n    insights: Trace.Insights.Types.TraceInsightSets|null,\n    metadata: Trace.Types.File.MetaData|null,\n  }> {\n    // Force the TraceBounds to be reset to empty. This ensures that in\n    // tests where we are using the new engine data we don't accidentally\n    // rely on the fact that a previous test has set the BoundsManager.\n    TraceBounds.TraceBounds.BoundsManager.instance({forceNew: true});\n\n    const configCacheKey = Trace.Types.Configuration.configToCacheKey(config);\n\n    const fromCache = traceEngineCache.get(name)?.get(configCacheKey);\n\n    // If we have results from the cache, we use those to ensure we keep the\n    // tests speedy and don't re-parse trace files over and over again.\n    if (fromCache) {\n      const syntheticEventsManager = fromCache.model.syntheticTraceEventsManager(0);\n      if (!syntheticEventsManager) {\n        throw new Error('Cached trace engine result did not have a synthetic events manager instance');\n      }\n      Trace.Helpers.SyntheticEvents.SyntheticEventsManager.activate(syntheticEventsManager);\n      TraceLoader.initTraceBoundsManager(fromCache.parsedTrace);\n      Timeline.ModificationsManager.ModificationsManager.reset();\n      Timeline.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(fromCache.model, 0);\n      return {parsedTrace: fromCache.parsedTrace, insights: fromCache.insights, metadata: fromCache.metadata};\n    }\n\n    const fileContents = await TraceLoader.fixtureContents(context, name);\n    const parsedTraceData =\n        await TraceLoader.executeTraceEngineOnFileContents(fileContents, /* emulate fresh recording */ false, config);\n\n    const cacheByName = traceEngineCache.get(name) ?? new Map<string, {\n                          parsedTrace: Trace.Handlers.Types.ParsedTrace,\n                          insights: Trace.Insights.Types.TraceInsightSets | null,\n                          metadata: Trace.Types.File.MetaData | null,\n                          model: Trace.TraceModel.Model,\n                        }>();\n    cacheByName.set(configCacheKey, parsedTraceData);\n    traceEngineCache.set(name, cacheByName);\n\n    TraceLoader.initTraceBoundsManager(parsedTraceData.parsedTrace);\n    Timeline.ModificationsManager.ModificationsManager.reset();\n    Timeline.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(parsedTraceData.model, 0);\n    return {\n      parsedTrace: parsedTraceData.parsedTrace,\n      insights: parsedTraceData.insights,\n      metadata: parsedTraceData.metadata,\n    };\n  }\n\n  /**\n   * Initialise the BoundsManager with the bounds from a trace.\n   * This isn't always required, but some of our code - particularly at the UI\n   * level - rely on this being set. This is always set in the actual panel, but\n   * parsing a trace in a test does not automatically set it.\n   **/\n  static initTraceBoundsManager(data: Trace.Handlers.Types.ParsedTrace): void {\n    TraceBounds.TraceBounds.BoundsManager\n        .instance({\n          forceNew: true,\n        })\n        .resetWithNewBounds(data.Meta.traceBounds);\n  }\n\n  static async executeTraceEngineOnFileContents(\n      contents: Trace.Types.File.Contents, emulateFreshRecording = false,\n      traceEngineConfig?: Trace.Types.Configuration.Configuration): Promise<{\n    model: Trace.TraceModel.Model,\n    metadata: Trace.Types.File.MetaData,\n    parsedTrace: Trace.Handlers.Types.ParsedTrace,\n    insights: Trace.Insights.Types.TraceInsightSets|null,\n  }> {\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return new Promise((resolve, reject) => {\n      const model = Trace.TraceModel.Model.createWithAllHandlers(traceEngineConfig);\n      model.addEventListener(Trace.TraceModel.ModelUpdateEvent.eventName, (event: Event) => {\n        const {data} = event as Trace.TraceModel.ModelUpdateEvent;\n\n        // When we receive the final update from the model, update the recording\n        // state back to waiting.\n        if (Trace.TraceModel.isModelUpdateDataComplete(data)) {\n          const metadata = model.metadata(0);\n          const parsedTrace = model.parsedTrace(0);\n          const insights = model.traceInsights(0);\n          if (metadata && parsedTrace) {\n            resolve({\n              model,\n              metadata,\n              parsedTrace,\n              insights,\n            });\n          } else {\n            reject(new Error('Unable to load trace'));\n          }\n        }\n      });\n\n      void model.parse(events, {metadata, isFreshRecording: emulateFreshRecording}).catch(e => console.error(e));\n    });\n  }\n}\n\n// Below this point are private methods used in the TraceLoader class. These\n// are purposefully not exported, you should use one of the static methods\n// defined above.\n\nasync function loadTraceFileFromURL(url: URL): Promise<Trace.Types.File.Contents> {\n  const response = await fetch(url);\n  if (response.status !== 200) {\n    throw new Error(`Unable to load ${url}`);\n  }\n\n  const contentType = response.headers.get('content-type');\n  const isGzipEncoded = contentType !== null && contentType.includes('gzip');\n  let buffer = await response.arrayBuffer();\n  if (isGzipEncoded) {\n    buffer = await decodeGzipBuffer(buffer);\n  }\n  const decoder = new TextDecoder('utf-8');\n  const contents = JSON.parse(decoder.decode(buffer)) as Trace.Types.File.Contents;\n  return contents;\n}\n\ninterface CompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ninterface DecompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ndeclare const CompressionStream: {\n  prototype: CompressionStream,\n  new (type: string): CompressionStream,\n};\n\ndeclare const DecompressionStream: {\n  prototype: DecompressionStream,\n  new (type: string): DecompressionStream,\n};\n\nfunction codec(buffer: ArrayBuffer, codecStream: CompressionStream|DecompressionStream): Promise<ArrayBuffer> {\n  const {readable, writable} = new TransformStream();\n  const codecReadable = readable.pipeThrough(codecStream);\n\n  const writer = writable.getWriter();\n  void writer.write(buffer);\n  void writer.close();\n\n  // Wrap in a response for convenience.\n  const response = new Response(codecReadable);\n  return response.arrayBuffer();\n}\n\nfunction decodeGzipBuffer(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  return codec(buffer, new DecompressionStream('gzip'));\n}\n"]}