{"version":3,"file":"TraceLoader.js","sourceRoot":"","sources":["../../../../../front_end/testing/TraceLoader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../core/common/common.js';\nimport * as SDK from '../core/sdk/sdk.js';\nimport type * as Protocol from '../generated/protocol.js';\nimport * as Trace from '../models/trace/trace.js';\nimport * as Timeline from '../panels/timeline/timeline.js';\nimport * as TraceBounds from '../services/trace_bounds/trace_bounds.js';\n\n// We maintain two caches:\n// 1. The file contents JSON.parsed for a given trace file.\n// 2. The trace engine models for a given file (used by the traceEngine function)\n// Both the file contents and the model data are not expected to change during\n// the lifetime of an instance of DevTools, so they are safe to cache and\n// re-use across tests to avoid extra time spent loading and parsing the same\n// inputs.\n// In the future once the data layer migration is complete, we can hopefully\n// simplify this into one method that loads the new engine and none of the old\n// ones.\nconst fileContentsCache = new Map<string, Trace.Types.File.Contents>();\n\ninterface ParsedTraceAndModel {\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  model: Trace.TraceModel.Model;\n}\n\n// The new engine cache is a map of maps of:\n// trace file name => trace engine configuration => trace data\n//\n// The first map is a Map of string (which is the name of the trace file) to a\n// new map, where the key is the trace engine configuration stringified.\n// This ensures that we cache as much as we can, but if you load the same trace\n// file with different trace engine configurations, we will not use the cache\n// and will reparse. This is required as some of the settings and experiments\n// change if events are kept and dropped.\nconst traceEngineCache = new Map<string, Map<string, ParsedTraceAndModel>>();\n\nexport interface TraceEngineLoaderOptions {\n  initTraceBounds: boolean;\n}\n\n/**\n * Loads trace files defined as fixtures in front_end/panels/timeline/fixtures/traces.\n *\n * Will automatically cache the results to save time processing the same trace\n * multiple times in a run of the test suite.\n **/\nexport class TraceLoader {\n  /**\n   * Parsing some trace files easily takes up more than our default Mocha timeout\n   * which is 2seconds. So for most tests that include parsing a trace, we have to\n   * increase the timeout. We use this function to ensure we set a consistent\n   * timeout across all trace model tests.\n   **/\n  static setTestTimeout(context: Mocha.Context|Mocha.Suite): void {\n    // Some traces take a long time to process, especially on our CQ machines.\n    // The trace that takes the longest on my Mac M1 Pro is ~3s (yahoo-news.json.gz).\n    // In CQ, that same trace takes ~10s (linux), ~7.5s (mac), ~11.5s (windows).\n    if (context.timeout() > 0) {\n      context.timeout(Math.max(context.timeout(), 30000));\n    }\n  }\n\n  /**\n   * Loads a trace file into memory and returns its contents after\n   * JSON.parse-ing them\n   *\n   **/\n  static async fixtureContents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Trace.Types.File.Contents> {\n    if (context) {\n      TraceLoader.setTestTimeout(context);\n    }\n    const cached = fileContentsCache.get(name);\n    if (cached) {\n      return cached;\n    }\n    const urlForTest = new URL(`../panels/timeline/fixtures/traces/${name}`, import.meta.url);\n\n    const contents = await TraceLoader.loadTraceFileFromURL(urlForTest);\n    fileContentsCache.set(name, contents);\n    return contents;\n  }\n\n  static async traceFile(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<Trace.Types.File.TraceFile> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n    const traceEvents = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return {traceEvents, metadata} as Trace.Types.File.TraceFile;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   **/\n  static async rawEvents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<readonly Trace.Types.Events.Event[]> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    return events;\n  }\n\n  /**\n   * Load the metadata from a trace file (throws if not present).\n   **/\n  static async metadata(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<Trace.Types.File.MetaData> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const metadata = 'metadata' in contents ? contents.metadata : null;\n    if (!metadata) {\n      throw new Error('expected metadata but found none');\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from Trace Engine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawCPUProfile(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Protocol.Profiler.Profile> {\n    const contents = await TraceLoader.fixtureContents(context, name) as unknown as Protocol.Profiler.Profile;\n    return contents;\n  }\n\n  /**\n   * Executes only the new trace engine on the fixture and returns the resulting parsed data.\n   *\n   * @param context The Mocha test context. Processing a trace can easily\n   * takes up longer than the default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example. See TraceLoader.setTestTimeout.\n   * @param file The name of the trace file to be loaded.\n   * The trace file should be in ../panels/timeline/fixtures/traces folder.\n   * @param options Additional trace options.\n   * @param options.initTraceBounds (defaults to `true`) after the trace is\n   * loaded, the TraceBounds manager will automatically be initialised using\n   * the bounds from the trace.\n   * @param config The config the new trace engine should run with. Optional,\n   * will fall back to the Default config if not provided.\n   */\n  static async traceEngine(\n      context: Mocha.Context|Mocha.Suite|null, name: string,\n      config: Trace.Types.Configuration.Configuration = Trace.Types.Configuration.defaults()):\n      Promise<Trace.TraceModel.ParsedTrace> {\n    if (context) {\n      TraceLoader.setTestTimeout(context);\n    }\n    // Force the TraceBounds to be reset to empty. This ensures that in\n    // tests where we are using the new engine data we don't accidentally\n    // rely on the fact that a previous test has set the BoundsManager.\n    TraceBounds.TraceBounds.BoundsManager.instance({forceNew: true});\n\n    const configCacheKey = Trace.Types.Configuration.configToCacheKey(config);\n\n    const fromCache = traceEngineCache.get(name)?.get(configCacheKey);\n\n    // If we have results from the cache, we use those to ensure we keep the\n    // tests speedy and don't re-parse trace files over and over again.\n    if (fromCache) {\n      const parsedTrace = fromCache.parsedTrace;\n      await wrapInTimeout(context, () => {\n        const syntheticEventsManager = fromCache.model.syntheticTraceEventsManager(0);\n        if (!syntheticEventsManager) {\n          throw new Error('Cached trace engine result did not have a synthetic events manager instance');\n        }\n        Trace.Helpers.SyntheticEvents.SyntheticEventsManager.activate(syntheticEventsManager);\n        TraceLoader.initTraceBoundsManager(parsedTrace);\n        Timeline.ModificationsManager.ModificationsManager.reset();\n        Timeline.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(fromCache.model, 0);\n      }, 4_000, 'Initializing state for cached trace');\n      return parsedTrace;\n    }\n\n    const fileContents = await wrapInTimeout(context, async () => {\n      return await TraceLoader.fixtureContents(context, name);\n    }, 15_000, `Loading fixtureContents for ${name}`);\n\n    const parsedTraceFileAndModel = await wrapInTimeout(context, async () => {\n      return await TraceLoader.executeTraceEngineOnFileContents(\n          fileContents, /* emulate fresh recording */ false, config);\n    }, 15_000, `Executing traceEngine for ${name}`);\n\n    const cacheByName = traceEngineCache.get(name) ?? new Map<string, ParsedTraceAndModel>();\n    cacheByName.set(configCacheKey, parsedTraceFileAndModel);\n    traceEngineCache.set(name, cacheByName);\n\n    TraceLoader.initTraceBoundsManager(parsedTraceFileAndModel.parsedTrace);\n    await wrapInTimeout(context, () => {\n      Timeline.ModificationsManager.ModificationsManager.reset();\n      Timeline.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(\n          parsedTraceFileAndModel.model, 0);\n    }, 5_000, `Creating modification manager for ${name}`);\n    return parsedTraceFileAndModel.parsedTrace;\n  }\n\n  /**\n   * Initialise the BoundsManager with the bounds from a trace.\n   * This isn't always required, but some of our code - particularly at the UI\n   * level - rely on this being set. This is always set in the actual panel, but\n   * parsing a trace in a test does not automatically set it.\n   **/\n  static initTraceBoundsManager(parsedTrace: Trace.TraceModel.ParsedTrace): void {\n    TraceBounds.TraceBounds.BoundsManager\n        .instance({\n          forceNew: true,\n        })\n        .resetWithNewBounds(parsedTrace.data.Meta.traceBounds);\n  }\n\n  static async executeTraceEngineOnFileContents(\n      contents: Trace.Types.File.Contents, emulateFreshRecording = false,\n      traceEngineConfig?: Trace.Types.Configuration.Configuration): Promise<ParsedTraceAndModel> {\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return await new Promise((resolve, reject) => {\n      const model = Trace.TraceModel.Model.createWithAllHandlers(traceEngineConfig);\n      model.addEventListener(Trace.TraceModel.ModelUpdateEvent.eventName, (event: Event) => {\n        const {data} = event as Trace.TraceModel.ModelUpdateEvent;\n\n        // When we receive the final update from the model, update the recording\n        // state back to waiting.\n        if (Trace.TraceModel.isModelUpdateDataComplete(data)) {\n          const parsedTrace = model.parsedTrace(0);\n          if (!parsedTrace) {\n            reject(new Error('Unable to load trace'));\n            return;\n          }\n\n          resolve({\n            model,\n            parsedTrace,\n          });\n        }\n      });\n\n      void model\n          .parse(events, {\n            metadata,\n            isFreshRecording: emulateFreshRecording,\n            async resolveSourceMap(params) {\n              const {sourceUrl, sourceMapUrl, cachedRawSourceMap} = params;\n\n              if (cachedRawSourceMap) {\n                return new SDK.SourceMap.SourceMap(sourceUrl, sourceMapUrl, cachedRawSourceMap);\n              }\n\n              if (sourceMapUrl.startsWith('data:')) {\n                const rawSourceMap = await (await fetch(sourceMapUrl)).json();\n                return new SDK.SourceMap.SourceMap(sourceUrl, sourceMapUrl, rawSourceMap);\n              }\n\n              return null;\n            },\n          })\n          .catch(e => console.error(e));\n    });\n  }\n\n  static async loadTraceFileFromURL(url: URL): Promise<Trace.Types.File.TraceFile> {\n    const contents = await fetchFileAsText(url);\n    const traceContents = JSON.parse(contents) as Trace.Types.File.TraceFile;\n    return traceContents;\n  }\n\n  /**\n   * Karma test run in a single context if we load all the traces\n   * we risk getting out of memory\n   */\n  static resetCache() {\n    fileContentsCache.clear();\n    traceEngineCache.clear();\n  }\n}\n\nexport async function fetchFileAsText(url: URL): Promise<string> {\n  const response = await fetch(url);\n  if (response.status !== 200) {\n    throw new Error(`Unable to load ${url}`);\n  }\n\n  const buffer = await response.arrayBuffer();\n  const contents = await Common.Gzip.arrayBufferToString(buffer);\n  return contents;\n}\n\n// Below this point are private methods used in the TraceLoader class. These\n// are purposefully not exported, you should use one of the static methods\n// defined above.\n\n/**\n * Wraps an async Promise with a timeout. We use this to break down and\n * instrument `TraceLoader` to understand on CQ where timeouts occur.\n *\n * @param asyncPromise The Promise representing the async operation to be timed.\n * @param timeoutMs The timeout in milliseconds.\n * @param stepName An identifier for the step (for logging).\n * @returns A promise that resolves with the operation's result, or rejects if it times out.\n */\nasync function wrapInTimeout<T>(\n    mochaContext: Mocha.Context|Mocha.Suite|null, callback: () => Promise<T>| T, timeoutMs: number,\n    stepName: string): Promise<T> {\n  const timeout = Promise.withResolvers<void>();\n  const timeoutId = setTimeout(() => {\n    let testTitle = '(unknown test)';\n    if (mochaContext) {\n      if (isMochaContext(mochaContext)) {\n        testTitle = mochaContext.currentTest?.fullTitle() ?? testTitle;\n      } else {\n        testTitle = mochaContext.fullTitle();\n      }\n    }\n    console.error(`TraceLoader: [${stepName}]: took longer than ${timeoutMs}ms in test \"${testTitle}\"`);\n    timeout.reject(new Error(`Timeout for TraceLoader: '${stepName}' after ${timeoutMs}ms.`));\n  }, timeoutMs);\n\n  // Race the original promise against the timeout promise\n  try {\n    const cbResult = await Promise.race([callback(), timeout.promise]);\n    timeout.resolve();\n    return cbResult as T;\n  } finally {\n    // Clear the timeout if the original promise resolves/rejects,\n    // or if the timeout promise wins the race.\n    clearTimeout(timeoutId);\n  }\n}\n\nfunction isMochaContext(arg: unknown): arg is Mocha.Context {\n  return typeof arg === 'object' && arg !== null && 'currentTest' in arg;\n}\n"]}