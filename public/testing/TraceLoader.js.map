{"version":3,"file":"TraceLoader.js","sourceRoot":"","sources":["../../../../../front_end/testing/TraceLoader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../generated/protocol.js';\nimport * as TimelineModel from '../models/timeline_model/timeline_model.js';\nimport * as TraceEngine from '../models/trace/trace.js';\nimport * as Timeline from '../panels/timeline/timeline.js';\nimport * as TraceBounds from '../services/trace_bounds/trace_bounds.js';\n\n// We maintain three caches:\n// 1. The file contents JSON.parsed for a given trace file.\n// 2. The created set of models for a given file (used by the allModels function)\n// 3. The trace engine models for a given file (used by the traceEngine function)\n// Both the file contents and the model data are not expected to change during\n// the lifetime of an instance of DevTools, so they are safe to cache and\n// re-use across tests to avoid extra time spent loading and parsing the same\n// inputs.\n// In the future once the data layer migration is complete, we can hopefully\n// simplify this into one method that loads the new engine and none of the old\n// ones.\nconst fileContentsCache = new Map<string, TraceEngine.Types.File.Contents>();\n\n// The new engine cache is a map of maps of:\n// trace file name => trace engine configuration => trace data\n//\n// The first map is a Map of string (which is the name of the trace file) to a\n// new map, where the key is the trace engine configuration stringified.\n// This ensures that we cache as much as we can, but if you load the same trace\n// file with different trace engine configurations, we will not use the cache\n// and will reparse. This is required as some of the settings and experiments\n// change if events are kept and dropped.\nconst traceEngineCache = new Map<string, Map<string, TraceEngine.Handlers.Types.TraceParseData>>();\n\nexport type AllModelsLoaded = Readonly<{\n  tracingModel: TraceEngine.Legacy.TracingModel,\n  timelineModel: TimelineModel.TimelineModel.TimelineModelImpl,\n  performanceModel: Timeline.PerformanceModel.PerformanceModel,\n  traceParsedData: TraceEngine.Handlers.Types.TraceParseData,\n}>;\nconst allModelsCache = new Map<string, AllModelsLoaded>();\n\n/**\n * Loads trace files defined as fixtures in front_end/panels/timeline/fixtures/traces.\n *\n * Will automatically cache the results to save time processing the same trace\n * multiple times in a run of the test suite.\n **/\nexport class TraceLoader {\n  /**\n   * Parsing some trace files easily takes up more than our default Mocha timeout\n   * which is 2seconds. So for most tests that include parsing a trace, we have to\n   * increase the timeout. We use this function to ensure we set a consistent\n   * timeout across all trace model tests.\n   * The context might be null when we only render a component example.\n   **/\n  static setTestTimeout(context: Mocha.Context|Mocha.Suite|null): void {\n    if (!context || context.timeout() >= 10_000) {\n      return;\n    }\n    context?.timeout(10_000);\n  }\n\n  /**\n   * Loads a trace file into memory and returns its contents after\n   * JSON.parse-ing them\n   *\n   **/\n  static async fixtureContents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<TraceEngine.Types.File.Contents> {\n    TraceLoader.setTestTimeout(context);\n    const cached = fileContentsCache.get(name);\n    if (cached) {\n      return cached;\n    }\n    // Required URLs differ across the component server and the unit tests, so try both.\n    const urlForTest = new URL(`../front_end/panels/timeline/fixtures/traces/${name}`, window.location.origin);\n    const urlForComponentExample =\n        new URL(`../front_end/panels/timeline/fixtures/traces/${name}`, window.location.origin);\n\n    if (window.location.pathname.includes('ui/components/docs') ||\n        window.location.pathname.includes('ui\\\\components\\\\docs')) {\n      const contents = await loadTraceFileFromURL(urlForComponentExample);\n      fileContentsCache.set(name, contents);\n      return contents;\n    }\n    const contents = await loadTraceFileFromURL(urlForTest);\n    fileContentsCache.set(name, contents);\n    return contents;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from TraceEngine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawEvents<T extends TraceEngine.Types.TraceEvents.TraceEventData|TraceEngine.TracingManager\n                                       .EventPayload = TraceEngine.Types.TraceEvents.TraceEventData>(\n      context: Mocha.Context|Mocha.Suite|null, name: string): Promise<readonly T[]> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    return events as unknown as T[];\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from TraceEngine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawCPUProfile(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Protocol.Profiler.Profile> {\n    const contents = await TraceLoader.fixtureContents(context, name) as unknown as Protocol.Profiler.Profile;\n    return contents;\n  }\n\n  /**\n   * Executes only the new trace engine on the fixture and returns the resulting parsed data.\n   *\n   * @param context The Mocha test context. |allModelsFromFile| function easily\n   * takes up more than our default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example.\n   *\n   * @param file The name of the trace file to be loaded.\n   * The trace file should be in ../panels/timeline/fixtures/traces folder.\n   *\n   * @param config The config the new trace engine should run with. Optional,\n   * will fall back to the Default config if not provided.\n   */\n  static async traceEngine(\n      context: Mocha.Context|Mocha.Suite|null, name: string,\n      config: TraceEngine.Types.Configuration.Configuration = TraceEngine.Types.Configuration.DEFAULT):\n      Promise<TraceEngine.Handlers.Types.TraceParseData> {\n    const configCacheKey = TraceEngine.Types.Configuration.configToCacheKey(config);\n\n    const fromCache = traceEngineCache.get(name)?.get(configCacheKey);\n    if (fromCache) {\n      return fromCache;\n    }\n    const fileContents = await TraceLoader.fixtureContents(context, name);\n    const traceEngineData =\n        await TraceLoader.executeTraceEngineOnFileContents(fileContents, /* emulate fresh recording */ false, config);\n\n    const cacheByName = traceEngineCache.get(name) || new Map<string, TraceEngine.Handlers.Types.TraceParseData>();\n    cacheByName.set(configCacheKey, traceEngineData.traceParsedData);\n    traceEngineCache.set(name, cacheByName);\n\n    return traceEngineData.traceParsedData;\n  }\n\n  /**\n   * Returns tracingModel, timelineModel, performanceModel, traceParsedData\n   * from the given trace file.\n   *\n   * @param context The Mocha test context. |allModelsFromFile| function easily\n   * takes up more than our default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example.\n   * @param file The name of the trace file to be loaded. The trace file should\n   * be in ../panels/timeline/fixtures/traces folder.\n   * @returns tracingModel, timelineModel, performanceModel, traceParsedData\n   * from this trace file\n   */\n  static async allModels(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<AllModelsLoaded> {\n    const fromCache = allModelsCache.get(name);\n    if (fromCache) {\n      return fromCache;\n    }\n    // Load the contents of the file and get the array of all the events.\n    let fileContents = await TraceLoader.fixtureContents(context, name);\n    if (name.endsWith('.cpuprofile.gz')) {\n      const rawEvents = await TraceLoader.rawCPUProfile(context, name);\n      fileContents = TimelineModel.TimelineJSProfile.TimelineJSProfileProcessor.createFakeTraceFromCpuProfile(\n                         rawEvents,\n                         1,\n                         true,\n                         ) as unknown as TraceEngine.Types.TraceEvents.TraceEventData[];\n    }\n\n    const events = 'traceEvents' in fileContents ? fileContents.traceEvents : fileContents;\n\n    // Execute the new trace engine\n    const traceEngineData = await TraceLoader.executeTraceEngineOnFileContents(fileContents);\n\n    // Execute and populate the legacy models\n    const tracingModel = new TraceEngine.Legacy.TracingModel();\n    const performanceModel = new Timeline.PerformanceModel.PerformanceModel();\n    tracingModel.addEvents(events as unknown as TraceEngine.TracingManager.EventPayload[]);\n    tracingModel.tracingComplete();\n    await performanceModel.setTracingModel(tracingModel);\n    const timelineModel = performanceModel.timelineModel();\n\n    TraceBounds.TraceBounds.BoundsManager\n        .instance({\n          forceNew: true,\n        })\n        .resetWithNewBounds(traceEngineData.traceParsedData.Meta.traceBounds);\n\n    const result: AllModelsLoaded = {\n      tracingModel,\n      timelineModel,\n      performanceModel,\n      traceParsedData: traceEngineData.traceParsedData,\n    };\n    allModelsCache.set(name, result);\n    return result;\n  }\n\n  static async executeTraceEngineOnFileContents(\n      contents: TraceEngine.Types.File.Contents, emulateFreshRecording = false,\n      traceEngineConfig?: TraceEngine.Types.Configuration.Configuration): Promise<{\n    metadata: TraceEngine.Types.File.MetaData,\n    traceParsedData: TraceEngine.Handlers.Types.TraceParseData,\n  }> {\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    return new Promise((resolve, reject) => {\n      const model = TraceEngine.TraceModel.Model.createWithAllHandlers(traceEngineConfig);\n      model.addEventListener(TraceEngine.TraceModel.ModelUpdateEvent.eventName, (event: Event) => {\n        const {data} = event as TraceEngine.TraceModel.ModelUpdateEvent;\n\n        // When we receive the final update from the model, update the recording\n        // state back to waiting.\n        if (TraceEngine.TraceModel.isModelUpdateDataComplete(data)) {\n          const metadata = model.metadata(0);\n          const traceParsedData = model.traceParsedData(0);\n          if (metadata && traceParsedData) {\n            resolve({\n              metadata,\n              traceParsedData,\n            });\n          } else {\n            reject(new Error('Unable to load trace'));\n          }\n        }\n      });\n\n      void model.parse(events, {metadata: {}, isFreshRecording: emulateFreshRecording}).catch(e => console.error(e));\n    });\n  }\n}\n\n// Below this point are private methods used in the TraceLoader class. These\n// are purposefully not exported, you should use one of the static methods\n// defined above.\n\nasync function loadTraceFileFromURL(url: URL): Promise<TraceEngine.Types.File.Contents> {\n  const response = await fetch(url);\n  if (response.status !== 200) {\n    throw new Error(`Unable to load ${url}`);\n  }\n\n  const contentType = response.headers.get('content-type');\n  const isGzipEncoded = contentType !== null && contentType.includes('gzip');\n  let buffer = await response.arrayBuffer();\n  if (isGzipEncoded) {\n    buffer = await decodeGzipBuffer(buffer);\n  }\n  const decoder = new TextDecoder('utf-8');\n  const contents = JSON.parse(decoder.decode(buffer)) as TraceEngine.Types.File.Contents;\n  return contents;\n}\n\ninterface CompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ninterface DecompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ndeclare const CompressionStream: {\n  prototype: CompressionStream,\n  new (type: string): CompressionStream,\n};\n\ndeclare const DecompressionStream: {\n  prototype: DecompressionStream,\n  new (type: string): DecompressionStream,\n};\n\nfunction codec(buffer: ArrayBuffer, codecStream: CompressionStream|DecompressionStream): Promise<ArrayBuffer> {\n  const {readable, writable} = new TransformStream();\n  const codecReadable = readable.pipeThrough(codecStream);\n\n  const writer = writable.getWriter();\n  void writer.write(buffer);\n  void writer.close();\n\n  // Wrap in a response for convenience.\n  const response = new Response(codecReadable);\n  return response.arrayBuffer();\n}\n\nfunction decodeGzipBuffer(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  return codec(buffer, new DecompressionStream('gzip'));\n}\n"]}