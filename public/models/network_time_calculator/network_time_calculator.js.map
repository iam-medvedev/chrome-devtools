{
  "version": 3,
  "sources": ["../../../../../../front_end/models/network_time_calculator/NetworkTimeCalculator.ts", "../../../../../../front_end/models/network_time_calculator/RequestTimeRanges.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2008, 2009 Anthony Ricaud <rik@webkit.org>\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\n\nimport type {Calculator} from './Calculator.js';\n\nconst UIStrings = {\n  /**\n   * @description Latency download total format in Network Time Calculator of the Network panel\n   * @example {20ms} PH1\n   * @example {20ms} PH2\n   * @example {40ms} PH3\n   */\n  sLatencySDownloadSTotal: '{PH1} latency, {PH2} download ({PH3} total)',\n  /**\n   * @description Latency format in Network Time Calculator of the Network panel\n   * @example {20ms} PH1\n   */\n  sLatency: '{PH1} latency',\n  /**\n   * @description Duration of the download in ms/s shown for a completed network request.\n   * @example {5ms} PH1\n   */\n  sDownload: '{PH1} download',\n  /**\n   * @description From service worker format in Network Time Calculator of the Network panel\n   * @example {20ms latency} PH1\n   */\n  sFromServiceworker: '{PH1} (from `ServiceWorker`)',\n  /**\n   * @description From cache format in Network Time Calculator of the Network panel\n   * @example {20ms latency} PH1\n   */\n  sFromCache: '{PH1} (from cache)',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('models/network_time_calculator/NetworkTimeCalculator.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface Label {\n  left: string;\n  right: string;\n  tooltip?: string;\n}\n\nexport class NetworkTimeBoundary {\n  minimum: number;\n  maximum: number;\n  constructor(minimum: number, maximum: number) {\n    this.minimum = minimum;\n    this.maximum = maximum;\n  }\n\n  equals(other: NetworkTimeBoundary): boolean {\n    return (this.minimum === other.minimum) && (this.maximum === other.maximum);\n  }\n}\n\nexport class NetworkTimeCalculator extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements Calculator {\n  #minimumBoundary = -1;\n  #maximumBoundary = -1;\n  readonly #boundaryChangedEventThrottler = new Common.Throttler.Throttler(0);\n  #window: NetworkTimeBoundary|null = null;\n  #workingArea?: number;\n\n  startAtZero: boolean;\n\n  constructor(startAtZero: boolean) {\n    super();\n    this.startAtZero = startAtZero;\n  }\n\n  setWindow(window: NetworkTimeBoundary|null): void {\n    this.#window = window;\n    this.boundaryChanged();\n  }\n\n  computePosition(time: number): number {\n    return (time - this.minimumBoundary()) / this.boundarySpan() * (this.#workingArea || 0);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value, Boolean(precision));\n  }\n\n  minimumBoundary(): number {\n    return this.#window ? this.#window.minimum : this.#minimumBoundary;\n  }\n\n  zeroTime(): number {\n    return this.#minimumBoundary;\n  }\n\n  maximumBoundary(): number {\n    return this.#window ? this.#window.maximum : this.#maximumBoundary;\n  }\n\n  boundary(): NetworkTimeBoundary {\n    return new NetworkTimeBoundary(this.minimumBoundary(), this.maximumBoundary());\n  }\n\n  boundarySpan(): number {\n    return this.maximumBoundary() - this.minimumBoundary();\n  }\n\n  reset(): void {\n    this.#minimumBoundary = -1;\n    this.#maximumBoundary = -1;\n    this.boundaryChanged();\n  }\n\n  value(): number {\n    return 0;\n  }\n\n  setDisplayWidth(clientWidth: number): void {\n    this.#workingArea = clientWidth;\n  }\n\n  computeBarGraphPercentages(request: SDK.NetworkRequest.NetworkRequest): {\n    start: number,\n    middle: number,\n    end: number,\n  } {\n    let start;\n    let middle;\n    let end;\n    if (request.startTime !== -1) {\n      start = ((request.startTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      start = 0;\n    }\n\n    if (request.responseReceivedTime !== -1) {\n      middle = ((request.responseReceivedTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      middle = (this.startAtZero ? start : 100);\n    }\n\n    if (request.endTime !== -1) {\n      end = ((request.endTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      end = (this.startAtZero ? middle : 100);\n    }\n\n    if (this.startAtZero) {\n      end -= start;\n      middle -= start;\n      start = 0;\n    }\n\n    return {start, middle, end};\n  }\n\n  boundaryChanged(): void {\n    void this.#boundaryChangedEventThrottler.schedule(async () => {\n      this.dispatchEventToListeners(Events.BOUNDARIES_CHANGED);\n    });\n  }\n\n  updateBoundariesForEventTime(eventTime: number): void {\n    if (eventTime === -1 || this.startAtZero) {\n      return;\n    }\n\n    if (this.#maximumBoundary === undefined || eventTime > this.#maximumBoundary) {\n      this.#maximumBoundary = eventTime;\n      this.boundaryChanged();\n    }\n  }\n\n  computeBarGraphLabels(request: SDK.NetworkRequest.NetworkRequest): Label {\n    let rightLabel = '';\n    if (request.responseReceivedTime !== -1 && request.endTime !== -1) {\n      rightLabel = i18n.TimeUtilities.secondsToString(request.endTime - request.responseReceivedTime);\n    }\n\n    const hasLatency = request.latency > 0;\n    const leftLabel = hasLatency ? i18n.TimeUtilities.secondsToString(request.latency) : rightLabel;\n\n    if (request.timing) {\n      return {left: leftLabel, right: rightLabel, tooltip: undefined};\n    }\n\n    let tooltip;\n    if (hasLatency && rightLabel) {\n      const total = i18n.TimeUtilities.secondsToString(request.duration);\n      tooltip = i18nString(UIStrings.sLatencySDownloadSTotal, {PH1: leftLabel, PH2: rightLabel, PH3: total});\n    } else if (hasLatency) {\n      tooltip = i18nString(UIStrings.sLatency, {PH1: leftLabel});\n    } else if (rightLabel) {\n      tooltip = i18nString(UIStrings.sDownload, {PH1: rightLabel});\n    }\n\n    if (request.fetchedViaServiceWorker) {\n      tooltip = i18nString(UIStrings.sFromServiceworker, {PH1: String(tooltip)});\n    } else if (request.cached()) {\n      tooltip = i18nString(UIStrings.sFromCache, {PH1: String(tooltip)});\n    }\n    return {left: leftLabel, right: rightLabel, tooltip};\n  }\n\n  updateBoundaries(request: SDK.NetworkRequest.NetworkRequest): void {\n    const lowerBound = this.lowerBound(request);\n    const upperBound = this.upperBound(request);\n    let changed = false;\n    if (lowerBound !== -1 || this.startAtZero) {\n      changed = this.extendBoundariesToIncludeTimestamp(this.startAtZero ? 0 : lowerBound);\n    }\n    if (upperBound !== -1) {\n      changed = this.extendBoundariesToIncludeTimestamp(upperBound) || changed;\n    }\n    if (changed) {\n      this.boundaryChanged();\n    }\n  }\n\n  extendBoundariesToIncludeTimestamp(timestamp: number): boolean {\n    const previousMinimumBoundary = this.#minimumBoundary;\n    const previousMaximumBoundary = this.#maximumBoundary;\n    const minOffset = MINIMUM_SPREAD;\n    if (this.#minimumBoundary === -1 || this.#maximumBoundary === -1) {\n      this.#minimumBoundary = timestamp;\n      this.#maximumBoundary = timestamp + minOffset;\n    } else {\n      this.#minimumBoundary = Math.min(timestamp, this.#minimumBoundary);\n      this.#maximumBoundary = Math.max(timestamp, this.#minimumBoundary + minOffset, this.#maximumBoundary);\n    }\n    return previousMinimumBoundary !== this.#minimumBoundary || previousMaximumBoundary !== this.#maximumBoundary;\n  }\n\n  lowerBound(_request: SDK.NetworkRequest.NetworkRequest): number {\n    return 0;\n  }\n\n  upperBound(_request: SDK.NetworkRequest.NetworkRequest): number {\n    return 0;\n  }\n}\n\nconst MINIMUM_SPREAD = 0.1;\n\nexport const enum Events {\n  BOUNDARIES_CHANGED = 'BoundariesChanged',\n}\n\nexport interface EventTypes {\n  [Events.BOUNDARIES_CHANGED]: void;\n}\n\nexport class NetworkTransferTimeCalculator extends NetworkTimeCalculator {\n  constructor() {\n    super(false);\n  }\n\n  override formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value - this.zeroTime(), Boolean(precision));\n  }\n\n  override lowerBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.issueTime();\n  }\n\n  override upperBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.endTime;\n  }\n}\n\nexport class NetworkTransferDurationCalculator extends NetworkTimeCalculator {\n  constructor() {\n    super(true);\n  }\n\n  override formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value, Boolean(precision));\n  }\n\n  override upperBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.duration;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nexport const enum RequestTimeRangeNames {\n  PUSH = 'push',\n  QUEUEING = 'queueing',\n  BLOCKING = 'blocking',\n  CONNECTING = 'connecting',\n  DNS = 'dns',\n  PROXY = 'proxy',\n  RECEIVING = 'receiving',\n  RECEIVING_PUSH = 'receiving-push',\n  SENDING = 'sending',\n  SERVICE_WORKER = 'serviceworker',\n  SERVICE_WORKER_PREPARATION = 'serviceworker-preparation',\n  SERVICE_WORKER_RESPOND_WITH = 'serviceworker-respondwith',\n  SERVICE_WORKER_ROUTER_EVALUATION = 'serviceworker-routerevaluation',\n  SERVICE_WORKER_CACHE_LOOKUP = 'serviceworker-cachelookup',\n  SSL = 'ssl',\n  TOTAL = 'total',\n  WAITING = 'waiting',\n}\n\nexport const ServiceWorkerRangeNames = new Set<RequestTimeRangeNames>([\n  RequestTimeRangeNames.SERVICE_WORKER,\n  RequestTimeRangeNames.SERVICE_WORKER_PREPARATION,\n  RequestTimeRangeNames.SERVICE_WORKER_RESPOND_WITH,\n  RequestTimeRangeNames.SERVICE_WORKER_ROUTER_EVALUATION,\n  RequestTimeRangeNames.SERVICE_WORKER_CACHE_LOOKUP,\n]);\n\nexport const ConnectionSetupRangeNames = new Set<RequestTimeRangeNames>([\n  RequestTimeRangeNames.QUEUEING,\n  RequestTimeRangeNames.BLOCKING,\n  RequestTimeRangeNames.CONNECTING,\n  RequestTimeRangeNames.DNS,\n  RequestTimeRangeNames.PROXY,\n  RequestTimeRangeNames.SSL,\n]);\n\nexport interface RequestTimeRange {\n  name: RequestTimeRangeNames;\n  start: number;\n  end: number;\n}\n\nexport function calculateRequestTimeRanges(\n    request: SDK.NetworkRequest.NetworkRequest, navigationStart: number): RequestTimeRange[] {\n  const result: RequestTimeRange[] = [];\n  function addRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    if (start < Number.MAX_VALUE && start <= end) {\n      result.push({name, start, end});\n    }\n  }\n\n  function firstPositive(numbers: number[]): number|undefined {\n    for (let i = 0; i < numbers.length; ++i) {\n      if (numbers[i] > 0) {\n        return numbers[i];\n      }\n    }\n    return undefined;\n  }\n\n  function addOffsetRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    if (start >= 0 && end >= 0) {\n      addRange(name, startTime + (start / 1000), startTime + (end / 1000));\n    }\n  }\n\n  /**\n   * In some situations, argument `start` may come before `startTime` (`timing.requestStart`). This is especially true\n   * in cases such as SW static routing API where fields like `workerRouterEvaluationStart` or `workerCacheLookupStart`\n   * is set before setting `timing.requestStart`. If the `start` and `end` is known to be a valid value (i.e. not default\n   * invalid value -1 or undefined), we allow adding the range.\n   **/\n  function addMaybeNegativeOffsetRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    addRange(name, startTime + (start / 1000), startTime + (end / 1000));\n  }\n\n  const timing = request.timing;\n  if (!timing) {\n    const start = request.issueTime() !== -1 ? request.issueTime() : request.startTime !== -1 ? request.startTime : 0;\n    const hasDifferentIssueAndStartTime =\n        request.issueTime() !== -1 && request.startTime !== -1 && request.issueTime() !== request.startTime;\n    const middle = (request.responseReceivedTime === -1) ?\n        (hasDifferentIssueAndStartTime ? request.startTime : Number.MAX_VALUE) :\n        request.responseReceivedTime;\n    const end = (request.endTime === -1) ? Number.MAX_VALUE : request.endTime;\n    addRange(RequestTimeRangeNames.TOTAL, start, end);\n    addRange(RequestTimeRangeNames.BLOCKING, start, middle);\n    const state =\n        request.responseReceivedTime === -1 ? RequestTimeRangeNames.CONNECTING : RequestTimeRangeNames.RECEIVING;\n    addRange(state, middle, end);\n    return result;\n  }\n\n  const issueTime = request.issueTime();\n  const startTime = timing.requestTime;\n  const endTime = firstPositive([request.endTime, request.responseReceivedTime]) || startTime;\n\n  addRange(RequestTimeRangeNames.TOTAL, issueTime < startTime ? issueTime : startTime, endTime);\n  if (timing.pushStart) {\n    const pushEnd = timing.pushEnd || endTime;\n    // Only show the part of push that happened after the navigation/reload.\n    // Pushes that happened on the same connection before we started main request will not be shown.\n    if (pushEnd > navigationStart) {\n      addRange(RequestTimeRangeNames.PUSH, Math.max(timing.pushStart, navigationStart), pushEnd);\n    }\n  }\n  if (issueTime < startTime) {\n    addRange(RequestTimeRangeNames.QUEUEING, issueTime, startTime);\n  }\n\n  const responseReceived = (request.responseReceivedTime - startTime) * 1000;\n  if (request.fetchedViaServiceWorker) {\n    addOffsetRange(RequestTimeRangeNames.BLOCKING, 0, timing.workerStart);\n    addOffsetRange(RequestTimeRangeNames.SERVICE_WORKER_PREPARATION, timing.workerStart, timing.workerReady);\n    addOffsetRange(\n        RequestTimeRangeNames.SERVICE_WORKER_RESPOND_WITH, timing.workerFetchStart, timing.workerRespondWithSettled);\n    addOffsetRange(RequestTimeRangeNames.SERVICE_WORKER, timing.workerReady, timing.sendEnd);\n    addOffsetRange(RequestTimeRangeNames.WAITING, timing.sendEnd, responseReceived);\n  } else if (!timing.pushStart) {\n    const blockingEnd = firstPositive([timing.dnsStart, timing.connectStart, timing.sendStart, responseReceived]) || 0;\n    addOffsetRange(RequestTimeRangeNames.BLOCKING, 0, blockingEnd);\n    addOffsetRange(RequestTimeRangeNames.PROXY, timing.proxyStart, timing.proxyEnd);\n    addOffsetRange(RequestTimeRangeNames.DNS, timing.dnsStart, timing.dnsEnd);\n    addOffsetRange(RequestTimeRangeNames.CONNECTING, timing.connectStart, timing.connectEnd);\n    addOffsetRange(RequestTimeRangeNames.SSL, timing.sslStart, timing.sslEnd);\n    addOffsetRange(RequestTimeRangeNames.SENDING, timing.sendStart, timing.sendEnd);\n    addOffsetRange(\n        RequestTimeRangeNames.WAITING,\n        Math.max(timing.sendEnd, timing.connectEnd, timing.dnsEnd, timing.proxyEnd, blockingEnd), responseReceived);\n  }\n\n  const {serviceWorkerRouterInfo} = request;\n  if (serviceWorkerRouterInfo) {\n    if (timing.workerRouterEvaluationStart) {\n      // Depending on the source,the next timestamp will be different. Determine the timestamp by checking\n      // the matched and actual source.\n      let routerEvaluationEnd = timing.sendStart;\n      if (serviceWorkerRouterInfo?.matchedSourceType === Protocol.Network.ServiceWorkerRouterSource.Cache &&\n          timing.workerCacheLookupStart) {\n        routerEvaluationEnd = timing.workerCacheLookupStart;\n      } else if (serviceWorkerRouterInfo?.actualSourceType === Protocol.Network.ServiceWorkerRouterSource.FetchEvent) {\n        routerEvaluationEnd = timing.workerStart;\n      }\n      addMaybeNegativeOffsetRange(\n          RequestTimeRangeNames.SERVICE_WORKER_ROUTER_EVALUATION, timing.workerRouterEvaluationStart,\n          routerEvaluationEnd);\n    }\n\n    if (timing.workerCacheLookupStart) {\n      let cacheLookupEnd = timing.sendStart;\n      if (serviceWorkerRouterInfo?.actualSourceType === Protocol.Network.ServiceWorkerRouterSource.Cache) {\n        cacheLookupEnd = timing.receiveHeadersStart;\n      }\n      addMaybeNegativeOffsetRange(\n          RequestTimeRangeNames.SERVICE_WORKER_CACHE_LOOKUP, timing.workerCacheLookupStart, cacheLookupEnd);\n    }\n  }\n\n  if (request.endTime !== -1) {\n    addRange(\n        timing.pushStart ? RequestTimeRangeNames.RECEIVING_PUSH : RequestTimeRangeNames.RECEIVING,\n        request.responseReceivedTime, endTime);\n  }\n\n  return result;\n}\n"],
  "mappings": ";AAkCA,YAAY,YAAY;AACxB,YAAY,UAAU;AAKtB,IAAM,YAAY;;;;;;;EAOhB,yBAAyB;;;;;EAKzB,UAAU;;;;;EAKV,WAAW;;;;;EAKX,oBAAoB;;;;;EAKpB,YAAY;;AAEd,IAAM,OAAY,UAAK,kBAAkB,2DAA2D,SAAS;AAC7G,IAAM,aAAkB,UAAK,mBAAmB,KAAK,QAAW,IAAI;AAQ9D,IAAO,sBAAP,MAA0B;EAC9B;EACA;EACA,YAAY,SAAiB,SAAe;AAC1C,SAAK,UAAU;AACf,SAAK,UAAU;EACjB;EAEA,OAAO,OAA0B;AAC/B,WAAQ,KAAK,YAAY,MAAM,WAAa,KAAK,YAAY,MAAM;EACrE;;AAGI,IAAO,wBAAP,cAA4C,qBAAc,cAAyB;EACvF,mBAAmB;EACnB,mBAAmB;EACV,iCAAiC,IAAW,iBAAU,UAAU,CAAC;EAC1E,UAAoC;EACpC;EAEA;EAEA,YAAY,aAAoB;AAC9B,UAAK;AACL,SAAK,cAAc;EACrB;EAEA,UAAU,QAAgC;AACxC,SAAK,UAAU;AACf,SAAK,gBAAe;EACtB;EAEA,gBAAgB,MAAY;AAC1B,YAAQ,OAAO,KAAK,gBAAe,KAAM,KAAK,aAAY,KAAM,KAAK,gBAAgB;EACvF;EAEA,YAAY,OAAe,WAAkB;AAC3C,WAAY,mBAAc,gBAAgB,OAAO,QAAQ,SAAS,CAAC;EACrE;EAEA,kBAAe;AACb,WAAO,KAAK,UAAU,KAAK,QAAQ,UAAU,KAAK;EACpD;EAEA,WAAQ;AACN,WAAO,KAAK;EACd;EAEA,kBAAe;AACb,WAAO,KAAK,UAAU,KAAK,QAAQ,UAAU,KAAK;EACpD;EAEA,WAAQ;AACN,WAAO,IAAI,oBAAoB,KAAK,gBAAe,GAAI,KAAK,gBAAe,CAAE;EAC/E;EAEA,eAAY;AACV,WAAO,KAAK,gBAAe,IAAK,KAAK,gBAAe;EACtD;EAEA,QAAK;AACH,SAAK,mBAAmB;AACxB,SAAK,mBAAmB;AACxB,SAAK,gBAAe;EACtB;EAEA,QAAK;AACH,WAAO;EACT;EAEA,gBAAgB,aAAmB;AACjC,SAAK,eAAe;EACtB;EAEA,2BAA2B,SAA0C;AAKnE,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,QAAQ,cAAc,IAAI;AAC5B,eAAU,QAAQ,YAAY,KAAK,gBAAe,KAAM,KAAK,aAAY,IAAM;IACjF,OAAO;AACL,cAAQ;IACV;AAEA,QAAI,QAAQ,yBAAyB,IAAI;AACvC,gBAAW,QAAQ,uBAAuB,KAAK,gBAAe,KAAM,KAAK,aAAY,IAAM;IAC7F,OAAO;AACL,eAAU,KAAK,cAAc,QAAQ;IACvC;AAEA,QAAI,QAAQ,YAAY,IAAI;AAC1B,aAAQ,QAAQ,UAAU,KAAK,gBAAe,KAAM,KAAK,aAAY,IAAM;IAC7E,OAAO;AACL,YAAO,KAAK,cAAc,SAAS;IACrC;AAEA,QAAI,KAAK,aAAa;AACpB,aAAO;AACP,gBAAU;AACV,cAAQ;IACV;AAEA,WAAO,EAAC,OAAO,QAAQ,IAAG;EAC5B;EAEA,kBAAe;AACb,SAAK,KAAK,+BAA+B,SAAS,YAAW;AAC3D,WAAK;QAAwB;;MAAA;IAC/B,CAAC;EACH;EAEA,6BAA6B,WAAiB;AAC5C,QAAI,cAAc,MAAM,KAAK,aAAa;AACxC;IACF;AAEA,QAAI,KAAK,qBAAqB,UAAa,YAAY,KAAK,kBAAkB;AAC5E,WAAK,mBAAmB;AACxB,WAAK,gBAAe;IACtB;EACF;EAEA,sBAAsB,SAA0C;AAC9D,QAAI,aAAa;AACjB,QAAI,QAAQ,yBAAyB,MAAM,QAAQ,YAAY,IAAI;AACjE,mBAAkB,mBAAc,gBAAgB,QAAQ,UAAU,QAAQ,oBAAoB;IAChG;AAEA,UAAM,aAAa,QAAQ,UAAU;AACrC,UAAM,YAAY,aAAkB,mBAAc,gBAAgB,QAAQ,OAAO,IAAI;AAErF,QAAI,QAAQ,QAAQ;AAClB,aAAO,EAAC,MAAM,WAAW,OAAO,YAAY,SAAS,OAAS;IAChE;AAEA,QAAI;AACJ,QAAI,cAAc,YAAY;AAC5B,YAAM,QAAa,mBAAc,gBAAgB,QAAQ,QAAQ;AACjE,gBAAU,WAAW,UAAU,yBAAyB,EAAC,KAAK,WAAW,KAAK,YAAY,KAAK,MAAK,CAAC;IACvG,WAAW,YAAY;AACrB,gBAAU,WAAW,UAAU,UAAU,EAAC,KAAK,UAAS,CAAC;IAC3D,WAAW,YAAY;AACrB,gBAAU,WAAW,UAAU,WAAW,EAAC,KAAK,WAAU,CAAC;IAC7D;AAEA,QAAI,QAAQ,yBAAyB;AACnC,gBAAU,WAAW,UAAU,oBAAoB,EAAC,KAAK,OAAO,OAAO,EAAC,CAAC;IAC3E,WAAW,QAAQ,OAAM,GAAI;AAC3B,gBAAU,WAAW,UAAU,YAAY,EAAC,KAAK,OAAO,OAAO,EAAC,CAAC;IACnE;AACA,WAAO,EAAC,MAAM,WAAW,OAAO,YAAY,QAAO;EACrD;EAEA,iBAAiB,SAA0C;AACzD,UAAM,aAAa,KAAK,WAAW,OAAO;AAC1C,UAAM,aAAa,KAAK,WAAW,OAAO;AAC1C,QAAI,UAAU;AACd,QAAI,eAAe,MAAM,KAAK,aAAa;AACzC,gBAAU,KAAK,mCAAmC,KAAK,cAAc,IAAI,UAAU;IACrF;AACA,QAAI,eAAe,IAAI;AACrB,gBAAU,KAAK,mCAAmC,UAAU,KAAK;IACnE;AACA,QAAI,SAAS;AACX,WAAK,gBAAe;IACtB;EACF;EAEA,mCAAmC,WAAiB;AAClD,UAAM,0BAA0B,KAAK;AACrC,UAAM,0BAA0B,KAAK;AACrC,UAAM,YAAY;AAClB,QAAI,KAAK,qBAAqB,MAAM,KAAK,qBAAqB,IAAI;AAChE,WAAK,mBAAmB;AACxB,WAAK,mBAAmB,YAAY;IACtC,OAAO;AACL,WAAK,mBAAmB,KAAK,IAAI,WAAW,KAAK,gBAAgB;AACjE,WAAK,mBAAmB,KAAK,IAAI,WAAW,KAAK,mBAAmB,WAAW,KAAK,gBAAgB;IACtG;AACA,WAAO,4BAA4B,KAAK,oBAAoB,4BAA4B,KAAK;EAC/F;EAEA,WAAW,UAA2C;AACpD,WAAO;EACT;EAEA,WAAW,UAA2C;AACpD,WAAO;EACT;;AAGF,IAAM,iBAAiB;AAUjB,IAAO,gCAAP,cAA6C,sBAAqB;EACtE,cAAA;AACE,UAAM,KAAK;EACb;EAES,YAAY,OAAe,WAAkB;AACpD,WAAY,mBAAc,gBAAgB,QAAQ,KAAK,SAAQ,GAAI,QAAQ,SAAS,CAAC;EACvF;EAES,WAAW,SAA0C;AAC5D,WAAO,QAAQ,UAAS;EAC1B;EAES,WAAW,SAA0C;AAC5D,WAAO,QAAQ;EACjB;;AAGI,IAAO,oCAAP,cAAiD,sBAAqB;EAC1E,cAAA;AACE,UAAM,IAAI;EACZ;EAES,YAAY,OAAe,WAAkB;AACpD,WAAY,mBAAc,gBAAgB,OAAO,QAAQ,SAAS,CAAC;EACrE;EAES,WAAW,SAA0C;AAC5D,WAAO,QAAQ;EACjB;;;;AC7RK,IAAM,0BAA0B,oBAAI,IAA2B;;;;;;CAMrE;AAEM,IAAM,4BAA4B,oBAAI,IAA2B;;;;;;;CAOvE;AAQK,SAAU,2BACZ,SAA4C,iBAAuB;AACrE,QAAM,SAA6B,CAAA;AACnC,WAAS,SAAS,MAA6B,OAAe,KAAW;AACvE,QAAI,QAAQ,OAAO,aAAa,SAAS,KAAK;AAC5C,aAAO,KAAK,EAAC,MAAM,OAAO,IAAG,CAAC;IAChC;EACF;AAEA,WAAS,cAAc,SAAiB;AACtC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,UAAI,QAAQ,CAAC,IAAI,GAAG;AAClB,eAAO,QAAQ,CAAC;MAClB;IACF;AACA,WAAO;EACT;AAEA,WAAS,eAAe,MAA6B,OAAe,KAAW;AAC7E,QAAI,SAAS,KAAK,OAAO,GAAG;AAC1B,eAAS,MAAM,YAAa,QAAQ,KAAO,YAAa,MAAM,GAAK;IACrE;EACF;AAQA,WAAS,4BAA4B,MAA6B,OAAe,KAAW;AAC1F,aAAS,MAAM,YAAa,QAAQ,KAAO,YAAa,MAAM,GAAK;EACrE;AAEA,QAAM,SAAS,QAAQ;AACvB,MAAI,CAAC,QAAQ;AACX,UAAM,QAAQ,QAAQ,UAAS,MAAO,KAAK,QAAQ,UAAS,IAAK,QAAQ,cAAc,KAAK,QAAQ,YAAY;AAChH,UAAM,gCACF,QAAQ,UAAS,MAAO,MAAM,QAAQ,cAAc,MAAM,QAAQ,UAAS,MAAO,QAAQ;AAC9F,UAAM,SAAU,QAAQ,yBAAyB,KAC5C,gCAAgC,QAAQ,YAAY,OAAO,YAC5D,QAAQ;AACZ,UAAM,MAAO,QAAQ,YAAY,KAAM,OAAO,YAAY,QAAQ;AAClE,aAAQ,SAA8B,OAAO,GAAG;AAChD,aAAQ,YAAiC,OAAO,MAAM;AACtD,UAAM,QACF,QAAQ,yBAAyB,KAAI,eAAmC;AAC5E,aAAS,OAAO,QAAQ,GAAG;AAC3B,WAAO;EACT;AAEA,QAAM,YAAY,QAAQ,UAAS;AACnC,QAAM,YAAY,OAAO;AACzB,QAAM,UAAU,cAAc,CAAC,QAAQ,SAAS,QAAQ,oBAAoB,CAAC,KAAK;AAElF,WAAQ,SAA8B,YAAY,YAAY,YAAY,WAAW,OAAO;AAC5F,MAAI,OAAO,WAAW;AACpB,UAAM,UAAU,OAAO,WAAW;AAGlC,QAAI,UAAU,iBAAiB;AAC7B,eAAQ,QAA6B,KAAK,IAAI,OAAO,WAAW,eAAe,GAAG,OAAO;IAC3F;EACF;AACA,MAAI,YAAY,WAAW;AACzB,aAAQ,YAAiC,WAAW,SAAS;EAC/D;AAEA,QAAM,oBAAoB,QAAQ,uBAAuB,aAAa;AACtE,MAAI,QAAQ,yBAAyB;AACnC,mBAAc,YAAiC,GAAG,OAAO,WAAW;AACpE,mBAAc,6BAAmD,OAAO,aAAa,OAAO,WAAW;AACvG,mBAAc,6BACyC,OAAO,kBAAkB,OAAO,wBAAwB;AAC/G,mBAAc,iBAAuC,OAAO,aAAa,OAAO,OAAO;AACvF,mBAAc,WAAgC,OAAO,SAAS,gBAAgB;EAChF,WAAW,CAAC,OAAO,WAAW;AAC5B,UAAM,cAAc,cAAc,CAAC,OAAO,UAAU,OAAO,cAAc,OAAO,WAAW,gBAAgB,CAAC,KAAK;AACjH,mBAAc,YAAiC,GAAG,WAAW;AAC7D,mBAAc,SAA8B,OAAO,YAAY,OAAO,QAAQ;AAC9E,mBAAc,OAA4B,OAAO,UAAU,OAAO,MAAM;AACxE,mBAAc,cAAmC,OAAO,cAAc,OAAO,UAAU;AACvF,mBAAc,OAA4B,OAAO,UAAU,OAAO,MAAM;AACxE,mBAAc,WAAgC,OAAO,WAAW,OAAO,OAAO;AAC9E,mBAAc,WAEV,KAAK,IAAI,OAAO,SAAS,OAAO,YAAY,OAAO,QAAQ,OAAO,UAAU,WAAW,GAAG,gBAAgB;EAChH;AAEA,QAAM,EAAC,wBAAuB,IAAI;AAClC,MAAI,yBAAyB;AAC3B,QAAI,OAAO,6BAA6B;AAGtC,UAAI,sBAAsB,OAAO;AACjC,UAAI,yBAAyB,sBAAiB,WAC1C,OAAO,wBAAwB;AACjC,8BAAsB,OAAO;MAC/B,WAAW,yBAAyB,qBAAgB,eAA4D;AAC9G,8BAAsB,OAAO;MAC/B;AACA,kCAA2B,kCACiC,OAAO,6BAC/D,mBAAmB;IACzB;AAEA,QAAI,OAAO,wBAAwB;AACjC,UAAI,iBAAiB,OAAO;AAC5B,UAAI,yBAAyB,qBAAgB,SAAuD;AAClG,yBAAiB,OAAO;MAC1B;AACA,kCAA2B,6BAC4B,OAAO,wBAAwB,cAAc;IACtG;EACF;AAEA,MAAI,QAAQ,YAAY,IAAI;AAC1B,aACI,OAAO,YAAW,mBAAuC,aACzD,QAAQ,sBAAsB,OAAO;EAC3C;AAEA,SAAO;AACT;",
  "names": []
}
