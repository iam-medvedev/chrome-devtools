{"version":3,"file":"RequestTimeRanges.js","sourceRoot":"","sources":["../../../../../../front_end/models/network_time_calculator/RequestTimeRanges.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nexport const enum RequestTimeRangeNames {\n  PUSH = 'push',\n  QUEUEING = 'queueing',\n  BLOCKING = 'blocking',\n  CONNECTING = 'connecting',\n  DNS = 'dns',\n  PROXY = 'proxy',\n  RECEIVING = 'receiving',\n  RECEIVING_PUSH = 'receiving-push',\n  SENDING = 'sending',\n  SERVICE_WORKER = 'serviceworker',\n  SERVICE_WORKER_PREPARATION = 'serviceworker-preparation',\n  SERVICE_WORKER_RESPOND_WITH = 'serviceworker-respondwith',\n  SERVICE_WORKER_ROUTER_EVALUATION = 'serviceworker-routerevaluation',\n  SERVICE_WORKER_CACHE_LOOKUP = 'serviceworker-cachelookup',\n  SSL = 'ssl',\n  TOTAL = 'total',\n  WAITING = 'waiting',\n}\n\nexport const ServiceWorkerRangeNames = new Set<RequestTimeRangeNames>([\n  RequestTimeRangeNames.SERVICE_WORKER,\n  RequestTimeRangeNames.SERVICE_WORKER_PREPARATION,\n  RequestTimeRangeNames.SERVICE_WORKER_RESPOND_WITH,\n  RequestTimeRangeNames.SERVICE_WORKER_ROUTER_EVALUATION,\n  RequestTimeRangeNames.SERVICE_WORKER_CACHE_LOOKUP,\n]);\n\nexport const ConnectionSetupRangeNames = new Set<RequestTimeRangeNames>([\n  RequestTimeRangeNames.QUEUEING,\n  RequestTimeRangeNames.BLOCKING,\n  RequestTimeRangeNames.CONNECTING,\n  RequestTimeRangeNames.DNS,\n  RequestTimeRangeNames.PROXY,\n  RequestTimeRangeNames.SSL,\n]);\n\nexport interface RequestTimeRange {\n  name: RequestTimeRangeNames;\n  start: number;\n  end: number;\n}\n\nexport function calculateRequestTimeRanges(\n    request: SDK.NetworkRequest.NetworkRequest, navigationStart: number): RequestTimeRange[] {\n  const result: RequestTimeRange[] = [];\n  function addRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    if (start < Number.MAX_VALUE && start <= end) {\n      result.push({name, start, end});\n    }\n  }\n\n  function firstPositive(numbers: number[]): number|undefined {\n    for (let i = 0; i < numbers.length; ++i) {\n      if (numbers[i] > 0) {\n        return numbers[i];\n      }\n    }\n    return undefined;\n  }\n\n  function addOffsetRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    if (start >= 0 && end >= 0) {\n      addRange(name, startTime + (start / 1000), startTime + (end / 1000));\n    }\n  }\n\n  /**\n   * In some situations, argument `start` may come before `startTime` (`timing.requestStart`). This is especially true\n   * in cases such as SW static routing API where fields like `workerRouterEvaluationStart` or `workerCacheLookupStart`\n   * is set before setting `timing.requestStart`. If the `start` and `end` is known to be a valid value (i.e. not default\n   * invalid value -1 or undefined), we allow adding the range.\n   **/\n  function addMaybeNegativeOffsetRange(name: RequestTimeRangeNames, start: number, end: number): void {\n    addRange(name, startTime + (start / 1000), startTime + (end / 1000));\n  }\n\n  const timing = request.timing;\n  if (!timing) {\n    const start = request.issueTime() !== -1 ? request.issueTime() : request.startTime !== -1 ? request.startTime : 0;\n    const hasDifferentIssueAndStartTime =\n        request.issueTime() !== -1 && request.startTime !== -1 && request.issueTime() !== request.startTime;\n    const middle = (request.responseReceivedTime === -1) ?\n        (hasDifferentIssueAndStartTime ? request.startTime : Number.MAX_VALUE) :\n        request.responseReceivedTime;\n    const end = (request.endTime === -1) ? Number.MAX_VALUE : request.endTime;\n    addRange(RequestTimeRangeNames.TOTAL, start, end);\n    addRange(RequestTimeRangeNames.BLOCKING, start, middle);\n    const state =\n        request.responseReceivedTime === -1 ? RequestTimeRangeNames.CONNECTING : RequestTimeRangeNames.RECEIVING;\n    addRange(state, middle, end);\n    return result;\n  }\n\n  const issueTime = request.issueTime();\n  const startTime = timing.requestTime;\n  const endTime = firstPositive([request.endTime, request.responseReceivedTime]) || startTime;\n\n  addRange(RequestTimeRangeNames.TOTAL, issueTime < startTime ? issueTime : startTime, endTime);\n  if (timing.pushStart) {\n    const pushEnd = timing.pushEnd || endTime;\n    // Only show the part of push that happened after the navigation/reload.\n    // Pushes that happened on the same connection before we started main request will not be shown.\n    if (pushEnd > navigationStart) {\n      addRange(RequestTimeRangeNames.PUSH, Math.max(timing.pushStart, navigationStart), pushEnd);\n    }\n  }\n  if (issueTime < startTime) {\n    addRange(RequestTimeRangeNames.QUEUEING, issueTime, startTime);\n  }\n\n  const responseReceived = (request.responseReceivedTime - startTime) * 1000;\n  if (request.fetchedViaServiceWorker) {\n    addOffsetRange(RequestTimeRangeNames.BLOCKING, 0, timing.workerStart);\n    addOffsetRange(RequestTimeRangeNames.SERVICE_WORKER_PREPARATION, timing.workerStart, timing.workerReady);\n    addOffsetRange(\n        RequestTimeRangeNames.SERVICE_WORKER_RESPOND_WITH, timing.workerFetchStart, timing.workerRespondWithSettled);\n    addOffsetRange(RequestTimeRangeNames.SERVICE_WORKER, timing.workerReady, timing.sendEnd);\n    addOffsetRange(RequestTimeRangeNames.WAITING, timing.sendEnd, responseReceived);\n  } else if (!timing.pushStart) {\n    const blockingEnd = firstPositive([timing.dnsStart, timing.connectStart, timing.sendStart, responseReceived]) || 0;\n    addOffsetRange(RequestTimeRangeNames.BLOCKING, 0, blockingEnd);\n    addOffsetRange(RequestTimeRangeNames.PROXY, timing.proxyStart, timing.proxyEnd);\n    addOffsetRange(RequestTimeRangeNames.DNS, timing.dnsStart, timing.dnsEnd);\n    addOffsetRange(RequestTimeRangeNames.CONNECTING, timing.connectStart, timing.connectEnd);\n    addOffsetRange(RequestTimeRangeNames.SSL, timing.sslStart, timing.sslEnd);\n    addOffsetRange(RequestTimeRangeNames.SENDING, timing.sendStart, timing.sendEnd);\n    addOffsetRange(\n        RequestTimeRangeNames.WAITING,\n        Math.max(timing.sendEnd, timing.connectEnd, timing.dnsEnd, timing.proxyEnd, blockingEnd), responseReceived);\n  }\n\n  const {serviceWorkerRouterInfo} = request;\n  if (serviceWorkerRouterInfo) {\n    if (timing.workerRouterEvaluationStart) {\n      // Depending on the source,the next timestamp will be different. Determine the timestamp by checking\n      // the matched and actual source.\n      let routerEvaluationEnd = timing.sendStart;\n      if (serviceWorkerRouterInfo?.matchedSourceType === Protocol.Network.ServiceWorkerRouterSource.Cache &&\n          timing.workerCacheLookupStart) {\n        routerEvaluationEnd = timing.workerCacheLookupStart;\n      } else if (serviceWorkerRouterInfo?.actualSourceType === Protocol.Network.ServiceWorkerRouterSource.FetchEvent) {\n        routerEvaluationEnd = timing.workerStart;\n      }\n      addMaybeNegativeOffsetRange(\n          RequestTimeRangeNames.SERVICE_WORKER_ROUTER_EVALUATION, timing.workerRouterEvaluationStart,\n          routerEvaluationEnd);\n    }\n\n    if (timing.workerCacheLookupStart) {\n      let cacheLookupEnd = timing.sendStart;\n      if (serviceWorkerRouterInfo?.actualSourceType === Protocol.Network.ServiceWorkerRouterSource.Cache) {\n        cacheLookupEnd = timing.receiveHeadersStart;\n      }\n      addMaybeNegativeOffsetRange(\n          RequestTimeRangeNames.SERVICE_WORKER_CACHE_LOOKUP, timing.workerCacheLookupStart, cacheLookupEnd);\n    }\n  }\n\n  if (request.endTime !== -1) {\n    addRange(\n        timing.pushStart ? RequestTimeRangeNames.RECEIVING_PUSH : RequestTimeRangeNames.RECEIVING,\n        request.responseReceivedTime, endTime);\n  }\n\n  return result;\n}\n"]}