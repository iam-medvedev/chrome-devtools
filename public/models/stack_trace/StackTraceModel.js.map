{"version":3,"file":"StackTraceModel.js","sourceRoot":"","sources":["../../../../../../front_end/models/stack_trace/StackTraceModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\n// eslint-disable-next-line rulesdir/es-modules-import\nimport * as StackTrace from './stack_trace.js';\nimport {AsyncFragmentImpl, FragmentImpl, FrameImpl, StackTraceImpl} from './StackTraceImpl.js';\nimport {type FrameNode, type RawFrame, Trie} from './Trie.js';\n\n/**\n * A stack trace translation function.\n *\n * Any implementation must return an array with the same length as `frames`.\n */\nexport type TranslateRawFrames = (frames: readonly RawFrame[], target: SDK.Target.Target) =>\n    Promise<Array<Array<Pick<StackTrace.StackTrace.Frame, 'url'|'uiSourceCode'|'name'|'line'|'column'>>>>;\n\n/**\n * The {@link StackTraceModel} is a thin wrapper around a fragment trie.\n *\n * We want to store stack trace fragments per target so a SDKModel is the natural choice.\n */\nexport class StackTraceModel extends SDK.SDKModel.SDKModel<unknown> {\n  readonly #trie = new Trie();\n\n  /** @returns the {@link StackTraceModel} for the target, or the model for the primaryPageTarget when passing null/undefined */\n  static #modelForTarget(target: SDK.Target.Target|null|undefined): StackTraceModel {\n    const model = (target ?? SDK.TargetManager.TargetManager.instance().primaryPageTarget())?.model(StackTraceModel);\n    if (!model) {\n      throw new Error('Unable to find StackTraceModel');\n    }\n    return model;\n  }\n\n  async createFromProtocolRuntime(stackTrace: Protocol.Runtime.StackTrace, rawFramesToUIFrames: TranslateRawFrames):\n      Promise<StackTrace.StackTrace.StackTrace> {\n    const translatePromises: Array<Promise<unknown>> = [];\n\n    const fragment = this.#createFragment(stackTrace.callFrames);\n    translatePromises.push(this.#translateFragment(fragment, rawFramesToUIFrames));\n\n    const asyncFragments: AsyncFragmentImpl[] = [];\n    const debuggerModel = this.target().model(SDK.DebuggerModel.DebuggerModel);\n    if (debuggerModel) {\n      for await (const {stackTrace: asyncStackTrace, target} of debuggerModel.iterateAsyncParents(stackTrace)) {\n        const model = StackTraceModel.#modelForTarget(target);\n        const asyncFragment = model.#createFragment(asyncStackTrace.callFrames);\n        translatePromises.push(model.#translateFragment(asyncFragment, rawFramesToUIFrames));\n        asyncFragments.push(new AsyncFragmentImpl(asyncStackTrace.description ?? '', asyncFragment));\n      }\n    }\n\n    await Promise.all(translatePromises);\n\n    return new StackTraceImpl(fragment, asyncFragments);\n  }\n\n  /** Trigger re-translation of all fragments with the provide script in their call stack */\n  async scriptInfoChanged(script: SDK.Script.Script, translateRawFrames: TranslateRawFrames): Promise<void> {\n    const translatePromises: Array<Promise<unknown>> = [];\n    let stackTracesToUpdate = new Set<StackTraceImpl>();\n\n    for (const fragment of this.#affectedFragments(script)) {\n      // We trigger re-translation only for fragments of leaf-nodes. Any fragment along the ancestor-chain\n      // is re-translated as a side-effect.\n      // We just need to remember the stack traces of the skipped over fragments, so we can send the\n      // UPDATED event also to them.\n      if (fragment.node.children.length === 0) {\n        translatePromises.push(this.#translateFragment(fragment, translateRawFrames));\n      }\n      stackTracesToUpdate = stackTracesToUpdate.union(fragment.stackTraces);\n    }\n\n    await Promise.all(translatePromises);\n\n    for (const stackTrace of stackTracesToUpdate) {\n      stackTrace.dispatchEventToListeners(StackTrace.StackTrace.Events.UPDATED);\n    }\n  }\n\n  #createFragment(frames: RawFrame[]): FragmentImpl {\n    return FragmentImpl.getOrCreate(this.#trie.insert(frames));\n  }\n\n  async #translateFragment(fragment: FragmentImpl, rawFramesToUIFrames: TranslateRawFrames): Promise<void> {\n    const rawFrames = fragment.node.getCallStack().map(node => node.rawFrame).toArray();\n    const uiFrames = await rawFramesToUIFrames(rawFrames, this.target());\n    console.assert(rawFrames.length === uiFrames.length, 'Broken rawFramesToUIFrames implementation');\n\n    let i = 0;\n    for (const node of fragment.node.getCallStack()) {\n      node.frames = uiFrames[i++].map(\n          frame => new FrameImpl(frame.url, frame.uiSourceCode, frame.name, frame.line, frame.column));\n    }\n  }\n\n  #affectedFragments(script: SDK.Script.Script): Set<FragmentImpl> {\n    // 1. Collect branches with the matching script.\n    const affectedBranches = new Set<FrameNode>();\n    this.#trie.walk(null, node => {\n      // scriptId has precedence, but if the frame does not have one, check the URL.\n      if (node.rawFrame.scriptId === script.scriptId ||\n          (!node.rawFrame.scriptId && node.rawFrame.url === script.sourceURL)) {\n        affectedBranches.add(node);\n        return false;\n      }\n      return true;\n    });\n\n    // 2. For each branch collect all the fragments.\n    const fragments = new Set<FragmentImpl>();\n    for (const branch of affectedBranches) {\n      this.#trie.walk(branch, node => {\n        if (node.fragment) {\n          fragments.add(node.fragment);\n        }\n        return true;\n      });\n    }\n    return fragments;\n  }\n}\n\nSDK.SDKModel.SDKModel.register(StackTraceModel, {capabilities: SDK.Target.Capability.NONE, autostart: false});\n"]}