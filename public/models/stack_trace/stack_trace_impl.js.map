{
  "version": 3,
  "sources": ["../../../../../../front_end/models/stack_trace/StackTraceImpl.ts", "../../../../../../front_end/models/stack_trace/StackTraceModel.ts", "../../../../../../front_end/models/stack_trace/Trie.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Workspace from '../workspace/workspace.js';\n\nimport type * as StackTrace from './stack_trace.js';\nimport type {FrameNode} from './Trie.js';\n\nexport class StackTraceImpl extends Common.ObjectWrapper.ObjectWrapper<StackTrace.StackTrace.EventTypes> implements\n    StackTrace.StackTrace.StackTrace {\n  readonly syncFragment: FragmentImpl;\n  readonly asyncFragments: readonly AsyncFragmentImpl[];\n\n  constructor(syncFragment: FragmentImpl, asyncFragments: AsyncFragmentImpl[]) {\n    super();\n    this.syncFragment = syncFragment;\n    this.asyncFragments = asyncFragments;\n\n    syncFragment.stackTraces.add(this);\n    this.asyncFragments.forEach(asyncFragment => asyncFragment.fragment.stackTraces.add(this));\n  }\n}\n\nexport class FragmentImpl implements StackTrace.StackTrace.Fragment {\n  readonly node: FrameNode;\n  readonly stackTraces = new Set<StackTraceImpl>();\n\n  /**\n   * Fragments are deduplicated based on the node.\n   *\n   * In turn, each fragment can be part of multiple stack traces.\n   */\n  static getOrCreate(node: FrameNode): FragmentImpl {\n    if (!node.fragment) {\n      node.fragment = new FragmentImpl(node);\n    }\n    return node.fragment;\n  }\n\n  private constructor(node: FrameNode) {\n    this.node = node;\n  }\n\n  get frames(): FrameImpl[] {\n    const frames: FrameImpl[] = [];\n\n    for (const node of this.node.getCallStack()) {\n      frames.push(...node.frames);\n    }\n\n    return frames;\n  }\n}\n\nexport class AsyncFragmentImpl implements StackTrace.StackTrace.AsyncFragment {\n  constructor(readonly description: string, readonly fragment: FragmentImpl) {\n  }\n\n  get frames(): StackTrace.StackTrace.Frame[] {\n    return this.fragment.frames;\n  }\n}\n\nexport class FrameImpl implements StackTrace.StackTrace.Frame {\n  readonly url?: string;\n  readonly uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n  readonly name?: string;\n  readonly line: number;\n  readonly column: number;\n\n  constructor(\n      url: string|undefined, uiSourceCode: Workspace.UISourceCode.UISourceCode|undefined, name: string|undefined,\n      line: number, column: number) {\n    this.url = url;\n    this.uiSourceCode = uiSourceCode;\n    this.name = name;\n    this.line = line;\n    this.column = column;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type * as StackTrace from './stack_trace.js';\nimport {AsyncFragmentImpl, FragmentImpl, FrameImpl, StackTraceImpl} from './StackTraceImpl.js';\nimport {type RawFrame, Trie} from './Trie.js';\n\n/**\n * A stack trace translation function.\n *\n * Any implementation must return an array with the same length as `frames`.\n */\nexport type TranslateRawFrames = (frames: readonly RawFrame[], target: SDK.Target.Target) =>\n    Promise<Array<Array<Pick<StackTrace.StackTrace.Frame, 'url'|'uiSourceCode'|'name'|'line'|'column'>>>>;\n\n/**\n * The {@link StackTraceModel} is a thin wrapper around a fragment trie.\n *\n * We want to store stack trace fragments per target so a SDKModel is the natural choice.\n */\nexport class StackTraceModel extends SDK.SDKModel.SDKModel<unknown> {\n  readonly #trie = new Trie();\n\n  /** @returns the {@link StackTraceModel} for the target, or the model for the primaryPageTarget when passing null/undefined */\n  static #modelForTarget(target: SDK.Target.Target|null|undefined): StackTraceModel {\n    const model = (target ?? SDK.TargetManager.TargetManager.instance().primaryPageTarget())?.model(StackTraceModel);\n    if (!model) {\n      throw new Error('Unable to find StackTraceModel');\n    }\n    return model;\n  }\n\n  async createFromProtocolRuntime(stackTrace: Protocol.Runtime.StackTrace, rawFramesToUIFrames: TranslateRawFrames):\n      Promise<StackTrace.StackTrace.StackTrace> {\n    const translatePromises: Array<Promise<unknown>> = [];\n\n    const fragment = this.#createFragment(stackTrace.callFrames);\n    translatePromises.push(this.#translateFragment(fragment, rawFramesToUIFrames));\n\n    const asyncFragments: AsyncFragmentImpl[] = [];\n    const debuggerModel = this.target().model(SDK.DebuggerModel.DebuggerModel);\n    if (debuggerModel) {\n      for await (const {stackTrace: asyncStackTrace, target} of debuggerModel.iterateAsyncParents(stackTrace)) {\n        const model = StackTraceModel.#modelForTarget(target);\n        const asyncFragment = model.#createFragment(asyncStackTrace.callFrames);\n        translatePromises.push(model.#translateFragment(asyncFragment, rawFramesToUIFrames));\n        asyncFragments.push(new AsyncFragmentImpl(asyncStackTrace.description ?? '', asyncFragment));\n      }\n    }\n\n    await Promise.all(translatePromises);\n\n    return new StackTraceImpl(fragment, asyncFragments);\n  }\n\n  #createFragment(frames: RawFrame[]): FragmentImpl {\n    return FragmentImpl.getOrCreate(this.#trie.insert(frames));\n  }\n\n  async #translateFragment(fragment: FragmentImpl, rawFramesToUIFrames: TranslateRawFrames): Promise<void> {\n    const rawFrames = fragment.node.getCallStack().map(node => node.rawFrame).toArray();\n    const uiFrames = await rawFramesToUIFrames(rawFrames, this.target());\n    console.assert(rawFrames.length === uiFrames.length, 'Broken rawFramesToUIFrames implementation');\n\n    let i = 0;\n    for (const node of fragment.node.getCallStack()) {\n      node.frames = uiFrames[i++].map(\n          frame => new FrameImpl(frame.url, frame.uiSourceCode, frame.name, frame.line, frame.column));\n    }\n  }\n}\n\nSDK.SDKModel.SDKModel.register(StackTraceModel, {capabilities: SDK.Target.Capability.NONE, autostart: false});\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type {FragmentImpl, FrameImpl} from './StackTraceImpl.js';\n\n/**\n * Intentionally very close to a {@link Protocol.Runtime.CallFrame} but with optional `scriptId`.\n */\nexport interface RawFrame {\n  readonly scriptId?: Protocol.Runtime.ScriptId;\n  readonly url?: string;\n  readonly functionName?: string;\n  readonly lineNumber: number;\n  readonly columnNumber: number;\n}\n\ninterface FrameNodeBase<ChildT, ParentT> {\n  readonly parent: ParentT;\n  readonly children: ChildT[];\n}\n\ntype RootFrameNode = FrameNodeBase<WeakRef<FrameNode>, null>;\ntype AnyFrameNode = FrameNode|RootFrameNode;\n\nexport class FrameNode implements FrameNodeBase<FrameNode, AnyFrameNode> {\n  readonly parent: AnyFrameNode;\n  readonly children: FrameNode[] = [];\n\n  readonly rawFrame: RawFrame;\n  frames: FrameImpl[] = [];\n\n  fragment?: FragmentImpl;\n\n  constructor(rawFrame: RawFrame, parent: AnyFrameNode) {\n    this.rawFrame = rawFrame;\n    this.parent = parent;\n  }\n\n  /**\n   * Produces the ancestor chain. Including `this` but excluding the `RootFrameNode`.\n   */\n  * getCallStack(): Generator<FrameNode> {\n    // The `RootFrameNode` doesn't have an actual frame attached, that's why we check for `node.parent` instead of `node`.\n    for (let node: AnyFrameNode|null = this; node.parent; node = node.parent) {\n      yield node;\n    }\n  }\n}\n\n/**\n * Stores stack trace fragments in a trie, but does not own them/keep them alive.\n */\nexport class Trie {\n  readonly #root: RootFrameNode = {parent: null, children: []};\n\n  /**\n   * Most sources produce stack traces in \"top-to-bottom\" order, so that is what this method expects.\n   *\n   * @returns The {@link FrameNode} corresponding to the top-most stack frame.\n   */\n  insert(frames: RawFrame[]): FrameNode {\n    if (frames.length === 0) {\n      throw new Error('Trie.insert called with an empty frames array.');\n    }\n\n    let currentNode: AnyFrameNode = this.#root;\n    for (let i = frames.length - 1; i >= 0; --i) {\n      currentNode = this.#insert(currentNode, frames[i]);\n    }\n    return currentNode as FrameNode;\n  }\n\n  /**\n   * Inserts `rawFrame` into the children of the provided node if not already there.\n   *\n   * @returns the child node corresponding to `rawFrame`.\n   */\n  #insert(node: AnyFrameNode, rawFrame: RawFrame): FrameNode {\n    let i = 0;\n    for (; i < node.children.length; ++i) {\n      const maybeChild = node.children[i];\n      const child = maybeChild instanceof WeakRef ? maybeChild.deref() : maybeChild;\n      if (!child) {\n        continue;\n      }\n\n      const compareResult = compareRawFrames(child.rawFrame, rawFrame);\n      if (compareResult === 0) {\n        return child;\n      }\n      if (compareResult > 0) {\n        break;\n      }\n    }\n\n    const newNode = new FrameNode(rawFrame, node);\n    if (node.parent) {\n      node.children.splice(i, 0, newNode);\n    } else {\n      node.children.splice(i, 0, new WeakRef(newNode));\n    }\n    return newNode;\n  }\n}\n\n/**\n * @returns a number < 0, 0 or > 0, if the `a` is smaller then, equal or greater then `b`.\n */\nexport function compareRawFrames(a: RawFrame, b: RawFrame): number {\n  const scriptIdCompare = (a.scriptId ?? '').localeCompare(b.scriptId ?? '');\n  if (scriptIdCompare !== 0) {\n    return scriptIdCompare;\n  }\n\n  const urlCompare = (a.url ?? '').localeCompare(b.url ?? '');\n  if (urlCompare !== 0) {\n    return urlCompare;\n  }\n\n  const nameCompare = (a.functionName ?? '').localeCompare(b.functionName ?? '');\n  if (nameCompare !== 0) {\n    return nameCompare;\n  }\n\n  if (a.lineNumber !== b.lineNumber) {\n    return a.lineNumber - b.lineNumber;\n  }\n\n  return a.columnNumber - b.columnNumber;\n}\n"],
  "mappings": "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",
  "names": []
}
