// Copyright 2022 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import { describeWithEnvironment } from '../../testing/EnvironmentHelpers.js';
import { DevToolsTimelineCategory, makeFakeSDKEventFromPayload, StubbedThread, } from '../../testing/TraceHelpers.js';
import { TraceLoader } from '../../testing/TraceLoader.js';
import * as TimelineModel from '../timeline_model/timeline_model.js';
import * as TraceEngine from '../trace/trace.js';
describeWithEnvironment('TimelineModel', function () {
    describe('isMarkerEvent', function () {
        it('is true for a timestamp event', async function () {
            // Note: exact trace does not matter here, but we need a real one so all the metadata is set correctly on the TimelineModel
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const timestampEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.TimeStamp,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
            });
            assert.isTrue(timelineModel.isMarkerEvent(timestampEvent));
        });
        it('is true for a Mark First Paint event that is on the main frame', async function () {
            const { timelineModel, traceParsedData } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markFirstPaintEventOnMainFrame = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkFirstPaint,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    frame: traceParsedData.Meta.mainFrameId,
                    data: {},
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markFirstPaintEventOnMainFrame));
        });
        it('is true for a Mark FCP event that is on the main frame', async function () {
            const { timelineModel, traceParsedData } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markFCPEventOnMainFrame = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkFCP,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    frame: traceParsedData.Meta.mainFrameId,
                    data: {},
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markFCPEventOnMainFrame));
        });
        it('is false for a Mark FCP event that is not on the main frame', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markFCPEventOnOtherFrame = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkFCP,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    frame: 'not-main-frame',
                    data: {},
                },
            });
            assert.isFalse(timelineModel.isMarkerEvent(markFCPEventOnOtherFrame));
        });
        it('is false for a Mark First Paint event that is not on the main frame', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markFirstPaintEventOnOtherFrame = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkFirstPaint,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    frame: 'not-main-frame',
                    data: {},
                },
            });
            assert.isFalse(timelineModel.isMarkerEvent(markFirstPaintEventOnOtherFrame));
        });
        it('is true for a MarkDOMContent event is set to isMainFrame', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markDOMContentEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkDOMContent,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isMainFrame: true,
                    },
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markDOMContentEvent));
        });
        it('is true for a MarkDOMContent event that set to isOutermostMainFrame', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markDOMContentEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkDOMContent,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isOutermostMainFrame: true,
                    },
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markDOMContentEvent));
        });
        it('is false for a MarkDOMContent event that set to isOutermostMainFrame=false', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markDOMContentEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkDOMContent,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isOutermostMainFrame: false,
                    },
                },
            });
            assert.isFalse(timelineModel.isMarkerEvent(markDOMContentEvent));
        });
        it('is false for a MarkDOMContent event that set to isMainFrame=false', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markDOMContentEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkDOMContent,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isMainFrame: false,
                    },
                },
            });
            assert.isFalse(timelineModel.isMarkerEvent(markDOMContentEvent));
        });
        it('is true for a MarkLoad event that set to isMainFrame=true', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markLoadEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkLoad,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isMainFrame: true,
                    },
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markLoadEvent));
        });
        it('is true for a MarkLCPCandidate event that set to isOutermostMainFrame=true', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markLCPCandidateEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkLCPCandidate,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isOutermostMainFrame: true,
                    },
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markLCPCandidateEvent));
        });
        it('is true for a MarkLCPInvalidate event that set to isOutermostMainFrame=true', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const markLCPInvalidateEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.MarkLCPInvalidate,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                args: {
                    data: {
                        isOutermostMainFrame: true,
                    },
                },
            });
            assert.isTrue(timelineModel.isMarkerEvent(markLCPInvalidateEvent));
        });
        it('is false for some unrelated event that is never a marker such as an animation', async function () {
            const { timelineModel } = await TraceLoader.allModels(this, 'slow-interaction-button-click.json.gz');
            const animationEvent = makeFakeSDKEventFromPayload({
                categories: [DevToolsTimelineCategory],
                name: TimelineModel.TimelineModel.RecordType.Animation,
                ph: "X" /* TraceEngine.Types.TraceEvents.Phase.COMPLETE */,
                ts: 1,
                threadId: 1,
            });
            assert.isFalse(timelineModel.isMarkerEvent(animationEvent));
        });
    });
});
describeWithEnvironment('TimelineData', function () {
    function getAllTracingModelPayloadEvents(tracingModel) {
        const allSDKEvents = tracingModel.sortedProcesses().flatMap(process => {
            return process.sortedThreads().flatMap(thread => thread.events().filter(TraceEngine.Legacy.eventHasPayload));
        });
        allSDKEvents.sort((eventA, eventB) => {
            if (eventA.startTime > eventB.startTime) {
                return 1;
            }
            if (eventB.startTime > eventA.startTime) {
                return -1;
            }
            return 0;
        });
        return allSDKEvents;
    }
    it('stores data for an SDK.TracingModel.PayloadEvent using the raw payload as the key', async function () {
        const data = await TraceLoader.allModels(this, 'web-dev.json.gz');
        const allSDKEvents = getAllTracingModelPayloadEvents(data.tracingModel);
        // The exact event we use is not important, so let's use the first LCP event.
        const lcpSDKEvent = allSDKEvents.find(event => event.name === TimelineModel.TimelineModel.RecordType.MarkLCPCandidate);
        if (!lcpSDKEvent) {
            throw new Error('Could not find SDK Event.');
        }
        const dataForEvent = TimelineModel.TimelineModel.EventOnTimelineData.forEvent(lcpSDKEvent);
        dataForEvent.backendNodeIds.push(123);
        // Now find the same event from the new engine
        const lcpNewEngineEvent = data.traceParsedData.PageLoadMetrics.allMarkerEvents.find(event => {
            return TraceEngine.Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event);
        });
        if (!lcpNewEngineEvent) {
            throw new Error('Could not find LCP New engine event.');
        }
        // Make sure we got the matching events.
        assert.strictEqual(lcpNewEngineEvent, lcpSDKEvent.rawPayload());
        assert.strictEqual(TimelineModel.TimelineModel.EventOnTimelineData.forEvent(lcpSDKEvent).backendNodeIds, TimelineModel.TimelineModel.EventOnTimelineData.forEvent(lcpNewEngineEvent).backendNodeIds);
    });
    it('stores data for a constructed event using the event as the key', async function () {
        const thread = StubbedThread.make(1);
        // None of the details here matter, we just need some constructed event.
        const fakeConstructedEvent = new TraceEngine.Legacy.ConstructedEvent('blink.user_timing', 'some-test-event', "I" /* TraceEngine.Types.TraceEvents.Phase.INSTANT */, 100, thread);
        const dataForEvent = TimelineModel.TimelineModel.EventOnTimelineData.forEvent(fakeConstructedEvent);
        dataForEvent.backendNodeIds.push(123);
        assert.strictEqual(dataForEvent, TimelineModel.TimelineModel.EventOnTimelineData.forEvent(fakeConstructedEvent));
    });
    it('extracts backend node ids and image url for a Decode Image event', async function () {
        const data = await TraceLoader.allModels(this, 'web-dev.json.gz');
        const allSDKEvents = getAllTracingModelPayloadEvents(data.tracingModel);
        const decodeImageEvent = allSDKEvents.find(event => event.name === "Decode Image" /* TraceEngine.Types.TraceEvents.KnownEventName.DecodeImage */);
        if (!decodeImageEvent) {
            throw new Error('Could not find Decode Image event Event.');
        }
        const dataForEvent = TimelineModel.TimelineModel.EventOnTimelineData.forEvent(decodeImageEvent);
        assert.strictEqual(dataForEvent.backendNodeIds[0], 240);
        assert.isTrue(dataForEvent.url?.includes('.jpg'));
    });
});
//# sourceMappingURL=TimelineModel.test.js.map