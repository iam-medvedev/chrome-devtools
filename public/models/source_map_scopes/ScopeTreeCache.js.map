{"version":3,"file":"ScopeTreeCache.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/ScopeTreeCache.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAG7B,OAAO,KAAK,SAAS,MAAM,2BAA2B,CAAC;AAIvD,4FAA4F;AAC5F,MAAM,UAAU,GAAG,IAAI,OAAO,EAAkD,CAAC;AAEjF;;;;;;;GAOG;AACH,MAAM,UAAU,kBAAkB,CAAC,MAAyB;IAC1D,IAAI,OAAO,GAAG,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACrC,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;QAC1B,OAAO,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,CAAC,EAAC,OAAO,EAAC,EAAE,EAAE;YACnD,IAAI,OAAO,KAAK,IAAI,EAAE,CAAC;gBACrB,OAAO,IAAI,CAAC;YACd,CAAC;YAED,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;YACzD,OAAO,SAAS,CAAC,mBAAmB,CAAC,mBAAmB,EAAE,CAAC,mBAAmB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACtG,CAAC,CAAC,CAAC;QACH,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClC,CAAC;IACD,kFAAkF;IAClF,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as Formatter from '../formatter/formatter.js';\n\ntype ScopeTreeNode = Formatter.FormatterWorkerPool.ScopeTreeNode;\n\n/** If a script failed to parse, we stash null in order to prevent unnecessary re-parsing */\nconst scopeTrees = new WeakMap<SDK.Script.Script, Promise<ScopeTreeNode|null>>();\n\n/**\n * Computes and caches the scope tree for `script`.\n *\n * We use {@link SDK.Script.Script} as a key to uniquely identify scripts.\n * {@link SDK.Script.Script} boils down to \"target\" + \"script ID\". This\n * duplicates work in case of identitical script running on multiple targets\n * (e.g. workers).\n */\nexport function scopeTreeForScript(script: SDK.Script.Script): Promise<ScopeTreeNode|null> {\n  let promise = scopeTrees.get(script);\n  if (promise === undefined) {\n    promise = script.requestContent().then(({content}) => {\n      if (content === null) {\n        return null;\n      }\n\n      const sourceType = script.isModule ? 'module' : 'script';\n      return Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptScopeTree(content, sourceType);\n    });\n    scopeTrees.set(script, promise);\n  }\n  // We intentionally return `null` here if the script already failed to parse once.\n  return promise;\n}\n"]}