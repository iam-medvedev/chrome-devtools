{"version":3,"file":"ScopeChainModel.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/ScopeChainModel.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,6BAA6B,CAAC;AACtD,OAAO,KAAK,GAAG,MAAM,uBAAuB,CAAC;AAE7C;;;;;;;;;;;GAWG;AACH,MAAM,OAAO,eAAgB,SAAQ,MAAM,CAAC,aAAa,CAAC,aAAyB;IACxE,UAAU,CAA8B;IAEjD,2GAA2G;IAClG,UAAU,GAAG,IAAI,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC/C,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAEhD,YAAY,SAAsC;QAChD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,CAC1C,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,CAC7D,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAElF,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACnD,CAAC;IAED,OAAO;QACL,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,mBAAmB,CAC7C,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAChE,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;IACpF,CAAC;IAED,KAAK,CAAC,OAAO;QACX,8FAA8F;QAC9F,IAAI,CAAC,wBAAwB,qDAA2B,IAAI,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAC3F,CAAC;IAED,kBAAkB,CAAC,KAA6D;QAC9E,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YAC1C,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAED,kBAAkB,CAAC,KACsF;QACvG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YACjD,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;CACF;AAUD;;;;GAIG;AACH,MAAM,OAAO,UAAU;IACZ,SAAS,CAA8B;IAEhD,YAAY,SAAsC;QAChD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\n/**\n * This class is responsible for resolving / updating the scope chain for a specific {@link SDK.DebuggerModel.CallFrame}\n * instance.\n *\n * There are several sources that can influence the scope view:\n *   - Debugger plugins can provide the whole scope info (e.g. from DWARF)\n *   - Source Maps can provide OR augment scope info\n *\n * Source maps can be enabled/disabled dynamically and debugger plugins can attach debug info after the fact.\n *\n * This class tracks all that and sends events with the latest scope chain for a specific call frame.\n */\nexport class ScopeChainModel extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly #callFrame: SDK.DebuggerModel.CallFrame;\n\n  /** We use the `Throttler` here to make sure that `#boundUpdate` is not run multiple times simultanously */\n  readonly #throttler = new Common.Throttler.Throttler(5);\n  readonly #boundUpdate = this.#update.bind(this);\n\n  constructor(callFrame: SDK.DebuggerModel.CallFrame) {\n    super();\n    this.#callFrame = callFrame;\n    this.#callFrame.debuggerModel.addEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().addEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n\n    void this.#throttler.schedule(this.#boundUpdate);\n  }\n\n  dispose(): void {\n    this.#callFrame.debuggerModel.removeEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().removeEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n  }\n\n  async #update(): Promise<void> {\n    // TODO(crbug.com/40277685): Actually resolve the scope info and send it along with the event.\n    this.dispatchEventToListeners(Events.ScopeChainUpdated, new ScopeChain(this.#callFrame));\n  }\n\n  #debugInfoAttached(event: Common.EventTarget.EventTargetEvent<SDK.Script.Script>): void {\n    if (event.data === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n\n  #sourceMapAttached(event: Common.EventTarget\n                         .EventTargetEvent<{client: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap}>): void {\n    if (event.data.client === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n}\n\nexport const enum Events {\n  ScopeChainUpdated = 'ScopeChainUpdated',\n}\n\nexport type EventTypes = {\n  [Events.ScopeChainUpdated]: ScopeChain,\n};\n\n/**\n * Placeholder event payload.\n *\n * TODO(crbug.com/40277685): Send an actual scope chain.\n */\nexport class ScopeChain {\n  readonly callFrame: SDK.DebuggerModel.CallFrame;\n\n  constructor(callFrame: SDK.DebuggerModel.CallFrame) {\n    this.callFrame = callFrame;\n  }\n}\n"]}