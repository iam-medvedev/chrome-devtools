{
  "version": 3,
  "sources": ["../../../../../../front_end/models/ai_code_completion/AiCodeCompletion.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as Root from '../../core/root/root.js';\nimport * as TextEditor from '../../ui/components/text_editor/text_editor.js';\nimport type {AgentOptions, RequestOptions} from '../ai_assistance/ai_assistance.js';\n\nexport const DELAY_BEFORE_SHOWING_RESPONSE_MS = 500;\nexport const AIDA_REQUEST_DEBOUNCE_TIMEOUT_MS = 200;\n\n/**\n * The AiCodeCompletion class is responsible for fetching code completion suggestions\n * from the AIDA backend and displaying them in the text editor.\n *\n * 1. **Debouncing requests:** As the user types, we don't want to send a request\n *    for every keystroke. Instead, we use debouncing to schedule a request\n *    only after the user has paused typing for a short period\n *    (AIDA_REQUEST_THROTTLER_TIMEOUT_MS). This prevents spamming the backend with\n *    requests for intermediate typing states.\n *\n * 2. **Delaying suggestions:** When a suggestion is received from the AIDA\n *    backend, we don't show it immediately. There is a minimum delay\n *    (DELAY_BEFORE_SHOWING_RESPONSE_MS) from when the request was sent to when\n *    the suggestion is displayed.\n */\nexport class AiCodeCompletion extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  #editor: TextEditor.TextEditor.TextEditor;\n\n  readonly #sessionId: string = crypto.randomUUID();\n  readonly #aidaClient: Host.AidaClient.AidaClient;\n  readonly #serverSideLoggingEnabled: boolean;\n\n  constructor(opts: AgentOptions, editor: TextEditor.TextEditor.TextEditor) {\n    super();\n    this.#aidaClient = opts.aidaClient;\n    this.#serverSideLoggingEnabled = opts.serverSideLoggingEnabled ?? false;\n    this.#editor = editor;\n  }\n\n  #buildRequest(\n      prefix: string, suffix: string,\n      inferenceLanguage: Host.AidaClient.AidaInferenceLanguage = Host.AidaClient.AidaInferenceLanguage.JAVASCRIPT):\n      Host.AidaClient.CompletionRequest {\n    const userTier = Host.AidaClient.convertToUserTierEnum(this.#userTier);\n    function validTemperature(temperature: number|undefined): number|undefined {\n      return typeof temperature === 'number' && temperature >= 0 ? temperature : undefined;\n    }\n    return {\n      client: Host.AidaClient.CLIENT_NAME,\n      prefix,\n      suffix,\n      options: {\n        inference_language: inferenceLanguage,\n        temperature: validTemperature(this.#options.temperature),\n        model_id: this.#options.modelId || undefined,\n        stop_sequences: ['\\n'],  // We are prioritizing single line suggestions to reduce noise\n      },\n      metadata: {\n        disable_user_content_logging: !(this.#serverSideLoggingEnabled ?? false),\n        string_session_id: this.#sessionId,\n        user_tier: userTier,\n        client_version: Root.Runtime.getChromeVersion(),\n      },\n    };\n  }\n\n  async #requestAidaSuggestion(request: Host.AidaClient.CompletionRequest, cursor: number): Promise<void> {\n    const startTime = performance.now();\n    this.dispatchEventToListeners(Events.REQUEST_TRIGGERED, {});\n\n    try {\n      const response = await this.#aidaClient.completeCode(request);\n      if (response && response.generatedSamples.length > 0 && response.generatedSamples[0].generationString) {\n        if (response.generatedSamples[0].attributionMetadata?.attributionAction ===\n            Host.AidaClient.RecitationAction.BLOCK) {\n          this.dispatchEventToListeners(Events.RESPONSE_RECEIVED, {});\n          return;\n        }\n\n        const remainderDelay = Math.max(DELAY_BEFORE_SHOWING_RESPONSE_MS - (performance.now() - startTime), 0);\n        // Delays the rendering of the Code completion\n        setTimeout(() => {\n          // We are not cancelling the previous responses even when there are more recent responses\n          // from the LLM as:\n          // In case the user kept typing characters that are prefix of the previous suggestion, it\n          // is a valid suggestion and we should display it to the user.\n          // In case the user typed a different character, the config for AI auto complete suggestion\n          // will set the suggestion to null.\n          this.#editor.dispatch({\n            effects: TextEditor.Config.setAiAutoCompleteSuggestion.of(\n                {text: response.generatedSamples[0].generationString, from: cursor}),\n          });\n          const citations = response.generatedSamples[0].attributionMetadata?.citations;\n          this.dispatchEventToListeners(Events.RESPONSE_RECEIVED, {citations});\n        }, remainderDelay);\n      } else {\n        this.dispatchEventToListeners(Events.RESPONSE_RECEIVED, {});\n      }\n    } catch {\n      this.dispatchEventToListeners(Events.RESPONSE_RECEIVED, {});\n    }\n  }\n\n  get #userTier(): string|undefined {\n    return Root.Runtime.hostConfig.devToolsAiCodeCompletion?.userTier;\n  }\n\n  get #options(): RequestOptions {\n    const temperature = Root.Runtime.hostConfig.devToolsAiCodeCompletion?.temperature;\n    const modelId = Root.Runtime.hostConfig.devToolsAiCodeCompletion?.modelId;\n\n    return {\n      temperature,\n      modelId,\n    };\n  }\n\n  onTextChanged = Common.Debouncer.debounce((prefix: string, suffix: string, cursor: number) => {\n    void this.#requestAidaSuggestion(this.#buildRequest(prefix, suffix), cursor);\n  }, AIDA_REQUEST_DEBOUNCE_TIMEOUT_MS);\n}\n\nexport const enum Events {\n  RESPONSE_RECEIVED = 'ResponseReceived',\n  REQUEST_TRIGGERED = 'RequestTriggered',\n}\n\nexport interface ResponseReceivedEvent {\n  citations?: Host.AidaClient.Citation[];\n}\n\nexport interface EventTypes {\n  [Events.RESPONSE_RECEIVED]: ResponseReceivedEvent;\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  [Events.REQUEST_TRIGGERED]: {};\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;;;AAIA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,gBAAgB;AAGrB,IAAM,mCAAmC;AACzC,IAAM,mCAAmC;AAiB1C,IAAO,mBAAP,cAAuC,qBAAc,cAAyB;EAClF;EAES,aAAqB,OAAO,WAAU;EACtC;EACA;EAET,YAAY,MAAoB,QAAwC;AACtE,UAAK;AACL,SAAK,cAAc,KAAK;AACxB,SAAK,4BAA4B,KAAK,4BAA4B;AAClE,SAAK,UAAU;EACjB;EAEA,cACI,QAAgB,QAChB,oBAAA,cAA2G;AAE7G,UAAM,WAAgB,gBAAW,sBAAsB,KAAK,SAAS;AACrE,aAAS,iBAAiB,aAA6B;AACrD,aAAO,OAAO,gBAAgB,YAAY,eAAe,IAAI,cAAc;IAC7E;AACA,WAAO;MACL,QAAa,gBAAW;MACxB;MACA;MACA,SAAS;QACP,oBAAoB;QACpB,aAAa,iBAAiB,KAAK,SAAS,WAAW;QACvD,UAAU,KAAK,SAAS,WAAW;QACnC,gBAAgB,CAAC,IAAI;;;MAEvB,UAAU;QACR,8BAA8B,EAAE,KAAK,6BAA6B;QAClE,mBAAmB,KAAK;QACxB,WAAW;QACX,gBAAqB,aAAQ,iBAAgB;;;EAGnD;EAEA,MAAM,uBAAuB,SAA4C,QAAc;AACrF,UAAM,YAAY,YAAY,IAAG;AACjC,SAAK,yBAAwB,oBAA2B,CAAA,CAAE;AAE1D,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,YAAY,aAAa,OAAO;AAC5D,UAAI,YAAY,SAAS,iBAAiB,SAAS,KAAK,SAAS,iBAAiB,CAAC,EAAE,kBAAkB;AACrG,YAAI,SAAS,iBAAiB,CAAC,EAAE,qBAAqB,sBAC7C,gBAAW,iBAAiB,OAAO;AAC1C,eAAK,yBAAwB,oBAA2B,CAAA,CAAE;AAC1D;QACF;AAEA,cAAM,iBAAiB,KAAK,IAAI,oCAAoC,YAAY,IAAG,IAAK,YAAY,CAAC;AAErG,mBAAW,MAAK;AAOd,eAAK,QAAQ,SAAS;YACpB,SAAoB,kBAAO,4BAA4B,GACnD,EAAC,MAAM,SAAS,iBAAiB,CAAC,EAAE,kBAAkB,MAAM,OAAM,CAAC;WACxE;AACD,gBAAM,YAAY,SAAS,iBAAiB,CAAC,EAAE,qBAAqB;AACpE,eAAK,yBAAwB,oBAA2B,EAAC,UAAS,CAAC;QACrE,GAAG,cAAc;MACnB,OAAO;AACL,aAAK,yBAAwB,oBAA2B,CAAA,CAAE;MAC5D;IACF,QAAQ;AACN,WAAK,yBAAwB,oBAA2B,CAAA,CAAE;IAC5D;EACF;EAEA,IAAI,YAAS;AACX,WAAY,aAAQ,WAAW,0BAA0B;EAC3D;EAEA,IAAI,WAAQ;AACV,UAAM,cAAmB,aAAQ,WAAW,0BAA0B;AACtE,UAAM,UAAe,aAAQ,WAAW,0BAA0B;AAElE,WAAO;MACL;MACA;;EAEJ;EAEA,gBAAuB,iBAAU,SAAS,CAAC,QAAgB,QAAgB,WAAkB;AAC3F,SAAK,KAAK,uBAAuB,KAAK,cAAc,QAAQ,MAAM,GAAG,MAAM;EAC7E,GAAG,gCAAgC;;",
  "names": []
}
