{"version":3,"file":"TreeHelpers.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/TreeHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nimport {eventIsInBounds, microSecondsToMilliseconds} from './Timing.js';\n\nlet nodeIdCount = 0;\nexport const makeTraceEntryNodeId = (): TraceEntryNodeId => (++nodeIdCount) as TraceEntryNodeId;\n\nexport const makeEmptyTraceEntryTree = (): TraceEntryTree => ({\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nexport const makeEmptyTraceEntryNode = (entry: Types.Events.Event, id: TraceEntryNodeId): TraceEntryNode => ({\n  entry,\n  id,\n  parent: null,\n  children: [],\n  depth: 0,\n});\n\nexport interface TraceEntryTree {\n  roots: Set<TraceEntryNode>;\n  maxDepth: number;\n}\n\n/** Node in the graph that defines all parent/child relationships. */\nexport interface TraceEntryNode {\n  entry: Types.Events.Event;\n  depth: number;\n  selfTime?: Types.Timing.MicroSeconds;\n  id: TraceEntryNodeId;\n  parent: TraceEntryNode|null;\n  children: TraceEntryNode[];\n}\n\nexport interface AINodeSerialized {\n  name: string;\n  dur?: number;\n  self?: number;\n  children?: AINodeSerialized[];\n  url?: string;\n  selected?: boolean;\n}\n\n/**\n * Node in a graph simplified for AI Assistance processing. The graph mirrors the TraceEntryNode one.\n * Huge tip of the hat to Victor Porof for prototyping this with some great work: https://crrev.com/c/5711249\n */\nexport class AINode {\n  // event: Types.Events.Event; // Set in the constructor.\n  name: string;\n  duration?: Types.Timing.MilliSeconds;\n  selfDuration?: Types.Timing.MilliSeconds;\n  id?: TraceEntryNodeId;\n  children?: AINode[];\n  url?: string;\n  selected?: boolean;\n\n  constructor(public event: Types.Events.Event) {\n    this.name = event.name;\n    this.duration = event.dur === undefined ? undefined : microSecondsToMilliseconds(event.dur);\n\n    if (Types.Events.isProfileCall(event)) {\n      this.name = event.callFrame.functionName || '(anonymous)';\n      this.url = event.callFrame.url;\n    }\n  }\n\n  // Manually handle how nodes in this tree are serialized. We'll drop serveral properties that we don't need in the JSON string.\n  // FYI: toJSON() is invoked implicitly via JSON.stringify()\n  toJSON(): AINodeSerialized {\n    return {\n      selected: this.selected,\n      name: this.name,\n      url: this.url,\n      // Round milliseconds because we don't need the precision\n      dur: this.duration === undefined ? undefined : Math.round(this.duration * 10) / 10,\n      self: this.selfDuration === undefined ? undefined : Math.round(this.selfDuration * 10) / 10,\n      children: this.children?.length ? this.children : undefined,\n    };\n  }\n\n  static #fromTraceEvent(event: Types.Events.Event): AINode {\n    return new AINode(event);\n  }\n\n  /**\n   * Builds a TraceEntryNodeForAI tree from a node and marks the selected node. Primary entrypoint from EntriesFilter\n   */\n  static fromEntryNode(selectedNode: TraceEntryNode, entryIsVisibleInTimeline: (event: Types.Events.Event) => boolean):\n      AINode {\n    /**\n     * Builds a AINode tree from a TraceEntryNode tree and marks the selected node.\n     */\n    function fromEntryNodeAndTree(node: TraceEntryNode): AINode {\n      const aiNode = AINode.#fromTraceEvent(node.entry);\n      aiNode.id = node.id;\n      if (node === selectedNode) {\n        aiNode.selected = true;\n      }\n      aiNode.selfDuration = node.selfTime === undefined ? undefined : microSecondsToMilliseconds(node.selfTime);\n      for (const child of node.children) {\n        aiNode.children ??= [];\n        aiNode.children.push(fromEntryNodeAndTree(child));\n      }\n      return aiNode;\n    }\n\n    function findTopMostVisibleAncestor(node: TraceEntryNode): TraceEntryNode {\n      const parentNodes = [node];\n      let parent = node.parent;\n      while (parent) {\n        parentNodes.unshift(parent);\n        parent = parent.parent;\n      }\n      return parentNodes.find(node => entryIsVisibleInTimeline(node.entry)) ?? node;\n    }\n\n    const topMostVisibleRoot = findTopMostVisibleAncestor(selectedNode);\n    const aiNode = fromEntryNodeAndTree(topMostVisibleRoot);\n\n    // If our root wasn't visible, this could return an array of multiple RunTasks.\n    // But with a visible root, we safely get back the exact same root, now with its descendent tree updated.\n    // Filter to ensure our tree here only has \"visible\" entries\n    const [filteredAiNodeRoot] = AINode.#filterRecursive([aiNode], node => {\n      if (node.event.name === 'V8.CompileCode' || node.event.name === 'UpdateCounters') {\n        return false;\n      }\n      return entryIsVisibleInTimeline(node.event);\n    });\n    return filteredAiNodeRoot;\n  }\n\n  static getSelectedNodeWithinTree(node: AINode): AINode|null {\n    if (node.selected) {\n      return node;\n    }\n    if (!node.children) {\n      return null;\n    }\n    for (const child of node.children) {\n      const returnedNode = AINode.getSelectedNodeWithinTree(child);\n      if (returnedNode) {\n        return returnedNode;\n      }\n    }\n    return null;\n  }\n\n  static #filterRecursive(list: AINode[], predicate: (node: AINode) => boolean): AINode[] {\n    let done;\n    do {\n      done = true;\n      const filtered: AINode[] = [];\n      for (const node of list) {\n        if (predicate(node)) {\n          // Keep it\n          filtered.push(node);\n        } else if (node.children) {\n          filtered.push(...node.children);\n          done = false;\n        }\n      }\n      list = filtered;\n    } while (!done);\n\n    for (const node of list) {\n      if (node.children) {\n        node.children = AINode.#filterRecursive(node.children, predicate);\n      }\n    }\n    return list;\n  }\n\n  static #removeInexpensiveNodesRecursively(\n      list: AINode[],\n      options?: {minDuration?: number, minSelf?: number, minJsDuration?: number, minJsSelf?: number}): AINode[] {\n    const minDuration = options?.minDuration ?? 0;\n    const minSelf = options?.minSelf ?? 0;\n    const minJsDuration = options?.minJsDuration ?? 0;\n    const minJsSelf = options?.minJsSelf ?? 0;\n\n    const isJS = (node: AINode): boolean => Boolean(node.url);\n    const longEnough = (node: AINode): boolean =>\n        node.duration === undefined || node.duration >= (isJS(node) ? minJsDuration : minDuration);\n    const selfLongEnough = (node: AINode): boolean =>\n        node.selfDuration === undefined || node.selfDuration >= (isJS(node) ? minJsSelf : minSelf);\n\n    return AINode.#filterRecursive(list, node => longEnough(node) && selfLongEnough(node));\n  }\n\n  // Invoked from DrJonesPerformanceAgent\n  sanitize(): void {\n    if (this.children) {\n      this.children = AINode.#removeInexpensiveNodesRecursively(this.children, {\n        minDuration: Types.Timing.MilliSeconds(1),\n        minJsDuration: Types.Timing.MilliSeconds(1),\n        minJsSelf: Types.Timing.MilliSeconds(0.1),\n      });\n    }\n  }\n}\n\nclass TraceEntryNodeIdTag {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #tag: (symbol|undefined);\n}\nexport type TraceEntryNodeId = number&TraceEntryNodeIdTag;\n\n/**\n * Builds a hierarchy of the entries (trace events and profile calls) in\n * a particular thread of a particular process, assuming that they're\n * sorted, by iterating through all of the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A\n * stack maintains local context. A scanner peeks and pops from the data\n * stream. Various \"tokens\" (events) are treated as \"whitespace\"\n * (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built.\n * The nodes are also assumed to be created empty, with no known parent\n * or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(entries: Types.Events.Event[], options?: {\n  filter: {has: (name: Types.Events.Name) => boolean},\n}): {tree: TraceEntryTree, entryToNode: Map<Types.Events.Event, TraceEntryNode>} {\n  // As we construct the tree, store a map of each entry to its node. This\n  // means if you are iterating over a list of RendererEntry events you can\n  // easily look up that node in the tree.\n  const entryToNode = new Map<Types.Events.Event, TraceEntryNode>();\n\n  const stack = [];\n  // Reset the node id counter for every new renderer.\n  nodeIdCount = -1;\n  const tree = makeEmptyTraceEntryTree();\n\n  for (let i = 0; i < entries.length; i++) {\n    const event = entries[i];\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (options && !options.filter.has(event.name as Types.Events.Name)) {\n      continue;\n    }\n\n    const duration = event.dur || 0;\n    const nodeId = makeTraceEntryNodeId();\n    const node = makeEmptyTraceEntryNode(event, nodeId);\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      tree.roots.add(node);\n      node.selfTime = Types.Timing.MicroSeconds(duration);\n      stack.push(node);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      entryToNode.set(event, node);\n      continue;\n    }\n\n    const parentNode = stack.at(-1);\n    if (parentNode === undefined) {\n      throw new Error('Impossible: no parent node found in the stack');\n    }\n\n    const parentEvent = parentNode.entry;\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = parentEvent.dur || 0;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possiblities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      // The last created node has been discarded, so discard this id.\n      nodeIdCount--;\n      continue;\n    }\n    // 3. If the current event starts during the parent event, but ends\n    //    after it, then the data is messed up some way, for example a\n    //    profile call was sampled too late after its start, ignore the\n    //    problematic event.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      continue;\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    node.depth = stack.length;\n    node.parent = parentNode;\n    parentNode.children.push(node);\n    node.selfTime = Types.Timing.MicroSeconds(duration);\n    if (parentNode.selfTime !== undefined) {\n      parentNode.selfTime = Types.Timing.MicroSeconds(parentNode.selfTime - (event.dur || 0));\n    }\n    stack.push(node);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    entryToNode.set(event, node);\n  }\n  return {tree, entryToNode};\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n */\nexport function walkTreeFromEntry(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootEntry: Types.Events.Event,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    ): void {\n  const startNode = entryToNode.get(rootEntry);\n  if (!startNode) {\n    return;\n  }\n  walkTreeByNode(entryToNode, startNode, onEntryStart, onEntryEnd);\n}\n\n/**\n * Given a Helpers.TreeHelpers.RendererTree, this will iterates events in hierarchically, visiting\n * each root node and working from top to bottom, calling back on every event's\n * start and end in the order as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n * 10. Start E\n * 11. End E\n *\n */\n\nexport function walkEntireTree(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    tree: TraceEntryTree,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicroSeconds,\n    minDuration?: Types.Timing.MicroSeconds,\n    ): void {\n  for (const rootNode of tree.roots) {\n    walkTreeByNode(entryToNode, rootNode, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n}\n\nfunction walkTreeByNode(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootNode: TraceEntryNode,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicroSeconds,\n    minDuration?: Types.Timing.MicroSeconds,\n    ): void {\n  if (traceWindowToInclude && !treeNodeIsInWindow(rootNode, traceWindowToInclude)) {\n    // If this node is not within the provided window, we can skip it. We also\n    // can skip all its children too, as we know they won't be in the window if\n    // their parent is not.\n    return;\n  }\n\n  if (typeof minDuration !== 'undefined') {\n    const duration = Types.Timing.MicroSeconds(\n        rootNode.entry.ts + Types.Timing.MicroSeconds(rootNode.entry.dur ?? 0),\n    );\n    if (duration < minDuration) {\n      return;\n    }\n  }\n\n  onEntryStart(rootNode.entry);\n  for (const child of rootNode.children) {\n    walkTreeByNode(entryToNode, child, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n  onEntryEnd(rootNode.entry);\n}\n\n/**\n * Returns true if the provided node is partially or fully within the trace\n * window. The entire node does not have to fit inside the window, but it does\n * have to partially intersect it.\n */\nfunction treeNodeIsInWindow(node: TraceEntryNode, traceWindow: Types.Timing.TraceWindowMicroSeconds): boolean {\n  return eventIsInBounds(node.entry, traceWindow);\n}\n\n/**\n * Determines if the given events, which are assumed to be ordered can\n * be organized into tree structures.\n * This condition is met if there is *not* a pair of async events\n * e1 and e2 where:\n *\n * e1.startTime < e2.startTime && e1.endTime > e2.startTime && e1.endTime < e2.endTime.\n * or, graphically:\n * |------- e1 ------|\n *   |------- e2 --------|\n *\n * Because a parent-child relationship cannot be made from the example\n * above, a tree cannot be made from the set of events.\n *\n * Sync events from the same thread are tree-able by definition.\n *\n * Note that this will also return true if multiple trees can be\n * built, for example if none of the events overlap with each other.\n */\nexport function canBuildTreesFromEvents(events: readonly Types.Events.Event[]): boolean {\n  const stack: Types.Events.Event[] = [];\n  for (const event of events) {\n    const startTime = event.ts;\n    const endTime = event.ts + (event.dur ?? 0);\n    let parent = stack.at(-1);\n    if (parent === undefined) {\n      stack.push(event);\n      continue;\n    }\n    let parentEndTime = parent.ts + (parent.dur ?? 0);\n    // Discard events that are not parents for this event. The parent\n    // is one whose end time is after this event start time.\n    while (stack.length && startTime >= parentEndTime) {\n      stack.pop();\n      parent = stack.at(-1);\n\n      if (parent === undefined) {\n        break;\n      }\n      parentEndTime = parent.ts + (parent.dur ?? 0);\n    }\n    if (stack.length && endTime > parentEndTime) {\n      // If such an event exists but its end time is before this\n      // event's end time, then a tree cannot be made using this\n      // events.\n      return false;\n    }\n    stack.push(event);\n  }\n  return true;\n}\n"]}