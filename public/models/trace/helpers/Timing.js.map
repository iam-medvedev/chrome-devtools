{"version":3,"file":"Timing.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/Timing.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nimport {getNavigationForTraceEvent} from './Trace.js';\n\nexport const milliToMicro = (value: Types.Timing.Milli): Types.Timing.Micro => Types.Timing.Micro(value * 1000);\n\nexport const secondsToMilli = (value: Types.Timing.Seconds): Types.Timing.Milli => Types.Timing.Milli(value * 1000);\n\nexport const secondsToMicro = (value: Types.Timing.Seconds): Types.Timing.Micro => milliToMicro(secondsToMilli(value));\n\nexport const microToMilli = (value: Types.Timing.Micro): Types.Timing.Milli => Types.Timing.Milli(value / 1000);\n\nexport const microToSeconds = (value: Types.Timing.Micro): Types.Timing.Seconds =>\n    Types.Timing.Seconds(value / 1000 / 1000);\n\nexport function timeStampForEventAdjustedByClosestNavigation(\n    event: Types.Events.Event,\n    traceBounds: Types.Timing.TraceWindowMicro,\n    navigationsByNavigationId: Map<string, Types.Events.NavigationStart>,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Timing.Micro {\n  let eventTimeStamp = event.ts - traceBounds.min;\n  if (event.args?.data?.navigationId) {\n    const navigationForEvent = navigationsByNavigationId.get(event.args.data.navigationId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  } else if (event.args?.data?.frame) {\n    const navigationForEvent = getNavigationForTraceEvent(event, event.args.data.frame, navigationsByFrameId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  }\n  return Types.Timing.Micro(eventTimeStamp);\n}\n\n// Expands the trace window by a provided percentage or, if it the expanded window is smaller than 1 millisecond, expands it to 1 millisecond.\n// If the expanded window is outside of the max trace window, cut the overflowing bound to the max trace window bound.\nexport function expandWindowByPercentOrToOneMillisecond(\n    annotationWindow: Types.Timing.TraceWindowMicro, maxTraceWindow: Types.Timing.TraceWindowMicro,\n    percentage: number): Types.Timing.TraceWindowMicro {\n  // Expand min and max of the window by half of the provided percentage. That way, in total, the window will be expanded by the provided percentage.\n  let newMin = annotationWindow.min - annotationWindow.range * (percentage / 100) / 2;\n  let newMax = annotationWindow.max + annotationWindow.range * (percentage / 100) / 2;\n\n  if (newMax - newMin < 1_000) {\n    const rangeMiddle = (annotationWindow.min + annotationWindow.max) / 2;\n    newMin = rangeMiddle - 500;\n    newMax = rangeMiddle + 500;\n  }\n\n  newMin = Math.max(newMin, maxTraceWindow.min);\n  newMax = Math.min(newMax, maxTraceWindow.max);\n\n  const expandedWindow: Types.Timing.TraceWindowMicro = {\n    min: Types.Timing.Micro(newMin),\n    max: Types.Timing.Micro(newMax),\n    range: Types.Timing.Micro(newMax - newMin),\n  };\n\n  return expandedWindow;\n}\n\nexport interface EventTimingsData<ValueType extends Types.Timing.Micro|Types.Timing.Milli|Types.Timing.Seconds, > {\n  startTime: ValueType;\n  endTime: ValueType;\n  duration: ValueType;\n}\n\nexport function eventTimingsMicroSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Micro> {\n  return {\n    startTime: event.ts as Types.Timing.Micro,\n    endTime: (event.ts + (event.dur ?? 0)) as Types.Timing.Micro,\n    duration: (event.dur || 0) as Types.Timing.Micro,\n  };\n}\nexport function eventTimingsMilliSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Milli> {\n  return {\n    startTime: (event.ts / 1000) as Types.Timing.Milli,\n    endTime: (event.ts + (event.dur ?? 0)) / 1000 as Types.Timing.Milli,\n    duration: (event.dur || 0) / 1000 as Types.Timing.Milli,\n  };\n}\n\nexport function traceWindowMilliSeconds(bounds: Types.Timing.TraceWindowMicro): Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowMicroSecondsToMilliSeconds(bounds: Types.Timing.TraceWindowMicro):\n    Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowFromMilliSeconds(\n    min: Types.Timing.Milli, max: Types.Timing.Milli): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min: milliToMicro(min),\n    max: milliToMicro(max),\n    range: Types.Timing.Micro(milliToMicro(max) - milliToMicro(min)),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromMicroSeconds(\n    min: Types.Timing.Micro, max: Types.Timing.Micro): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min,\n    max,\n    range: Types.Timing.Micro(max - min),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromEvent(event: Types.Events.Event): Types.Timing.TraceWindowMicro {\n  return {\n    min: event.ts,\n    max: Types.Timing.Micro(event.ts + (event.dur ?? 0)),\n    range: event.dur ?? Types.Timing.Micro(0),\n  };\n}\n\nexport interface BoundsIncludeTimeRange {\n  timeRange: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Checks to see if the timeRange is within the bounds. By \"within\" we mean\n * \"has any overlap\":\n *         |------------------------|\n *      ==                                     no overlap (entirely before)\n *       =========                             overlap\n *            =========                        overlap\n *                             =========       overlap\n *                                     ====    no overlap (entirely after)\n *        ==============================       overlap (time range is larger than bounds)\n *         |------------------------|\n */\nexport function boundsIncludeTimeRange(data: BoundsIncludeTimeRange): boolean {\n  const {min: visibleMin, max: visibleMax} = data.bounds;\n  const {min: rangeMin, max: rangeMax} = data.timeRange;\n\n  return visibleMin <= rangeMax && visibleMax >= rangeMin;\n}\n\n/** Checks to see if the event is within or overlaps the bounds */\nexport function eventIsInBounds(event: Types.Events.Event, bounds: Types.Timing.TraceWindowMicro): boolean {\n  const startTime = event.ts;\n  return startTime <= bounds.max && bounds.min <= (startTime + (event.dur ?? 0));\n}\n\nexport function timestampIsInBounds(bounds: Types.Timing.TraceWindowMicro, timestamp: Types.Timing.Micro): boolean {\n  return timestamp >= bounds.min && timestamp <= bounds.max;\n}\n\nexport interface WindowFitsInsideBounds {\n  window: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Returns true if the window fits entirely within the bounds.\n * Note that if the window is equivalent to the bounds, that is considered to fit\n */\nexport function windowFitsInsideBounds(data: WindowFitsInsideBounds): boolean {\n  return data.window.min >= data.bounds.min && data.window.max <= data.bounds.max;\n}\n\nexport function windowsEqual(w1: Types.Timing.TraceWindowMicro, w2: Types.Timing.TraceWindowMicro): boolean {\n  return w1.min === w2.min && w1.max === w2.max;\n}\n"]}