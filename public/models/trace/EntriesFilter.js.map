{"version":3,"file":"EntriesFilter.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/EntriesFilter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Helpers from './helpers/helpers.js';\nimport * as Types from './types/types.js';\n\ntype EntryToNodeMap = Map<Types.TraceEvents.TraceEntry, Helpers.TreeHelpers.TraceEntryNode>;\n\nexport type FilterAction = FilterApplyAction|FilterUndoAction;\n\nexport const enum FilterApplyAction {\n  MERGE_FUNCTION = 'MERGE_FUNCTION',\n  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',\n  COLLAPSE_REPEATING_DESCENDANTS = 'COLLAPSE_REPEATING_DESCENDANTS',\n}\n\nexport const enum FilterUndoAction {\n  RESET_CHILDREN = 'RESET_CHILDREN',\n  UNDO_ALL_ACTIONS = 'UNDO_ALL_ACTIONS',\n}\n\nconst filterApplyActionSet: Set<FilterApplyAction> = new Set([\n  FilterApplyAction.MERGE_FUNCTION,\n  FilterApplyAction.COLLAPSE_FUNCTION,\n  FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS,\n]);\n\nconst filterUndoActionSet: Set<FilterUndoAction> = new Set([\n  FilterUndoAction.RESET_CHILDREN,\n  FilterUndoAction.UNDO_ALL_ACTIONS,\n]);\n\n// Object passed from the frontend that can be either Undo or Apply filter action.\nexport interface UserFilterAction {\n  type: FilterAction;\n  entry: Types.TraceEvents.TraceEntry;\n}\n\nexport interface UserApplyFilterAction {\n  type: FilterApplyAction;\n  entry: Types.TraceEvents.TraceEntry;\n}\n\n// Object used to indicate to the Context Menu if an action is possible on the selected entry.\nexport interface PossibleFilterActions {\n  [FilterApplyAction.COLLAPSE_FUNCTION]: boolean;\n  [FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS]: boolean;\n}\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the invisibleEntries() method will return the\n * entries that are invisible, and this is the list of entries that should be\n * removed before rendering the resulting thread on the timeline.\n **/\nexport class EntriesFilter {\n  // Maps from an individual TraceEvent entry to its representation as a\n  // RendererEntryNode. We need this so we can then parse the tree structure\n  // generated by the RendererHandler.\n  #entryToNode: EntryToNodeMap;\n\n  // Track the set of invisible entries.\n  #invisibleEntries: Types.TraceEvents.TraceEventData[] = [];\n  // List of entries whose children are modified. This list is used to\n  // keep track of entries that should be identified in the UI as modified.\n  #modifiedVisibleEntries: Types.TraceEvents.TraceEventData[] = [];\n  // Cache for descendants of entry that have already been gathered. The descendants\n  // will never change so we can avoid running the potentially expensive search again.\n  #entryToDescendantsMap: Map<Helpers.TreeHelpers.TraceEntryNode, Types.TraceEvents.TraceEventData[]> = new Map();\n\n  constructor(entryToNode: EntryToNodeMap) {\n    this.#entryToNode = entryToNode;\n  }\n\n  /**\n   * Applies an action to hide entries or removes entries\n   * from hidden entries array depending on the type of action.\n   **/\n  applyAction(action: UserFilterAction): void {\n    if (/* FilterApplyActions */ this.#isUserApplyFilterAction(action)) {\n      this.#applyFilterAction(action);\n\n    } else if (/* FilterUndoActions */ this.#isFilterUndoAction(action.type)) {\n      this.#applyUndoAction(action);\n    }\n  }\n\n  /**\n   * Checks which actions can be applied on an entry. This allows us to only show possible actions in the Context Menu.\n   * For example, if an entry has no children, COLLAPSE_FUNCTION will not change the FlameChart, therefore there is no need to show this action as an option.\n   **/\n  findPossibleActions(entry: Types.TraceEvents.TraceEntry): PossibleFilterActions {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, return no possible actions.\n      return {\n        [FilterApplyAction.COLLAPSE_FUNCTION]: false,\n        [FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS]: false,\n      };\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n    // If there are children to hide, indicate action as possible\n    const possibleActions: PossibleFilterActions = {\n      [FilterApplyAction.COLLAPSE_FUNCTION]: allDescendants.length > 0,\n      [FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS]: allRepeatingDescendants.length > 0,\n    };\n    return possibleActions;\n  }\n\n  /**\n   * Returns the amount of entry descendants that belong to the hidden entries array.\n   * **/\n  findHiddenDescendantsAmount(entry: Types.TraceEvents.TraceEntry): number {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      return 0;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    return allDescendants.filter(descendant => this.invisibleEntries().includes(descendant)).length;\n  }\n\n  /**\n   * If undo action is UNDO_ALL_ACTIONS, assign invisibleEntries array to an empty one.\n   * **/\n  #applyUndoAction(action: UserFilterAction): void {\n    switch (action.type) {\n      case FilterUndoAction.UNDO_ALL_ACTIONS: {\n        this.#invisibleEntries = [];\n        this.#modifiedVisibleEntries = [];\n        break;\n      }\n      case FilterUndoAction.RESET_CHILDREN: {\n        this.#makeEntryChildrenVisible(action.entry);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Returns the set of entries that are invisible given the set of applied actions.\n   **/\n  invisibleEntries(): Types.TraceEvents.TraceEventData[] {\n    return this.#invisibleEntries;\n  }\n\n  #applyFilterAction(action: UserApplyFilterAction): Types.TraceEvents.TraceEventData[] {\n    // We apply new user action to the set of all entries, and mark\n    // any that should be hidden by adding them to this set.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set and return it as an array at the end.\n    const entriesToHide = new Set<Types.TraceEvents.TraceEventData>();\n\n    switch (action.type) {\n      case FilterApplyAction.MERGE_FUNCTION: {\n        // The entry that was clicked on is merged into its parent. All its\n        // children remain visible, so we just have to hide the entry that was\n        // selected.\n        entriesToHide.add(action.entry);\n        // If parent node exists, add it to modifiedVisibleEntries, so it would be possible to uncollapse its' children.\n        const actionNode = this.#entryToNode.get(action.entry) || null;\n        const parentNode = actionNode && this.#findNextVisibleParent(actionNode);\n        if (parentNode) {\n          this.#modifiedVisibleEntries.push(parentNode?.entry);\n        }\n        break;\n      }\n\n      case FilterApplyAction.COLLAPSE_FUNCTION: {\n        // The entry itself remains visible, but all of its descendants are hidden.\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n        allDescendants.forEach(descendant => entriesToHide.add(descendant));\n        // If there are any children to hide, add selected entry to modifiedVisibleEntries array to identify in the UI that children of the selected entry are modified.\n        if (entriesToHide.size > 0) {\n          this.#modifiedVisibleEntries.push(action.entry);\n        }\n        break;\n      }\n\n      case FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS: {\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n        allRepeatingDescendants.forEach(descendant => entriesToHide.add(descendant));\n        if (entriesToHide.size > 0) {\n          this.#modifiedVisibleEntries.push(action.entry);\n        }\n        break;\n      }\n      default:\n        Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);\n    }\n\n    this.#invisibleEntries.push(...entriesToHide);\n\n    return this.#invisibleEntries;\n  }\n\n  // The direct parent might be hidden by other actions, therefore we look for the next visible parent.\n  #findNextVisibleParent(node: Helpers.TreeHelpers.TraceEntryNode): Helpers.TreeHelpers.TraceEntryNode|null {\n    let parent = node.parent;\n    while (parent && this.#invisibleEntries.includes(parent.entry)) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  #findAllDescendantsOfNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEventData[] {\n    const cachedDescendants = this.#entryToDescendantsMap.get(root);\n    if (cachedDescendants) {\n      return cachedDescendants;\n    }\n\n    const descendants: Types.TraceEvents.TraceEventData[] = [];\n\n    // Walk through all the descendants, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        descendants.push(childNode.entry);\n        const childNodeCachedDescendants = this.#entryToDescendantsMap.get(childNode);\n        // If the descendants of a child are cached, get them from the cache instead of iterating through them again\n        if (childNodeCachedDescendants) {\n          descendants.push(...childNodeCachedDescendants);\n        } else {\n          children.push(...childNode.children);\n        }\n      }\n    }\n\n    this.#entryToDescendantsMap.set(root, descendants);\n    return descendants;\n  }\n\n  #findAllRepeatingDescendantsOfNext(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {\n    // Walk through all the descendants, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    const repeatingNodes: Types.TraceEvents.TraceEntry[] = [];\n    const rootIsProfileCall = Types.TraceEvents.isProfileCall(root.entry);\n\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        const childIsProfileCall = Types.TraceEvents.isProfileCall(childNode.entry);\n        if (/* Handle TraceEventSyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {\n          const rootNodeEntry = root.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;\n          const childNodeEntry = childNode.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;\n\n          if (Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(\n                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {\n            repeatingNodes.push(childNode.entry);\n          }\n        } /* Handle SyntheticRendererEvents */ else if (!rootIsProfileCall && !childIsProfileCall) {\n          if (root.entry.name === childNode.entry.name) {\n            repeatingNodes.push(childNode.entry);\n          }\n        }\n        children.push(...childNode.children);\n      }\n    }\n\n    return repeatingNodes;\n  }\n\n  /**\n   * Removes all of the entry children from the\n   * invisible entries array to make them visible.\n   **/\n  #makeEntryChildrenVisible(entry: Types.TraceEvents.TraceEntry): void {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const descendants = this.#findAllDescendantsOfNode(entryNode);\n\n    /**\n     * Filter out all descendant of the node\n     * from the invisible entries list.\n     **/\n    this.#invisibleEntries = this.#invisibleEntries.filter(entry => {\n      if (descendants.includes(entry)) {\n        return false;\n      }\n      return true;\n    });\n\n    /**\n     * Filter out all descentants and entry from modified entries\n     * list to not show that some entries below those are hidden.\n     **/\n    this.#modifiedVisibleEntries = this.#modifiedVisibleEntries.filter(iterEntry => {\n      if (descendants.includes(iterEntry) || iterEntry === entry) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  isEntryModified(event: Types.TraceEvents.TraceEventData): boolean {\n    return this.#modifiedVisibleEntries.includes(event);\n  }\n\n  #isUserApplyFilterAction(action: UserFilterAction): action is UserApplyFilterAction {\n    return filterApplyActionSet.has(action.type as FilterApplyAction);\n  }\n\n  #isFilterUndoAction(action: FilterAction): action is FilterUndoAction {\n    return filterUndoActionSet.has(action as FilterUndoAction);\n  }\n}\n"]}