{"version":3,"file":"EntriesFilter.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/EntriesFilter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Helpers from './helpers/helpers.js';\nimport * as Types from './types/types.js';\n\ntype EntryToNodeMap = Map<Types.TraceEvents.TraceEntry, Helpers.TreeHelpers.TraceEntryNode>;\n\nexport type FilterAction = FilterApplyAction|FilterUndoAction;\n\nexport const enum FilterApplyAction {\n  MERGE_FUNCTION = 'MERGE_FUNCTION',\n  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',\n  COLLAPSE_REPEATING_DESCENDANTS = 'COLLAPSE_REPEATING_DESCENDANTS',\n}\n\n// TODO(crbug.com/1469887): Implement UNDO_MERGE function when it's decided how to select merged function.\nexport const enum FilterUndoAction {\n  UNDO_ALL_ACTIONS = 'UNDO_ALL_ACTIONS',\n  UNDO_COLLAPSE_FUNCTION = 'UNDO_COLLAPSE_FUNCTION',\n  UNDO_COLLAPSE_REPEATING_DESCENDANTS = 'UNDO_COLLAPSE_REPEATING_DESCENDANTS',\n}\n\nconst filterApplyActionSet: Set<FilterApplyAction> = new Set([\n  FilterApplyAction.MERGE_FUNCTION,\n  FilterApplyAction.COLLAPSE_FUNCTION,\n  FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS,\n]);\n\nconst filterUndoActionSet: Set<FilterUndoAction> = new Set([\n  FilterUndoAction.UNDO_ALL_ACTIONS,\n  FilterUndoAction.UNDO_COLLAPSE_FUNCTION,\n  FilterUndoAction.UNDO_COLLAPSE_REPEATING_DESCENDANTS,\n]);\n\nconst actionToUndoActionMap: Map<FilterUndoAction, FilterApplyAction> = new Map([\n  [FilterUndoAction.UNDO_COLLAPSE_FUNCTION, FilterApplyAction.COLLAPSE_FUNCTION],\n  [FilterUndoAction.UNDO_COLLAPSE_REPEATING_DESCENDANTS, FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS],\n]);\n\n// Object passed from the frontend that can be either Undo or Apply filter action.\nexport interface UserFilterAction {\n  type: FilterAction;\n  entry: Types.TraceEvents.TraceEntry;\n}\n\nexport interface UserApplyFilterAction {\n  type: FilterApplyAction;\n  entry: Types.TraceEvents.TraceEntry;\n}\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the invisibleEntries() method will return the\n * entries that are invisible, and this is the list of entries that should be\n * removed before rendering the resulting thread on the timeline.\n **/\nexport class EntriesFilter {\n  // Maps from an individual TraceEvent entry to its representation as a\n  // RendererEntryNode. We need this so we can then parse the tree structure\n  // generated by the RendererHandler.\n  #entryToNode: EntryToNodeMap;\n\n  // Track the last calculated set of invisible entries. This means we can avoid\n  // re-generating this if the set of actions that have been applied has not\n  // changed.\n  #lastInvisibleEntries: Types.TraceEvents.TraceEntry[]|null = null;\n  #activeActions: UserApplyFilterAction[] = [];\n\n  constructor(entryToNode: EntryToNodeMap) {\n    this.#entryToNode = entryToNode;\n  }\n\n  /**\n   * Adds or removes an action (filter) to/from activeActions\n   * array depending on the type of action.\n   **/\n  applyAction(action: UserFilterAction): void {\n    if (/* FilterApplyActions */ this.isUserApplyFilterAction(action)) {\n      if (this.#actionIsActive(action)) {\n        // If the action is already active there is no reason to apply it again.\n        return;\n      }\n      this.#activeActions.push(action);\n    } else if (/* FilterUndoActions */ this.isFilterUndoAction(action.type)) {\n      this.#applyUndoAction(action.type, action.entry);\n    }\n    // Clear the last list of invisible entries - this invalidates the cache and\n    // ensures that the invisible list will be recalculated, which we have to do\n    // now we have changed the list of actions.\n    this.#lastInvisibleEntries = null;\n  }\n\n  /**\n   * If undo action is UNDO_ALL_ACTIONS, assign activeActions array to an empty one.\n   * Otherwise, get the action to remove from actionToUndoActionMap and remove it form the activeActions array.\n   * Afterwards, the FlameChart will be rerendered and activeActions will be reaplied without the removed action.\n   * **/\n  #applyUndoAction(action: FilterUndoAction, entry: Types.TraceEvents.TraceEntry): void {\n    switch (action) {\n      case FilterUndoAction.UNDO_ALL_ACTIONS: {\n        this.#activeActions = [];\n        break;\n      }\n      default: {\n        const actionToRemove = actionToUndoActionMap.get(action);\n        if (actionToRemove) {\n          this.removeActiveAction(\n              {\n                type: actionToRemove,\n                entry: entry,\n              },\n          );\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Removes a matching action, if one is found, from the active actions set.\n   * Note that we do not match on action equality and instead search through\n   * the set of active actions for one that is of the same type, and has the\n   * same entry associated with it.\n   *\n   * This is a no-op if the action is not active.\n   **/\n  removeActiveAction(action: UserFilterAction): void {\n    this.#activeActions = this.#activeActions.filter(activeAction => {\n      if (activeAction.type === action.type && activeAction.entry === action.entry) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  #actionIsActive(action: UserApplyFilterAction): boolean {\n    return this.#activeActions.some(activeAction => {\n      return action.entry === activeAction.entry && action.type === activeAction.type;\n    });\n  }\n\n  /**\n   * The set of entries that are invisible given the set of applied actions. If\n   * no actions are applied, this will return an empty list of entries.\n   *\n   * This method is cached, so it is safe to call multiple times.\n   **/\n  invisibleEntries(): Types.TraceEvents.TraceEventData[] {\n    if (this.#activeActions.length === 0) {\n      return [];\n    }\n    return this.#calculateInvisibleEntries();\n  }\n\n  #calculateInvisibleEntries(): Types.TraceEvents.TraceEventData[] {\n    // When an action is added, we clear this cache. So if this cache is\n    // present it means that the set of active actions has not changed, and so\n    // we do not need to recalculate anything.\n    if (this.#lastInvisibleEntries) {\n      return this.#lastInvisibleEntries;\n    }\n\n    // We apply each user action in turn to the set of all entries, and mark\n    // any that should be hidden by adding them to this set. We do this to\n    // ensure we minimise the amount of passes through the list of all entries.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set and return it as an array at the end.\n    const entriesToHide = new Set<Types.TraceEvents.TraceEntry>();\n\n    for (const action of this.#activeActions) {\n      switch (action.type) {\n        case FilterApplyAction.MERGE_FUNCTION: {\n          // The entry that was clicked on is merged into its parent. All its\n          // children remain visible, so we just have to hide the entry that was\n          // selected.\n          entriesToHide.add(action.entry);\n          break;\n        }\n\n        case FilterApplyAction.COLLAPSE_FUNCTION: {\n          // The entry itself remains visible, but all of its ancestors are hidden.\n          const entryNode = this.#entryToNode.get(action.entry);\n          if (!entryNode) {\n            // Invalid node was given, just ignore and move on.\n            continue;\n          }\n          const allAncestors = this.#findAllAncestorsOfNode(entryNode);\n          allAncestors.forEach(ancestor => entriesToHide.add(ancestor));\n          break;\n        }\n\n        case FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS: {\n          const entryNode = this.#entryToNode.get(action.entry);\n          if (!entryNode) {\n            // Invalid node was given, just ignore and move on.\n            continue;\n          }\n          const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n          allRepeatingDescendants.forEach(ancestor => entriesToHide.add(ancestor));\n          break;\n        }\n        default:\n          Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);\n      }\n    }\n\n    // Now we have applied all actions, return the invisible entries.\n    // We cache this under lastInvisibleEntries - if this function is called\n    // again and the user actions have not changed, we can avoid recalculating\n    // this and just return the last one. This cache is automatically cleared\n    // when the user actions are changed.\n\n    this.#lastInvisibleEntries = [...entriesToHide];\n\n    return this.#lastInvisibleEntries;\n  }\n\n  #findAllAncestorsOfNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {\n    const ancestors: Types.TraceEvents.TraceEntry[] = [];\n\n    // Walk through all the ancestors, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        ancestors.push(childNode.entry);\n        children.push(...childNode.children);\n      }\n    }\n\n    return ancestors;\n  }\n\n  #findAllRepeatingDescendantsOfNext(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {\n    // Walk through all the ancestors, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    const repeatingNodes: Types.TraceEvents.TraceEntry[] = [];\n    const rootIsProfileCall = Types.TraceEvents.isProfileCall(root.entry);\n\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        const childIsProfileCall = Types.TraceEvents.isProfileCall(childNode.entry);\n        if (/* Handle TraceEventSyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {\n          const rootNodeEntry = root.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;\n          const childNodeEntry = childNode.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;\n\n          if (Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(\n                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {\n            repeatingNodes.push(childNode.entry);\n          }\n        } /* Handle SyntheticRendererEvents */ else if (!rootIsProfileCall && !childIsProfileCall) {\n          if (root.entry.name === childNode.entry.name) {\n            repeatingNodes.push(childNode.entry);\n          }\n        }\n        children.push(...childNode.children);\n      }\n    }\n\n    return repeatingNodes;\n  }\n\n  isUserApplyFilterAction(action: UserFilterAction): action is UserApplyFilterAction {\n    return filterApplyActionSet.has(action.type as FilterApplyAction);\n  }\n\n  isFilterUndoAction(action: FilterAction): action is FilterUndoAction {\n    return filterUndoActionSet.has(action as FilterUndoAction);\n  }\n}\n"]}