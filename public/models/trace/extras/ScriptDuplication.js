// Copyright 2025 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Ignore modules smaller than an absolute threshold.
const ABSOLUTE_SIZE_THRESHOLD_BYTES = 1024 * 0.5;
// Ignore modules smaller than a % size of largest copy of the module.
const RELATIVE_SIZE_THRESHOLD = 0.1;
/**
 * Using a script's contents and source map, attribute every generated byte to an authored source file.
 */
export function computeGeneratedFileSizes(script) {
    if (!script.sourceMap) {
        throw new Error('expected source map');
    }
    const map = script.sourceMap;
    const content = script.content ?? '';
    const contentLength = content.length;
    const lines = content.split('\n');
    const files = {};
    const totalBytes = contentLength;
    let unmappedBytes = totalBytes;
    const lastGeneratedColumnMap = computeLastGeneratedColumnMap(script.sourceMap);
    for (const mapping of map.mappings()) {
        const source = mapping.sourceURL;
        const lineNum = mapping.lineNumber;
        const colNum = mapping.columnNumber;
        const lastColNum = lastGeneratedColumnMap.get(mapping);
        // Webpack sometimes emits null mappings.
        // https://github.com/mozilla/source-map/pull/303
        if (!source) {
            continue;
        }
        // Lines and columns are zero-based indices. Visually, lines are shown as a 1-based index.
        const line = lines[lineNum];
        if (line === null || line === undefined) {
            const errorMessage = `${map.url()} mapping for line out of bounds: ${lineNum + 1}`;
            return { errorMessage };
        }
        if (colNum > line.length) {
            const errorMessage = `${map.url()} mapping for column out of bounds: ${lineNum + 1}:${colNum}`;
            return { errorMessage };
        }
        let mappingLength = 0;
        if (lastColNum !== undefined) {
            if (lastColNum > line.length) {
                const errorMessage = `${map.url()} mapping for last column out of bounds: ${lineNum + 1}:${lastColNum}`;
                return { errorMessage };
            }
            mappingLength = lastColNum - colNum;
        }
        else {
            // Add +1 to account for the newline.
            mappingLength = line.length - colNum + 1;
        }
        files[source] = (files[source] || 0) + mappingLength;
        unmappedBytes -= mappingLength;
    }
    return {
        files,
        unmappedBytes,
        totalBytes,
    };
}
export function normalizeSource(source) {
    // Trim trailing question mark - b/c webpack.
    source = source.replace(/\?$/, '');
    // Normalize paths for dependencies by only keeping everything after the last `node_modules`.
    const lastNodeModulesIndex = source.lastIndexOf('node_modules');
    if (lastNodeModulesIndex !== -1) {
        source = source.substring(lastNodeModulesIndex);
    }
    return source;
}
function shouldIgnoreSource(source) {
    // Ignore bundle overhead.
    if (source.includes('webpack/bootstrap')) {
        return true;
    }
    if (source.includes('(webpack)/buildin')) {
        return true;
    }
    // Ignore webpack module shims, i.e. aliases of the form `module.exports = window.jQuery`
    if (source.includes('external ')) {
        return true;
    }
    return false;
}
/**
 * Sorts each array within @see ScriptDuplication by attributedSize, drops information
 * on sources that are too small, and calculates esimatedDuplicateBytes.
 */
export function normalizeDuplication(duplication) {
    for (const [key, data] of duplication) {
        // Sort by resource size.
        data.duplicates.sort((a, b) => b.attributedSize - a.attributedSize);
        // Ignore modules smaller than a % size of largest.
        if (data.duplicates.length > 1) {
            const largestResourceSize = data.duplicates[0].attributedSize;
            data.duplicates = data.duplicates.filter(duplicate => {
                const percentSize = duplicate.attributedSize / largestResourceSize;
                return percentSize >= RELATIVE_SIZE_THRESHOLD;
            });
        }
        // Ignore modules smaller than an absolute threshold.
        data.duplicates = data.duplicates.filter(duplicate => duplicate.attributedSize >= ABSOLUTE_SIZE_THRESHOLD_BYTES);
        // Delete any that now don't have multiple entries.
        if (data.duplicates.length <= 1) {
            duplication.delete(key);
            continue;
        }
        data.estimatedDuplicateBytes = data.duplicates.slice(1).reduce((acc, cur) => acc + cur.attributedSize, 0);
    }
}
function indexOfOrLength(haystack, needle, startPosition = 0) {
    const index = haystack.indexOf(needle, startPosition);
    return index === -1 ? haystack.length : index;
}
export function getNodeModuleName(source) {
    const sourceSplit = source.split('node_modules/');
    source = sourceSplit[sourceSplit.length - 1];
    const indexFirstSlash = indexOfOrLength(source, '/');
    if (source[0] === '@') {
        return source.slice(0, indexOfOrLength(source, '/', indexFirstSlash + 1));
    }
    return source.slice(0, indexFirstSlash);
}
function groupByNodeModules(duplication) {
    const groupedDuplication = new Map();
    for (const [source, data] of duplication.entries()) {
        if (!source.includes('node_modules')) {
            groupedDuplication.set(source, data);
            continue;
        }
        const nodeModuleKey = 'node_modules/' + getNodeModuleName(source);
        const aggregatedData = groupedDuplication.get(nodeModuleKey) ?? {
            duplicates: [],
            // This is calculated in normalizeDuplication.
            estimatedDuplicateBytes: 0,
        };
        groupedDuplication.set(nodeModuleKey, aggregatedData);
        for (const { script, attributedSize } of data.duplicates) {
            let duplicate = aggregatedData.duplicates.find(d => d.script === script);
            if (!duplicate) {
                duplicate = { script, attributedSize: 0 };
                aggregatedData.duplicates.push(duplicate);
            }
            duplicate.attributedSize += attributedSize;
        }
    }
    return groupedDuplication;
}
function computeLastGeneratedColumnMap(map) {
    const result = new Map();
    const mappings = map.mappings();
    for (let i = 0; i < mappings.length - 1; i++) {
        const mapping = mappings[i];
        const nextMapping = mappings[i + 1];
        if (mapping.lineNumber === nextMapping.lineNumber) {
            result.set(mapping, nextMapping.columnNumber);
        }
    }
    // Now, all but the last mapping on each line will have 'lastColumnNumber' set to a number.
    return result;
}
/**
 * Returns a @see ScriptDuplication for the given collection of script contents + source maps.
 */
export function computeScriptDuplication(scriptsData) {
    const sizesMap = new Map();
    for (const script of scriptsData.scripts) {
        if (script.content && script.sourceMap) {
            sizesMap.set(script, computeGeneratedFileSizes(script));
        }
    }
    const sourceDatasMap = new Map();
    // Determine size of each `sources` entry.
    for (const [script, sizes] of sizesMap) {
        if (!script.sourceMap) {
            continue;
        }
        if ('errorMessage' in sizes) {
            console.error(sizes.errorMessage);
            continue;
        }
        const sourceDataArray = [];
        sourceDatasMap.set(script, sourceDataArray);
        const sources = script.sourceMap.sourceURLs();
        for (let i = 0; i < sources.length; i++) {
            if (shouldIgnoreSource(sources[i])) {
                continue;
            }
            const sourceSize = sizes.files[sources[i]];
            sourceDataArray.push({
                source: normalizeSource(sources[i]),
                resourceSize: sourceSize,
            });
        }
    }
    let duplication = new Map();
    for (const [script, sourceDataArray] of sourceDatasMap) {
        for (const sourceData of sourceDataArray) {
            let data = duplication.get(sourceData.source);
            if (!data) {
                data = { estimatedDuplicateBytes: 0, duplicates: [] };
                duplication.set(sourceData.source, data);
            }
            data.duplicates.push({
                script,
                attributedSize: sourceData.resourceSize,
            });
        }
    }
    duplication = groupByNodeModules(duplication);
    normalizeDuplication(duplication);
    // Sort by estimated savings.
    return new Map([...duplication].sort((a, b) => b[1].estimatedDuplicateBytes - a[1].estimatedDuplicateBytes));
}
//# sourceMappingURL=ScriptDuplication.js.map