{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/extras/FilmStrip.ts", "../../../../../../../front_end/models/trace/extras/MainThreadActivity.ts", "../../../../../../../front_end/models/trace/extras/ScriptDuplication.ts", "../../../../../../../front_end/models/trace/extras/StackTraceForEvent.ts", "../../../../../../../front_end/models/trace/extras/ThirdParties.ts", "../../../../../../../front_end/models/trace/extras/TraceFilter.ts", "../../../../../../../front_end/models/trace/extras/TraceTree.ts", "../../../../../../../front_end/models/trace/helpers/SamplesIntegrator.ts", "../../../../../../../front_end/models/trace/helpers/Timing.ts", "../../../../../../../front_end/models/trace/helpers/Trace.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport type * as Types from '../types/types.js';\n\nexport interface Data {\n  zeroTime: Types.Timing.Micro;\n  spanTime: Types.Timing.Micro;\n  frames: readonly Frame[];\n}\n\nexport interface Frame {\n  screenshotEvent: Types.Events.LegacySyntheticScreenshot|Types.Events.Screenshot;\n  index: number;\n}\n\nexport type HandlersWithFilmStrip = Handlers.Types.HandlersWithMeta<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Screenshots: typeof Handlers.ModelHandlers.Screenshots,\n}>;\n\nexport type HandlerDataWithScreenshots = Handlers.Types.EnabledHandlerDataWithMeta<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Screenshots: typeof Handlers.ModelHandlers.Screenshots,\n}>;\n\n// Cache film strips based on:\n// 1. The trace parsed data object\n// 2. The start time.\nconst filmStripCache = new WeakMap<HandlerDataWithScreenshots, Map<Types.Timing.Micro, Data>>();\n\nexport function fromHandlerData(data: HandlerDataWithScreenshots, customZeroTime?: Types.Timing.Micro): Data {\n  const frames: Frame[] = [];\n\n  const zeroTime = typeof customZeroTime !== 'undefined' ? customZeroTime : data.Meta.traceBounds.min;\n  const spanTime = data.Meta.traceBounds.range;\n  const fromCache = filmStripCache.get(data)?.get(zeroTime);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  const screenshots = data.Screenshots.screenshots ?? data.Screenshots.legacySyntheticScreenshots ?? [];\n\n  for (const screenshotEvent of screenshots) {\n    if (screenshotEvent.ts < zeroTime) {\n      continue;\n    }\n    const frame: Frame = {\n      index: frames.length,\n      screenshotEvent,\n    };\n    frames.push(frame);\n  }\n\n  const result: Data = {\n    zeroTime,\n    spanTime,\n    frames: Array.from(frames),\n  };\n\n  const cachedForData =\n      Platform.MapUtilities.getWithDefault(filmStripCache, data, () => new Map<Types.Timing.Micro, Data>());\n  cachedForData.set(zeroTime, result);\n\n  return result;\n}\n\nexport function frameClosestToTimestamp(filmStrip: Data, searchTimestamp: Types.Timing.Micro): Frame|null {\n  const closestFrameIndexBeforeTimestamp = Platform.ArrayUtilities.nearestIndexFromEnd(\n      filmStrip.frames, frame => frame.screenshotEvent.ts < searchTimestamp);\n  if (closestFrameIndexBeforeTimestamp === null) {\n    return null;\n  }\n  return filmStrip.frames[closestFrameIndexBeforeTimestamp];\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nconst IDLE_FUNCTION_CALL_NAMES = new Set([\n  '(program)',\n  '(idle)',\n  '(root)',\n]);\n\nexport function calculateWindow(\n    traceBounds: Types.Timing.TraceWindowMicro,\n    mainThreadEntries: readonly Types.Events.Event[]): Types.Timing.TraceWindowMicro {\n  if (!mainThreadEntries.length) {\n    return traceBounds;\n  }\n  const entriesWithIdleRemoved = mainThreadEntries.filter(entry => {\n    if (Types.Events.isProfileCall(entry) &&\n        (IDLE_FUNCTION_CALL_NAMES.has(entry.callFrame.functionName) || !entry.callFrame.functionName)) {\n      return false;\n    }\n    return true;\n  });\n\n  if (entriesWithIdleRemoved.length === 0) {\n    return traceBounds;\n  }\n  /**\n   * Calculates regions of low utilization and returns the index of the event\n   * that is the first event that should be included.\n   **/\n  function findLowUtilizationRegion(startIndex: number, stopIndex: number): number {\n    const threshold = 0.1;\n\n    let cutIndex = startIndex;\n    const entryAtCut = entriesWithIdleRemoved[cutIndex];\n    const timings = Helpers.Timing.eventTimingsMicroSeconds(entryAtCut);\n    let cutTime = (timings.startTime + timings.endTime) / 2;\n    let usedTime = 0;\n    const step = Math.sign(stopIndex - startIndex);\n    for (let i = startIndex; i !== stopIndex; i += step) {\n      const task = entriesWithIdleRemoved[i];\n      const taskTimings = Helpers.Timing.eventTimingsMicroSeconds(task);\n      const taskTime = (taskTimings.startTime + taskTimings.endTime) / 2;\n      const interval = Math.abs(cutTime - taskTime);\n      if (usedTime < threshold * interval) {\n        cutIndex = i;\n        cutTime = taskTime;\n        usedTime = 0;\n      }\n      usedTime += taskTimings.duration;\n    }\n    return cutIndex;\n  }\n  const rightIndex = findLowUtilizationRegion(entriesWithIdleRemoved.length - 1, 0);\n  const leftIndex = findLowUtilizationRegion(0, rightIndex);\n  const leftTimings = Helpers.Timing.eventTimingsMicroSeconds(entriesWithIdleRemoved[leftIndex]);\n  const rightTimings = Helpers.Timing.eventTimingsMicroSeconds(entriesWithIdleRemoved[rightIndex]);\n\n  let leftTime = leftTimings.startTime;\n  let rightTime = rightTimings.endTime;\n  const zoomedInSpan = rightTime - leftTime;\n\n  if (zoomedInSpan < traceBounds.range * 0.1) {\n    // If the area we have chosen to zoom into is less than 10% of the entire\n    // span, we bail and show the entire trace. It would not be so useful to\n    // the user to zoom in on such a small area; we assume they have\n    // purposefully recorded a trace that contains empty periods of time.\n    return traceBounds;\n  }\n\n  // Adjust the left time down by 5%, and the right time up by 5%, so that\n  // we give the range we want to zoom a bit of breathing space. At the\n  // same time, ensure that we do not stray beyond the bounds of the\n  // min/max time of the entire trace.\n  leftTime = Types.Timing.Micro(Math.max(leftTime - 0.05 * zoomedInSpan, traceBounds.min));\n  rightTime = Types.Timing.Micro(Math.min(rightTime + 0.05 * zoomedInSpan, traceBounds.max));\n\n  return {\n    min: leftTime,\n    max: rightTime,\n    range: Types.Timing.Micro(rightTime - leftTime),\n  };\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Handlers from '../handlers/handlers.js';\n\n// Ignore modules smaller than an absolute threshold.\nconst ABSOLUTE_SIZE_THRESHOLD_BYTES = 1024 * 0.5;\n// Ignore modules smaller than a % size of largest copy of the module.\nconst RELATIVE_SIZE_THRESHOLD = 0.1;\n\ninterface SourceData {\n  source: string;\n  resourceSize: number;\n}\n\nexport function normalizeSource(source: string): string {\n  // Trim trailing question mark - b/c webpack.\n  source = source.replace(/\\?$/, '');\n\n  // Normalize paths for dependencies by only keeping everything after the last `node_modules`.\n  const lastNodeModulesIndex = source.lastIndexOf('node_modules');\n  if (lastNodeModulesIndex !== -1) {\n    source = source.substring(lastNodeModulesIndex);\n  }\n\n  return source;\n}\n\nfunction shouldIgnoreSource(source: string): boolean {\n  // Ignore bundle overhead.\n  if (source.includes('webpack/bootstrap')) {\n    return true;\n  }\n  if (source.includes('(webpack)/buildin')) {\n    return true;\n  }\n\n  // Ignore webpack module shims, i.e. aliases of the form `module.exports = window.jQuery`\n  if (source.includes('external ')) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * The key is a source map `sources` entry (these are URLs/file paths), but normalized\n * via `normalizeSource`.\n *\n * The value is an object with an entry for every script that has a source map which\n * denotes that this source was used, along with the estimated resource size it takes\n * up in the script.\n */\nexport type ScriptDuplication = Map<string, {\n  /**\n   * This is the sum of all (but one) `attributedSize` in `scripts`.\n   *\n   * One copy of this module is treated as the canonical version - the rest will\n   * have non-zero `wastedBytes`. The canonical copy is the first entry of\n   * `scripts`.\n   *\n   * In the case of all copies being the same version, all sizes are\n   * equal and the selection doesn't matter (ignoring compression ratios). When\n   * the copies are different versions, it does matter. Ideally the newest\n   * version would be the canonical copy, but version information is not present.\n   * Instead, size is used as a heuristic for latest version. This makes the\n   * value here conserative in its estimation.\n   */\n  estimatedDuplicateBytes: number,\n  duplicates: Array<{\n    script: Handlers.ModelHandlers.Scripts.Script,\n    /**\n     * The number of bytes in the script bundle that map back to this module,\n     * in terms of estimated impact on transfer size.\n     */\n    attributedSize: number,\n  }>,\n}>;\n\n/**\n * Sorts each array within @see ScriptDuplication by attributedSize, drops information\n * on sources that are too small, and calculates esimatedDuplicateBytes.\n */\nexport function normalizeDuplication(duplication: ScriptDuplication): void {\n  for (const [key, data] of duplication) {\n    // Sort by resource size.\n    data.duplicates.sort((a, b) => b.attributedSize - a.attributedSize);\n\n    // Ignore modules smaller than a % size of largest.\n    if (data.duplicates.length > 1) {\n      const largestResourceSize = data.duplicates[0].attributedSize;\n      data.duplicates = data.duplicates.filter(duplicate => {\n        const percentSize = duplicate.attributedSize / largestResourceSize;\n        return percentSize >= RELATIVE_SIZE_THRESHOLD;\n      });\n    }\n\n    // Ignore modules smaller than an absolute threshold.\n    data.duplicates = data.duplicates.filter(duplicate => duplicate.attributedSize >= ABSOLUTE_SIZE_THRESHOLD_BYTES);\n\n    // Delete any that now don't have multiple entries.\n    if (data.duplicates.length <= 1) {\n      duplication.delete(key);\n      continue;\n    }\n\n    data.estimatedDuplicateBytes = data.duplicates.slice(1).reduce((acc, cur) => acc + cur.attributedSize, 0);\n  }\n}\n\nfunction indexOfOrLength(haystack: string, needle: string, startPosition = 0): number {\n  const index = haystack.indexOf(needle, startPosition);\n  return index === -1 ? haystack.length : index;\n}\n\nexport function getNodeModuleName(source: string): string {\n  const sourceSplit = source.split('node_modules/');\n  source = sourceSplit[sourceSplit.length - 1];\n\n  const indexFirstSlash = indexOfOrLength(source, '/');\n  if (source[0] === '@') {\n    return source.slice(0, indexOfOrLength(source, '/', indexFirstSlash + 1));\n  }\n\n  return source.slice(0, indexFirstSlash);\n}\n\nfunction groupByNodeModules(duplication: ScriptDuplication): ScriptDuplication {\n  const groupedDuplication: ScriptDuplication = new Map();\n  for (const [source, data] of duplication) {\n    if (!source.includes('node_modules')) {\n      groupedDuplication.set(source, data);\n      continue;\n    }\n\n    const nodeModuleKey = 'node_modules/' + getNodeModuleName(source);\n    const aggregatedData = groupedDuplication.get(nodeModuleKey) ?? {\n      duplicates: [],\n      // This is calculated in normalizeDuplication.\n      estimatedDuplicateBytes: 0,\n    };\n    groupedDuplication.set(nodeModuleKey, aggregatedData);\n\n    for (const {script, attributedSize} of data.duplicates) {\n      let duplicate = aggregatedData.duplicates.find(d => d.script === script);\n      if (!duplicate) {\n        duplicate = {script, attributedSize: 0};\n        aggregatedData.duplicates.push(duplicate);\n      }\n      duplicate.attributedSize += attributedSize;\n    }\n  }\n\n  return groupedDuplication;\n}\n\n/**\n * Sort by estimated savings.\n */\nfunction sorted(duplication: ScriptDuplication): ScriptDuplication {\n  return new Map([...duplication].sort((a, b) => b[1].estimatedDuplicateBytes - a[1].estimatedDuplicateBytes));\n}\n\n/**\n * Returns 2 @see ScriptDuplication for the given collection of script contents + source maps:\n *\n * 1. `duplication` keys correspond to authored files\n * 2. `duplication` keys correspond to authored files, except all files within the same\n *    node_module package are aggregated under the same entry.\n */\nexport function computeScriptDuplication(\n    scriptsData: Handlers.ModelHandlers.Scripts.ScriptsData, compressionRatios: Map<string, number>):\n    {duplication: ScriptDuplication, duplicationGroupedByNodeModules: ScriptDuplication} {\n  const sourceDatasMap = new Map<Handlers.ModelHandlers.Scripts.Script, SourceData[]>();\n\n  // Determine size of each `sources` entry.\n  for (const script of scriptsData.scripts) {\n    if (!script.content || !script.sourceMap) {\n      continue;\n    }\n\n    const sizes = Handlers.ModelHandlers.Scripts.getScriptGeneratedSizes(script);\n    if (!sizes) {\n      continue;\n    }\n\n    if ('errorMessage' in sizes) {\n      console.error(sizes.errorMessage);\n      continue;\n    }\n\n    const sourceDataArray: SourceData[] = [];\n    sourceDatasMap.set(script, sourceDataArray);\n\n    const sources = script.sourceMap.sourceURLs();\n    for (let i = 0; i < sources.length; i++) {\n      if (shouldIgnoreSource(sources[i])) {\n        continue;\n      }\n\n      const sourceSize = sizes.files[sources[i]];\n      sourceDataArray.push({\n        source: normalizeSource(sources[i]),\n        resourceSize: sourceSize,\n      });\n    }\n  }\n\n  const duplication: ScriptDuplication = new Map();\n  for (const [script, sourceDataArray] of sourceDatasMap) {\n    for (const sourceData of sourceDataArray) {\n      let data = duplication.get(sourceData.source);\n      if (!data) {\n        data = {estimatedDuplicateBytes: 0, duplicates: []};\n        duplication.set(sourceData.source, data);\n      }\n      const compressionRatio = script.request ? compressionRatios.get(script.request?.args.data.requestId) ?? 1 : 1;\n      const transferSize = Math.round(sourceData.resourceSize * compressionRatio);\n      data.duplicates.push({\n        script,\n        attributedSize: transferSize,\n      });\n    }\n  }\n\n  const duplicationGroupedByNodeModules = groupByNodeModules(duplication);\n\n  normalizeDuplication(duplication);\n  normalizeDuplication(duplicationGroupedByNodeModules);\n\n  return {\n    duplication: sorted(duplication),\n    duplicationGroupedByNodeModules: sorted(duplicationGroupedByNodeModules),\n  };\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nexport const stackTraceForEventInTrace =\n    new Map<Handlers.Types.HandlerData, Map<Types.Events.Event, Protocol.Runtime.StackTrace>>();\n\nexport function clearCacheForTrace(data: Handlers.Types.HandlerData): void {\n  stackTraceForEventInTrace.delete(data);\n}\n/**\n * This util builds a stack trace that includes async calls for a given\n * event. It leverages data we collect from sampling to deduce sync\n * stacks and trace event instrumentation on the V8 debugger to stitch\n * them together.\n */\nexport function get(event: Types.Events.Event, data: Handlers.Types.HandlerData): Protocol.Runtime.StackTrace|null {\n  let cacheForTrace = stackTraceForEventInTrace.get(data);\n  if (!cacheForTrace) {\n    cacheForTrace = new Map();\n    stackTraceForEventInTrace.set(data, cacheForTrace);\n  }\n  const resultFromCache = cacheForTrace.get(event);\n  if (resultFromCache) {\n    return resultFromCache;\n  }\n  let result: Protocol.Runtime.StackTrace|null = null;\n  if (Types.Extensions.isSyntheticExtensionEntry(event)) {\n    result = getForExtensionEntry(event, data);\n  } else if (Types.Events.isPerformanceMeasureBegin(event)) {\n    result = getForPerformanceMeasure(event, data);\n  } else {\n    result = getForEvent(event, data);\n    const payloadCallFrames =\n        getTraceEventPayloadStackAsProtocolCallFrame(event).filter(callFrame => !isNativeJSFunction(callFrame));\n    // If the event has a payload stack trace, replace the synchronous\n    // portion of the calculated stack with the payload's call frames.\n    // We do this because trace payload call frames contain call\n    // locations, unlike profile call frames obtained with getForEvent\n    // (which contain function declaration locations).\n    // This way the user knows which exact JS location triggered an\n    // event.\n    if (!result.callFrames.length) {\n      result.callFrames = payloadCallFrames;\n    } else {\n      for (let i = 0; i < payloadCallFrames.length && i < result.callFrames.length; i++) {\n        result.callFrames[i] = payloadCallFrames[i];\n      }\n    }\n  }\n  if (result) {\n    cacheForTrace.set(event, result);\n  }\n  return result;\n}\n\n/**\n * Fallback method to obtain a stack trace using the parsed event tree\n * hierarchy. This shouldn't be called outside of this file, use `get`\n * instead to ensure the correct event in the tree hierarchy is used.\n */\nfunction getForEvent(event: Types.Events.Event, data: Handlers.Types.HandlerData): Protocol.Runtime.StackTrace {\n  // When working with a CPU profile the renderer handler won't have\n  // entries in its tree.\n  const entryToNode = data.Renderer.entryToNode.size > 0 ? data.Renderer.entryToNode : data.Samples.entryToNode;\n  const topStackTrace: Protocol.Runtime.StackTrace = {callFrames: []};\n  let stackTrace: Protocol.Runtime.StackTrace = topStackTrace;\n  let currentEntry: Types.Events.SyntheticProfileCall;\n  let node: Helpers.TreeHelpers.TraceEntryNode|null|undefined = entryToNode.get(event);\n  const traceCache = stackTraceForEventInTrace.get(data) || new Map<Types.Events.Event, Protocol.Runtime.StackTrace>();\n  stackTraceForEventInTrace.set(data, traceCache);\n  // Move up this node's ancestor tree appending JS frames to its\n  // stack trace. If an async caller is detected, move up in the async\n  // stack instead.\n  while (node) {\n    if (!Types.Events.isProfileCall(node.entry)) {\n      const maybeAsyncParent = data.AsyncJSCalls.runEntryPointToScheduler.get(node.entry);\n      if (!maybeAsyncParent) {\n        node = node.parent;\n        continue;\n      }\n      const maybeAsyncParentNode = maybeAsyncParent && entryToNode.get(maybeAsyncParent.scheduler);\n      if (maybeAsyncParentNode) {\n        stackTrace = addAsyncParentToStack(stackTrace, maybeAsyncParent.taskName);\n        node = maybeAsyncParentNode;\n      }\n      continue;\n    }\n    currentEntry = node.entry;\n    // First check if this entry was processed before.\n    const stackTraceFromCache = traceCache.get(node.entry);\n    if (stackTraceFromCache) {\n      stackTrace.callFrames.push(...stackTraceFromCache.callFrames.filter(callFrame => !isNativeJSFunction(callFrame)));\n      stackTrace.parent = stackTraceFromCache.parent;\n      // Only set the description to the cache value if we didn't\n      // compute it in the previous iteration, since the async stack\n      // trace descriptions / taskNames is only extracted when jumping\n      // to the async parent, and that might not have happened when\n      // the cached value was computed (e.g. the cached value\n      // computation started at some point inside the parent stack\n      // trace).\n      stackTrace.description = stackTrace.description || stackTraceFromCache.description;\n      break;\n    }\n\n    if (!isNativeJSFunction(currentEntry.callFrame)) {\n      stackTrace.callFrames.push(currentEntry.callFrame);\n    }\n    const maybeAsyncParentEvent = data.AsyncJSCalls.asyncCallToScheduler.get(currentEntry);\n    const maybeAsyncParentNode = maybeAsyncParentEvent && entryToNode.get(maybeAsyncParentEvent.scheduler);\n    if (maybeAsyncParentNode) {\n      stackTrace = addAsyncParentToStack(stackTrace, maybeAsyncParentEvent.taskName);\n      node = maybeAsyncParentNode;\n      continue;\n    }\n    node = node.parent;\n  }\n  return topStackTrace;\n}\n\nfunction addAsyncParentToStack(stackTrace: Protocol.Runtime.StackTrace, taskName: string): Protocol.Runtime.StackTrace {\n  const parent: Protocol.Runtime.StackTrace = {callFrames: []};\n  // The Protocol.Runtime.StackTrace type is recursive, so we\n  // move one level deeper in it as we walk up the ancestor tree.\n  stackTrace.parent = parent;\n  // Note: this description effectively corresponds to the name\n  // of the task that scheduled the stack trace we are jumping\n  // FROM, so it would make sense that it was set to that stack\n  // trace instead of the one we are jumping TO. However, the\n  // JS presentation utils we use to present async stack traces\n  // assume the description is added to the stack trace that\n  // scheduled the async task, so we build the data that way.\n  parent.description = taskName;\n  return parent;\n}\n\n/**\n * Finds the JS call in which an extension entry was injected (the\n * code location that called the extension API), and returns its stack\n * trace.\n */\nfunction getForExtensionEntry(event: Types.Extensions.SyntheticExtensionEntry, data: Handlers.Types.HandlerData):\n    Protocol.Runtime.StackTrace|null {\n  const rawEvent: Types.Events.Event = event.rawSourceEvent;\n  if (Types.Events.isPerformanceMeasureBegin(rawEvent)) {\n    return getForPerformanceMeasure(rawEvent, data);\n  }\n  if (!rawEvent) {\n    return null;\n  }\n  return get(rawEvent, data);\n}\n\n/**\n * Gets the raw event for a user timing and obtains its stack trace.\n */\nfunction getForPerformanceMeasure(\n    event: Types.Events.PerformanceMeasureBegin, data: Handlers.Types.HandlerData): Protocol.Runtime.StackTrace|null {\n  let rawEvent: Types.Events.Event|undefined = event;\n  if (event.args.traceId === undefined) {\n    return null;\n  }\n  // performance.measure calls dispatch 2 events: one for the call\n  // itself and another to represent the measured entry in the trace\n  // timeline. They are connected via a common traceId. At this\n  // point `rawEvent` corresponds to the second case, we must\n  // encounter the event for the call itself to obtain its callstack.\n  rawEvent = data.UserTimings.measureTraceByTraceId.get(event.args.traceId);\n  if (!rawEvent) {\n    return null;\n  }\n  return get(rawEvent, data);\n}\n/**\n * Determines if a function is a native JS API (like setTimeout,\n * requestAnimationFrame, consoleTask.run. etc.). This is useful to\n * discard stack frames corresponding to the JS scheduler function\n * itself, since it's already being used as title of async stack traces\n * taken from the async `taskName`. This is also consistent with the\n * behaviour of the stack trace in the sources\n * panel.\n */\nfunction isNativeJSFunction({columnNumber, lineNumber, url, scriptId}: Protocol.Runtime.CallFrame): boolean {\n  return lineNumber === -1 && columnNumber === -1 && url === '' && scriptId === '0';\n}\n\n/**\n * Converts a stack trace from a trace event's payload into an array of\n * Protocol.Runtime.CallFrame.\n */\nfunction getTraceEventPayloadStackAsProtocolCallFrame(event: Types.Events.Event): Protocol.Runtime.CallFrame[] {\n  const payloadCallStack = Helpers.Trace.getZeroIndexedStackTraceInEventPayload(event) || [];\n  const callFrames: Protocol.Runtime.CallFrame[] = [];\n  for (const frame of payloadCallStack) {\n    callFrames.push({...frame, scriptId: String(frame.scriptId) as Protocol.Runtime.ScriptId});\n  }\n  return callFrames;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport * as TraceFilter from './TraceFilter.js';\nimport * as TraceTree from './TraceTree.js';\n\nexport type Entity = typeof ThirdPartyWeb.ThirdPartyWeb.entities[number];\n\ninterface BaseSummary {\n  entity: Entity;\n  transferSize: number;\n  mainThreadTime: Types.Timing.Milli;\n}\n\nexport interface EntitySummary extends BaseSummary {\n  relatedEvents: Types.Events.Event[];\n}\n\nexport interface URLSummary extends BaseSummary {\n  url: string;\n  request?: Types.Events.SyntheticNetworkRequest;\n}\n\n/**\n *\n * Returns Main frame main thread events.\n * These events are inline with the ones used by selectedEvents() of TimelineTreeViews\n */\nfunction collectMainThreadActivity(data: Handlers.Types.HandlerData): Types.Events.Event[] {\n  // TODO: Note b/402658800 could be an issue here.\n  const mainFrameMainThread = data.Renderer.processes.values()\n                                  .find(p => {\n                                    const url = p.url ?? '';\n                                    // Frame url checked a la CompatibilityTracksAppenders's addThreadAppenders\n                                    return p.isOnMainFrame && !url.startsWith('about:') && !url.startsWith('chrome:');\n                                  })\n                                  ?.threads.values()\n                                  .find(t => t.name === 'CrRendererMain');\n\n  if (!mainFrameMainThread) {\n    return [];\n  }\n\n  return mainFrameMainThread.entries;\n}\n\nexport function summarizeByThirdParty(\n    data: Handlers.Types.HandlerData, traceBounds: Types.Timing.TraceWindowMicro): EntitySummary[] {\n  const mainThreadEvents = collectMainThreadActivity(data).sort(Helpers.Trace.eventTimeComparator);\n  const groupingFunction = (event: Types.Events.Event): string => {\n    const entity = data.Renderer.entityMappings.entityByEvent.get(event);\n    return entity?.name ?? '';\n  };\n  const node = getBottomUpTree(mainThreadEvents, traceBounds, groupingFunction);\n  const summaries = summarizeBottomUpByEntity(node, data);\n\n  return summaries;\n}\n\n/**\n * Used only by Lighthouse.\n */\nexport function summarizeByURL(\n    data: Handlers.Types.HandlerData, traceBounds: Types.Timing.TraceWindowMicro): URLSummary[] {\n  const mainThreadEvents = collectMainThreadActivity(data).sort(Helpers.Trace.eventTimeComparator);\n  const groupingFunction = (event: Types.Events.Event): string => {\n    return Handlers.Helpers.getNonResolvedURL(event, data) ?? '';\n  };\n  const node = getBottomUpTree(mainThreadEvents, traceBounds, groupingFunction);\n  const summaries = summarizeBottomUpByURL(node, data);\n\n  return summaries;\n}\n\nfunction summarizeBottomUpByEntity(\n    root: TraceTree.BottomUpRootNode, data: Handlers.Types.HandlerData): EntitySummary[] {\n  const summaries: EntitySummary[] = [];\n\n  // Top nodes are the 3P entities.\n  const topNodes = [...root.children().values()].flat();\n  for (const node of topNodes) {\n    if (node.id === '') {\n      continue;\n    }\n\n    const entity = data.Renderer.entityMappings.entityByEvent.get(node.event);\n    if (!entity) {\n      continue;\n    }\n\n    // Lets use the mapper events as our source of events, since we use the main thread to construct\n    // the bottom up tree. The mapper will give us all related events.\n    const summary: EntitySummary = {\n      transferSize: node.transferSize,\n      mainThreadTime: Types.Timing.Milli(node.selfTime),\n      entity,\n      relatedEvents: data.Renderer.entityMappings.eventsByEntity.get(entity) ?? [],\n    };\n    summaries.push(summary);\n  }\n\n  return summaries;\n}\n\nfunction summarizeBottomUpByURL(root: TraceTree.BottomUpRootNode, data: Handlers.Types.HandlerData): URLSummary[] {\n  const summaries: URLSummary[] = [];\n  const allRequests = data.NetworkRequests.byTime;\n\n  // Top nodes are URLs.\n  const topNodes = [...root.children().values()].flat();\n  for (const node of topNodes) {\n    if (node.id === '' || typeof node.id !== 'string') {\n      continue;\n    }\n\n    const entity = data.Renderer.entityMappings.entityByEvent.get(node.event);\n    if (!entity) {\n      continue;\n    }\n\n    const url = node.id;\n    const request = allRequests.find(r => r.args.data.url === url);\n\n    const summary: URLSummary = {\n      request,\n      url,\n      entity,\n      transferSize: node.transferSize,\n      mainThreadTime: Types.Timing.Milli(node.selfTime),\n    };\n    summaries.push(summary);\n  }\n\n  return summaries;\n}\n\nfunction getBottomUpTree(\n    mainThreadEvents: Types.Events.Event[], tracebounds: Types.Timing.TraceWindowMicro,\n    groupingFunction: ((arg0: Types.Events.Event) => string)|null): TraceTree.BottomUpRootNode {\n  // Use the same filtering as front_end/panels/timeline/TimelineTreeView.ts.\n  const visibleEvents = Helpers.Trace.VISIBLE_TRACE_EVENT_TYPES.values().toArray();\n  const filter =\n      new TraceFilter.VisibleEventsFilter(visibleEvents.concat([Types.Events.Name.SYNTHETIC_NETWORK_REQUEST]));\n\n  // The bottom up root node handles all the \"in Tracebounds\" checks we need for the insight.\n  const startTime = Helpers.Timing.microToMilli(tracebounds.min);\n  const endTime = Helpers.Timing.microToMilli(tracebounds.max);\n  return new TraceTree.BottomUpRootNode(mainThreadEvents, {\n    textFilter: new TraceFilter.ExclusiveNameFilter([]),\n    filters: [filter],\n    startTime,\n    endTime,\n    eventGroupIdCallback: groupingFunction,\n    calculateTransferSize: true,\n    // Ensure we group by 3P alongside eventID for correct 3P grouping.\n    forceGroupIdCallback: true,\n  });\n}\n", "// Copyright 2017 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Handlers from '../handlers/handlers.js';\nimport * as Types from '../types/types.js';\n\nexport abstract class TraceFilter {\n  abstract accept(_event: Types.Events.Event, handlerData?: Handlers.Types.HandlerData): boolean;\n}\n\nexport class VisibleEventsFilter extends TraceFilter {\n  private readonly visibleTypes: Set<string>;\n  constructor(visibleTypes: string[]) {\n    super();\n    this.visibleTypes = new Set(visibleTypes);\n  }\n\n  accept(event: Types.Events.Event): boolean {\n    if (Types.Extensions.isSyntheticExtensionEntry(event)) {\n      return true;\n    }\n    return this.visibleTypes.has(VisibleEventsFilter.eventType(event));\n  }\n\n  static eventType(event: Types.Events.Event): Types.Events.Name {\n    // Any blink.console category events are treated as ConsoleTime events\n    if (event.cat.includes('blink.console')) {\n      return Types.Events.Name.CONSOLE_TIME;\n    }\n    // Any blink.user_timing egory events are treated as UserTiming events\n    if (event.cat.includes('blink.user_timing')) {\n      return Types.Events.Name.USER_TIMING;\n    }\n    return event.name as Types.Events.Name;\n  }\n}\n\nexport class InvisibleEventsFilter extends TraceFilter {\n  #invisibleTypes: Set<Types.Events.Name>;\n\n  constructor(invisibleTypes: Types.Events.Name[]) {\n    super();\n    this.#invisibleTypes = new Set(invisibleTypes);\n  }\n\n  accept(event: Types.Events.Event): boolean {\n    return !this.#invisibleTypes.has(VisibleEventsFilter.eventType(event));\n  }\n}\n\nexport class ExclusiveNameFilter extends TraceFilter {\n  #excludeNames: Set<Types.Events.Name>;\n  constructor(excludeNames: Types.Events.Name[]) {\n    super();\n    this.#excludeNames = new Set(excludeNames);\n  }\n\n  accept(event: Types.Events.Event): boolean {\n    return !this.#excludeNames.has(event.name as Types.Events.Name);\n  }\n}\n", "// Copyright 2016 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport {SamplesIntegrator} from '../helpers/SamplesIntegrator.js';\nimport * as Types from '../types/types.js';\n\nimport type {TraceFilter} from './TraceFilter.js';\n\nexport class Node {\n  /** ms */\n  totalTime: number;\n  /** ms */\n  selfTime: number;\n  transferSize: number;\n  id: string|symbol;\n  /** The first trace event encountered that necessitated the creation of this tree node. */\n  event: Types.Events.Event;\n  /**\n   * All of the trace events associated with this aggregate node.\n   * Minor: In the case of Event Log (EventsTimelineTreeView), the node is not aggregate and this will only hold 1 event, the same that's in this.event\n   */\n  events: Types.Events.Event[];\n  parent!: Node|null;\n  groupId: string;\n  isGroupNodeInternal: boolean;\n  depth: number;\n\n  constructor(id: string|symbol, event: Types.Events.Event) {\n    this.totalTime = 0;\n    this.selfTime = 0;\n    this.transferSize = 0;\n    this.id = id;\n    this.event = event;\n    this.events = [event];\n\n    this.groupId = '';\n    this.isGroupNodeInternal = false;\n    this.depth = 0;\n  }\n\n  isGroupNode(): boolean {\n    return this.isGroupNodeInternal;\n  }\n\n  hasChildren(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  setHasChildren(_value: boolean): void {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Returns the direct descendants of this node.\n   * @returns a map with ordered <nodeId, Node> tuples.\n   */\n  children(): ChildrenCache {\n    throw new Error('Not implemented');\n  }\n\n  searchTree(matchFunction: (arg0: Types.Events.Event) => boolean, results?: Node[]): Node[] {\n    results = results || [];\n    if (this.event && matchFunction(this.event)) {\n      results.push(this);\n    }\n    for (const child of this.children().values()) {\n      child.searchTree(matchFunction, results);\n    }\n    return results;\n  }\n}\n\nexport class TopDownNode extends Node {\n  root: TopDownRootNode|null;\n  private hasChildrenInternal: boolean;\n  childrenInternal: ChildrenCache|null;\n  override parent: TopDownNode|null;\n\n  constructor(id: string|symbol, event: Types.Events.Event, parent: TopDownNode|null) {\n    super(id, event);\n    this.root = parent?.root ?? null;\n    this.hasChildrenInternal = false;\n    this.childrenInternal = null;\n    this.parent = parent;\n  }\n\n  override hasChildren(): boolean {\n    return this.hasChildrenInternal;\n  }\n\n  override setHasChildren(value: boolean): void {\n    this.hasChildrenInternal = value;\n  }\n\n  override children(): ChildrenCache {\n    return this.childrenInternal || this.buildChildren();\n  }\n\n  private buildChildren(): ChildrenCache {\n    // Tracks the ancestor path of this node, includes the current node.\n    const path: TopDownNode[] = [];\n    for (let node: TopDownNode = this; node.parent && !node.isGroupNode(); node = node.parent) {\n      path.push((node));\n    }\n    path.reverse();\n    const children: ChildrenCache = new Map();\n    const self = this;\n    const root = this.root;\n    if (!root) {\n      this.childrenInternal = children;\n      return this.childrenInternal;\n    }\n    const startTime = root.startTime;\n    const endTime = root.endTime;\n    const instantEventCallback = (root.doNotAggregate || root.includeInstantEvents) ? onInstantEvent : undefined;\n    const eventIdCallback = root.doNotAggregate ? undefined : generateEventID;\n    const eventGroupIdCallback = root.getEventGroupIdCallback();\n    let depth = 0;\n    // The amount of ancestors found to match this node's ancestors\n    // during the event tree walk.\n    let matchedDepth = 0;\n    let currentDirectChild: Node|null = null;\n\n    // Walk on the full event tree to find this node's children.\n    Helpers.Trace.forEachEvent(\n        root.events,\n        {\n          onStartEvent,\n          onEndEvent,\n          onInstantEvent: instantEventCallback,\n          startTime: Helpers.Timing.milliToMicro(startTime),\n          endTime: Helpers.Timing.milliToMicro(endTime),\n          eventFilter: root.filter,\n          ignoreAsyncEvents: false,\n        },\n    );\n\n    function onStartEvent(e: Types.Events.Event): void {\n      const {startTime: currentStartTime, endTime: currentEndTime} = Helpers.Timing.eventTimingsMilliSeconds(e);\n\n      ++depth;\n      if (depth > path.length + 2) {\n        return;\n      }\n      if (!matchPath(e)) {\n        return;\n      }\n      const actualEndTime = currentEndTime !== undefined ? Math.min(currentEndTime, endTime) : endTime;\n      const duration = actualEndTime - Math.max(startTime, currentStartTime);\n      if (duration < 0) {\n        console.error('Negative event duration');\n      }\n      processEvent(e, duration);\n    }\n\n    function onInstantEvent(e: Types.Events.Event): void {\n      ++depth;\n      if (matchedDepth === path.length && depth <= path.length + 2) {\n        processEvent(e, 0);\n      }\n      --depth;\n    }\n\n    /**\n     * Creates a child node.\n     */\n    function processEvent(e: Types.Events.Event, duration: number): void {\n      if (depth === path.length + 2) {\n        if (!currentDirectChild) {\n          return;\n        }\n        currentDirectChild.setHasChildren(true);\n        currentDirectChild.selfTime -= duration;\n        return;\n      }\n      let id;\n      let groupId = '';\n      if (!eventIdCallback) {\n        id = Symbol('uniqueId');\n      } else {\n        id = eventIdCallback(e);\n        groupId = eventGroupIdCallback ? eventGroupIdCallback(e) : '';\n        if (groupId) {\n          id += '/' + groupId;\n        }\n      }\n      let node = children.get(id);\n      if (!node) {\n        node = new TopDownNode(id, e, self);\n        node.groupId = groupId;\n        children.set(id, node);\n      } else {\n        node.events.push(e);\n      }\n      node.selfTime += duration;\n      node.totalTime += duration;\n      if (Types.Events.isReceivedDataEvent(e)) {\n        node.transferSize += e.args.data.encodedDataLength;\n      }\n      currentDirectChild = node;\n    }\n\n    /**\n     * Checks if the path of ancestors of an event matches the path of\n     * ancestors of the current node. In other words, checks if an event\n     * is a child of this node. As the check is done, the partial result\n     * is cached on `matchedDepth`, for future checks.\n     */\n    function matchPath(e: Types.Events.Event): boolean {\n      const {endTime} = Helpers.Timing.eventTimingsMilliSeconds(e);\n      if (matchedDepth === path.length) {\n        return true;\n      }\n      if (matchedDepth !== depth - 1) {\n        return false;\n      }\n      if (!endTime) {\n        return false;\n      }\n      if (!eventIdCallback) {\n        if (e === path[matchedDepth].event) {\n          ++matchedDepth;\n        }\n        return false;\n      }\n      let id = eventIdCallback(e);\n      const groupId = eventGroupIdCallback ? eventGroupIdCallback(e) : '';\n      if (groupId) {\n        id += '/' + groupId;\n      }\n      if (id === path[matchedDepth].id) {\n        ++matchedDepth;\n      }\n      return false;\n    }\n\n    function onEndEvent(): void {\n      --depth;\n      if (matchedDepth > depth) {\n        matchedDepth = depth;\n      }\n    }\n\n    this.childrenInternal = children;\n    return children;\n  }\n}\n\nexport class TopDownRootNode extends TopDownNode {\n  readonly filter: (e: Types.Events.Event) => boolean;\n  readonly startTime: Types.Timing.Milli;\n  readonly endTime: Types.Timing.Milli;\n  eventGroupIdCallback: ((arg0: Types.Events.Event) => string)|null|undefined;\n  /** Default behavior is to aggregate similar trace events into one Node based on generateEventID(), eventGroupIdCallback(), etc. Set true to keep nodes 1:1 with events. */\n  readonly doNotAggregate: boolean|undefined;\n  readonly includeInstantEvents?: boolean;\n  override totalTime: number;\n  override selfTime: number;\n\n  constructor(\n      events: Types.Events.Event[],\n      {filters, startTime, endTime, doNotAggregate, eventGroupIdCallback, includeInstantEvents}: {\n        filters: TraceFilter[],\n        startTime: Types.Timing.Milli,\n        endTime: Types.Timing.Milli,\n        doNotAggregate?: boolean,\n        eventGroupIdCallback?: ((arg0: Types.Events.Event) => string)|null,\n        includeInstantEvents?: boolean,\n      }) {\n    super('', events[0], null);\n    this.event = events[0];\n    this.root = this;\n    this.events = events;\n    this.filter = (e: Types.Events.Event): boolean => filters.every(f => f.accept(e));\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.eventGroupIdCallback = eventGroupIdCallback;\n    this.doNotAggregate = doNotAggregate;\n    this.includeInstantEvents = includeInstantEvents;\n\n    this.totalTime = endTime - startTime;\n    this.selfTime = this.totalTime;\n  }\n  override children(): ChildrenCache {\n    // FYI tree nodes are built lazily. https://codereview.chromium.org/2674283003\n    return this.childrenInternal || this.grouppedTopNodes();\n  }\n\n  private grouppedTopNodes(): ChildrenCache {\n    const flatNodes = super.children();\n    for (const node of flatNodes.values()) {\n      this.selfTime -= node.totalTime;\n    }\n    if (!this.eventGroupIdCallback) {\n      return flatNodes;\n    }\n    const groupNodes = new Map<string, GroupNode>();\n    for (const node of flatNodes.values()) {\n      const groupId = this.eventGroupIdCallback(node.event);\n      let groupNode = groupNodes.get(groupId);\n      if (!groupNode) {\n        groupNode = new GroupNode(groupId, this, node.events);\n        groupNodes.set(groupId, groupNode);\n      } else {\n        groupNode.events.push(...node.events);\n      }\n      groupNode.addChild(node as BottomUpNode, node.selfTime, node.totalTime, node.transferSize);\n    }\n    this.childrenInternal = groupNodes;\n    return groupNodes;\n  }\n\n  getEventGroupIdCallback(): ((arg0: Types.Events.Event) => string)|null|undefined {\n    return this.eventGroupIdCallback;\n  }\n}\n\nexport class BottomUpRootNode extends Node {\n  private childrenInternal: ChildrenCache|null;\n  private textFilter: TraceFilter;\n  readonly filter: (e: Types.Events.Event) => boolean;\n  readonly startTime: Types.Timing.Milli;\n  readonly endTime: Types.Timing.Milli;\n  override totalTime: number;\n  eventGroupIdCallback: ((arg0: Types.Events.Event) => string)|null|undefined;\n  private calculateTransferSize?: boolean;\n  private forceGroupIdCallback?: boolean;\n\n  constructor(events: Types.Events.Event[], {\n    textFilter,\n    filters,\n    startTime,\n    endTime,\n    eventGroupIdCallback,\n    calculateTransferSize,\n    forceGroupIdCallback,\n  }: {\n    textFilter: TraceFilter,\n    filters: readonly TraceFilter[],\n    startTime: Types.Timing.Milli,\n    endTime: Types.Timing.Milli,\n    eventGroupIdCallback?: ((arg0: Types.Events.Event) => string)|null,\n    calculateTransferSize?: boolean,\n    /**\n     * This forces using `eventGroupIdCallback` in combination with generateEventID\n     * to generate the ID of the node.\n     *\n     * This is used in the ThirdPartyTreeView and BottomUpTreeView, where we want to group all events\n     * related to a specific 3P entity together, regardless of the specific event name/type.\n     * There are cases where events under the same event name belong to different entities. But, because\n     * they get grouped first by event name/type, it throws off the 3P groupBy - grouping events of different\n     * 3P entities together.\n     */\n    forceGroupIdCallback?: boolean,\n  }) {\n    super('', events[0]);\n    this.childrenInternal = null;\n    this.events = events;\n    this.textFilter = textFilter;\n    this.filter = (e: Types.Events.Event): boolean => filters.every(f => f.accept(e));\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.eventGroupIdCallback = eventGroupIdCallback;\n    this.totalTime = endTime - startTime;\n    this.calculateTransferSize = calculateTransferSize;\n    this.forceGroupIdCallback = forceGroupIdCallback;\n  }\n\n  override hasChildren(): boolean {\n    return true;\n  }\n\n  filterChildren(children: ChildrenCache): ChildrenCache {\n    for (const [id, child] of children) {\n      // to provide better context to user only filter first (top) level.\n      if (child.event && child.depth <= 1 && !this.textFilter.accept(child.event)) {\n        children.delete((id));\n      }\n    }\n    return children;\n  }\n\n  override children(): ChildrenCache {\n    // FYI tree nodes are built lazily. https://codereview.chromium.org/2674283003\n    if (!this.childrenInternal) {\n      this.childrenInternal = this.filterChildren(this.grouppedTopNodes());\n    }\n    return this.childrenInternal;\n  }\n\n  // If no grouping is applied, the nodes returned here are what's initially shown in the bottom-up view.\n  // \"No grouping\" == no grouping in UI dropdown == no groupingFunction…\n  // … HOWEVER, nodes are still aggregated via `generateEventID`, which is ~= the event name.\n  private ungroupedTopNodes(): ChildrenCache {\n    const root = this;\n    const startTime = this.startTime;\n    const endTime = this.endTime;\n    const nodeById = new Map<string, Node>();\n    const selfTimeStack: number[] = [endTime - startTime];\n    const firstNodeStack: boolean[] = [];\n    const totalTimeById = new Map<string, number>();\n    // TODO(paulirish): rename to getGroupNodeId\n    const eventGroupIdCallback = this.eventGroupIdCallback;\n    const forceGroupIdCallback = this.forceGroupIdCallback;\n\n    // encodedDataLength is provided solely on instant events.\n    const sumTransferSizeOfInstantEvent = (e: Types.Events.Event): void => {\n      if (Types.Events.isReceivedDataEvent(e)) {\n        let id = generateEventID(e);\n        if (this.forceGroupIdCallback && this.eventGroupIdCallback) {\n          id = `${id}-${this.eventGroupIdCallback(e)}`;\n        }\n        let node = nodeById.get(id);\n        if (!node) {\n          node = new BottomUpNode(root, id, e, false, root);\n          nodeById.set(id, node);\n        } else {\n          node.events.push(e);\n        }\n\n        // ResourceReceivedData events tally up the transfer size over time, but the\n        // ResourceReceiveResponse / ResourceFinish events hold the final result.\n        if (e.name === 'ResourceReceivedData') {\n          node.transferSize += e.args.data.encodedDataLength;\n        } else if (e.args.data.encodedDataLength > 0) {\n          // For some reason, ResourceFinish can be zero even if data was sent.\n          // Ignore that case.\n          // Note: this will count the entire resource size if just the last bit of a\n          // request is in view. If it isn't in view, the transfer size is counted\n          // gradually, in proportion with the ResourceReceivedData events in the\n          // current view.\n          node.transferSize = e.args.data.encodedDataLength;\n        }\n      }\n    };\n\n    Helpers.Trace.forEachEvent(\n        this.events,\n        {\n          onStartEvent,\n          onEndEvent,\n          onInstantEvent: this.calculateTransferSize ? sumTransferSizeOfInstantEvent : undefined,\n          startTime: Helpers.Timing.milliToMicro(this.startTime),\n          endTime: Helpers.Timing.milliToMicro(this.endTime),\n          eventFilter: this.filter,\n          ignoreAsyncEvents: false,\n        },\n    );\n\n    function onStartEvent(e: Types.Events.Event): void {\n      const {startTime: currentStartTime, endTime: currentEndTime} = Helpers.Timing.eventTimingsMilliSeconds(e);\n\n      const actualEndTime = currentEndTime !== undefined ? Math.min(currentEndTime, endTime) : endTime;\n      const duration = actualEndTime - Math.max(currentStartTime, startTime);\n      selfTimeStack[selfTimeStack.length - 1] -= duration;\n      selfTimeStack.push(duration);\n      let id = generateEventID(e);\n      if (forceGroupIdCallback && eventGroupIdCallback) {\n        id = `${id}-${eventGroupIdCallback(e)}`;\n      }\n      const noNodeOnStack = !totalTimeById.has(id);\n      if (noNodeOnStack) {\n        totalTimeById.set(id, duration);\n      }\n      firstNodeStack.push(noNodeOnStack);\n    }\n\n    function onEndEvent(event: Types.Events.Event): void {\n      let id = generateEventID(event);\n      if (forceGroupIdCallback && eventGroupIdCallback) {\n        id = `${id}-${eventGroupIdCallback(event)}`;\n      }\n      let node = nodeById.get(id);\n      if (!node) {\n        node = new BottomUpNode(root, id, event, false, root);\n        nodeById.set(id, node);\n      } else {\n        node.events.push(event);\n      }\n      node.selfTime += selfTimeStack.pop() || 0;\n      if (firstNodeStack.pop()) {\n        node.totalTime += totalTimeById.get(id) || 0;\n        totalTimeById.delete(id);\n      }\n      if (firstNodeStack.length) {\n        node.setHasChildren(true);\n      }\n    }\n\n    this.selfTime = selfTimeStack.pop() || 0;\n    // Delete any nodes that have no selfTime (or transferSize, if it's being calculated)\n    for (const pair of nodeById) {\n      if (pair[1].selfTime <= 0 && (!this.calculateTransferSize || pair[1].transferSize <= 0)) {\n        nodeById.delete((pair[0]));\n      }\n    }\n    return nodeById;\n  }\n\n  private grouppedTopNodes(): ChildrenCache {\n    const flatNodes = this.ungroupedTopNodes();\n    if (!this.eventGroupIdCallback) {\n      return flatNodes;\n    }\n    const groupNodes = new Map<string, GroupNode>();\n    for (const node of flatNodes.values()) {\n      const groupId = this.eventGroupIdCallback(node.event);\n      let groupNode = groupNodes.get(groupId);\n      if (!groupNode) {\n        groupNode = new GroupNode(groupId, this, node.events);\n        groupNodes.set(groupId, groupNode);\n      } else {\n        for (const e of node.events) {\n          groupNode.events.push(e);\n        }\n      }\n      groupNode.addChild(node as BottomUpNode, node.selfTime, node.selfTime, node.transferSize);\n    }\n    return groupNodes;\n  }\n}\n\nexport class GroupNode extends Node {\n  private readonly childrenInternal: ChildrenCache;\n  override isGroupNodeInternal: boolean;\n  override events: Types.Events.Event[];\n\n  constructor(id: string, parent: BottomUpRootNode|TopDownRootNode, events: Types.Events.Event[]) {\n    super(id, events[0]);\n    this.events = events;\n    this.childrenInternal = new Map();\n    this.parent = parent;\n    this.isGroupNodeInternal = true;\n  }\n\n  addChild(child: BottomUpNode, selfTime: number, totalTime: number, transferSize: number): void {\n    this.childrenInternal.set(child.id, child);\n    this.selfTime += selfTime;\n    this.totalTime += totalTime;\n    this.transferSize += transferSize;\n    child.parent = this;\n  }\n\n  override hasChildren(): boolean {\n    return true;\n  }\n\n  override children(): ChildrenCache {\n    return this.childrenInternal;\n  }\n}\n\nexport class BottomUpNode extends Node {\n  override parent: Node;\n  private root: BottomUpRootNode;\n  override depth: number;\n  private cachedChildren: ChildrenCache|null;\n  private hasChildrenInternal: boolean;\n\n  constructor(root: BottomUpRootNode, id: string, event: Types.Events.Event, hasChildren: boolean, parent: Node) {\n    super(id, event);\n    this.parent = parent;\n    this.root = root;\n    this.depth = (parent.depth || 0) + 1;\n    this.cachedChildren = null;\n    this.hasChildrenInternal = hasChildren;\n  }\n\n  override hasChildren(): boolean {\n    return this.hasChildrenInternal;\n  }\n\n  override setHasChildren(value: boolean): void {\n    this.hasChildrenInternal = value;\n  }\n\n  override children(): ChildrenCache {\n    if (this.cachedChildren) {\n      return this.cachedChildren;\n    }\n    const selfTimeStack: number[] = [0];\n    const eventIdStack: string[] = [];\n    const eventStack: Types.Events.Event[] = [];\n    const nodeById = new Map<string, BottomUpNode>();\n    const startTime = this.root.startTime;\n    const endTime = this.root.endTime;\n    let lastTimeMarker: number = startTime;\n    const self = this;\n    Helpers.Trace.forEachEvent(\n        this.root.events,\n        {\n          onStartEvent,\n          onEndEvent,\n          startTime: Helpers.Timing.milliToMicro(startTime),\n          endTime: Helpers.Timing.milliToMicro(endTime),\n          eventFilter: this.root.filter,\n          ignoreAsyncEvents: false,\n        },\n    );\n    function onStartEvent(e: Types.Events.Event): void {\n      const {startTime: currentStartTime, endTime: currentEndTime} = Helpers.Timing.eventTimingsMilliSeconds(e);\n      const actualEndTime = currentEndTime !== undefined ? Math.min(currentEndTime, endTime) : endTime;\n      const duration = actualEndTime - Math.max(currentStartTime, startTime);\n      if (duration < 0) {\n        console.assert(false, 'Negative duration of an event');\n      }\n      selfTimeStack[selfTimeStack.length - 1] -= duration;\n      selfTimeStack.push(duration);\n      const id = generateEventID(e);\n      eventIdStack.push(id);\n      eventStack.push(e);\n    }\n\n    function onEndEvent(e: Types.Events.Event): void {\n      const {startTime: currentStartTime, endTime: currentEndTime} = Helpers.Timing.eventTimingsMilliSeconds(e);\n      const selfTime = selfTimeStack.pop();\n      const id = eventIdStack.pop();\n      eventStack.pop();\n      let node;\n      for (node = self; node.depth > 1; node = node.parent) {\n        if (node.id !== eventIdStack[eventIdStack.length + 1 - node.depth]) {\n          return;\n        }\n      }\n      if (node.id !== id || eventIdStack.length < self.depth) {\n        return;\n      }\n      const childId = eventIdStack[eventIdStack.length - self.depth];\n      node = nodeById.get(childId);\n      if (!node) {\n        const event = eventStack[eventStack.length - self.depth];\n        const hasChildren = eventStack.length > self.depth;\n        node = new BottomUpNode(self.root, childId, event, hasChildren, self);\n        nodeById.set(childId, node);\n      } else {\n        node.events.push(e);\n      }\n      const actualEndTime = currentEndTime !== undefined ? Math.min(currentEndTime, endTime) : endTime;\n      const totalTime = actualEndTime - Math.max(currentStartTime, lastTimeMarker);\n      node.selfTime += selfTime || 0;\n      node.totalTime += totalTime;\n      lastTimeMarker = actualEndTime;\n    }\n\n    this.cachedChildren = this.root.filterChildren(nodeById);\n    return this.cachedChildren;\n  }\n\n  override searchTree(matchFunction: (arg0: Types.Events.Event) => boolean, results?: Node[]): Node[] {\n    results = results || [];\n    if (this.event && matchFunction(this.event)) {\n      results.push(this);\n    }\n    return results;\n  }\n}\n\nexport function eventStackFrame(event: Types.Events.Event): Protocol.Runtime.CallFrame|null {\n  if (Types.Events.isProfileCall(event)) {\n    return event.callFrame;\n  }\n  const topFrame = event.args?.data?.stackTrace?.[0];\n  if (!topFrame) {\n    return null;\n  }\n  return {...topFrame, scriptId: String(topFrame.scriptId) as Protocol.Runtime.ScriptId};\n}\n\n// TODO(paulirish): rename to generateNodeId\nexport function generateEventID(event: Types.Events.Event): string {\n  if (Types.Events.isProfileCall(event)) {\n    const name = SamplesIntegrator.isNativeRuntimeFrame(event.callFrame) ?\n        SamplesIntegrator.nativeGroup(event.callFrame.functionName) :\n        event.callFrame.functionName;\n    const location = event.callFrame.scriptId || event.callFrame.url || '';\n    return `f:${name}@${location}`;\n  }\n\n  if (Types.Events.isConsoleTimeStamp(event) && event.args.data) {\n    return `${event.name}:${event.args.data.name}`;\n  }\n  if (Types.Events.isSyntheticNetworkRequest(event) || Types.Events.isReceivedDataEvent(event)) {\n    return `req:${event.args.data.requestId}`;\n  }\n\n  return event.name;\n}\n\nexport type ChildrenCache = Map<string|symbol, Node>;\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {milliToMicro} from './Timing.js';\nimport {extractSampleTraceId, makeProfileCall, mergeEventsInOrder, sortTraceEventsInPlace} from './Trace.js';\n\n/**\n * This is a helper that integrates CPU profiling data coming in the\n * shape of samples, with trace events. Samples indicate what the JS\n * stack trace looked at a given point in time, but they don't have\n * duration. The SamplesIntegrator task is to make an approximation\n * of what the duration of each JS call was, given the sample data and\n * given the trace events profiled during that time. At the end of its\n * execution, the SamplesIntegrator returns an array of ProfileCalls\n * (under SamplesIntegrator::buildProfileCalls()), which\n * represent JS calls, with a call frame and duration. These calls have\n * the shape of a complete trace events and can be treated as flame\n * chart entries in the timeline.\n *\n * The approach to build the profile calls consists in tracking the\n * current stack as the following events happen (in order):\n * 1. A sample was done.\n * 2. A trace event started.\n * 3. A trace event ended.\n * Depending on the event and on the data that's coming with it the\n * stack is updated by adding or removing JS calls to it and updating\n * the duration of the calls in the tracking stack.\n *\n * note: Although this approach has been implemented since long ago, and\n * is relatively efficient (adds a complexity over the trace parsing of\n * O(n) where n is the number of samples) it has proven to be faulty.\n * It might be worthwhile experimenting with improvements or with a\n * completely different approach. Improving the approach is tracked in\n * crbug.com/1417439\n */\nexport class SamplesIntegrator {\n  /**\n   * The result of running the samples integrator. Holds the JS calls\n   * with their approximated duration after integrating samples into the\n   * trace event tree.\n   */\n  #constructedProfileCalls: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * tracks the state of the JS stack at each point in time to update\n   * the profile call durations as new events arrive. This doesn't only\n   * happen with new profile calls (in which case we would compare the\n   * stack in them) but also with trace events (in which case we would\n   * update the duration of the events we are tracking at the moment).\n   */\n  #currentJSStack: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * Process holding the CPU profile and trace events.\n   */\n  #processId: Types.Events.ProcessID;\n  /**\n   * Thread holding the CPU profile and trace events.\n   */\n  #threadId: Types.Events.ThreadID;\n  /**\n   * Tracks the depth of the JS stack at the moment a trace event starts\n   * or ends. It is assumed that for the duration of a trace event, the\n   * JS stack's depth cannot decrease, since JS calls that started\n   * before a trace event cannot end during the trace event. So as trace\n   * events arrive, we store the \"locked\" amount of JS frames that were\n   * in the stack before the event came.\n   */\n  #lockedJsStackDepth: number[] = [];\n  /**\n   * Used to keep track when samples should be integrated even if they\n   * are not children of invocation trace events. This is useful in\n   * cases where we can be missing the start of JS invocation events if\n   * we start tracing half-way through.\n   */\n  #fakeJSInvocation = false;\n  /**\n   * The parsed CPU profile, holding the tree hierarchy of JS frames and\n   * the sample data.\n   */\n  #profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Because GC nodes don't have a stack, we artificially add a stack to\n   * them which corresponds to that of the previous sample. This map\n   * tracks which node is used for the stack of a GC call.\n   * Note that GC samples are not shown in the flamechart, however they\n   * are used during the construction of for profile calls, as we can\n   * infer information about the duration of the executed code when a\n   * GC node is sampled.\n   */\n  #nodeForGC = new Map<Types.Events.SyntheticProfileCall, CPUProfile.ProfileTreeModel.ProfileNode>();\n\n  #engineConfig: Types.Configuration.Configuration;\n  #profileId: Types.Events.ProfileID;\n\n  /**\n   * Keeps track of the individual samples from the CPU Profile.\n   * Only used with Debug Mode experiment enabled.\n   */\n  jsSampleEvents: Types.Events.SyntheticJSSample[] = [];\n\n  constructor(\n      profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, profileId: Types.Events.ProfileID,\n      pid: Types.Events.ProcessID, tid: Types.Events.ThreadID, configuration?: Types.Configuration.Configuration) {\n    this.#profileModel = profileModel;\n    this.#threadId = tid;\n    this.#processId = pid;\n    this.#engineConfig = configuration || Types.Configuration.defaults();\n    this.#profileId = profileId;\n  }\n\n  buildProfileCalls(traceEvents: Types.Events.Event[]): Types.Events.SyntheticProfileCall[] {\n    const mergedEvents = mergeEventsInOrder(traceEvents, this.callsFromProfileSamples());\n    const stack = [];\n    for (let i = 0; i < mergedEvents.length; i++) {\n      const event = mergedEvents[i];\n      // Because instant trace events have no duration, they don't provide\n      // useful information for possible changes in the duration of calls\n      // in the JS stack.\n      if (event.ph === Types.Events.Phase.INSTANT && !extractSampleTraceId(event)) {\n        continue;\n      }\n      if (stack.length === 0) {\n        if (Types.Events.isProfileCall(event)) {\n          this.#onProfileCall(event);\n          continue;\n        }\n        stack.push(event);\n        this.#onTraceEventStart(event);\n        continue;\n      }\n\n      const parentEvent = stack.at(-1);\n      if (parentEvent === undefined) {\n        continue;\n      }\n      const begin = event.ts;\n      const parentBegin = parentEvent.ts;\n      const parentDuration = parentEvent.dur || 0;\n      const parentEnd = parentBegin + parentDuration;\n\n      const startsAfterParent = begin >= parentEnd;\n      if (startsAfterParent) {\n        this.#onTraceEventEnd(parentEvent);\n        stack.pop();\n        i--;\n        continue;\n      }\n      if (Types.Events.isProfileCall(event)) {\n        this.#onProfileCall(event, parentEvent);\n        continue;\n      }\n      this.#onTraceEventStart(event);\n      stack.push(event);\n    }\n    while (stack.length) {\n      const last = stack.pop();\n      if (last) {\n        this.#onTraceEventEnd(last);\n      }\n    }\n    sortTraceEventsInPlace(this.jsSampleEvents);\n    return this.#constructedProfileCalls;\n  }\n\n  #onTraceEventStart(event: Types.Events.Event): void {\n    // Top level events cannot be nested into JS frames so we reset\n    // the stack when we find one.\n    if (event.name === Types.Events.Name.RUN_MICROTASKS || event.name === Types.Events.Name.RUN_TASK) {\n      this.#lockedJsStackDepth = [];\n      this.#truncateJSStack(0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n\n    if (this.#fakeJSInvocation) {\n      this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n    this.#extractStackTrace(event);\n    // Keep track of the call frames in the stack before the event\n    // happened. For the duration of this event, these frames cannot\n    // change (none can be terminated before this event finishes).\n    //\n    // Also, every frame that is opened after this event, is considered\n    // to be a descendant of the event. So once the event finishes, the\n    // frames that were opened after it, need to be closed (see\n    // onEndEvent).\n    //\n    // TODO(crbug.com/1417439):\n    // The assumption that every frame opened after an event is a\n    // descendant of the event is incorrect. For example, a JS call that\n    // parents a trace event might have been sampled after the event was\n    // dispatched. In this case the JS call would be discarded if this\n    // event isn't an invocation event, otherwise the call will be\n    // considered a child of the event. In both cases, the result would\n    // be incorrect.\n    this.#lockedJsStackDepth.push(this.#currentJSStack.length);\n  }\n\n  #onProfileCall(event: Types.Events.SyntheticProfileCall, parent?: Types.Events.Event): void {\n    if ((parent && Types.Events.isJSInvocationEvent(parent)) || this.#fakeJSInvocation) {\n      this.#extractStackTrace(event);\n    } else if (Types.Events.isProfileCall(event) && this.#currentJSStack.length === 0) {\n      // Force JS Samples to show up even if we are not inside a JS\n      // invocation event, because we can be missing the start of JS\n      // invocation events if we start tracing half-way through. Pretend\n      // we have a top-level JS invocation event.\n      this.#fakeJSInvocation = true;\n      const stackDepthBefore = this.#currentJSStack.length;\n      this.#extractStackTrace(event);\n      this.#lockedJsStackDepth.push(stackDepthBefore);\n    }\n  }\n\n  #onTraceEventEnd(event: Types.Events.Event): void {\n    // Because the event has ended, any frames that happened after\n    // this event are terminated. Frames that are ancestors to this\n    // event are extended to cover its ending.\n    const endTime = Types.Timing.Micro(event.ts + (event.dur ?? 0));\n    this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, endTime);\n  }\n\n  /**\n   * Builds the initial calls with no duration from samples. Their\n   * purpose is to be merged with the trace event array being parsed so\n   * that they can be traversed in order with them and their duration\n   * can be updated as the SampleIntegrator callbacks are invoked.\n   */\n  callsFromProfileSamples(): Types.Events.SyntheticProfileCall[] {\n    const samples = this.#profileModel.samples;\n    const timestamps = this.#profileModel.timestamps;\n    if (!samples) {\n      return [];\n    }\n    const calls: Types.Events.SyntheticProfileCall[] = [];\n    let prevNode;\n    for (let i = 0; i < samples.length; i++) {\n      const node = this.#profileModel.nodeByIndex(i);\n      const timestamp = milliToMicro(Types.Timing.Milli(timestamps[i]));\n      if (!node) {\n        continue;\n      }\n      const call = makeProfileCall(node, this.#profileId, i, timestamp, this.#processId, this.#threadId);\n      calls.push(call);\n\n      if (this.#engineConfig.debugMode) {\n        const traceId = this.#profileModel.traceIds?.[i];\n        this.jsSampleEvents.push(this.#makeJSSampleEvent(call, timestamp, traceId));\n      }\n      if (node.id === this.#profileModel.gcNode?.id && prevNode) {\n        // GC samples have no stack, so we just put GC node on top of the\n        // last recorded sample. Cache the previous sample for future\n        // reference.\n        this.#nodeForGC.set(call, prevNode);\n        continue;\n      }\n      prevNode = node;\n    }\n    return calls;\n  }\n\n  /**\n   * Given a synthetic profile call, returns an array of profile calls\n   * representing the stack trace that profile call belongs to based on\n   * its nodeId. The input profile call will be at the top of the\n   * returned stack (last position), meaning that any other frames that\n   * were effectively above it are omitted.\n   * @param profileCall\n   * @param overrideTimeStamp a custom timestamp to use for the returned\n   * profile calls. If not defined, the timestamp of the input\n   * profileCall is used instead. This param is useful for example when\n   * creating the profile calls for a sample with a trace id, since the\n   * timestamp of the corresponding trace event should be used instead\n   * of the sample's.\n   */\n\n  #makeProfileCallsForStack(profileCall: Types.Events.SyntheticProfileCall, overrideTimeStamp?: Types.Timing.Micro):\n      Types.Events.SyntheticProfileCall[] {\n    let node = this.#profileModel.nodeById(profileCall.nodeId);\n    const isGarbageCollection = node?.id === this.#profileModel.gcNode?.id;\n    if (isGarbageCollection) {\n      // Because GC don't have a stack, we use the stack of the previous\n      // sample.\n      node = this.#nodeForGC.get(profileCall) || null;\n    }\n    if (!node) {\n      return [];\n    }\n    // `node.depth` is 0 based, so to set the size of the array we need\n    // to add 1 to its value.\n    const callFrames = new Array<Types.Events.SyntheticProfileCall>(node.depth + 1 + Number(isGarbageCollection));\n    // Add the stack trace in reverse order (bottom first).\n    let i = callFrames.length - 1;\n    if (isGarbageCollection) {\n      // Place the garbage collection call frame on top of the stack.\n      callFrames[i--] = profileCall;\n    }\n\n    // Many of these ProfileCalls will be GC'd later when we estimate the frame\n    // durations\n    while (node) {\n      callFrames[i--] = makeProfileCall(\n          node, profileCall.profileId, profileCall.sampleIndex, overrideTimeStamp ?? profileCall.ts, this.#processId,\n          this.#threadId);\n      node = node.parent;\n    }\n    return callFrames;\n  }\n\n  #getStackForSampleTraceId(traceId: number, timestamp: Types.Timing.Micro): Types.Events.SyntheticProfileCall[]|null {\n    const nodeId = this.#profileModel.traceIds?.[traceId];\n    const node = nodeId && this.#profileModel.nodeById(nodeId);\n    const maybeCallForTraceId =\n        node && makeProfileCall(node, this.#profileId, -1, timestamp, this.#processId, this.#threadId);\n    if (!maybeCallForTraceId) {\n      return null;\n    }\n    if (this.#engineConfig.debugMode) {\n      this.jsSampleEvents.push(this.#makeJSSampleEvent(maybeCallForTraceId, timestamp, traceId));\n    }\n    return this.#makeProfileCallsForStack(maybeCallForTraceId);\n  }\n  /**\n   * Update tracked stack using this event's call stack.\n   */\n  #extractStackTrace(event: Types.Events.Event): void {\n    let stackTrace = this.#currentJSStack;\n    if (Types.Events.isProfileCall(event)) {\n      stackTrace = this.#makeProfileCallsForStack(event);\n    }\n    const traceId = extractSampleTraceId(event);\n    const maybeCallForTraceId = traceId && this.#getStackForSampleTraceId(traceId, event.ts);\n    if (maybeCallForTraceId) {\n      stackTrace = maybeCallForTraceId;\n    }\n\n    SamplesIntegrator.filterStackFrames(stackTrace, this.#engineConfig);\n\n    const endTime = event.ts + (event.dur || 0);\n    const minFrames = Math.min(stackTrace.length, this.#currentJSStack.length);\n    let i;\n    // Merge a sample's stack frames with the stack frames we have\n    // so far if we detect they are equivalent.\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    //                ^ t = x1    ^ t = x2\n\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                  ^ t = x2\n    for (i = this.#lockedJsStackDepth.at(-1) || 0; i < minFrames; ++i) {\n      const newFrame = stackTrace[i].callFrame;\n      const oldFrame = this.#currentJSStack[i].callFrame;\n      if (!SamplesIntegrator.framesAreEqual(newFrame, oldFrame)) {\n        break;\n      }\n      // Scoot the right edge of this callFrame to the right\n      this.#currentJSStack[i].dur =\n          Types.Timing.Micro(Math.max(this.#currentJSStack[i].dur || 0, endTime - this.#currentJSStack[i].ts));\n    }\n\n    // If there are call frames in the sample that differ with the stack\n    // we have, update the stack, but keeping the common frames in place\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    // [-------D------]          [E]\n    //                ^ t = x1    ^ t = x2\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                [E]\n    //                  ^ t = x2\n    this.#truncateJSStack(i, event.ts);\n\n    for (; i < stackTrace.length; ++i) {\n      const call = stackTrace[i];\n      if (call.nodeId === this.#profileModel.programNode?.id || call.nodeId === this.#profileModel.root?.id ||\n          call.nodeId === this.#profileModel.idleNode?.id || call.nodeId === this.#profileModel.gcNode?.id) {\n        // Skip (root), (program) and (idle) frames, since this are not\n        // relevant for web profiling and we don't want to show them in\n        // the timeline.\n        continue;\n      }\n      this.#currentJSStack.push(call);\n      this.#constructedProfileCalls.push(call);\n    }\n  }\n\n  /**\n   * When a call stack that differs from the one we are tracking has\n   * been detected in the samples, the latter is \"truncated\" by\n   * setting the ending time of its call frames and removing the top\n   * call frames that aren't shared with the new call stack. This way,\n   * we can update the tracked stack with the new call frames on top.\n   * @param depth the amount of call frames from bottom to top that\n   * should be kept in the tracking stack trace. AKA amount of shared\n   * call frames between two stacks.\n   * @param time the new end of the call frames in the stack.\n   */\n  #truncateJSStack(depth: number, time: Types.Timing.Micro): void {\n    if (this.#lockedJsStackDepth.length) {\n      const lockedDepth = this.#lockedJsStackDepth.at(-1);\n      if (lockedDepth && depth < lockedDepth) {\n        console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);\n        depth = lockedDepth;\n      }\n    }\n    if (this.#currentJSStack.length < depth) {\n      console.error(`Trying to truncate higher than the current stack size at ${time}`);\n      depth = this.#currentJSStack.length;\n    }\n    for (let k = 0; k < this.#currentJSStack.length; ++k) {\n      this.#currentJSStack[k].dur = Types.Timing.Micro(Math.max(time - this.#currentJSStack[k].ts, 0));\n    }\n    this.#currentJSStack.length = depth;\n  }\n\n  #makeJSSampleEvent(call: Types.Events.SyntheticProfileCall, timestamp: Types.Timing.Micro, traceId?: number):\n      Types.Events.SyntheticJSSample {\n    const JSSampleEvent: Types.Events.SyntheticJSSample = {\n      name: Types.Events.Name.JS_SAMPLE,\n      cat: 'devtools.timeline',\n      args: {\n        data: {traceId, stackTrace: this.#makeProfileCallsForStack(call).map(e => e.callFrame)},\n      },\n      ph: Types.Events.Phase.INSTANT,\n      ts: timestamp,\n      dur: Types.Timing.Micro(0),\n      pid: this.#processId,\n      tid: this.#threadId,\n    };\n    return JSSampleEvent;\n  }\n\n  static framesAreEqual(frame1: Protocol.Runtime.CallFrame, frame2: Protocol.Runtime.CallFrame): boolean {\n    return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName &&\n        frame1.lineNumber === frame2.lineNumber;\n  }\n\n  static showNativeName(name: string, runtimeCallStatsEnabled: boolean): boolean {\n    return runtimeCallStatsEnabled && Boolean(SamplesIntegrator.nativeGroup(name));\n  }\n\n  static nativeGroup(nativeName: string): SamplesIntegrator.NativeGroups|null {\n    if (nativeName.startsWith('Parse')) {\n      return SamplesIntegrator.NativeGroups.PARSE;\n    }\n    if (nativeName.startsWith('Compile') || nativeName.startsWith('Recompile')) {\n      return SamplesIntegrator.NativeGroups.COMPILE;\n    }\n    return null;\n  }\n\n  static isNativeRuntimeFrame(frame: Protocol.Runtime.CallFrame): boolean {\n    return frame.url === 'native V8Runtime';\n  }\n\n  static filterStackFrames(stack: Types.Events.SyntheticProfileCall[], engineConfig: Types.Configuration.Configuration):\n      void {\n    const showAllEvents = engineConfig.showAllEvents;\n    if (showAllEvents) {\n      return;\n    }\n    let previousNativeFrameName: string|null = null;\n    let j = 0;\n    for (let i = 0; i < stack.length; ++i) {\n      const frame = stack[i].callFrame;\n      const nativeRuntimeFrame = SamplesIntegrator.isNativeRuntimeFrame(frame);\n      if (nativeRuntimeFrame &&\n          !SamplesIntegrator.showNativeName(frame.functionName, engineConfig.includeRuntimeCallStats)) {\n        continue;\n      }\n      const nativeFrameName = nativeRuntimeFrame ? SamplesIntegrator.nativeGroup(frame.functionName) : null;\n      if (previousNativeFrameName && previousNativeFrameName === nativeFrameName) {\n        continue;\n      }\n      previousNativeFrameName = nativeFrameName;\n      stack[j++] = stack[i];\n    }\n    stack.length = j;\n  }\n\n  static createFakeTraceFromCpuProfile(profile: Protocol.Profiler.Profile, tid: Types.Events.ThreadID):\n      Types.File.TraceFile {\n    if (!profile) {\n      return {traceEvents: [], metadata: {}};\n    }\n    // The |Name.CPU_PROFILE| will let MetaHandler to set |traceIsGeneric| to false\n    // The start time and duration is important here because we'll use them to determine the traceBounds\n    // We use the start and end time of the profile (which is longer than all samples), so the Performance\n    // panel won't truncate this time period.\n    const cpuProfileEvent: Types.Events.SyntheticCpuProfile = {\n      cat: 'disabled-by-default-devtools.timeline',\n      name: Types.Events.Name.CPU_PROFILE,\n      ph: Types.Events.Phase.COMPLETE,\n      pid: Types.Events.ProcessID(1),\n      tid,\n      ts: Types.Timing.Micro(profile.startTime),\n      dur: Types.Timing.Micro(profile.endTime - profile.startTime),\n      args: {data: {cpuProfile: profile}},\n      // Create an arbitrary profile id.\n      id: '0x1' as Types.Events.ProfileID,\n    };\n\n    return {\n      traceEvents: [cpuProfileEvent],\n      metadata: {\n        dataOrigin: Types.File.DataOrigin.CPU_PROFILE,\n      }\n    };\n  }\n\n  static extractCpuProfileFromFakeTrace(traceEvents: readonly Types.Events.Event[]): Protocol.Profiler.Profile {\n    const profileEvent = traceEvents.find(e => Types.Events.isSyntheticCpuProfile(e));\n    const profile = profileEvent?.args.data.cpuProfile;\n    if (!profile) {\n      throw new Error('Missing cpuProfile data');\n    }\n    return profile;\n  }\n}\n\nexport namespace SamplesIntegrator {\n  export const enum NativeGroups {\n    COMPILE = 'Compile',\n    PARSE = 'Parse',\n  }\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {getNavigationForTraceEvent} from './Trace.js';\n\nexport const milliToMicro = (value: Types.Timing.Milli): Types.Timing.Micro => Types.Timing.Micro(value * 1000);\n\nexport const secondsToMilli = (value: Types.Timing.Seconds): Types.Timing.Milli => Types.Timing.Milli(value * 1000);\n\nexport const secondsToMicro = (value: Types.Timing.Seconds): Types.Timing.Micro => milliToMicro(secondsToMilli(value));\n\nexport const microToMilli = (value: Types.Timing.Micro): Types.Timing.Milli => Types.Timing.Milli(value / 1000);\n\nexport const microToSeconds = (value: Types.Timing.Micro): Types.Timing.Seconds =>\n    Types.Timing.Seconds(value / 1000 / 1000);\n\nexport function timeStampForEventAdjustedByClosestNavigation(\n    event: Types.Events.Event,\n    traceBounds: Types.Timing.TraceWindowMicro,\n    navigationsByNavigationId: Map<string, Types.Events.NavigationStart>,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Timing.Micro {\n  let eventTimeStamp = event.ts - traceBounds.min;\n  if (event.args?.data?.navigationId) {\n    const navigationForEvent = navigationsByNavigationId.get(event.args.data.navigationId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  } else if (event.args?.data?.frame) {\n    const navigationForEvent = getNavigationForTraceEvent(event, event.args.data.frame, navigationsByFrameId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  }\n  return Types.Timing.Micro(eventTimeStamp);\n}\n\n// Expands the trace window by a provided percentage or, if it the expanded window is smaller than 1 millisecond, expands it to 1 millisecond.\n// If the expanded window is outside of the max trace window, cut the overflowing bound to the max trace window bound.\nexport function expandWindowByPercentOrToOneMillisecond(\n    annotationWindow: Types.Timing.TraceWindowMicro, maxTraceWindow: Types.Timing.TraceWindowMicro,\n    percentage: number): Types.Timing.TraceWindowMicro {\n  // Expand min and max of the window by half of the provided percentage. That way, in total, the window will be expanded by the provided percentage.\n  let newMin = annotationWindow.min - annotationWindow.range * (percentage / 100) / 2;\n  let newMax = annotationWindow.max + annotationWindow.range * (percentage / 100) / 2;\n\n  if (newMax - newMin < 1_000) {\n    const rangeMiddle = (annotationWindow.min + annotationWindow.max) / 2;\n    newMin = rangeMiddle - 500;\n    newMax = rangeMiddle + 500;\n  }\n\n  newMin = Math.max(newMin, maxTraceWindow.min);\n  newMax = Math.min(newMax, maxTraceWindow.max);\n\n  const expandedWindow: Types.Timing.TraceWindowMicro = {\n    min: Types.Timing.Micro(newMin),\n    max: Types.Timing.Micro(newMax),\n    range: Types.Timing.Micro(newMax - newMin),\n  };\n\n  return expandedWindow;\n}\n\nexport interface EventTimingsData<ValueType extends Types.Timing.Micro|Types.Timing.Milli|Types.Timing.Seconds, > {\n  startTime: ValueType;\n  endTime: ValueType;\n  duration: ValueType;\n}\n\nexport function eventTimingsMicroSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Micro> {\n  return {\n    startTime: event.ts,\n    endTime: (event.ts + (event.dur ?? 0)) as Types.Timing.Micro,\n    duration: (event.dur || 0) as Types.Timing.Micro,\n  };\n}\nexport function eventTimingsMilliSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Milli> {\n  return {\n    startTime: (event.ts / 1000) as Types.Timing.Milli,\n    endTime: (event.ts + (event.dur ?? 0)) / 1000 as Types.Timing.Milli,\n    duration: (event.dur || 0) / 1000 as Types.Timing.Milli,\n  };\n}\n\nexport function traceWindowMilliSeconds(bounds: Types.Timing.TraceWindowMicro): Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowMicroSecondsToMilliSeconds(bounds: Types.Timing.TraceWindowMicro):\n    Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowFromMilliSeconds(\n    min: Types.Timing.Milli, max: Types.Timing.Milli): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min: milliToMicro(min),\n    max: milliToMicro(max),\n    range: Types.Timing.Micro(milliToMicro(max) - milliToMicro(min)),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromMicroSeconds(\n    min: Types.Timing.Micro, max: Types.Timing.Micro): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min,\n    max,\n    range: (max - min) as Types.Timing.Micro,\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromEvent(event: Types.Events.Event): Types.Timing.TraceWindowMicro {\n  return {\n    min: event.ts,\n    max: event.ts + (event.dur ?? 0) as Types.Timing.Micro,\n    range: event.dur ?? 0 as Types.Timing.Micro,\n  };\n}\n\nexport function traceWindowFromOverlay(overlay: Types.Overlays.Overlay): Types.Timing.TraceWindowMicro|null {\n  switch (overlay.type) {\n    case 'ENTRY_LABEL':\n    case 'ENTRY_OUTLINE':\n    case 'ENTRY_SELECTED': {\n      return traceWindowFromEvent(overlay.entry);\n    }\n\n    case 'TIMESPAN_BREAKDOWN': {\n      const windows = overlay.sections.map(s => s.bounds);\n      if (overlay.entry) {\n        windows.push(traceWindowFromEvent(overlay.entry));\n      }\n      return combineTraceWindowsMicro(windows);\n    }\n\n    case 'CANDY_STRIPED_TIME_RANGE':\n    case 'TIME_RANGE': {\n      return structuredClone(overlay.bounds);\n    }\n\n    case 'ENTRIES_LINK': {\n      const from = traceWindowFromEvent(overlay.entryFrom);\n      if (!overlay.entryTo) {\n        return from;\n      }\n\n      const to = traceWindowFromEvent(overlay.entryTo);\n      return combineTraceWindowsMicro([from, to]);\n    }\n\n    case 'TIMESTAMP_MARKER':\n      return traceWindowFromMicroSeconds(overlay.timestamp, overlay.timestamp);\n    case 'TIMINGS_MARKER':\n      return traceWindowFromMicroSeconds(overlay.adjustedTimestamp, overlay.adjustedTimestamp);\n    case 'BOTTOM_INFO_BAR':\n      return null;\n\n    default:\n      Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n  }\n}\n\n/**\n * Combines (as in a union) multiple windows into one.\n */\nexport function combineTraceWindowsMicro(windows: Types.Timing.TraceWindowMicro[]): Types.Timing.TraceWindowMicro|null {\n  if (!windows.length) {\n    return null;\n  }\n\n  const result: Types.Timing.TraceWindowMicro = structuredClone(windows[0]);\n  for (const bounds of windows.slice(1)) {\n    result.min = Math.min(result.min, bounds.min) as Types.Timing.Micro;\n    result.max = Math.max(result.max, bounds.max) as Types.Timing.Micro;\n  }\n\n  result.range = result.max - result.min as Types.Timing.Micro;\n\n  return result;\n}\n\nexport interface BoundsIncludeTimeRange {\n  timeRange: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Checks to see if the timeRange is within the bounds. By \"within\" we mean\n * \"has any overlap\":\n *         |------------------------|\n *      ==                                     no overlap (entirely before)\n *       =========                             overlap\n *            =========                        overlap\n *                             =========       overlap\n *                                     ====    no overlap (entirely after)\n *        ==============================       overlap (time range is larger than bounds)\n *         |------------------------|\n */\nexport function boundsIncludeTimeRange(data: BoundsIncludeTimeRange): boolean {\n  const {min: visibleMin, max: visibleMax} = data.bounds;\n  const {min: rangeMin, max: rangeMax} = data.timeRange;\n\n  return visibleMin <= rangeMax && visibleMax >= rangeMin;\n}\n\n/** Checks to see if the event is within or overlaps the bounds */\nexport function eventIsInBounds(event: Types.Events.Event, bounds: Types.Timing.TraceWindowMicro): boolean {\n  const startTime = event.ts;\n  return startTime <= bounds.max && bounds.min <= (startTime + (event.dur ?? 0));\n}\n\nexport function timestampIsInBounds(bounds: Types.Timing.TraceWindowMicro, timestamp: Types.Timing.Micro): boolean {\n  return timestamp >= bounds.min && timestamp <= bounds.max;\n}\n\nexport interface WindowFitsInsideBounds {\n  window: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Returns true if the window fits entirely within the bounds.\n * Note that if the window is equivalent to the bounds, that is considered to fit\n */\nexport function windowFitsInsideBounds(data: WindowFitsInsideBounds): boolean {\n  return data.window.min >= data.bounds.min && data.window.max <= data.bounds.max;\n}\n\nexport function windowsEqual(w1: Types.Timing.TraceWindowMicro, w2: Types.Timing.TraceWindowMicro): boolean {\n  return w1.min === w2.min && w1.max === w2.max;\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {SyntheticEventsManager} from './SyntheticEvents.js';\nimport {eventTimingsMicroSeconds} from './Timing.js';\n\ninterface MatchingPairableAsyncEvents {\n  begin: Types.Events.PairableAsyncBegin|null;\n  end: Types.Events.PairableAsyncEnd|null;\n  instant?: Types.Events.PairableAsyncInstant[];\n}\n\n/**\n * Extracts the raw stack trace in known trace events. Most likely than\n * not you want to use `getZeroIndexedStackTraceForEvent`, which returns\n * the stack with zero based numbering. Since some trace events are\n * one based this function can yield unexpected results when used\n * indiscriminately.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function stackTraceInEvent(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  if (event.args?.data?.stackTrace) {\n    return event.args.data.stackTrace;\n  }\n  if (event.args?.stackTrace) {\n    return event.args.stackTrace;\n  }\n  if (Types.Events.isRecalcStyle(event)) {\n    return event.args.beginData?.stackTrace || null;\n  }\n  if (Types.Events.isLayout(event)) {\n    return event.args.beginData.stackTrace ?? null;\n  }\n  if (Types.Events.isFunctionCall(event)) {\n    const data = event.args.data;\n    if (!data) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = data;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  if (Types.Events.isProfileCall(event)) {\n    // Of type Protocol.Runtime.CallFrame, handle accordingly.\n    const callFrame = event.callFrame;\n    if (!callFrame) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = callFrame;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  return null;\n}\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = Common.ParsedURL.ParsedURL.fromString(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.Events.Event> = Map<Types.Events.ThreadID, T[]>;\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nexport function addEventToProcessThread<T extends Types.Events.Event>(\n    event: T,\n    eventsInProcessThread: Map<Types.Events.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.Events.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\nexport function compareBeginAndEnd(aBeginTime: number, bBeginTime: number, aEndTime: number, bEndTime: number): -1|0|1 {\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexport function eventTimeComparator(a: Types.Events.Event, b: Types.Events.Event): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  const timeDifference = compareBeginAndEnd(aBeginTime, bBeginTime, aEndTime, bEndTime);\n  if (timeDifference) {\n    return timeDifference;\n  }\n\n  // If times are equal, prioritize profile calls over trace events,\n  // since an exactly equal timestamp with a trace event is likely\n  // indicates that the SamplesIntegrator meant to parent the trace\n  // event with the profile call.\n  if (Types.Events.isProfileCall(a) && !Types.Events.isProfileCall(b)) {\n    return -1;\n  }\n  if (Types.Events.isProfileCall(b) && !Types.Events.isProfileCall(a)) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: Types.Events.Event[]): void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function mergeEventsInOrder<T1 extends Types.Events.Event, T2 extends Types.Events.Event>(\n    eventsArray1: readonly T1[], eventsArray2: readonly T2[]): Array<T1|T2> {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function parseDevtoolsDetails(timingDetail: string, key: string): Types.Extensions.DevToolsObj|\n    Types.Extensions.ExtensionTrackEntryPayloadDeeplink|null {\n  try {\n    // Attempt to parse the detail as an object that might be coming from a\n    // DevTools Perf extension.\n    // Wrapped in a try-catch because timingDetail might either:\n    // 1. Not be `json.parse`-able (it should, but just in case...)\n    // 2. Not be an object - in which case the `in` check will error.\n    // If we hit either of these cases, we just ignore this mark and move on.\n    const detailObj = JSON.parse(timingDetail);\n    if (!(key in detailObj)) {\n      return null;\n    }\n    if (!Types.Extensions.isValidExtensionPayload(detailObj[key])) {\n      return null;\n    }\n    return detailObj[key];\n  } catch {\n    // No need to worry about this error, just discard this event and don't\n    // treat it as having any useful information for the purposes of extensions.\n    return null;\n  }\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.Events.Event,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Events.NavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(\n    event: Types.Events.PairableAsync|Types.Events.SyntheticEventPair<Types.Events.PairableAsync>): string|undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.Micro,\n    rendererProcessesByFrame: Map<\n        string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>):\n    string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\n/**\n * @param node the node attached to the profile call. Here a node represents a function in the call tree.\n * @param profileId the profile ID that the sample came from that backs this call.\n * @param sampleIndex the index of the sample in the given profile that this call was created from\n * @param ts the timestamp of the profile call\n * @param pid the process ID of the profile call\n * @param tid the thread ID of the profile call\n *\n * See `panels/timeline/docs/profile_calls.md` for more context on how these events are created.\n */\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, profileId: Types.Events.ProfileID, sampleIndex: number,\n    ts: Types.Timing.Micro, pid: Types.Events.ProcessID,\n    tid: Types.Events.ThreadID): Types.Events.SyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.Events.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.Micro(0),\n    callFrame: node.callFrame,\n    sampleIndex,\n    profileId,\n  };\n}\n\n/**\n * Matches beginning events with PairableAsyncEnd and PairableAsyncInstant (ASYNC_NESTABLE_INSTANT)\n * if provided, though currently only coming from Animations. Traces may contain multiple instant events so we need to\n * account for that.\n *\n * @returns Map of the animation's ID to it's matching events.\n */\nexport function matchEvents(unpairedEvents: Types.Events.PairableAsync[]): Map<string, MatchingPairableAsyncEvents> {\n  // map to store begin and end of the event\n  const matchedPairs = new Map<string, MatchingPairableAsyncEvents>();\n\n  // looking for start and end\n  for (const event of unpairedEvents) {\n    const syntheticId = getSyntheticId(event);\n    if (syntheticId === undefined) {\n      continue;\n    }\n    // Create a synthetic id to prevent collisions across categories.\n    // Console timings can be dispatched with the same id, so use the\n    // event name as well to generate unique ids.\n    const otherEventsWithID = Platform.MapUtilities.getWithDefault(matchedPairs, syntheticId, () => {\n      return {begin: null, end: null, instant: []};\n    });\n\n    const isStartEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_START;\n    const isEndEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_END;\n    const isInstantEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_INSTANT;\n\n    if (isStartEvent) {\n      otherEventsWithID.begin = event as Types.Events.PairableAsyncBegin;\n    } else if (isEndEvent) {\n      otherEventsWithID.end = event as Types.Events.PairableAsyncEnd;\n    } else if (isInstantEvent) {\n      if (!otherEventsWithID.instant) {\n        otherEventsWithID.instant = [];\n      }\n      otherEventsWithID.instant.push(event as Types.Events.PairableAsyncInstant);\n    }\n  }\n  return matchedPairs;\n}\n\nexport function getSyntheticId(event: Types.Events.PairableAsync): string|undefined {\n  const id = extractId(event);\n  return id && `${event.cat}:${id}:${event.name}`;\n}\n\nexport function createSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    matchedPairs: Map<string, {\n      begin: Types.Events.PairableAsyncBegin | null,\n      end: Types.Events.PairableAsyncEnd | null,\n      instant?: Types.Events.PairableAsyncInstant[],\n    }>,\n    syntheticEventCallback?: (syntheticEvent: Types.Events.SyntheticEventPair<T>) => void,\n    ): Array<Types.Events.SyntheticEventPair<T>> {\n  const syntheticEvents: Array<Types.Events.SyntheticEventPair<T>> = [];\n  for (const [id, eventsTriplet] of matchedPairs.entries()) {\n    const beginEvent = eventsTriplet.begin;\n    const endEvent = eventsTriplet.end;\n    const instantEvents = eventsTriplet.instant;\n    if (!beginEvent || !(endEvent || instantEvents)) {\n      // This should never happen, the backend only creates the events once it\n      // has them both (beginEvent & endEvent/instantEvents), so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n    const triplet = {beginEvent, endEvent, instantEvents};\n    /**\n     * When trying to pair events with instant events present, there are times when these\n     * ASYNC_NESTABLE_INSTANT ('n') don't have a corresponding ASYNC_NESTABLE_END ('e') event.\n     * In these cases, pair without needing the endEvent.\n     */\n    function eventsArePairable(data: {\n      beginEvent: Types.Events.PairableAsyncBegin,\n      endEvent: Types.Events.PairableAsyncEnd|null,\n      instantEvents?: Types.Events.PairableAsyncInstant[],\n    }): data is Types.Events.SyntheticEventPair<T>['args']['data'] {\n      const instantEventsMatch = data.instantEvents ? data.instantEvents.some(e => id === getSyntheticId(e)) : false;\n      const endEventMatch = data.endEvent ? id === getSyntheticId(data.endEvent) : false;\n      return Boolean(id) && (instantEventsMatch || endEventMatch);\n    }\n    if (!eventsArePairable(triplet)) {\n      continue;\n    }\n    const targetEvent = endEvent || beginEvent;\n\n    const event = SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticEventPair<T>>({\n      rawSourceEvent: triplet.beginEvent,\n      cat: targetEvent.cat,\n      ph: targetEvent.ph,\n      pid: targetEvent.pid,\n      tid: targetEvent.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: beginEvent.name,\n      dur: Types.Timing.Micro(targetEvent.ts - beginEvent.ts),\n      ts: beginEvent.ts,\n      args: {\n        data: triplet,\n      },\n    });\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEventCallback?.(event);\n    syntheticEvents.push(event);\n  }\n  return syntheticEvents.sort((a, b) => a.ts - b.ts);\n}\n\nexport function createMatchedSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    unpairedAsyncEvents: T[], syntheticEventCallback?: (syntheticEvent: Types.Events.SyntheticEventPair<T>) => void):\n    Array<Types.Events.SyntheticEventPair<T>> {\n  const matchedPairs = matchEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents<T>(matchedPairs, syntheticEventCallback);\n  return syntheticEvents;\n}\n\n/**\n * Different trace events return line/column numbers that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n */\nexport function getZeroIndexedLineAndColumnForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  // Some events emit line numbers that are 1 indexed, but the UI layer expects\n  // numbers to be 0 indexed. So here, if the event matches a known 1-indexed\n  // number event, we subtract one from the line and column numbers.\n  // Otherwise, if the event has args.data.lineNumber/colNumber, we return it\n  // as is.\n  const numbers = getRawLineAndColumnNumbersForEvent(event);\n  const {lineNumber, columnNumber} = numbers;\n\n  switch (event.name) {\n    // All these events have line/column numbers which are 1 indexed; so we\n    // subtract to make them 0 indexed.\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.EVALUATE_SCRIPT:\n    case Types.Events.Name.COMPILE:\n    case Types.Events.Name.CACHE_SCRIPT: {\n      return {\n        lineNumber: typeof lineNumber === 'number' ? lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? columnNumber - 1 : undefined,\n      };\n    }\n    case Types.Events.Name.PROFILE_CALL: {\n      const callFrame = (event as Types.Events.SyntheticProfileCall).callFrame;\n      return {\n        lineNumber: typeof lineNumber === 'number' ? callFrame.lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? callFrame.columnNumber - 1 : undefined,\n      };\n    }\n    default: {\n      return numbers;\n    }\n  }\n}\n\n/**\n * Different trace events contain stack traces with line/column numbers\n * that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function getZeroIndexedStackTraceInEventPayload(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return stack.map(makeZeroBasedCallFrame);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return stack.map(makeZeroBasedCallFrame);\n      }\n\n      return stack;\n    }\n  }\n}\n\n/**\n * Same as getZeroIndexedStackTraceInEventPayload, but only returns the top call frame.\n */\nexport function getStackTraceTopCallFrameInEventPayload(event: Types.Events.Event): Types.Events.CallFrame|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack || stack.length === 0) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return makeZeroBasedCallFrame(stack[0]);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return makeZeroBasedCallFrame(stack[0]);\n      }\n\n      return stack[0];\n    }\n  }\n}\n\n/**\n * Given a 1-based call frame creates a 0-based one.\n */\nexport function makeZeroBasedCallFrame(callFrame: Types.Events.CallFrame): Types.Events.CallFrame {\n  const normalizedCallFrame = {...callFrame};\n\n  normalizedCallFrame.lineNumber = callFrame.lineNumber && callFrame.lineNumber - 1;\n  normalizedCallFrame.columnNumber = callFrame.columnNumber && callFrame.columnNumber - 1;\n  return normalizedCallFrame;\n}\n\n/**\n * NOTE: you probably do not want this function! (Which is why it is not exported).\n *\n * Some trace events have 0 indexed line/column numbers, and others have 1\n * indexed. This function does NOT normalize them, but\n * `getZeroIndexedLineAndColumnNumbersForEvent` does. It is best to use that!\n *\n * @see {@link getZeroIndexedLineAndColumnForEvent}\n **/\nfunction getRawLineAndColumnNumbersForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  if (!event.args?.data) {\n    return {\n      lineNumber: undefined,\n      columnNumber: undefined,\n    };\n  }\n  let lineNumber: number|undefined = undefined;\n  let columnNumber: number|undefined = undefined;\n  if ('lineNumber' in event.args.data && typeof event.args.data.lineNumber === 'number') {\n    lineNumber = event.args.data.lineNumber;\n  }\n  if ('columnNumber' in event.args.data && typeof event.args.data.columnNumber === 'number') {\n    columnNumber = event.args.data.columnNumber;\n  }\n\n  return {lineNumber, columnNumber};\n}\n\nexport function frameIDForEvent(event: Types.Events.Event): string|null {\n  // There are a few events (for example RecalcStyle, ParseHTML) that have\n  // the frame stored in args.beginData\n  // Rather than list them all we just check for the presence of the field, so\n  // we are robust against future trace events also doing this.\n  // This check seems very robust, but it also helps satisfy TypeScript and\n  // prevents us against unexpected data.\n  if (event.args && 'beginData' in event.args && typeof event.args.beginData === 'object' &&\n      event.args.beginData !== null && 'frame' in event.args.beginData &&\n      typeof event.args.beginData.frame === 'string') {\n    return event.args.beginData.frame;\n  }\n  // Otherwise, we expect frame to be in args.data\n  if (event.args?.data?.frame) {\n    return event.args.data.frame;\n  }\n\n  // No known frame for this event.\n  return null;\n}\n\nconst DevToolsTimelineEventCategory = 'disabled-by-default-devtools.timeline';\nexport function isTopLevelEvent(event: Types.Events.Event): boolean {\n  return event.cat.includes(DevToolsTimelineEventCategory) && event.name === Types.Events.Name.RUN_TASK;\n}\n\nexport function isExtensionUrl(url: string): boolean {\n  return url.startsWith('extensions:') || url.startsWith('chrome-extension:');\n}\n\nfunction topLevelEventIndexEndingAfter(events: Types.Events.Event[], time: Types.Timing.Micro): number {\n  let index = Platform.ArrayUtilities.upperBound(events, time, (time, event) => time - event.ts) - 1;\n  while (index > 0 && !isTopLevelEvent(events[index])) {\n    index--;\n  }\n  return Math.max(index, 0);\n}\nexport function findRecalcStyleEvents(\n    events: Types.Events.Event[], startTime: Types.Timing.Micro,\n    endTime?: Types.Timing.Micro): Types.Events.RecalcStyle[] {\n  const foundEvents: Types.Events.RecalcStyle[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, startTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const event = events[i];\n    if (!Types.Events.isRecalcStyle(event)) {\n      continue;\n    }\n    if (event.ts >= (endTime || Infinity)) {\n      continue;\n    }\n    foundEvents.push(event);\n  }\n  return foundEvents;\n}\n\nexport function findNextEventAfterTimestamp<T extends Types.Events.Event>(candidates: T[], ts: Types.Timing.Micro): T|\n    null {\n  const index = Platform.ArrayUtilities.nearestIndexFromBeginning(candidates, candidate => ts < candidate.ts);\n  return index === null ? null : candidates[index];\n}\n\nexport function findPreviousEventBeforeTimestamp<T extends Types.Events.Event>(\n    candidates: T[], ts: Types.Timing.Micro): T|null {\n  const index = Platform.ArrayUtilities.nearestIndexFromEnd(candidates, candidate => candidate.ts < ts);\n  return index === null ? null : candidates[index];\n}\n\nexport interface ForEachEventConfig {\n  onStartEvent: (event: Types.Events.Event) => void;\n  onEndEvent: (event: Types.Events.Event) => void;\n  onInstantEvent?: (event: Types.Events.Event) => void;\n  eventFilter?: (event: Types.Events.Event) => boolean;\n  startTime?: Types.Timing.Micro;\n  endTime?: Types.Timing.Micro;\n  /* If async events should be skipped. Defaults to true */\n  ignoreAsyncEvents?: boolean;\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * dictated by the corresponding timestamp.\n *\n * Events are assumed to be in ascendent order by timestamp.\n *\n * Events with 0 duration are treated as instant events. These do not have a\n * begin and end, but will be passed to the config.onInstantEvent callback as\n * they are discovered. Do not provide this callback if you are not interested\n * in them.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n * By default, async events are skipped. This behaviour can be\n * overridden making use of the config.ignoreAsyncEvents parameter.\n */\nexport function forEachEvent(\n    events: Types.Events.Event[],\n    config: ForEachEventConfig,\n    ): void {\n  const globalStartTime = config.startTime ?? Types.Timing.Micro(0);\n  const globalEndTime = config.endTime || Types.Timing.Micro(Infinity);\n  const ignoreAsyncEvents = config.ignoreAsyncEvents === false ? false : true;\n\n  const stack: Types.Events.Event[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, globalStartTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const currentEvent = events[i];\n    const currentEventTimings = eventTimingsMicroSeconds(currentEvent);\n    if (currentEventTimings.endTime < globalStartTime) {\n      continue;\n    }\n    if (currentEventTimings.startTime > globalEndTime) {\n      break;\n    }\n\n    const isIgnoredAsyncEvent = ignoreAsyncEvents && Types.Events.isPhaseAsync(currentEvent.ph);\n    if (isIgnoredAsyncEvent || Types.Events.isFlowPhase(currentEvent.ph)) {\n      continue;\n    }\n\n    // If we have now reached an event that is after a bunch of events, we need\n    // to call the onEndEvent callback for those events before moving on.\n    let lastEventOnStack = stack.at(-1);\n    let lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    while (lastEventOnStack && lastEventEndTime && lastEventEndTime <= currentEventTimings.startTime) {\n      stack.pop();\n      config.onEndEvent(lastEventOnStack);\n      lastEventOnStack = stack.at(-1);\n      lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    }\n\n    // Now we have dealt with all events prior to this one, see if we need to care about this one.\n    if (config.eventFilter && !config.eventFilter(currentEvent)) {\n      // The user has chosen to filter this event out, so continue on and do nothing\n      continue;\n    }\n\n    if (currentEventTimings.duration) {\n      config.onStartEvent(currentEvent);\n      stack.push(currentEvent);\n    } else if (config.onInstantEvent) {\n      // An event with 0 duration is an instant event.\n      config.onInstantEvent(currentEvent);\n    }\n  }\n\n  // Now we have finished looping over all events; any events remaining on the\n  // stack need to have their onEndEvent called.\n  while (stack.length) {\n    const last = stack.pop();\n    if (last) {\n      config.onEndEvent(last);\n    }\n  }\n}\n\n// Parsed categories are cached to prevent calling cat.split()\n// multiple times on the same categories string.\nconst parsedCategories = new Map<string, Set<string>>();\nexport function eventHasCategory(event: Types.Events.Event, category: string): boolean {\n  let parsedCategoriesForEvent = parsedCategories.get(event.cat);\n  if (!parsedCategoriesForEvent) {\n    parsedCategoriesForEvent = new Set(event.cat.split(',') || []);\n  }\n  return parsedCategoriesForEvent.has(category);\n}\n\n/**\n * This compares Types.Events.CallFrame with Protocol.Runtime.CallFrame and checks for equality.\n */\nexport function isMatchingCallFrame(\n    eventFrame: Types.Events.CallFrame, nodeFrame: Protocol.Runtime.CallFrame): boolean {\n  return eventFrame.columnNumber === nodeFrame.columnNumber && eventFrame.lineNumber === nodeFrame.lineNumber &&\n      String(eventFrame.scriptId) === nodeFrame.scriptId && eventFrame.url === nodeFrame.url &&\n      eventFrame.functionName === nodeFrame.functionName;\n}\n\nexport function eventContainsTimestamp(event: Types.Events.Event, ts: Types.Timing.Micro): boolean {\n  return event.ts <= ts && event.ts + (event.dur || 0) >= ts;\n}\n\nexport function extractSampleTraceId(event: Types.Events.Event): number|null {\n  if (!event.args) {\n    return null;\n  }\n  if ('beginData' in event.args) {\n    const beginData = event.args['beginData'] as {sampleTraceId?: number};\n    return beginData.sampleTraceId ?? null;\n  }\n  return event.args?.sampleTraceId ?? event.args?.data?.sampleTraceId ?? null;\n}\n\n// This exactly matches Trace.Styles.visibleTypes. See the runtime verification in maybeInitStylesMap.\n// TODO(crbug.com/410884528)\nexport const VISIBLE_TRACE_EVENT_TYPES = new Set<Types.Events.Name>([\n  Types.Events.Name.ABORT_POST_TASK_CALLBACK,\n  Types.Events.Name.ANIMATION,\n  Types.Events.Name.ASYNC_TASK,\n  Types.Events.Name.BACKGROUND_DESERIALIZE,\n  Types.Events.Name.CACHE_MODULE,\n  Types.Events.Name.CACHE_SCRIPT,\n  Types.Events.Name.CANCEL_ANIMATION_FRAME,\n  Types.Events.Name.CANCEL_IDLE_CALLBACK,\n  Types.Events.Name.COMMIT,\n  Types.Events.Name.COMPILE_CODE,\n  Types.Events.Name.COMPILE_MODULE,\n  Types.Events.Name.COMPILE,\n  Types.Events.Name.COMPOSITE_LAYERS,\n  Types.Events.Name.COMPUTE_INTERSECTION,\n  Types.Events.Name.CONSOLE_TIME,\n  Types.Events.Name.CPPGC_SWEEP,\n  Types.Events.Name.CRYPTO_DO_DECRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_DECRYPT,\n  Types.Events.Name.CRYPTO_DO_DIGEST_REPLY,\n  Types.Events.Name.CRYPTO_DO_DIGEST,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT,\n  Types.Events.Name.CRYPTO_DO_SIGN_REPLY,\n  Types.Events.Name.CRYPTO_DO_SIGN,\n  Types.Events.Name.CRYPTO_DO_VERIFY_REPLY,\n  Types.Events.Name.CRYPTO_DO_VERIFY,\n  Types.Events.Name.DECODE_IMAGE,\n  Types.Events.Name.EMBEDDER_CALLBACK,\n  Types.Events.Name.EVALUATE_MODULE,\n  Types.Events.Name.EVALUATE_SCRIPT,\n  Types.Events.Name.EVENT_DISPATCH,\n  Types.Events.Name.EVENT_TIMING,\n  Types.Events.Name.FINALIZE_DESERIALIZATION,\n  Types.Events.Name.FIRE_ANIMATION_FRAME,\n  Types.Events.Name.FIRE_IDLE_CALLBACK,\n  Types.Events.Name.FUNCTION_CALL,\n  Types.Events.Name.GC_COLLECT_GARBARGE,\n  Types.Events.Name.GC,\n  Types.Events.Name.GPU_TASK,\n  Types.Events.Name.HANDLE_POST_MESSAGE,\n  Types.Events.Name.HIT_TEST,\n  Types.Events.Name.JS_SAMPLE,\n  Types.Events.Name.LAYERIZE,\n  Types.Events.Name.LAYOUT,\n  Types.Events.Name.MAJOR_GC,\n  Types.Events.Name.MINOR_GC,\n  Types.Events.Name.OPTIMIZE_CODE,\n  Types.Events.Name.PAINT_SETUP,\n  Types.Events.Name.PAINT,\n  Types.Events.Name.PARSE_AUTHOR_STYLE_SHEET,\n  Types.Events.Name.PARSE_HTML,\n  Types.Events.Name.PRE_PAINT,\n  Types.Events.Name.PROFILE_CALL,\n  Types.Events.Name.PROGRAM,\n  Types.Events.Name.RASTER_TASK,\n  Types.Events.Name.REQUEST_ANIMATION_FRAME,\n  Types.Events.Name.REQUEST_IDLE_CALLBACK,\n  Types.Events.Name.RESOURCE_FINISH,\n  Types.Events.Name.RESOURCE_RECEIVE_DATA,\n  Types.Events.Name.RESOURCE_RECEIVE_RESPONSE,\n  Types.Events.Name.RESOURCE_SEND_REQUEST,\n  Types.Events.Name.RESOURCE_WILL_SEND_REQUEST,\n  Types.Events.Name.RUN_MICROTASKS,\n  Types.Events.Name.RUN_POST_TASK_CALLBACK,\n  Types.Events.Name.RUN_TASK,\n  Types.Events.Name.SCHEDULE_POST_MESSAGE,\n  Types.Events.Name.SCHEDULE_POST_TASK_CALLBACK,\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.SCROLL_LAYER,\n  Types.Events.Name.START_PROFILING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_PARSING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_WAITING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT_CLUSTER,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT,\n  Types.Events.Name.TIME_STAMP,\n  Types.Events.Name.TIMER_FIRE,\n  Types.Events.Name.TIMER_INSTALL,\n  Types.Events.Name.TIMER_REMOVE,\n  Types.Events.Name.UPDATE_LAYER_TREE,\n  Types.Events.Name.RECALC_STYLE,\n  Types.Events.Name.USER_TIMING,\n  Types.Events.Name.V8_CONSOLE_RUN_TASK,\n  Types.Events.Name.WASM_CACHED_MODULE,\n  Types.Events.Name.WASM_COMPILED_MODULE,\n  Types.Events.Name.WASM_MODULE_CACHE_HIT,\n  Types.Events.Name.WASM_MODULE_CACHE_INVALID,\n  Types.Events.Name.WASM_STREAM_FROM_RESPONSE_CALLBACK,\n  Types.Events.Name.WEB_SOCKET_CREATE,\n  Types.Events.Name.WEB_SOCKET_DESTROY,\n  Types.Events.Name.WEB_SOCKET_RECEIVE_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_RECEIVE,\n  Types.Events.Name.WEB_SOCKET_SEND_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_SEND,\n  Types.Events.Name.XHR_LOAD,\n  Types.Events.Name.XHR_READY_STATE_CHANGED,\n]);\n"],
  "mappings": "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",
  "names": ["Helpers", "Types", "maybeAsyncParentNode", "Handlers", "Helpers", "Types", "Types", "Helpers", "Types", "Platform", "Types", "Platform", "Types", "Types", "endTime"]
}
