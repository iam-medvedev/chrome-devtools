{"version":3,"file":"ThirdParties.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/extras/ThirdParties.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nexport type Entity = typeof ThirdPartyWeb.ThirdPartyWeb.entities[number];\n\nexport interface Summary {\n  transferSize: number;\n  mainThreadTime: Types.Timing.MicroSeconds;\n}\n\nexport interface SummaryMaps {\n  byEntity: Map<Entity, Summary>;\n  byRequest: Map<Types.Events.SyntheticNetworkRequest, Summary>;\n  requestsByEntity: Map<Entity, Types.Events.SyntheticNetworkRequest[]>;\n}\n\nfunction getSelfTimeByUrl(\n    parsedTrace: Handlers.Types.ParsedTrace, bounds: Types.Timing.TraceWindowMicroSeconds): Map<string, number> {\n  const selfTimeByUrl = new Map<string, number>();\n\n  for (const process of parsedTrace.Renderer.processes.values()) {\n    if (!process.isOnMainFrame) {\n      continue;\n    }\n\n    for (const thread of process.threads.values()) {\n      if (thread.name === 'CrRendererMain') {\n        if (!thread.tree) {\n          break;\n        }\n\n        for (const event of thread.entries) {\n          if (!Helpers.Timing.eventIsInBounds(event, bounds)) {\n            continue;\n          }\n\n          const node = parsedTrace.Renderer.entryToNode.get(event);\n          if (!node || !node.selfTime) {\n            continue;\n          }\n\n          const url = Handlers.Helpers.getNonResolvedURL(event, parsedTrace as Handlers.Types.ParsedTrace);\n          if (!url) {\n            continue;\n          }\n\n          selfTimeByUrl.set(url, node.selfTime + (selfTimeByUrl.get(url) ?? 0));\n        }\n      }\n    }\n  }\n\n  return selfTimeByUrl;\n}\n\nexport function getEntitiesByRequest(requests: Types.Events.SyntheticNetworkRequest[]):\n    {entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>, madeUpEntityCache: Map<string, Entity>} {\n  const entityByRequest = new Map<Types.Events.SyntheticNetworkRequest, Entity>();\n  const madeUpEntityCache = new Map<string, Entity>();\n  for (const request of requests) {\n    const url = request.args.data.url;\n    const entity = ThirdPartyWeb.ThirdPartyWeb.getEntity(url) ?? Handlers.Helpers.makeUpEntity(madeUpEntityCache, url);\n    if (entity) {\n      entityByRequest.set(request, entity);\n    }\n  }\n  return {entityByRequest, madeUpEntityCache};\n}\n\nfunction getSummaryMap(\n    requests: Types.Events.SyntheticNetworkRequest[],\n    entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>,\n    selfTimeByUrl: Map<string, number>): SummaryMaps {\n  const byRequest = new Map<Types.Events.SyntheticNetworkRequest, Summary>();\n  const byEntity = new Map<Entity, Summary>();\n  const defaultSummary: Summary = {transferSize: 0, mainThreadTime: Types.Timing.MicroSeconds(0)};\n\n  for (const request of requests) {\n    const urlSummary = byRequest.get(request) || {...defaultSummary};\n    urlSummary.transferSize += request.args.data.encodedDataLength;\n    urlSummary.mainThreadTime =\n        Types.Timing.MicroSeconds(urlSummary.mainThreadTime + (selfTimeByUrl.get(request.args.data.url) ?? 0));\n    byRequest.set(request, urlSummary);\n  }\n\n  // Map each request's stat to a particular entity.\n  const requestsByEntity = new Map<Entity, Types.Events.SyntheticNetworkRequest[]>();\n  for (const [request, requestSummary] of byRequest.entries()) {\n    const entity = entityByRequest.get(request);\n    if (!entity) {\n      byRequest.delete(request);\n      continue;\n    }\n\n    const entitySummary = byEntity.get(entity) || {...defaultSummary};\n    entitySummary.transferSize += requestSummary.transferSize;\n    entitySummary.mainThreadTime =\n        Types.Timing.MicroSeconds(entitySummary.mainThreadTime + requestSummary.mainThreadTime);\n    byEntity.set(entity, entitySummary);\n\n    const entityRequests = requestsByEntity.get(entity) || [];\n    entityRequests.push(request);\n    requestsByEntity.set(entity, entityRequests);\n  }\n\n  return {byEntity, byRequest, requestsByEntity};\n}\n\nexport function getSummariesAndEntitiesForTraceBounds(\n    parsedTrace: Handlers.Types.ParsedTrace, traceBounds: Types.Timing.TraceWindowMicroSeconds,\n    networkRequests: Types.Events.SyntheticNetworkRequest[]): {\n  summaries: SummaryMaps,\n  entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>,\n  madeUpEntityCache: Map<string, Entity>,\n} {\n  // Ensure we only handle requests that are within the given traceBounds.\n  const reqs = networkRequests.filter(event => {\n    return Helpers.Timing.eventIsInBounds(event, traceBounds);\n  });\n\n  const {entityByRequest, madeUpEntityCache} = getEntitiesByRequest(reqs);\n\n  const selfTimeByUrl = getSelfTimeByUrl(parsedTrace, traceBounds);\n  // TODO(crbug.com/352244718): re-work to still collect main thread activity if no request is present\n  const summaries = getSummaryMap(reqs, entityByRequest, selfTimeByUrl);\n\n  return {summaries, entityByRequest, madeUpEntityCache};\n}\n"]}