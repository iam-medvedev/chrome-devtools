// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import * as Platform from '../../core/platform/platform.js';
import * as Helpers from './helpers/helpers.js';
import * as Types from './types/types.js';
const filterApplyActionSet = new Set([
    "MERGE_FUNCTION" /* FilterApplyAction.MERGE_FUNCTION */,
    "COLLAPSE_FUNCTION" /* FilterApplyAction.COLLAPSE_FUNCTION */,
    "COLLAPSE_REPEATING_DESCENDANTS" /* FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS */,
]);
const filterUndoActionSet = new Set([
    "RESET_CHILDREN" /* FilterUndoAction.RESET_CHILDREN */,
    "UNDO_ALL_ACTIONS" /* FilterUndoAction.UNDO_ALL_ACTIONS */,
]);
/**
 * This class can take in a thread that has been generated by the
 * RendererHandler and apply certain actions to it in order to modify what is
 * shown to the user. These actions can be automatically applied by DevTools or
 * applied by the user.
 *
 * Once actions are applied, the invisibleEntries() method will return the
 * entries that are invisible, and this is the list of entries that should be
 * removed before rendering the resulting thread on the timeline.
 **/
export class EntriesFilter {
    // Maps from an individual TraceEvent entry to its representation as a
    // RendererEntryNode. We need this so we can then parse the tree structure
    // generated by the RendererHandler.
    #entryToNode;
    // Track the set of invisible entries.
    #invisibleEntries = [];
    // List of entries whose children are modified. This list is used to
    // keep track of entries that should be identified in the UI as modified.
    #modifiedVisibleEntries = [];
    // Cache for ancestors of entry that have already been gathered. The ancestors
    // will never change so we can avoid running the potentially expensive search again.
    #entryToAncestorsMap = new Map();
    constructor(entryToNode) {
        this.#entryToNode = entryToNode;
    }
    /**
     * Applies an action to hide entries or removes entries
     * from hidden entries array depending on the type of action.
     **/
    applyAction(action) {
        if ( /* FilterApplyActions */this.#isUserApplyFilterAction(action)) {
            this.#applyFilterAction(action);
        }
        else if ( /* FilterUndoActions */this.#isFilterUndoAction(action.type)) {
            this.#applyUndoAction(action);
        }
    }
    /**
     * If undo action is UNDO_ALL_ACTIONS, assign invisibleEntries array to an empty one.
     * **/
    #applyUndoAction(action) {
        switch (action.type) {
            case "UNDO_ALL_ACTIONS" /* FilterUndoAction.UNDO_ALL_ACTIONS */: {
                this.#invisibleEntries = [];
                this.#modifiedVisibleEntries = [];
                break;
            }
            case "RESET_CHILDREN" /* FilterUndoAction.RESET_CHILDREN */: {
                this.#makeEntryChildrenVisible(action.entry);
                break;
            }
        }
    }
    /**
     * Returns the set of entries that are invisible given the set of applied actions.
     **/
    invisibleEntries() {
        return this.#invisibleEntries;
    }
    #applyFilterAction(action) {
        // Identify in the UI that children of the entry are modified.
        this.#modifiedVisibleEntries.push(action.entry);
        // We apply new user action to the set of all entries, and mark
        // any that should be hidden by adding them to this set.
        // Another approach would be to use splice() to remove items from the
        // array, but doing this would be a mutation of the arry for every hidden
        // event. Instead, we add entries to this set and return it as an array at the end.
        const entriesToHide = new Set();
        switch (action.type) {
            case "MERGE_FUNCTION" /* FilterApplyAction.MERGE_FUNCTION */: {
                // The entry that was clicked on is merged into its parent. All its
                // children remain visible, so we just have to hide the entry that was
                // selected.
                entriesToHide.add(action.entry);
                break;
            }
            case "COLLAPSE_FUNCTION" /* FilterApplyAction.COLLAPSE_FUNCTION */: {
                // The entry itself remains visible, but all of its ancestors are hidden.
                const entryNode = this.#entryToNode.get(action.entry);
                if (!entryNode) {
                    // Invalid node was given, just ignore and move on.
                    break;
                }
                const allAncestors = this.#findAllAncestorsOfNode(entryNode);
                allAncestors.forEach(ancestor => entriesToHide.add(ancestor));
                break;
            }
            case "COLLAPSE_REPEATING_DESCENDANTS" /* FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS */: {
                const entryNode = this.#entryToNode.get(action.entry);
                if (!entryNode) {
                    // Invalid node was given, just ignore and move on.
                    break;
                }
                const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);
                allRepeatingDescendants.forEach(ancestor => entriesToHide.add(ancestor));
                break;
            }
            default:
                Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);
        }
        this.#invisibleEntries.push(...entriesToHide);
        return this.#invisibleEntries;
    }
    #findAllAncestorsOfNode(root) {
        const cachedAncestors = this.#entryToAncestorsMap.get(root);
        if (cachedAncestors) {
            return cachedAncestors;
        }
        const ancestors = [];
        // Walk through all the ancestors, starting at the root node.
        const children = [...root.children];
        while (children.length > 0) {
            const childNode = children.shift();
            if (childNode) {
                ancestors.push(childNode.entry);
                const childNodeCachedAncestors = this.#entryToAncestorsMap.get(childNode);
                // If the ancestors of a child are cached, get them from the cache instead of iterating through them again
                if (childNodeCachedAncestors) {
                    ancestors.push(...childNodeCachedAncestors);
                }
                else {
                    children.push(...childNode.children);
                }
            }
        }
        this.#entryToAncestorsMap.set(root, ancestors);
        return ancestors;
    }
    #findAllRepeatingDescendantsOfNext(root) {
        // Walk through all the ancestors, starting at the root node.
        const children = [...root.children];
        const repeatingNodes = [];
        const rootIsProfileCall = Types.TraceEvents.isProfileCall(root.entry);
        while (children.length > 0) {
            const childNode = children.shift();
            if (childNode) {
                const childIsProfileCall = Types.TraceEvents.isProfileCall(childNode.entry);
                if ( /* Handle TraceEventSyntheticProfileCalls */rootIsProfileCall && childIsProfileCall) {
                    const rootNodeEntry = root.entry;
                    const childNodeEntry = childNode.entry;
                    if (Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(rootNodeEntry.callFrame, childNodeEntry.callFrame)) {
                        repeatingNodes.push(childNode.entry);
                    }
                } /* Handle SyntheticRendererEvents */
                else if (!rootIsProfileCall && !childIsProfileCall) {
                    if (root.entry.name === childNode.entry.name) {
                        repeatingNodes.push(childNode.entry);
                    }
                }
                children.push(...childNode.children);
            }
        }
        return repeatingNodes;
    }
    /**
     * Removes all of the entry children from the
     * invisible entries array to make them visible.
     **/
    #makeEntryChildrenVisible(entry) {
        const entryNode = this.#entryToNode.get(entry);
        if (!entryNode) {
            // Invalid node was given, just ignore and move on.
            return;
        }
        const ancestors = this.#findAllAncestorsOfNode(entryNode);
        /**
         * Filter out all ancestors of the node
         * from the invisible entries list.
         **/
        this.#invisibleEntries = this.#invisibleEntries.filter(entry => {
            if (ancestors.includes(entry)) {
                return false;
            }
            return true;
        });
        /**
         * Filter out all ancestors and entry from modified entries
         * list to not show that some entries below those are hidden.
         **/
        this.#modifiedVisibleEntries = this.#modifiedVisibleEntries.filter(iterEntry => {
            if (ancestors.includes(iterEntry) || iterEntry === entry) {
                return false;
            }
            return true;
        });
    }
    isEntryModified(event) {
        return this.#modifiedVisibleEntries.includes(event);
    }
    #isUserApplyFilterAction(action) {
        return filterApplyActionSet.has(action.type);
    }
    #isFilterUndoAction(action) {
        return filterUndoActionSet.has(action);
    }
}
//# sourceMappingURL=EntriesFilter.js.map