{"version":3,"file":"EntityMapper.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/EntityMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport type {ParsedTrace} from './ModelImpl.js';\nimport type * as Types from './types/types.js';\n\nexport class EntityMapper {\n  #parsedTrace: ParsedTrace;\n  #entityMappings: Handlers.Helpers.EntityMappings;\n  #firstPartyEntity: Handlers.Helpers.Entity|null;\n  #thirdPartyEvents: Types.Events.Event[] = [];\n  /**\n   * When resolving urls and updating our entity mapping in the\n   * SourceMapsResolver, a single call frame can appear multiple times\n   * as different cpu profile nodes. To avoid duplicate work on the\n   * same CallFrame, we can keep track of them.\n   */\n  #resolvedCallFrames = new Set<Protocol.Runtime.CallFrame>();\n\n  constructor(parsedTrace: ParsedTrace) {\n    this.#parsedTrace = parsedTrace;\n    this.#entityMappings = this.#parsedTrace.data.Renderer.entityMappings;\n    this.#firstPartyEntity = this.#findFirstPartyEntity();\n    this.#thirdPartyEvents = this.#getThirdPartyEvents();\n  }\n\n  #findFirstPartyEntity(): Handlers.Helpers.Entity|null {\n    // As a starting point, we consider the first navigation as the 1P.\n    const nav =\n        Array.from(this.#parsedTrace.data.Meta.navigationsByNavigationId.values()).sort((a, b) => a.ts - b.ts)[0];\n    const firstPartyUrl = nav?.args.data?.documentLoaderURL ?? this.#parsedTrace.data.Meta.mainFrameURL;\n    if (!firstPartyUrl) {\n      return null;\n    }\n    return Handlers.Helpers.getEntityForUrl(firstPartyUrl, this.#entityMappings) ?? null;\n  }\n\n  #getThirdPartyEvents(): Types.Events.Event[] {\n    const entries = Array.from(this.#entityMappings.eventsByEntity.entries());\n    const thirdPartyEvents = entries.flatMap(([entity, events]) => {\n      return entity !== this.#firstPartyEntity ? events : [];\n    });\n    return thirdPartyEvents;\n  }\n\n  /**\n   * Returns an entity for a given event if any.\n   */\n  entityForEvent(event: Types.Events.Event): Handlers.Helpers.Entity|null {\n    return this.#entityMappings.entityByEvent.get(event) ?? null;\n  }\n\n  /**\n   * Returns trace events that correspond with a given entity if any.\n   */\n  eventsForEntity(entity: Handlers.Helpers.Entity): Types.Events.Event[] {\n    return this.#entityMappings.eventsByEntity.get(entity) ?? [];\n  }\n\n  firstPartyEntity(): Handlers.Helpers.Entity|null {\n    return this.#firstPartyEntity;\n  }\n\n  thirdPartyEvents(): Types.Events.Event[] {\n    return this.#thirdPartyEvents;\n  }\n\n  mappings(): Handlers.Helpers.EntityMappings {\n    return this.#entityMappings;\n  }\n\n  /**\n   * This updates entity mapping given a callFrame and sourceURL (newly resolved),\n   * updating both eventsByEntity and entityByEvent. The call frame provides us the\n   * URL and sourcemap source location that events map to. This describes the exact events we\n   * want to update. We then update the events with the new sourceURL.\n   *\n   * compiledURLs -> the actual file's url (e.g. my-big-bundle.min.js)\n   * sourceURLs -> the resolved urls (e.g. react.development.js, my-app.ts)\n   * @param callFrame\n   * @param sourceURL\n   */\n  updateSourceMapEntities(callFrame: Protocol.Runtime.CallFrame, sourceURL: string): void {\n    // Avoid the extra work, if we have already resolved this callFrame.\n    if (this.#resolvedCallFrames.has(callFrame)) {\n      return;\n    }\n\n    const compiledURL = callFrame.url;\n    const currentEntity = Handlers.Helpers.getEntityForUrl(compiledURL, this.#entityMappings);\n    const resolvedEntity = Handlers.Helpers.getEntityForUrl(sourceURL, this.#entityMappings);\n    // If the entity changed, then we should update our caches. If we don't have a currentEntity,\n    // we can't do much with that. Additionally without our current entity, we don't have a reference to the related\n    // events so there are no relationships to be made.\n    if ((resolvedEntity === currentEntity) || (!currentEntity || !resolvedEntity)) {\n      return;\n    }\n    const currentEntityEvents = (currentEntity && this.#entityMappings.eventsByEntity.get(currentEntity)) ?? [];\n    // The events of the entity that match said source location.\n    const sourceLocationEvents: Types.Events.Event[] = [];\n    // The events that don't match the source location, but that we should keep mapped to its current entity.\n    const unrelatedEvents: Types.Events.Event[] = [];\n    currentEntityEvents?.forEach(e => {\n      const cf = Helpers.Trace.getStackTraceTopCallFrameInEventPayload(e);\n\n      const matchesCallFrame = cf && Helpers.Trace.isMatchingCallFrame(cf, callFrame);\n      if (matchesCallFrame) {\n        sourceLocationEvents.push(e);\n      } else {\n        unrelatedEvents.push(e);\n      }\n    });\n    // Update current entity.\n    this.#entityMappings.eventsByEntity.set(currentEntity, unrelatedEvents);\n    // Map the source location events to the new entity.\n    this.#entityMappings.eventsByEntity.set(resolvedEntity, sourceLocationEvents);\n    sourceLocationEvents.forEach(e => {\n      this.#entityMappings.entityByEvent.set(e, resolvedEntity);\n    });\n    // Update our CallFrame cache when we've got a resolved entity.\n    this.#resolvedCallFrames.add(callFrame);\n  }\n\n  // Update entities with proper Chrome Extension names.\n  updateExtensionEntitiesWithName(executionContextNamesByOrigin: Map<Platform.DevToolsPath.UrlString, string>): void {\n    const entities = Array.from(this.#entityMappings.eventsByEntity.keys());\n    for (const [origin, name] of executionContextNamesByOrigin) {\n      // In makeUpChromeExtensionEntity, the extension origin is set as the only domain for the entity.\n      const entity = entities.find(e => e.domains[0] === origin);\n      if (entity) {\n        entity.name = entity.company = name;\n      }\n    }\n  }\n}\n"]}