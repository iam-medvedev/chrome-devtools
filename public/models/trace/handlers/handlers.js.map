{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/helpers.ts", "../../../../../../../front_end/models/trace/handlers/ModelHandlers.ts", "../../../../../../../front_end/models/trace/handlers/AnimationFramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/AnimationHandler.ts", "../../../../../../../front_end/models/trace/handlers/AsyncJSCallsHandler.ts", "../../../../../../../front_end/models/trace/handlers/FlowsHandler.ts", "../../../../../../../front_end/models/trace/handlers/RendererHandler.ts", "../../../../../../../front_end/models/trace/handlers/AuctionWorkletsHandler.ts", "../../../../../../../front_end/models/trace/handlers/MetaHandler.ts", "../../../../../../../front_end/models/trace/handlers/NetworkRequestsHandler.ts", "../../../../../../../front_end/models/trace/handlers/SamplesHandler.ts", "../../../../../../../front_end/models/trace/handlers/DOMStatsHandler.ts", "../../../../../../../front_end/models/trace/handlers/ExtensionTraceDataHandler.ts", "../../../../../../../front_end/models/trace/handlers/UserTimingsHandler.ts", "../../../../../../../front_end/models/trace/handlers/FramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/LayerTreeHandler.ts", "../../../../../../../front_end/models/trace/handlers/Threads.ts", "../../../../../../../front_end/models/trace/handlers/GPUHandler.ts", "../../../../../../../front_end/models/trace/handlers/ImagePaintingHandler.ts", "../../../../../../../front_end/models/trace/handlers/InitiatorsHandler.ts", "../../../../../../../front_end/models/trace/handlers/InvalidationsHandler.ts", "../../../../../../../front_end/models/trace/handlers/LargestImagePaintHandler.ts", "../../../../../../../front_end/models/trace/handlers/PageLoadMetricsHandler.ts", "../../../../../../../front_end/models/trace/handlers/LargestTextPaintHandler.ts", "../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.ts", "../../../../../../../front_end/models/trace/handlers/ScreenshotsHandler.ts", "../../../../../../../front_end/models/trace/handlers/MemoryHandler.ts", "../../../../../../../front_end/models/trace/handlers/PageFramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/ScriptsHandler.ts", "../../../../../../../front_end/models/trace/handlers/SelectorStatsHandler.ts", "../../../../../../../front_end/models/trace/handlers/UserInteractionsHandler.ts", "../../../../../../../front_end/models/trace/handlers/WarningsHandler.ts", "../../../../../../../front_end/models/trace/handlers/WorkersHandler.ts", "types.js"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport * as Types from '../types/types.js';\n\nimport type {TraceEventsForNetworkRequest} from './NetworkRequestsHandler.js';\nimport type {ParsedTrace} from './types.js';\n\nexport type Entity = typeof ThirdPartyWeb.ThirdPartyWeb.entities[number]&{\n  isUnrecognized?: boolean,\n};\n\nexport interface EntityMappings {\n  createdEntityCache: Map<string, Entity>;\n  entityByEvent: Map<Types.Events.Event, Entity>;\n  /**\n   * This holds the entities that had to be created, because they were not found using the\n   * ThirdPartyWeb database.\n   */\n  eventsByEntity: Map<Entity, Types.Events.Event[]>;\n}\n\nexport function getEntityForEvent(event: Types.Events.Event, entityCache: Map<string, Entity>): Entity|undefined {\n  const url = getNonResolvedURL(event);\n  if (!url) {\n    return;\n  }\n  return getEntityForUrl(url, entityCache);\n}\n\nexport function getEntityForUrl(url: string, entityCache: Map<string, Entity>): Entity|undefined {\n  return ThirdPartyWeb.ThirdPartyWeb.getEntity(url) ?? makeUpEntity(entityCache, url);\n}\n\nexport function getNonResolvedURL(\n    entry: Types.Events.Event, parsedTrace?: ParsedTrace): Platform.DevToolsPath.UrlString|null {\n  if (Types.Events.isProfileCall(entry)) {\n    return entry.callFrame.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (Types.Events.isSyntheticNetworkRequest(entry)) {\n    return entry.args.data.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (Types.Events.isParseAuthorStyleSheetEvent(entry) && entry.args) {\n    return entry.args.data.stylesheetUrl as Platform.DevToolsPath.UrlString;\n  }\n\n  if (entry.args?.data?.stackTrace && entry.args.data.stackTrace.length > 0) {\n    return entry.args.data.stackTrace[0].url as Platform.DevToolsPath.UrlString;\n  }\n\n  // ParseHTML events store the URL under beginData, not data.\n  if (Types.Events.isParseHTML(entry)) {\n    return entry.args.beginData.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (parsedTrace) {\n    // DecodeImage events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDecodeImage(entry)) {\n      const paintEvent = parsedTrace.ImagePainting.paintImageForEvent.get(entry);\n      return paintEvent ? getNonResolvedURL(paintEvent, parsedTrace) : null;\n    }\n\n    // DrawLazyPixelRef events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDrawLazyPixelRef(entry) && entry.args?.LazyPixelRef) {\n      const paintEvent = parsedTrace.ImagePainting.paintImageByDrawLazyPixelRef.get(entry.args.LazyPixelRef);\n      return paintEvent ? getNonResolvedURL(paintEvent, parsedTrace) : null;\n    }\n  }\n\n  // For all other events, try to see if the URL is provided, else return null.\n  if (entry.args?.data?.url) {\n    return entry.args.data.url as Platform.DevToolsPath.UrlString;\n  }\n\n  // Many events don't have a url, but are associated with a request. Use the\n  // request's url.\n  const requestId = (entry.args?.data as {requestId?: string})?.requestId;\n  if (parsedTrace && requestId) {\n    const url = parsedTrace.NetworkRequests.byId.get(requestId)?.args.data.url;\n    if (url) {\n      return url as Platform.DevToolsPath.UrlString;\n    }\n  }\n\n  return null;\n}\n\nexport function makeUpEntity(entityCache: Map<string, Entity>, url: string): Entity|undefined {\n  if (url.startsWith('chrome-extension:')) {\n    return makeUpChromeExtensionEntity(entityCache, url);\n  }\n\n  // Make up an entity only for valid http/https URLs.\n  if (!url.startsWith('http')) {\n    return;\n  }\n\n  // NOTE: Lighthouse uses a tld database to determine the root domain, but here\n  // we are using third party web's database. Doesn't really work for the case of classifying\n  // domains 3pweb doesn't know about, so it will just give us a guess.\n  const rootDomain = ThirdPartyWeb.ThirdPartyWeb.getRootDomain(url);\n  if (!rootDomain) {\n    return;\n  }\n\n  if (entityCache.has(rootDomain)) {\n    return entityCache.get(rootDomain);\n  }\n\n  const unrecognizedEntity = {\n    name: rootDomain,\n    company: rootDomain,\n    category: '',\n    categories: [],\n    domains: [rootDomain],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n    isUnrecognized: true,\n  };\n  entityCache.set(rootDomain, unrecognizedEntity);\n  return unrecognizedEntity;\n}\n\nfunction getChromeExtensionOrigin(url: URL): string {\n  return url.protocol + '//' + url.host;\n}\n\nfunction makeUpChromeExtensionEntity(entityCache: Map<string, Entity>, url: string, extensionName?: string): Entity {\n  const parsedUrl = new URL(url);\n  const origin = getChromeExtensionOrigin(parsedUrl);\n  const host = new URL(origin).host;\n  const name = extensionName || host;\n\n  const cachedEntity = entityCache.get(origin);\n  if (cachedEntity) {\n    return cachedEntity;\n  }\n\n  const chromeExtensionEntity = {\n    name,\n    company: name,\n    category: 'Chrome Extension',\n    homepage: 'https://chromewebstore.google.com/detail/' + host,\n    categories: [],\n    domains: [origin],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n  };\n\n  entityCache.set(origin, chromeExtensionEntity);\n  return chromeExtensionEntity;\n}\n\nexport function addEventToEntityMapping(event: Types.Events.Event, entityMappings: EntityMappings): void {\n  const entity = getEntityForEvent(event, entityMappings.createdEntityCache);\n  if (!entity) {\n    return;\n  }\n\n  // As we share the entityMappings between Network and Renderer... We can have ResourceSendRequest events passed in here\n  // that were already mapped in Network. So, to avoid mapping twice, we always check that we didn't yet.\n  if (entityMappings.entityByEvent.has(event)) {\n    return;\n  }\n\n  const mappedEvents = entityMappings.eventsByEntity.get(entity);\n  if (mappedEvents) {\n    mappedEvents.push(event);\n  } else {\n    entityMappings.eventsByEntity.set(entity, [event]);\n  }\n  entityMappings.entityByEvent.set(event, entity);\n}\n\n// A slight upgrade of addEventToEntityMapping to handle the sub-events of a network request.\nexport function addNetworkRequestToEntityMapping(\n    networkRequest: Types.Events.SyntheticNetworkRequest, entityMappings: EntityMappings,\n    requestTraceEvents: TraceEventsForNetworkRequest): void {\n  const entity = getEntityForEvent(networkRequest, entityMappings.createdEntityCache);\n  if (!entity) {\n    return;\n  }\n  // In addition to mapping the network request, we'll also assign this entity to its \"child\" instant events like receiveData, willSendRequest, finishLoading, etc,\n  const eventsToMap = [networkRequest, ...Object.values(requestTraceEvents).flat()];\n  const mappedEvents = entityMappings.eventsByEntity.get(entity);\n  if (mappedEvents) {\n    mappedEvents.push(...eventsToMap);\n  } else {\n    entityMappings.eventsByEntity.set(entity, eventsToMap);\n  }\n  for (const evt of eventsToMap) {\n    entityMappings.entityByEvent.set(evt, entity);\n  }\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport * as AnimationFrames from './AnimationFramesHandler.js';\nexport * as Animations from './AnimationHandler.js';\nexport * as AsyncJSCalls from './AsyncJSCallsHandler.js';\nexport * as AuctionWorklets from './AuctionWorkletsHandler.js';\nexport * as DOMStats from './DOMStatsHandler.js';\nexport * as ExtensionTraceData from './ExtensionTraceDataHandler.js';\nexport * as Flows from './FlowsHandler.js';\nexport * as Frames from './FramesHandler.js';\nexport * as GPU from './GPUHandler.js';\nexport * as ImagePainting from './ImagePaintingHandler.js';\nexport * as Initiators from './InitiatorsHandler.js';\nexport * as Invalidations from './InvalidationsHandler.js';\nexport * as LargestImagePaint from './LargestImagePaintHandler.js';\nexport * as LargestTextPaint from './LargestTextPaintHandler.js';\nexport * as LayerTree from './LayerTreeHandler.js';\nexport * as LayoutShifts from './LayoutShiftsHandler.js';\nexport * as Memory from './MemoryHandler.js';\nexport * as Meta from './MetaHandler.js';\nexport * as NetworkRequests from './NetworkRequestsHandler.js';\nexport * as PageFrames from './PageFramesHandler.js';\nexport * as PageLoadMetrics from './PageLoadMetricsHandler.js';\nexport * as Renderer from './RendererHandler.js';\nexport * as Samples from './SamplesHandler.js';\nexport * as Screenshots from './ScreenshotsHandler.js';\nexport * as Scripts from './ScriptsHandler.js';\nexport * as SelectorStats from './SelectorStatsHandler.js';\nexport * as UserInteractions from './UserInteractionsHandler.js';\nexport * as UserTimings from './UserTimingsHandler.js';\nexport * as Warnings from './WarningsHandler.js';\nexport * as Workers from './WorkersHandler.js';\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\nexport interface Data {\n  animationFrames: Types.Events.SyntheticAnimationFramePair[];\n  presentationForFrame: Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation>;\n}\n\nfunction threadKey(data: Types.Events.Event): string {\n  return `${data.pid}-${data.tid}`;\n}\n// Track all the start + end events. We key them by the PID+TID so we don't\n// accidentally pair across different threads.\nconst animationFrameStarts = new Map<string, Types.Events.AnimationFrameAsyncStart[]>();\nconst animationFrameEnds = new Map<string, Types.Events.AnimationFrameAsyncEnd[]>();\n// Store all the AnimationFrame::Presentation events. Key them by their ID for\n// easy look-up later on when we associate one to the AnimationFrame event.\nconst animationFramePresentations = new Map<string, Types.Events.AnimationFramePresentation>();\n\n// The final list of animation frames that we return.\nconst animationFrames: Types.Events.SyntheticAnimationFramePair[] = [];\n\nconst presentationForFrame =\n    new Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation>();\n\nexport function reset(): void {\n  animationFrameStarts.clear();\n  animationFrameEnds.clear();\n  animationFrames.length = 0;\n  presentationForFrame.clear();\n  animationFramePresentations.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAnimationFrameAsyncStart(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameStarts.get(key) ?? [];\n    existing.push(event);\n    animationFrameStarts.set(key, existing);\n  } else if (Types.Events.isAnimationFrameAsyncEnd(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameEnds.get(key) ?? [];\n    existing.push(event);\n    animationFrameEnds.set(key, existing);\n  } else if (Types.Events.isAnimationFramePresentation(event) && event.args?.id) {\n    animationFramePresentations.set(event.args.id, event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // AnimationFrames are represented with begin & end events on a stack; so we\n  // can pair them by walking through the list of start events and pairing with\n  // the same index in the list of end events, once both lists are sorted by\n  // timestamp.\n  // We walk through the set of begin/end events we gathered per pid+tid and\n  // pair those up.\n  // Unfortunately we cannot use the pairing helpers in Helpers.Trace because\n  // only the begin event has an ID; the end event does not. But because we\n  // know that AnimationFrames are sequential and do not overlap, we can pair\n  // up events easily.\n  for (const [key, startEvents] of animationFrameStarts.entries()) {\n    const endEvents = animationFrameEnds.get(key);\n    if (!endEvents) {\n      continue;\n    }\n\n    Helpers.Trace.sortTraceEventsInPlace(startEvents);\n    Helpers.Trace.sortTraceEventsInPlace(endEvents);\n\n    for (let i = 0; i < startEvents.length; i++) {\n      const endEvent = endEvents.at(i);\n      if (!endEvent) {\n        // Invalid data: break. We can't pair any other events up.\n        break;\n      }\n      const startEvent = startEvents[i];\n\n      const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager\n                                 .registerSyntheticEvent<Types.Events.SyntheticAnimationFramePair>({\n                                   rawSourceEvent: startEvent,\n                                   ...startEvent,\n                                   dur: Types.Timing.Micro(endEvent.ts - startEvent.ts),\n                                   args: {\n                                     data: {\n                                       beginEvent: startEvent,\n                                       endEvent,\n                                     },\n                                   },\n                                 });\n      animationFrames.push(syntheticEvent);\n\n      // AnimationFrame begin events + AnimationFrame::Presentation events share\n      // an args.id, so we can pair them up based on that.\n      const id = startEvent.args?.id;\n      if (id) {\n        const presentationEvent = animationFramePresentations.get(id);\n        if (presentationEvent) {\n          presentationForFrame.set(syntheticEvent, presentationEvent);\n        }\n      }\n    }\n  }\n}\n\nexport function data(): Data {\n  return {\n    animationFrames,\n    presentationForFrame,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nconst animations: Types.Events.Animation[] = [];\nconst animationsSyntheticEvents: Types.Events.SyntheticAnimationPair[] = [];\n\nexport interface AnimationData {\n  animations: readonly Types.Events.SyntheticAnimationPair[];\n}\n\nexport function reset(): void {\n  animations.length = 0;\n  animationsSyntheticEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAnimation(event)) {\n    animations.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(animations);\n  animationsSyntheticEvents.push(...syntheticEvents);\n}\n\nexport function data(): AnimationData {\n  return {\n    animations: animationsSyntheticEvents,\n  };\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as flowsHandlerData} from './FlowsHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\nconst schedulerToRunEntryPoints = new Map<Types.Events.Event, Types.Events.Event[]>();\n\nconst taskScheduleForTaskRunEvent =\n    new Map<Types.Events.DebuggerAsyncTaskRun, Types.Events.DebuggerAsyncTaskScheduled>();\nconst asyncCallToScheduler =\n    new Map<Types.Events.SyntheticProfileCall, {taskName: string, scheduler: Types.Events.Event}>();\n\nconst runEntryPointToScheduler = new Map<Types.Events.Event, {taskName: string, scheduler: Types.Events.Event}>();\n\nexport function reset(): void {\n  schedulerToRunEntryPoints.clear();\n  asyncCallToScheduler.clear();\n  taskScheduleForTaskRunEvent.clear();\n  runEntryPointToScheduler.clear();\n}\n\nexport function handleEvent(_: Types.Events.Event): void {\n}\n\nexport async function finalize(): Promise<void> {\n  const {flows} = flowsHandlerData();\n  const {entryToNode} = rendererHandlerData();\n  // Process async task flows\n  for (const flow of flows) {\n    let maybeAsyncTaskScheduled = flow.at(0);\n    if (!maybeAsyncTaskScheduled) {\n      continue;\n    }\n    if (Types.Events.isDebuggerAsyncTaskRun(maybeAsyncTaskScheduled)) {\n      // Sometimes a AsyncTaskRun event run can incorrectly appear as\n      // initiated by another AsyncTaskRun from Perfetto's flows\n      // perspective.\n      // For example, in this snippet:\n      //\n      // const myTask = console.createTask('hola'); // creates an AsyncTaskSchedule\n      // myTask.run(something); // creates an AsyncTaskRun\n      // myTask.run(somethingElse); // creates an AsyncTaskRun\n      //\n      // or also in this one\n      //\n      // setInterval(something); // creates multiple connected AsyncTaskRun.\n      //\n      // Because the flow id is created based on the task's memory address,\n      // the three events will end up belonging to the same flow (even if\n      // in the frontend we receive it as pairs), and elements in a flow\n      // are connected to their immediately consecutive neighbor.\n      //\n      // To ensure we use the right Schedule event, if the \"initiating\"\n      // portion of the flow is a Run event, we look for any corresponding\n      // Schedule event that we might have found before.\n      maybeAsyncTaskScheduled = taskScheduleForTaskRunEvent.get(maybeAsyncTaskScheduled);\n    }\n    if (!maybeAsyncTaskScheduled || !Types.Events.isDebuggerAsyncTaskScheduled(maybeAsyncTaskScheduled)) {\n      continue;\n    }\n    const taskName = maybeAsyncTaskScheduled.args.taskName;\n    const asyncTaskRun = flow.at(1);\n    if (!asyncTaskRun || !Types.Events.isDebuggerAsyncTaskRun(asyncTaskRun)) {\n      // Unexpected flow shape, ignore.\n      continue;\n    }\n    // Cache the Schedule event for this Run for future reference.\n    taskScheduleForTaskRunEvent.set(asyncTaskRun, maybeAsyncTaskScheduled);\n\n    // Get the JS call scheduled the task.\n    const asyncCaller = findNearestJSAncestor(maybeAsyncTaskScheduled, entryToNode);\n\n    // Get the trace entrypoint for the scheduled task (e.g. FunctionCall, etc.).\n    const asyncEntryPoint = findFirstJsInvocationForAsyncTaskRun(asyncTaskRun, entryToNode);\n\n    // Store the async relationship between traces to be shown with initiator arrows.\n    // Default to the AsyncTask events in case the JS entrypoints aren't found.\n    runEntryPointToScheduler.set(\n        asyncEntryPoint || asyncTaskRun, {taskName, scheduler: asyncCaller || maybeAsyncTaskScheduled});\n    if (!asyncCaller || !asyncEntryPoint) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    // Set scheduler -> scheduled mapping.\n    // The scheduled being the JS entrypoint\n    const entryPoints = Platform.MapUtilities.getWithDefault(schedulerToRunEntryPoints, asyncCaller, () => []);\n    entryPoints.push(asyncEntryPoint);\n\n    // Set scheduled -> scheduler mapping.\n    // The scheduled being the JS calls (instead of the entrypoints as\n    // above, for usage ergonomics).\n    const scheduledProfileCalls = findFirstJSCallsForAsyncTaskRun(asyncTaskRun, entryToNode);\n    for (const call of scheduledProfileCalls) {\n      asyncCallToScheduler.set(call, {taskName, scheduler: asyncCaller});\n    }\n  }\n}\n/**\n * Given a DebuggerAsyncTaskScheduled event, returns its closest\n * ProfileCall or JS invocation ancestor, which represents the JS call\n * that scheduled the async task.\n */\nfunction findNearestJSAncestor(\n    asyncTaskScheduled: Types.Events.DebuggerAsyncTaskScheduled,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|null {\n  let node = entryToNode.get(asyncTaskScheduled)?.parent;\n  while (node) {\n    if (Types.Events.isProfileCall(node.entry) || acceptJSInvocationsPredicate(node.entry)) {\n      return node.entry;\n    }\n    node = node.parent;\n  }\n  return null;\n}\n/**\n * Entrypoints to JS execution in the timeline. We ignore those starting\n * with 'v8' because they aren't shown in the timeline, and ultimately\n * this function's output results in \"initiated\" events, so ideally this\n * returns events that end up in the flame chart.\n */\nfunction acceptJSInvocationsPredicate(event: Types.Events.Event): event is Types.Events.Event {\n  const eventIsConsoleRunTask = Types.Events.isConsoleRunTask(event);\n  const eventIsV8EntryPoint = event.name.startsWith('v8') || event.name.startsWith('V8');\n  return Types.Events.isJSInvocationEvent(event) && (eventIsConsoleRunTask || !eventIsV8EntryPoint);\n}\n\n/**\n * Given a DebuggerAsyncTaskRun event, returns its closest JS entry\n * point descendant, which contains the task being scheduled.\n */\nfunction findFirstJsInvocationForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|undefined {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n             asyncTaskRun, entryToNode, acceptJSInvocationsPredicate, Types.Events.isDebuggerAsyncTaskRun)\n      .at(0);\n}\n\n/**\n * Given an async task run event, returns the top level call frames\n * (profile calls) directly called by the async task. This implies that\n * any profile calls under another async task run event are ignored.\n * These profile calls represent the JS task being scheduled, AKA\n * the other part of the async stack.\n *\n * For example, here the profile calls \"js 1\", \"js 2\" and \"js 4\" would\n * be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |--FunctionCall--|\n * |-js 1-||-js 2-|        |-js 4-|\n * |-js 3-|\n *\n * But here, only \"js 1\" and \"js 2\" would be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |------------------------|\n * |-js 1-||-js 2-|       |---Async Task Run--|\n * |-js 3-|                |--FunctionCall--|\n *                          |-js 4-|\n */\nfunction findFirstJSCallsForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.SyntheticProfileCall[] {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n      asyncTaskRun, entryToNode, Types.Events.isProfileCall, Types.Events.isDebuggerAsyncTaskRun);\n}\n\n/**\n * Given a root event returns all the first descendants that meet a\n * predicate condition (predicateAccept) while ignoring subtrees whose\n * top event meets an ignore condition (predicateIgnore).\n */\nfunction findFirstDescendantsOfType<T extends Types.Events.Event>(\n    root: Types.Events.Event, entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>,\n    predicateAccept: (event: Types.Events.Event) => event is T,\n    predicateIgnore: (event: Types.Events.Event) => boolean): T[] {\n  const node = entryToNode.get(root);\n  if (!node) {\n    return [];\n  }\n  const childrenGroups = [[...node.children]];\n  const firstDescendants = [];\n  for (let i = 0; i < childrenGroups.length; i++) {\n    const siblings = childrenGroups[i];\n    for (let j = 0; j < siblings.length; j++) {\n      const node = siblings[j];\n      if (predicateAccept(node.entry)) {\n        firstDescendants.push(node.entry);\n      } else if (!predicateIgnore(node.entry)) {\n        childrenGroups.push([...node.children]);\n      }\n    }\n  }\n  return firstDescendants;\n}\n\nexport function data(): {\n  // Given a profile call, returns the JS entrypoint it scheduled (if any).\n  // For example, given a setTimeout call, returns the JS entry point\n  // trace event for the timeout callback run event (usually a\n  // FunctionCall event).\n  schedulerToRunEntryPoints: typeof schedulerToRunEntryPoints,\n  // Given a profile call, returns the profile call that scheduled it.\n  // For example given a timeout callback run event, returns its\n  // setTimeout call event.\n  asyncCallToScheduler: typeof asyncCallToScheduler,\n  // Given a trace event, returns its corresponding async parent trace\n  // event caused by an async js call. This can be used as a fallback\n  // for cases where a corresponding JS call is not found at either\n  // end of the async task scheduling pair (e.g. due to sampling data\n  // incompleteness).\n  // In the StackTraceForEvent helper, as we move up the call tree,\n  // this is used to jump to an async parent stack from a\n  // non-profile call trace event in cases where a profile call wasn't\n  // found before. In theory we should make the jump from the scheduled\n  // profile  call using `asyncCallToScheduler`, but its possible that\n  // the the call information isn't available to us as a consequence of\n  // missing samples.\n  runEntryPointToScheduler: typeof runEntryPointToScheduler,\n} {\n  return {\n    schedulerToRunEntryPoints,\n    asyncCallToScheduler,\n    runEntryPointToScheduler,\n  };\n}\n\nexport function deps(): ['Renderer', 'Flows'] {\n  return ['Renderer', 'Flows'];\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\n// A flow is a logic connection between trace events. We display this\n// connection as arrows between trace events belonging to the same flow.\n\n// In the trace event format, flows are represented with pairing \"flow\n// phase\" events. Each flow phase event corresponds to one trace event\n// and indicates the role a trace event plays in a flow (start, step or\n// end). For each flow, one `start` and one `end` phase events are\n// included, while the amount of `step` phase events can be >= 0.\n\n// A flow phase event is assigned to a trace event when their cat, tid,\n// pid and ts are equal (see @flowPhaseBindingTokenForEvent ).\n\n// It's possible for a single event to belong to multiple flows. In that\n// case, it will have multiple corresponding flow phase events (one\n// per flow).\n\n// To parse flows, we first handle flow phase events, by creating unique\n// flows with the timestamps of each phase. Then, we place trace events\n// in the flows where their corresponding phase events were placed (if\n// there are any corresponding flow phase events at all).\nconst flowDataByGroupToken = new Map<string, number>();\n\ninterface EventFlowData {\n  flows: Set<number>;\n  bindingParsed: boolean;\n}\ntype FlowBindingTuple =\n    Map<Types.Timing.Micro, Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Map<string, EventFlowData>>>>;\n\n// Given a trace event's flow binding tuple (timestamp, process id,\n// thread id and category) we determine if there is any flow data bound\n// to it by using this map's content. It's built when processing flow\n// events in a trace.\n// An alternative to having a map of four levels is having single map\n// from a string token built from concatenating the binding data to the\n// corresponding flow data. However, this token would be calculated for\n// every event in a trace, resulting in a lot of memory overhead and\n// major GC triggering. So we are trading off readability for\n// performance.\nconst boundFlowData: FlowBindingTuple = new Map();\n\nconst flowsById = new Map<number, Map<Types.Timing.Micro, Types.Events.Event>>();\nconst flowEvents: Types.Events.FlowEvent[] = [];\nconst nonFlowEvents: Types.Events.Event[] = [];\nlet flows: Types.Events.Event[][] = [];\nconst ID_COMPONENT_SEPARATOR = '-$-';\nexport function reset(): void {\n  flows = [];\n  flowEvents.length = 0;\n  nonFlowEvents.length = 0;\n  flowDataByGroupToken.clear();\n  boundFlowData.clear();\n  flowsById.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isFlowPhaseEvent(event)) {\n    flowEvents.push(event);\n    return;\n  }\n  nonFlowEvents.push(event);\n}\n\nfunction processNonFlowEvent(event: Types.Events.Event): void {\n  const flowDataForEvent = boundFlowData.get(event.ts)?.get(event.pid)?.get(event.tid)?.get(event.cat);\n  if (!flowDataForEvent) {\n    return;\n  }\n  const {flows, bindingParsed} = flowDataForEvent;\n  if (bindingParsed) {\n    // We only consider the first event for a given flow binding tuple.\n    return;\n  }\n  for (const flowId of flows) {\n    const flow = Platform.MapUtilities.getWithDefault(\n        flowsById, flowId, () => new Map<Types.Timing.Micro, Types.Events.Event>());\n    flow.set(event.ts, event);\n  }\n  flowDataForEvent.bindingParsed = true;\n}\n\n/**\n * Creates unique flows by tracking flow phase events. A new created\n * flow whenever a flow start phase event is detected.\n * Subsequent flow phase events with the same group token are added to\n * this flow until a flow end phase is detected.\n */\nfunction processFlowEvent(flowPhaseEvent: Types.Events.FlowEvent): void {\n  const flowGroup = flowGroupTokenForFlowPhaseEvent(flowPhaseEvent);\n  switch (flowPhaseEvent.ph) {\n    case (Types.Events.Phase.FLOW_START): {\n      const flowMetadata = {flowId: flowPhaseEvent.id, times: new Map([[flowPhaseEvent.ts, undefined]])};\n      flowDataByGroupToken.set(flowGroup, flowPhaseEvent.id);\n      addFlowIdToEventBinding(flowPhaseEvent, flowMetadata.flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_STEP): {\n      const flowId = flowDataByGroupToken.get(flowGroup);\n      if (flowId === undefined) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore the problematic event.\n        return;\n      }\n      addFlowIdToEventBinding(flowPhaseEvent, flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_END): {\n      const flowId = flowDataByGroupToken.get(flowGroup);\n      if (flowId === undefined) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore the problematic event.\n        return;\n      }\n      addFlowIdToEventBinding(flowPhaseEvent, flowId);\n      // We don't need this data anymore as the flow has been finished,\n      // so we can drop it.\n      flowDataByGroupToken.delete(flowGroup);\n    }\n  }\n}\n\ntype MapValueType<T extends Map<unknown, unknown>> = NonNullable<ReturnType<T['get']>>;\n/**\n * A single trace event can belong to multiple flows. This method\n * tracks which flows (flowId) an event belongs to given its flow\n * binding tuple (made of its ts, pid, tid and cat).\n */\nfunction addFlowIdToEventBinding(event: Types.Events.Event, flowId: number): void {\n  const flowsByPid = Platform.MapUtilities.getWithDefault<Types.Timing.Micro, MapValueType<typeof boundFlowData>>(\n      boundFlowData, event.ts, () => new Map());\n  const flowsByTid = Platform.MapUtilities.getWithDefault<Types.Events.ProcessID, MapValueType<typeof flowsByPid>>(\n      flowsByPid, event.pid, () => new Map());\n  const flowsByCat = Platform.MapUtilities.getWithDefault<Types.Events.ThreadID, MapValueType<typeof flowsByTid>>(\n      flowsByTid, event.tid, () => new Map());\n  const flowData =\n      Platform.MapUtilities.getWithDefault(flowsByCat, event.cat, () => ({flows: new Set(), bindingParsed: false}));\n  flowData.flows.add(flowId);\n}\n\n/**\n * Returns a token to group flow phase events (start, step and end)\n * belonging to the same flow. Flow phase events belonging to the same\n * flow share category, thread id, process id and name.\n *\n * Note that other phase events of other flows can share these\n * attributes too. For this reason, we group flow phase events in\n * cycles. A cycle starts on a flow start phase event and finishes on a\n * flow end phase event. For this reason, flow phase events need to be\n * handled in timestamp order.\n */\nfunction flowGroupTokenForFlowPhaseEvent(event: Types.Events.FlowEvent): string {\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.name}${ID_COMPONENT_SEPARATOR}${event.id}`;\n}\n\nexport async function finalize(): Promise<void> {\n  // Order is important: flow events need to be handled first.\n  flowEvents.forEach(processFlowEvent);\n  nonFlowEvents.forEach(processNonFlowEvent);\n  flows = [...flowsById.values()]\n              .map(flowMapping => [...flowMapping.values()])\n              .map(flow => flow.filter(event => event !== undefined))\n              .filter(flow => flow.length > 1);\n}\n\nexport function data(): {flows: Types.Events.Event[][]} {\n  return {\n    flows,\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData, type FrameProcessData} from './MetaHandler.js';\nimport {data as networkRequestHandlerData} from './NetworkRequestsHandler.js';\nimport {data as samplesHandlerData} from './SamplesHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * This handler builds the hierarchy of trace events and profile calls\n * on each thread on each process.\n *\n * Throughout the code, trace events and profile calls are referred to\n * as \"entries\", but note they are different types of data. Trace events\n * come directly from the backend and it's the type the engine commonly\n * refers to. Profile calls on the other hand are built in the frontend,\n * and, for compatibility purposes, typed as an extension to the trace\n * event type.\n */\n\nconst processes = new Map<Types.Events.ProcessID, RendererProcess>();\n\nlet entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\n// We track the compositor tile worker thread name events so that at the end we\n// can return these keyed by the process ID. These are used in the frontend to\n// show the user the rasterization thread(s) on the main frame as tracks.\nconst compositorTileWorkers = Array<{\n  pid: Types.Events.ProcessID,\n  tid: Types.Events.ThreadID,\n}>();\nconst entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\nlet allTraceEntries: Types.Events.Event[] = [];\n\nconst completeEventStack: (Types.Events.SyntheticComplete)[] = [];\n\nlet config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  entries: [],\n  profileCalls: [],\n  layoutEvents: [],\n  updateLayoutTreeEvents: [],\n});\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.Events.ProcessID, RendererProcess>, pid: Types.Events.ProcessID): RendererProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n    };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.Events.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  config = userConfig;\n}\n\nexport function reset(): void {\n  processes.clear();\n  entryToNode.clear();\n  entityMappings.eventsByEntity.clear();\n  entityMappings.entityByEvent.clear();\n  entityMappings.createdEntityCache.clear();\n  allTraceEntries.length = 0;\n  completeEventStack.length = 0;\n  compositorTileWorkers.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isThreadName(event) && event.args.name?.startsWith('CompositorTileWorker')) {\n    compositorTileWorkers.push({\n      pid: event.pid,\n      tid: event.tid,\n    });\n  }\n\n  if (Types.Events.isBegin(event) || Types.Events.isEnd(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    const completeEvent = makeCompleteEvent(event);\n    if (!completeEvent) {\n      return;\n    }\n    thread.entries.push(completeEvent);\n    allTraceEntries.push(completeEvent);\n    return;\n  }\n\n  if (Types.Events.isInstant(event) || Types.Events.isComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.entries.push(event);\n    allTraceEntries.push(event);\n  }\n\n  if (Types.Events.isLayout(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.layoutEvents.push(event);\n  }\n\n  if (Types.Events.isUpdateLayoutTree(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.updateLayoutTreeEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  entityMappings = networkRequestHandlerData().entityMappings;\n\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes);\n  sanitizeThreads(processes);\n  Helpers.Trace.sortTraceEventsInPlace(allTraceEntries);\n}\n\nexport function data(): RendererHandlerData {\n  return {\n    processes: new Map(processes),\n    compositorTileWorkers: new Map(gatherCompositorThreads()),\n    entryToNode: new Map(entryToNode),\n    allTraceEntries: [...allTraceEntries],\n    entityMappings: {\n      entityByEvent: new Map(entityMappings.entityByEvent),\n      eventsByEntity: new Map(entityMappings.eventsByEntity),\n      createdEntityCache: new Map(entityMappings.createdEntityCache),\n    },\n  };\n}\n\nfunction gatherCompositorThreads(): Map<Types.Events.ProcessID, Types.Events.ThreadID[]> {\n  const threadsByProcess = new Map<Types.Events.ProcessID, Types.Events.ThreadID[]>();\n  for (const worker of compositorTileWorkers) {\n    const byProcess = threadsByProcess.get(worker.pid) || [];\n    byProcess.push(worker.tid);\n    threadsByProcess.set(worker.pid, byProcess);\n  }\n  return threadsByProcess;\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  assignOrigin(processes, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData): void {\n  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {\n    for (const [pid, processWindows] of renderProcessesByPid) {\n      for (const processInfo of processWindows.flat()) {\n        const process = getOrCreateRendererProcess(processes, pid);\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if the last url is \"about:blank\", use the next frame's url,\n        // data from about:blank is irrelevant.\n        if (process.url === null || process.url === 'about:blank') {\n          // If we are here, it's because we care about this process and the URL. But before we store\n          // it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't\n          // set it, and this process will be filtered out later.\n          try {\n            new URL(processInfo.frame.url);\n            process.url = processInfo.frame.url;\n          } catch {\n            process.url = null;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData): void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  for (const [pid, process] of processes) {\n    for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n      const thread = getOrCreateRendererThread(process, tid);\n      thread.name = threadInfo?.args.name ?? `${tid}`;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unknown origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  const auctionWorklets = auctionWorkletsData().worklets;\n  const metaData = metaHandlerData();\n  if (metaData.traceIsGeneric) {\n    return;\n  }\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    //\n    // There is one exception; AuctionWorklet processes get parsed in a\n    // separate handler, so at this point we check to see if the process has\n    // been found by the AuctionWorkletsHandler, and if so we update the URL.\n    // This ensures that we keep this process around and do not drop it due to\n    // the lack of a URL.\n    if (process.url === null) {\n      const maybeWorklet = auctionWorklets.get(pid);\n      if (maybeWorklet) {\n        process.url = maybeWorklet.host;\n      } else {\n        processes.delete(pid);\n      }\n      continue;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    options?: {filter: {has: (name: Types.Events.Name) => boolean}}): void {\n  const samplesData = samplesHandlerData();\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      if (!thread.entries.length) {\n        thread.tree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n        continue;\n      }\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.entries);\n      // Step 2. Inject profile calls from samples\n      const samplesDataForThread = samplesData.profilesInProcess.get(pid)?.get(tid);\n      if (samplesDataForThread) {\n        const cpuProfile = samplesDataForThread.parsedProfile;\n        const samplesIntegrator = cpuProfile &&\n            new Helpers.SamplesIntegrator.SamplesIntegrator(\n                cpuProfile, samplesDataForThread.profileId, pid, tid, config);\n        const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);\n        if (samplesIntegrator && profileCalls) {\n          allTraceEntries = [...allTraceEntries, ...profileCalls];\n          thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, profileCalls);\n          thread.profileCalls = profileCalls;\n          // We'll also inject the instant JSSample events (in debug mode only)\n          const jsSamples = samplesIntegrator.jsSampleEvents;\n          if (jsSamples) {\n            allTraceEntries = [...allTraceEntries, ...jsSamples];\n            thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, jsSamples);\n          }\n        }\n      }\n      // Step 3. Build the tree.\n      const treeData = Helpers.TreeHelpers.treify(thread.entries, options);\n      thread.tree = treeData.tree;\n      // Update the entryToNode map with the entries from this thread\n      for (const [entry, node] of treeData.entryToNode) {\n        entryToNode.set(entry, node);\n        // Entity mapping is unrelated to the tree, but calling here as we need to call on every node anyway.\n        HandlerHelpers.addEventToEntityMapping(entry, entityMappings);\n      }\n    }\n  }\n}\n\nexport function makeCompleteEvent(event: Types.Events.Begin|Types.Events.End): Types.Events.SyntheticComplete|null {\n  if (Types.Events.isEnd(event)) {\n    // Quietly ignore unbalanced close events, they're legit (we could\n    // have missed start one).\n    const beginEvent = completeEventStack.pop();\n    if (!beginEvent) {\n      return null;\n    }\n    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {\n      console.error(\n          'Begin/End events mismatch at ' + beginEvent.ts + ' (' + beginEvent.name + ') vs. ' + event.ts + ' (' +\n          event.name + ')');\n      return null;\n    }\n    // Update the begin event's duration using the timestamp of the end\n    // event.\n    beginEvent.dur = Types.Timing.Micro(event.ts - beginEvent.ts);\n    return null;\n  }\n\n  // Create a synthetic event using the begin event, when we find the\n  // matching end event later we will update its duration.\n  const syntheticComplete: Types.Events.SyntheticComplete = {\n    ...event,\n    ph: Types.Events.Phase.COMPLETE,\n    dur: Types.Timing.Micro(0),\n  };\n\n  completeEventStack.push(syntheticComplete);\n  return syntheticComplete;\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Samples', 'AuctionWorklets', 'NetworkRequests'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.Events.ProcessID, RendererProcess>;\n  /**\n   * A map of all compositor workers (which we show in the UI as Rasterizers)\n   * by the process ID.\n   */\n  compositorTileWorkers: Map<Types.Events.ProcessID, Types.Events.ThreadID[]>;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  /**\n   * All trace events and synthetic profile calls made from\n   * samples.\n   */\n  allTraceEntries: Types.Events.Event[];\n  entityMappings: HandlerHelpers.EntityMappings;\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.Events.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  /**\n   * Contains trace events and synthetic profile calls made from\n   * samples.\n   */\n  entries: Types.Events.Event[];\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  layoutEvents: Types.Events.Layout[];\n  updateLayoutTreeEvents: Types.Events.UpdateLayoutTree[];\n  tree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * There are two metadata events that we care about.\n * => AuctionWorkletRunningInProcess tells us which process the Auction Worklet\n *    has taken to run in.\n * => AuctionWorkletDoneWithProcess tells us when the worklet is done with that\n *    process. This is less useful - but in the future we might want to surface\n *    this information so we still parse and return the event.\n *\n * It is important to note that the top level PID on these events is NOT the\n * PID that the worklet is running on; instead we have to look at its\n * args.data.pid property, which is the PID of the process that it is running\n * on.\n *\n * For any given RunningInProcess event, we would typically expect to see a\n * DoneWithProcess event, however this is not guaranteed, especially as users\n * can record any chunk of time in DevTools.\n *\n * Similarly, it is also possible to see a DoneWithProcess event without a\n * RunningInProcess event, if the user started recording after the auction\n * worklets started. Therefore we are happy to create\n * SyntheticAuctionWorklets as long as we see just one of these events.\n *\n * If we do get two events and need to pair them, we can use the\n * args.data.target property, which is a string ID shared by both\n * events.\n */\nconst runningInProcessEvents = new Map<Types.Events.ProcessID, Types.Events.AuctionWorkletRunningInProcess>();\nconst doneWithProcessEvents = new Map<Types.Events.ProcessID, Types.Events.AuctionWorkletDoneWithProcess>();\n\n// Keyed by the PID defined in  `args.data.pid` on AuctionWorklet trace events..\nconst createdSyntheticEvents = new Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet>();\n\n// Each AuctonWorklet takes over a process and has 2 threads (that we care\n// about and want to show as tracks):\n// 1. A CrUtilityMain thread which is known as the \"control process\".\n// 2. A AuctionV8HelperThread which is the actual auction worklet and will be\n//    either a \"Seller\" or a \"Bidder\"\n// To detect these we look for the metadata thread_name events. We key these by\n// PID so that we can easily look them up later without having to loop through.\nconst utilityThreads = new Map<Types.Events.ProcessID, Types.Events.ThreadName>();\nconst v8HelperThreads = new Map<Types.Events.ProcessID, Types.Events.ThreadName>();\n\nexport function reset(): void {\n  runningInProcessEvents.clear();\n  doneWithProcessEvents.clear();\n  createdSyntheticEvents.clear();\n  utilityThreads.clear();\n  v8HelperThreads.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAuctionWorkletRunningInProcess(event)) {\n    runningInProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isAuctionWorkletDoneWithProcess(event)) {\n    doneWithProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isThreadName(event)) {\n    if (event.args.name === 'auction_worklet.CrUtilityMain') {\n      utilityThreads.set(event.pid, event);\n      return;\n    }\n    if (event.args.name === 'AuctionV8HelperThread') {\n      v8HelperThreads.set(event.pid, event);\n    }\n  }\n}\n\nfunction workletType(input: string): Types.Events.AuctionWorkletType {\n  switch (input) {\n    case 'seller':\n      return Types.Events.AuctionWorkletType.SELLER;\n    case 'bidder':\n      return Types.Events.AuctionWorkletType.BIDDER;\n    default:\n      return Types.Events.AuctionWorkletType.UNKNOWN;\n  }\n}\n\n/**\n * We cannot make the full event without knowing the type of event, but we can\n * create everything other than the `args` field, as those are identical\n * regardless of the type of event.\n */\nfunction makeSyntheticEventBase(event: Types.Events.AuctionWorkletDoneWithProcess|\n                                Types.Events.AuctionWorkletRunningInProcess):\n    Omit<Types.Events.SyntheticAuctionWorklet, 'args'> {\n  return Helpers.SyntheticEvents.SyntheticEventsManager\n      .registerSyntheticEvent<Omit<Types.Events.SyntheticAuctionWorklet, 'args'>>({\n        rawSourceEvent: event,\n        name: 'SyntheticAuctionWorklet',\n        s: Types.Events.Scope.THREAD,\n        cat: event.cat,\n        tid: event.tid,\n        ts: event.ts,\n        ph: Types.Events.Phase.INSTANT,\n        pid: event.args.data.pid,\n        host: event.args.data.host,\n        target: event.args.data.target,\n        type: workletType(event.args.data.type),\n      });\n}\n\nexport async function finalize(): Promise<void> {\n  // Loop through the utility threads we found to create the worklet events. We\n  // expect each worklet to have a utility thread, so we can use them as the\n  // root of our list of worklets.\n  for (const [pid, utilityThreadNameEvent] of utilityThreads) {\n    const v8HelperEvent = v8HelperThreads.get(pid);\n    if (!v8HelperEvent) {\n      // Bad trace data - AuctionWorklets are expected to always have both threads.\n      continue;\n    }\n\n    const runningEvent = runningInProcessEvents.get(pid);\n    const doneWithEvent = doneWithProcessEvents.get(pid);\n\n    // We can create a worklet from either the runningEvent or doneWithEvent -\n    // we do not need both. We cannot express that to TypeScript with an early\n    // return here, so instead we set the event initially to null, and then\n    // create it from either the running event or the doneWith event. If it is\n    // still null after this, that means neither event was found, and we drop\n    // the worklet as we do not have enough information to create the synthetic\n    // event.\n\n    let syntheticEvent: Types.Events.SyntheticAuctionWorklet|null = null;\n\n    if (runningEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(runningEvent),\n        args: {\n          data: {\n            runningInProcessEvent: runningEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (doneWithEvent) {\n        syntheticEvent.args.data.doneWithProcessEvent = doneWithEvent;\n      }\n    } else if (doneWithEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(doneWithEvent),\n        args: {\n          data: {\n            doneWithProcessEvent: doneWithEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (runningEvent) {\n        syntheticEvent.args.data.runningInProcessEvent = runningEvent;\n      }\n    }\n    if (syntheticEvent === null) {\n      continue;\n    }\n    createdSyntheticEvents.set(pid, syntheticEvent);\n  }\n}\n\nexport interface AuctionWorkletsData {\n  worklets: Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet>;\n}\n\nexport function data(): AuctionWorkletsData {\n  return {\n    worklets: new Map(createdSyntheticEvents),\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n// We track the renderer processes we see in each frame on the way through the trace.\nconst rendererProcessesByFrameId: FrameProcessData = new Map();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId = '';\nlet mainFrameURL = '';\n\nconst framesByProcessId = new Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>();\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet browserThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet gpuProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet gpuThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet viewportRect: DOMRect|null = null;\nlet devicePixelRatio: number|null = null;\n\nconst processNames = new Map<Types.Events.ProcessID, Types.Events.ProcessName>();\n\nconst topLevelRendererIds = new Set<Types.Events.ProcessID>();\nconst traceBounds: Types.Timing.TraceWindowMicro = {\n  min: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n  max: Types.Timing.Micro(Number.NEGATIVE_INFINITY),\n  range: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n};\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n *\n * We also additionally maintain an array of only navigations that occurred on\n * the main frame. In many places in the UI we only care about highlighting\n * main frame navigations, so calculating this list here is better than\n * filtering either of the below maps over and over again at the UI layer.\n */\nconst navigationsByFrameId = new Map<string, Types.Events.NavigationStart[]>();\nconst navigationsByNavigationId = new Map<string, Types.Events.NavigationStart>();\nconst finalDisplayUrlByNavigationId = new Map<string, string>();\nconst mainFrameNavigations: Types.Events.NavigationStart[] = [];\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nconst threadsInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>();\n\nlet traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.Events.Phase.BEGIN,\n  Types.Events.Phase.END,\n  Types.Events.Phase.COMPLETE,\n  Types.Events.Phase.INSTANT,\n]);\n\n// Tracks if the trace is a generic trace, which here means that it did not come from athe DevTools Performance Panel recording.\n// We assume a trace is generic, and mark it as not generic if we see any of:\n// - TracingStartedInPage\n// - TracingStartedInBrowser\n// - TracingSessionIdForWorker\n// - CpuProfile\n// These are all events which indicate this is a Chrome browser trace.\nlet traceIsGeneric = true;\nconst CHROME_WEB_TRACE_EVENTS = new Set([\n  Types.Events.Name.TRACING_STARTED_IN_PAGE,\n  Types.Events.Name.TRACING_SESSION_ID_FOR_WORKER,\n  Types.Events.Name.TRACING_STARTED_IN_BROWSER,\n  Types.Events.Name.CPU_PROFILE,\n]);\n\nexport function reset(): void {\n  navigationsByFrameId.clear();\n  navigationsByNavigationId.clear();\n  finalDisplayUrlByNavigationId.clear();\n  processNames.clear();\n  mainFrameNavigations.length = 0;\n\n  browserProcessId = Types.Events.ProcessID(-1);\n  browserThreadId = Types.Events.ThreadID(-1);\n  gpuProcessId = Types.Events.ProcessID(-1);\n  gpuThreadId = Types.Events.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds.clear();\n  threadsInProcess.clear();\n  rendererProcessesByFrameId.clear();\n  framesByProcessId.clear();\n\n  traceBounds.min = Types.Timing.Micro(Number.POSITIVE_INFINITY);\n  traceBounds.max = Types.Timing.Micro(Number.NEGATIVE_INFINITY);\n  traceBounds.range = Types.Timing.Micro(Number.POSITIVE_INFINITY);\n  traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\n\n  traceIsGeneric = true;\n}\n\nfunction updateRendererProcessByFrame(event: Types.Events.Event, frame: Types.Events.TraceFrame): void {\n  const framesInProcessById = Platform.MapUtilities.getWithDefault(framesByProcessId, frame.processId, () => new Map());\n  framesInProcessById.set(frame.frame, frame);\n\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return [];\n  });\n  const lastProcessData = rendererProcessInfo.at(-1);\n\n  // Only store a new entry if the URL changed, otherwise it's just\n  // redundant information.\n  if (lastProcessData && lastProcessData.frame.url === frame.url) {\n    return;\n  }\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.push({\n    frame,\n    window: {\n      min: event.ts,\n      max: Types.Timing.Micro(0),\n      range: Types.Timing.Micro(0),\n    },\n  });\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (traceIsGeneric && CHROME_WEB_TRACE_EVENTS.has(event.name as Types.Events.Name)) {\n    traceIsGeneric = false;\n  }\n\n  if (Types.Events.isProcessName(event)) {\n    processNames.set(event.pid, event);\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.Micro(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur ?? Types.Timing.Micro(0);\n    traceBounds.max = Types.Timing.Micro(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.Events.isMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);\n    devicePixelRatio = event.args.data.dpr;\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    traceStartedTimeFromTracingStartedEvent = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (!frame.parent) {\n        topLevelRendererIds.add(frame.processId);\n      }\n      /**\n       * The code here uses a few different methods to try to determine the main frame.\n       * The ideal is that the frames have two flags present:\n       *\n       * 1. isOutermostMainFrame (added in April 2024 - crrev.com/c/5424783)\n       * 2. isInPrimaryMainFrame (added in June 2024 - crrev.com/c/5595033)\n       *\n       * The frame where both of these are set to `true` is the main frame. The\n       * reason we need both of these flags to have 100% confidence is because\n       * with the introduction of MPArch and pre-rendering, we can have other\n       * frames that are the outermost frame, but are not the primary process.\n       * Relying on isOutermostMainFrame in isolation caused the engine to\n       * incorrectly identify the wrong frame as main (see crbug.com/343873756).\n       *\n       * See https://source.chromium.org/chromium/chromium/src/+/main:docs/frame_trees.md\n       * for a bit more context on FrameTrees in Chromium.\n       *\n       * To avoid breaking entirely for traces pre-June 2024 that don't have\n       * both of these flags, we will fallback to less accurate methods:\n       *\n       * 1. If we have isOutermostMainFrame, we will use that\n       *    (and accept we might get it wrong)\n       * 2. If we don't have isOutermostMainFrame, we fallback to finding a\n       *    frame that has a URL, but doesn't have a parent. This is a crude\n       *    guess at the main frame...but better than nothing and is historically\n       *    how DevTools identified the main frame.\n       */\n\n      const traceHasPrimaryMainFrameFlag = 'isInPrimaryMainFrame' in frame;\n      const traceHasOutermostMainFrameFlag = 'isOutermostMainFrame' in frame;\n\n      if (traceHasPrimaryMainFrameFlag && traceHasOutermostMainFrameFlag) {\n        // Ideal situation: identify the main frame as the one that has both these flags set to true.\n        if (frame.isInPrimaryMainFrame && frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else if (traceHasOutermostMainFrameFlag) {\n        // Less ideal: \"guess\" at the main thread by using this flag.\n        if (frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n        // Worst case: guess by seeing if the frame doesn't have a parent, and does have a URL.\n      } else if (!frame.parent && frame.url) {\n        mainFrameId = frame.frame;\n        mainFrameURL = frame.url;\n      }\n    }\n\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.Events.isFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.Events.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  // (The filtering of empty URLs is done in the isNavigationStart check)\n  if (Types.Events.isNavigationStart(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      // We have only ever seen this situation once, in crbug.com/1503982, where the user ran:\n      // window.location.href = 'javascript:console.log(\"foo\")'\n      // In this situation two identical navigationStart events are emitted with the same data, URL and ID.\n      // So, in this situation we drop/ignore any subsequent navigations if we have already seen that ID.\n      return;\n    }\n    navigationsByNavigationId.set(navigationId, event);\n    finalDisplayUrlByNavigationId.set(navigationId, event.args.data.documentLoaderURL);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    if (frameId === mainFrameId) {\n      mainFrameNavigations.push(event);\n    }\n    return;\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect the latest redirect for each navigation.\n  if (Types.Events.isResourceSendRequest(event)) {\n    if (event.args.data.resourceType !== 'Document') {\n      return;\n    }\n\n    const maybeNavigationId = event.args.data.requestId;\n    const navigation = navigationsByNavigationId.get(maybeNavigationId);\n    if (!navigation) {\n      return;\n    }\n\n    finalDisplayUrlByNavigationId.set(maybeNavigationId, event.args.data.url);\n    return;\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect history API navigations.\n  if (Types.Events.isDidCommitSameDocumentNavigation(event)) {\n    if (event.args.render_frame_host.frame_type !== 'PRIMARY_MAIN_FRAME') {\n      return;\n    }\n\n    const navigation = mainFrameNavigations.at(-1);\n    const key = navigation?.args.data?.navigationId ?? '';\n    finalDisplayUrlByNavigationId.set(key, event.args.url);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // We try to set the minimum time by finding the event with the smallest\n  // timestamp. However, if we also got a timestamp from the\n  // TracingStartedInBrowser event, we should always use that.\n  // But in some traces (for example, CPU profiles) we do not get that event,\n  // hence why we need to check we got a timestamp from it before setting it.\n  if (traceStartedTimeFromTracingStartedEvent >= 0) {\n    traceBounds.min = traceStartedTimeFromTracingStartedEvent;\n  }\n  traceBounds.range = Types.Timing.Micro(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    // Sort the windows by time; we cannot assume by default they arrive via\n    // events in time order. Because we set the window bounds per-process based\n    // on the time of the current + next window, we need them sorted in ASC\n    // order.\n    const processWindowValues = [...processWindows.values()].flat().sort((a, b) => {\n      return a.window.min - b.window.min;\n    });\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.Micro(traceBounds.max);\n        currentWindow.window.range = Types.Timing.Micro(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.Micro(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.Micro(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  // Sometimes in traces the TracingStartedInBrowser event can give us an\n  // incorrect initial URL for the main frame's URL - about:blank or the URL of\n  // the previous page. This doesn't matter too much except we often use this\n  // URL as the visual name of the trace shown to the user (e.g. in the history\n  // dropdown). We can be more accurate by finding the first main frame\n  // navigation, and using its URL, if we have it.\n  // However, to avoid doing this in a case where the first navigation is far\n  // into the trace's lifecycle, we only do this in situations where the first\n  // navigation happened very soon (0.5 seconds) after the trace started\n  // recording.\n  const firstMainFrameNav = mainFrameNavigations.at(0);\n  const firstNavTimeThreshold = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(0.5));\n  if (firstMainFrameNav) {\n    const navigationIsWithinThreshold = firstMainFrameNav.ts - traceBounds.min < firstNavTimeThreshold;\n    if (firstMainFrameNav.args.data?.isOutermostMainFrame && firstMainFrameNav.args.data?.documentLoaderURL &&\n        navigationIsWithinThreshold) {\n      mainFrameURL = firstMainFrameNav.args.data.documentLoaderURL;\n    }\n  }\n}\n\nexport interface MetaHandlerData {\n  traceIsGeneric: boolean;\n  traceBounds: Types.Timing.TraceWindowMicro;\n  browserProcessId: Types.Events.ProcessID;\n  processNames: Map<Types.Events.ProcessID, Types.Events.ProcessName>;\n  browserThreadId: Types.Events.ThreadID;\n  gpuProcessId: Types.Events.ProcessID;\n  navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>;\n  navigationsByNavigationId: Map<string, Types.Events.NavigationStart>;\n  /**\n   * The user-visible URL displayed to users in the address bar.\n   * This captures:\n   *  - resolving all redirects\n   *  - history API pushState\n   *\n   * Given no redirects or history API usages, this is just the navigation event's documentLoaderURL.\n   *\n   * Note: empty string special case denotes the duration of the trace between the start\n   * and the first navigation. If there is no history API navigation during this time,\n   * there will be no value for empty string.\n   **/\n  finalDisplayUrlByNavigationId: Map<string, string>;\n  threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>;\n  mainFrameId: string;\n  mainFrameURL: string;\n  /**\n   * A frame can have multiple renderer processes, at the same time,\n   * a renderer process can have multiple URLs. This map tracks the\n   * processes active on a given frame, with the time window in which\n   * they were active. Because a renderer process might have multiple\n   * URLs, each process in each frame has an array of windows, with an\n   * entry for each URL it had.\n   */\n  rendererProcessesByFrame: FrameProcessData;\n  topLevelRendererIds: Set<Types.Events.ProcessID>;\n  frameByProcessId: Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>;\n  mainFrameNavigations: Types.Events.NavigationStart[];\n  gpuThreadId?: Types.Events.ThreadID;\n  viewportRect?: DOMRect;\n  devicePixelRatio?: number;\n}\n\n// Each frame has a single render process at a given time but it can have\n// multiple render processes  during a trace, for example if a navigation\n// occurred in the frame. This map tracks the process that was active for\n// each frame at each point in time. Also, because a process can be\n// assigned to multiple URLs, there is a window for each URL a process\n// was assigned.\n//\n// Note that different sites always end up in different render\n// processes, however two different URLs can point to the same site.\n// For example: https://google.com and https://maps.google.com point to\n// the same site.\n// Read more about this in\n// https://developer.chrome.com/articles/renderingng-architecture/#threads\n// and https://web.dev/same-site-same-origin/\nexport type FrameProcessData =\n    Map<string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>;\n\nexport function data(): MetaHandlerData {\n  return {\n    traceBounds: {...traceBounds},\n    browserProcessId,\n    browserThreadId,\n    processNames,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.Events.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    devicePixelRatio: devicePixelRatio ?? undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId,\n    navigationsByNavigationId,\n    finalDisplayUrlByNavigationId,\n    threadsInProcess,\n    rendererProcessesByFrame: rendererProcessesByFrameId,\n    topLevelRendererIds,\n    frameByProcessId: framesByProcessId,\n    mainFrameNavigations,\n    traceIsGeneric,\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n// Network requests from traces are actually formed of 5 trace records.\n// This handler tracks all trace records based on the request ID, and\n// then creates a new synthetic trace event for those network requests.\n//\n// This interface, then, defines the shape of the object we intend to\n// keep for each request in the trace. In the finalize we will convert\n// these 5 types of trace records to a synthetic complete event that\n// represents a composite of these trace records.\nexport interface TraceEventsForNetworkRequest {\n  changePriority?: Types.Events.ResourceChangePriority;\n  willSendRequests?: Types.Events.ResourceWillSendRequest[];\n  sendRequests?: Types.Events.ResourceSendRequest[];\n  receiveResponse?: Types.Events.ResourceReceiveResponse;\n  resourceFinish?: Types.Events.ResourceFinish;\n  receivedData?: Types.Events.ResourceReceivedData[];\n  resourceMarkAsCached?: Types.Events.ResourceMarkAsCached;\n}\n\nexport interface WebSocketTraceDataForFrame {\n  frame: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport interface WebSocketTraceDataForWorker {\n  workerId: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport type WebSocketTraceData = WebSocketTraceDataForFrame|WebSocketTraceDataForWorker;\n\nconst webSocketData = new Map<number, WebSocketTraceData>();\nconst linkPreconnectEvents: Types.Events.LinkPreconnect[] = [];\n\ninterface NetworkRequestData {\n  byId: Map<string, Types.Events.SyntheticNetworkRequest>;\n  byTime: Types.Events.SyntheticNetworkRequest[];\n  eventToInitiator: Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>;\n  webSocket: WebSocketTraceData[];\n  entityMappings: HandlerHelpers.EntityMappings;\n  linkPreconnectEvents: Types.Events.LinkPreconnect[];\n}\n\nconst requestMap = new Map<string, TraceEventsForNetworkRequest>();\nconst requestsById = new Map<string, Types.Events.SyntheticNetworkRequest>();\nconst requestsByTime: Types.Events.SyntheticNetworkRequest[] = [];\n\nconst networkRequestEventByInitiatorUrl = new Map<string, Types.Events.SyntheticNetworkRequest[]>();\nconst eventToInitiatorMap = new Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>();\n\n/**\n * These are to store ThirdParty data relationships between entities and events. To reduce iterating through data\n * more than we have to, here we start building the caches. After this, the RendererHandler will update\n * the relationships. When handling ThirdParty references, use the one in the RendererHandler instead.\n */\nconst entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.Events.Event[];\n    const values = value as Types.Events.Event[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: Array<number|null>): number {\n  for (const entry of entries) {\n    if (entry && entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return – say –\n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nexport function reset(): void {\n  requestsById.clear();\n  requestMap.clear();\n  requestsByTime.length = 0;\n  networkRequestEventByInitiatorUrl.clear();\n  eventToInitiatorMap.clear();\n  webSocketData.clear();\n  entityMappings.eventsByEntity.clear();\n  entityMappings.entityByEvent.clear();\n  entityMappings.createdEntityCache.clear();\n  linkPreconnectEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isResourceChangePriority(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'changePriority', event);\n    return;\n  }\n\n  if (Types.Events.isResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.Events.isResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n\n  if (Types.Events.isResourceMarkAsCached(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceMarkAsCached', event);\n    return;\n  }\n\n  if (Types.Events.isWebSocketCreate(event) || Types.Events.isWebSocketInfo(event) ||\n      Types.Events.isWebSocketTransfer(event)) {\n    const identifier = event.args.data.identifier;\n    if (!webSocketData.has(identifier)) {\n      if (event.args.data.frame) {\n        webSocketData.set(identifier, {\n          frame: event.args.data.frame,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      } else if (event.args.data.workerId) {\n        webSocketData.set(identifier, {\n          workerId: event.args.data.workerId,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      }\n    }\n\n    webSocketData.get(identifier)?.events.push(event);\n  }\n\n  if (Types.Events.isLinkPreconnect(event)) {\n    linkPreconnectEvents.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of sub-resources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.Events.SyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.Micro(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests?.[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.Micro(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        requestMethod: sendRequest.args.data.requestMethod,\n        ts,\n        dur,\n      });\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n\n    // We currently do not want to include data URI requests. We may revisit this in the future.\n    if (finalSendRequest.args.data.url.startsWith('data:')) {\n      continue;\n    }\n\n    /**\n     * LR loses transfer size information, but passes it in the 'X-TotalFetchedSize' header.\n     * 'X-TotalFetchedSize' is the canonical transfer size in LR.\n     *\n     * In Lightrider, due to instrumentation limitations, our values for encodedDataLength are bogus\n     * and not valid. However the resource's true encodedDataLength/transferSize is shared via a\n     * special response header, X-TotalFetchedSize. In this situation, we read this value from\n     * responseReceived, use it for the transferSize and ignore the original encodedDataLength values.\n     */\n    // @ts-expect-error\n    const isLightrider = globalThis.isLightrider;\n    if (isLightrider && request.resourceFinish && request.receiveResponse?.args.data.headers) {\n      const lrSizeHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TotalFetchedSize');\n      if (lrSizeHeader) {\n        const size = parseFloat(lrSizeHeader.value);\n        if (!isNaN(size)) {\n          request.resourceFinish.args.data.encodedDataLength = size;\n        }\n      }\n    }\n\n    // If a ResourceFinish event with an encoded data length is received,\n    // then the resource was not cached; it was fetched before it was\n    // requested, e.g. because it was pushed in this navigation.\n    const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;\n    // This works around crbug.com/998397, which reports pushed resources, and resources served by a service worker as disk cached.\n    const isDiskCached = !!request.receiveResponse && request.receiveResponse.args.data.fromCache &&\n        !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;\n    // If the request contains a resourceMarkAsCached event, it was served from memory cache.\n    // The timing data returned is from the original (uncached) request, which\n    // means that if we leave the above network record data as-is when the\n    // request came from either the disk cache or memory cache, our calculations\n    // will be incorrect.\n    //\n    // So we use this flag so when we calculate the timestamps of the various\n    // events, we can overwrite them.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    const isMemoryCached = request.resourceMarkAsCached !== undefined;\n    // If a request has `resourceMarkAsCached` field, the `timing` field is not correct.\n    // So let's discard it and override to 0 (which will be handled in later logic if timing field is undefined).\n    let timing = isMemoryCached ? undefined : request.receiveResponse?.args.data.timing;\n\n    /**\n     * LR gets additional, accurate timing information from its underlying fetch infrastructure.  This\n     * is passed in via X-Headers similar to 'X-TotalFetchedSize'.\n     *\n     * See `_updateTimingsForLightrider` in Lighthouse for more detail.\n     */\n    if (isLightrider && request.receiveResponse?.args.data.headers) {\n      timing = {\n        requestTime: Helpers.Timing.microToSeconds(request.sendRequests.at(0)?.ts ?? 0 as Types.Timing.Micro),\n        connectEnd: 0 as Types.Timing.Milli,\n        connectStart: 0 as Types.Timing.Milli,\n        dnsEnd: 0 as Types.Timing.Milli,\n        dnsStart: 0 as Types.Timing.Milli,\n        proxyEnd: 0 as Types.Timing.Milli,\n        proxyStart: 0 as Types.Timing.Milli,\n        pushEnd: 0 as Types.Timing.Milli,\n        pushStart: 0 as Types.Timing.Milli,\n        receiveHeadersEnd: 0 as Types.Timing.Milli,\n        receiveHeadersStart: 0 as Types.Timing.Milli,\n        sendEnd: 0 as Types.Timing.Milli,\n        sendStart: 0 as Types.Timing.Milli,\n        sslEnd: 0 as Types.Timing.Milli,\n        sslStart: 0 as Types.Timing.Milli,\n        workerReady: 0 as Types.Timing.Milli,\n        workerStart: 0 as Types.Timing.Milli,\n\n        ...timing,\n      };\n\n      const TCPMsHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TCPMs');\n      const TCPMs = TCPMsHeader ? Math.max(0, parseInt(TCPMsHeader.value, 10)) : 0;\n\n      if (request.receiveResponse.args.data.protocol.startsWith('h3')) {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n      } else {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.sslStart = TCPMs / 2 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n        timing.sslEnd = TCPMs as Types.Timing.Milli;\n      }\n    }\n\n    // If a non-cached response has no |timing|, we ignore it. An example of this is chrome://new-page / about:blank.\n    if (request.receiveResponse && !timing && !isMemoryCached) {\n      continue;\n    }\n\n    const initialPriority = finalSendRequest.args.data.priority;\n    let finalPriority = initialPriority;\n    if (request.changePriority) {\n      finalPriority = request.changePriority.args.data.priority;\n    }\n\n    // Network timings are complicated.\n    // https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/docs/Network-Timings.svg is generally correct, but.. less so for navigations/redirects/etc.\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests?.length) ? Types.Timing.Micro(request.willSendRequests[0].ts) :\n                                                           Types.Timing.Micro(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests?.length) ?\n        Types.Timing.Micro(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.Micro(finalSendRequest.ts);\n\n    // Finish time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish?.args.data.finishTime ?\n        Types.Timing.Micro(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.Micro(timing ? (finishTime || endRedirectTime) - endRedirectTime : 0);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.Micro(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.Micro(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueingFromTraceData = timing ? timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime : 0;\n    const queueing = Types.Timing.Micro(Platform.NumberUtilities.clamp(queueingFromTraceData, 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // If the request is cached, the amount of time stalled is the time between the start time and\n    // receiving a response.\n    // Otherwise it is whichever positive number comes first from the following timing info:\n    // DNS start, Connection start, Send Start, or the time duration between our start time and\n    // receiving a response.\n    const stalled = timing ?\n        Types.Timing.Micro(firstPositiveValueInList([\n          timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n          request.receiveResponse ? (request.receiveResponse.ts - endRedirectTime) : null,\n        ])) :\n        (request.receiveResponse ? Types.Timing.Micro(request.receiveResponse.ts - startTime) : Types.Timing.Micro(0));\n\n    // Sending HTTP request\n    // =======================\n    // Time when the HTTP request is sent.\n    const sendStartTime = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting = timing ?\n        Types.Timing.Micro((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n    const download = timing     ? Types.Timing.Micro(((finishTime || downloadStart) - downloadStart)) :\n        request.receiveResponse ? Types.Timing.Micro(endTime - request.receiveResponse.ts) :\n                                  Types.Timing.Micro(0);\n\n    const totalTime = Types.Timing.Micro(networkDuration + processingDuration);\n\n    // Collect a few values from the timing info.\n    // If the Network request is cached, these fields will be zero, so the minus will zero out them.\n    const dnsLookup = timing ? Types.Timing.Micro((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS) :\n                               Types.Timing.Micro(0);\n    const ssl = timing ? Types.Timing.Micro((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS) :\n                         Types.Timing.Micro(0);\n    const proxyNegotiation = timing ?\n        Types.Timing.Micro((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const requestSent = timing ?\n        Types.Timing.Micro((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const initialConnection = timing ?\n        Types.Timing.Micro((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Finally get some of the general data from the trace events.\n    const {frame, url, renderBlocking} = finalSendRequest.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const parsedUrl = new URL(url);\n    const isHttps = parsedUrl.protocol === 'https:';\n    const requestingFrameUrl =\n        Helpers.Trace.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || '';\n    // Construct a synthetic trace event for this network request.\n    const networkEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticNetworkRequest>({\n          rawSourceEvent: finalSendRequest,\n          args: {\n            data: {\n              // All data we create from trace events should be added to |syntheticData|.\n              syntheticData: {\n                dnsLookup,\n                download,\n                downloadStart,\n                finishTime,\n                initialConnection,\n                isDiskCached,\n                isHttps,\n                isMemoryCached,\n                isPushedResource,\n                networkDuration,\n                processingDuration,\n                proxyNegotiation,\n                queueing,\n                redirectionDuration,\n                requestSent,\n                sendStartTime,\n                ssl,\n                stalled,\n                totalTime,\n                waiting,\n              },\n              // All fields below are from TraceEventsForNetworkRequest.\n              decodedBodyLength,\n              encodedDataLength,\n              frame,\n              fromServiceWorker: request.receiveResponse?.args.data.fromServiceWorker,\n              isLinkPreload: finalSendRequest.args.data.isLinkPreload || false,\n              mimeType: request.receiveResponse?.args.data.mimeType ?? '',\n              priority: finalPriority,\n              initialPriority,\n              protocol: request.receiveResponse?.args.data.protocol ?? 'unknown',\n              redirects,\n              // In the event the property isn't set, assume non-blocking.\n              renderBlocking: renderBlocking ?? 'non_blocking',\n              requestId,\n              requestingFrameUrl,\n              requestMethod: finalSendRequest.args.data.requestMethod,\n              resourceType: finalSendRequest.args.data.resourceType ?? Protocol.Network.ResourceType.Other,\n              statusCode: request.receiveResponse?.args.data.statusCode ?? 0,\n              responseHeaders: request.receiveResponse?.args.data.headers ?? null,\n              fetchPriorityHint: finalSendRequest.args.data.fetchPriorityHint ?? 'auto',\n              initiator: finalSendRequest.args.data.initiator,\n              stackTrace: finalSendRequest.args.data.stackTrace,\n              timing,\n              url,\n              failed: request.resourceFinish?.args.data.didFail ?? false,\n              finished: Boolean(request.resourceFinish),\n              hasResponse: Boolean(request.receiveResponse),\n              connectionId: request.receiveResponse?.args.data.connectionId,\n              connectionReused: request.receiveResponse?.args.data.connectionReused,\n            },\n          },\n          cat: 'loading',\n          name: Types.Events.Name.SYNTHETIC_NETWORK_REQUEST,\n          ph: Types.Events.Phase.COMPLETE,\n          dur: Types.Timing.Micro(endTime - startTime),\n          tdur: Types.Timing.Micro(endTime - startTime),\n          ts: Types.Timing.Micro(startTime),\n          tts: Types.Timing.Micro(startTime),\n          pid: finalSendRequest.pid,\n          tid: finalSendRequest.tid,\n        });\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requestsByTime.push(networkEvent);\n    requestsById.set(networkEvent.args.data.requestId, networkEvent);\n\n    // Update entity relationships for network events\n    HandlerHelpers.addNetworkRequestToEntityMapping(networkEvent, entityMappings, request);\n\n    // Establish initiator relationships\n    const initiatorUrl = networkEvent.args.data.initiator?.url ||\n        Helpers.Trace.getZeroIndexedStackTraceInEventPayload(networkEvent)?.at(0)?.url;\n    if (initiatorUrl) {\n      const events = networkRequestEventByInitiatorUrl.get(initiatorUrl) ?? [];\n      events.push(networkEvent);\n      networkRequestEventByInitiatorUrl.set(initiatorUrl, events);\n    }\n  }\n\n  for (const request of requestsByTime) {\n    const initiatedEvents = networkRequestEventByInitiatorUrl.get(request.args.data.url);\n\n    if (initiatedEvents) {\n      for (const initiatedEvent of initiatedEvents) {\n        eventToInitiatorMap.set(initiatedEvent, request);\n      }\n    }\n  }\n\n  finalizeWebSocketData();\n}\n\nexport function data(): NetworkRequestData {\n  return {\n    byId: requestsById,\n    byTime: requestsByTime,\n    eventToInitiator: eventToInitiatorMap,\n    webSocket: [...webSocketData.values()],\n    entityMappings: {\n      entityByEvent: new Map(entityMappings.entityByEvent),\n      eventsByEntity: new Map(entityMappings.eventsByEntity),\n      createdEntityCache: new Map(entityMappings.createdEntityCache),\n    },\n    linkPreconnectEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nfunction finalizeWebSocketData(): void {\n  // for each WebSocketTraceData in webSocketData map, we create a synthetic event\n  // to represent the entire WebSocket connection. This is done by finding the start and end event\n  // if they exist, and if they don't, we use the first event in the list for start, and the traceBounds.max\n  // for the end. So each WebSocketTraceData will have\n  // {\n  //    events:  the list of WebSocket events\n  //    syntheticConnection:  the synthetic event representing the entire WebSocket connection\n  // }\n  webSocketData.forEach(data => {\n    let startEvent: Types.Events.WebSocketEvent|null = null;\n    let endEvent: Types.Events.WebSocketDestroy|null = null;\n    for (const event of data.events) {\n      if (Types.Events.isWebSocketCreate(event)) {\n        startEvent = event;\n      }\n      if (Types.Events.isWebSocketDestroy(event)) {\n        endEvent = event;\n      }\n    }\n    data.syntheticConnection = createSyntheticWebSocketConnection(startEvent, endEvent, data.events[0]);\n  });\n}\n\nfunction createSyntheticWebSocketConnection(\n    startEvent: Types.Events.WebSocketCreate|null, endEvent: Types.Events.WebSocketDestroy|null,\n    firstRecordedEvent: Types.Events.WebSocketEvent): Types.Events.SyntheticWebSocketConnection {\n  const {traceBounds} = metaHandlerData();\n  const startTs = startEvent ? startEvent.ts : traceBounds.min;\n  const endTs = endEvent ? endEvent.ts : traceBounds.max;\n  const duration = endTs - startTs;\n  const mainEvent = startEvent || endEvent || firstRecordedEvent;\n  return {\n    name: 'SyntheticWebSocketConnection',\n    cat: mainEvent.cat,\n    ph: Types.Events.Phase.COMPLETE,\n    ts: startTs,\n    dur: duration as Types.Timing.Micro,\n    pid: mainEvent.pid,\n    tid: mainEvent.tid,\n    s: mainEvent.s,\n    rawSourceEvent: mainEvent,\n    _tag: 'SyntheticEntryTag',\n    args: {\n      data: {\n        identifier: mainEvent.args.data.identifier,\n        priority: Protocol.Network.ResourcePriority.Low,\n        url: mainEvent.args.data.url || '',\n      },\n    },\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nconst events = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.Complete[]>>();\n\nconst profilesInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, ProfileData>>();\nconst entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\n\n// The profile head, containing its metadata like its start\n// time, comes in a \"Profile\" event. The sample data comes in\n// \"ProfileChunk\" events. We match these ProfileChunks with their head\n// using process and profile ids. However, in order to integrate sample\n// data with trace data, we need the thread id that owns each profile.\n// This thread id is extracted from the head event.\n// For this reason, we have a preprocessed data structure, where events\n// are matched by profile id, which we then finish processing to export\n// events matched by thread id.\nconst preprocessedData = new Map<Types.Events.ProcessID, Map<Types.Events.ProfileID, PreprocessedData>>();\n\nfunction parseCPUProfileData(parseOptions: Types.Configuration.ParseOptions): void {\n  for (const [processId, profiles] of preprocessedData) {\n    for (const [profileId, preProcessedData] of profiles) {\n      const threadId = preProcessedData.threadId;\n      if (!preProcessedData.rawProfile.nodes.length || threadId === undefined) {\n        continue;\n      }\n      const indexStack: number[] = [];\n\n      const profileModel = new CPUProfile.CPUProfileDataModel.CPUProfileDataModel(preProcessedData.rawProfile);\n      const profileTree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n      profileTree.maxDepth = profileModel.maxDepth;\n\n      const finalizedData: ProfileData = {\n        rawProfile: preProcessedData.rawProfile,\n        parsedProfile: profileModel,\n        profileCalls: [],\n        profileTree,\n        profileId,\n      };\n      const dataByThread = Platform.MapUtilities.getWithDefault(profilesInProcess, processId, () => new Map());\n      dataByThread.set(threadId, finalizedData);\n\n      // Only need to build pure JS ProfileCalls if we're parsing a CPU Profile, otherwise SamplesIntegrator does the work.\n      if (parseOptions.isCPUProfile) {\n        buildProfileCallsForCPUProfile();\n      }\n\n      function buildProfileCallsForCPUProfile(): void {\n        profileModel.forEachFrame(openFrameCallback, closeFrameCallback);\n\n        function openFrameCallback(\n            depth: number, node: CPUProfile.ProfileTreeModel.ProfileNode, sampleIndex: number,\n            timeStampMilliseconds: number): void {\n          if (threadId === undefined) {\n            return;\n          }\n          const ts = Helpers.Timing.milliToMicro(Types.Timing.Milli(timeStampMilliseconds));\n          const nodeId = node.id as Helpers.TreeHelpers.TraceEntryNodeId;\n\n          const profileCall = Helpers.Trace.makeProfileCall(node, profileId, sampleIndex, ts, processId, threadId);\n          finalizedData.profileCalls.push(profileCall);\n          indexStack.push(finalizedData.profileCalls.length - 1);\n          const traceEntryNode = Helpers.TreeHelpers.makeEmptyTraceEntryNode(profileCall, nodeId);\n          entryToNode.set(profileCall, traceEntryNode);\n          traceEntryNode.depth = depth;\n          if (indexStack.length === 1) {\n            // First call in the stack is a root call.\n            finalizedData.profileTree?.roots.add(traceEntryNode);\n          }\n        }\n        function closeFrameCallback(\n            _depth: number, _node: CPUProfile.ProfileTreeModel.ProfileNode, _sampleIndex: number,\n            _timeStampMillis: number, durMs: number, selfTimeMs: number): void {\n          const profileCallIndex = indexStack.pop();\n          const profileCall = profileCallIndex !== undefined && finalizedData.profileCalls[profileCallIndex];\n          if (!profileCall) {\n            return;\n          }\n          const {callFrame, ts, pid, tid} = profileCall;\n          const traceEntryNode = entryToNode.get(profileCall);\n          if (callFrame === undefined || ts === undefined || pid === undefined || profileId === undefined ||\n              tid === undefined || traceEntryNode === undefined) {\n            return;\n          }\n          const dur = Helpers.Timing.milliToMicro(Types.Timing.Milli(durMs));\n          const selfTime = Helpers.Timing.milliToMicro(Types.Timing.Milli(selfTimeMs));\n          profileCall.dur = dur;\n          traceEntryNode.selfTime = selfTime;\n\n          const parentIndex = indexStack.at(-1);\n          const parent = parentIndex !== undefined && finalizedData.profileCalls.at(parentIndex);\n          const parentNode = parent && entryToNode.get(parent);\n          if (!parentNode) {\n            return;\n          }\n          traceEntryNode.parent = parentNode;\n          parentNode.children.push(traceEntryNode);\n        }\n      }\n    }\n  }\n}\n\nexport function reset(): void {\n  events.clear();\n  preprocessedData.clear();\n  profilesInProcess.clear();\n  entryToNode.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  /**\n   * A fake trace event created to support CDP.Profiler.Profiles in the\n   * trace engine.\n   */\n  if (Types.Events.isSyntheticCpuProfile(event)) {\n    // At the moment we are attaching to a single node target so we\n    // should only get a single CPU profile. The values of the process\n    // id and thread id are not really important, so we use the data\n    // in the fake event. Should multi-thread CPU profiling be supported\n    // we could use these fields in the event to pass thread info.\n    const pid = event.pid;\n    const tid = event.tid;\n    // Create an arbitrary profile id.\n    const profileId = '0x1' as Types.Events.ProfileID;\n    const profileData = getOrCreatePreProcessedData(pid, profileId);\n    profileData.rawProfile = event.args.data.cpuProfile;\n    profileData.threadId = tid;\n    return;\n  }\n\n  if (Types.Events.isProfile(event)) {\n    // Do not use event.args.data.startTime as it is in CLOCK_MONOTONIC domain,\n    // but use profileEvent.ts which has been translated to Perfetto's clock\n    // domain. Also convert from ms to us.\n    // Note: events are collected on a different thread than what's sampled.\n    // The correct process and thread ids are specified by the profile.\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    profileData.rawProfile.startTime = event.ts;\n    profileData.threadId = event.tid;\n    return;\n  }\n  if (Types.Events.isProfileChunk(event)) {\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    const cdpProfile = profileData.rawProfile;\n    const nodesAndSamples: Types.Events.PartialProfile|undefined = event.args?.data?.cpuProfile || {samples: []};\n    const samples = nodesAndSamples?.samples || [];\n    const traceIds = event.args?.data?.cpuProfile?.trace_ids;\n    const nodes: CPUProfile.CPUProfileDataModel.ExtendedProfileNode[] = [];\n    for (const n of nodesAndSamples?.nodes || []) {\n      const lineNumber = typeof n.callFrame.lineNumber === 'undefined' ? -1 : n.callFrame.lineNumber;\n      const columnNumber = typeof n.callFrame.columnNumber === 'undefined' ? -1 : n.callFrame.columnNumber;\n\n      const scriptId = String(n.callFrame.scriptId) as Protocol.Runtime.ScriptId;\n      const url = n.callFrame.url || '';\n      const node = {\n        ...n,\n        callFrame: {\n          ...n.callFrame,\n          url,\n          lineNumber,\n          columnNumber,\n          scriptId,\n        },\n      };\n      nodes.push(node);\n    }\n\n    const timeDeltas = event.args.data?.timeDeltas || [];\n    const lines = event.args.data?.lines || Array(samples.length).fill(0);\n    cdpProfile.nodes.push(...nodes);\n    cdpProfile.samples?.push(...samples);\n    cdpProfile.timeDeltas?.push(...timeDeltas);\n    cdpProfile.lines?.push(...lines);\n\n    if (traceIds) {\n      cdpProfile.traceIds = cdpProfile.traceIds || {};\n      for (const [key, value] of Object.entries(traceIds)) {\n        cdpProfile.traceIds[key] = value;\n      }\n    }\n    if (cdpProfile.samples && cdpProfile.timeDeltas && cdpProfile.samples.length !== cdpProfile.timeDeltas.length) {\n      console.error('Failed to parse CPU profile.');\n      return;\n    }\n    if (!cdpProfile.endTime && cdpProfile.timeDeltas) {\n      const timeDeltas: number[] = cdpProfile.timeDeltas;\n      cdpProfile.endTime = timeDeltas.reduce((x, y) => x + y, cdpProfile.startTime);\n    }\n    return;\n  }\n}\n\nexport async function finalize(parseOptions: Types.Configuration.ParseOptions = {}): Promise<void> {\n  parseCPUProfileData(parseOptions);\n}\n\nexport function data(): SamplesHandlerData {\n  return {\n    profilesInProcess,\n    entryToNode,\n  };\n}\n\nfunction getOrCreatePreProcessedData(\n    processId: Types.Events.ProcessID, profileId: Types.Events.ProfileID): PreprocessedData {\n  const profileById = Platform.MapUtilities.getWithDefault(preprocessedData, processId, () => new Map());\n  return Platform.MapUtilities.getWithDefault<Types.Events.ProfileID, PreprocessedData>(\n      profileById, profileId, () => ({\n                                rawProfile: {\n                                  startTime: 0,\n                                  endTime: 0,\n                                  nodes: [],\n                                  samples: [],\n                                  timeDeltas: [],\n                                  lines: [],\n                                },\n                                profileId,\n                              }));\n}\n\nexport interface SamplesHandlerData {\n  profilesInProcess: typeof profilesInProcess;\n  entryToNode: typeof entryToNode;\n}\n\nexport interface ProfileData {\n  profileId: Types.Events.ProfileID;\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile;\n  parsedProfile: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Contains the calls built from the CPU profile samples.\n   * Note: This doesn't contain real trace events coming from the\n   * browser, only calls synthetically typed as trace events for\n   * compatibility, as such it only makes sense to use them in pure CPU\n   * profiles.\n   *\n   * If you need the profile calls from a CPU profile obtained from a\n   * web trace, use the data exported by the RendererHandler instead.\n   */\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  /**\n   * Contains the call tree built from the CPU profile samples.\n   * Similar to the profileCalls field, this tree does not contain nor\n   * take into account trace events, as such it only makes sense to use\n   * them in pure CPU profiles.\n   */\n  profileTree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n\ninterface PreprocessedData {\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile;\n  profileId: Types.Events.ProfileID;\n  threadId?: Types.Events.ThreadID;\n}\n\n/**\n * Returns the name of a function for a given synthetic profile call.\n * We first look to find the ProfileNode representing this call, and use its\n * function name. This is preferred (and should always exist) because if we\n * resolve sourcemaps, we will update this name. If that name is not present,\n * we fall back to the function name that was in the callframe that we got\n * when parsing the profile's trace data.\n */\nexport function getProfileCallFunctionName(data: SamplesHandlerData, entry: Types.Events.SyntheticProfileCall): string {\n  const profile = data.profilesInProcess.get(entry.pid)?.get(entry.tid);\n  const node = profile?.parsedProfile.nodeById(entry.nodeId);\n  if (node?.functionName) {\n    return node.functionName;\n  }\n  return entry.callFrame.functionName;\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nexport interface DOMStatsData {\n  domStatsByFrameId: Map<string, Types.Events.DOMStats[]>;\n}\n\nconst domStatsByFrameId: DOMStatsData['domStatsByFrameId'] = new Map();\n\nexport function reset(): void {\n  domStatsByFrameId.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isDOMStats(event)) {\n    return;\n  }\n  const domStatEvents = Platform.MapUtilities.getWithDefault(domStatsByFrameId, event.args.data.frame, () => []);\n  domStatEvents.push(event);\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): DOMStatsData {\n  return {domStatsByFrameId};\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\nimport {data as userTimingsData} from './UserTimingsHandler.js';\n\nconst extensionTrackEntries: Types.Extensions.SyntheticExtensionTrackEntry[] = [];\nconst extensionTrackData: Types.Extensions.ExtensionTrackData[] = [];\nconst extensionMarkers: Types.Extensions.SyntheticExtensionMarker[] = [];\nconst entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\nconst timeStampByName = new Map<string, Types.Events.ConsoleTimeStamp>();\n\nconst syntheticConsoleEntriesForTimingsTrack: Types.Events.SyntheticConsoleTimeStamp[] = [];\n\nexport interface ExtensionTraceData {\n  extensionTrackData: readonly Types.Extensions.ExtensionTrackData[];\n  extensionMarkers: readonly Types.Extensions.SyntheticExtensionMarker[];\n  // TODO(andoli): Can we augment Renderer's entryToNode instead? To avoid the split of TimelineUIUtils's getEventSelfTime()?\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  syntheticConsoleEntriesForTimingsTrack: Types.Events.SyntheticConsoleTimeStamp[];\n}\n\nexport function handleEvent(_event: Types.Events.Event): void {\n  // Implementation not needed because data is sourced from UserTimingsHandler\n}\n\nexport function reset(): void {\n  extensionTrackEntries.length = 0;\n  syntheticConsoleEntriesForTimingsTrack.length = 0;\n  extensionTrackData.length = 0;\n  extensionMarkers.length = 0;\n  entryToNode.clear();\n  timeStampByName.clear();\n}\n\nexport async function finalize(): Promise<void> {\n  createExtensionFlameChartEntries();\n}\n\nfunction createExtensionFlameChartEntries(): void {\n  const pairedMeasures: readonly Types.Events.SyntheticUserTimingPair[] = userTimingsData().performanceMeasures;\n  const marks: readonly Types.Events.PerformanceMark[] = userTimingsData().performanceMarks;\n  const mergedRawExtensionEvents = Helpers.Trace.mergeEventsInOrder(pairedMeasures, marks);\n\n  extractPerformanceAPIExtensionEntries(mergedRawExtensionEvents);\n  extractConsoleAPIExtensionEntries();\n  // extensionTrackEntries is filled by the above two calls.\n  Helpers.Trace.sortTraceEventsInPlace(extensionTrackEntries);\n  Helpers.Extensions.buildTrackDataFromExtensionEntries(extensionTrackEntries, extensionTrackData, entryToNode);\n}\n\n/**\n * Extracts extension entries from console.timeStamp events.\n *\n * Entries are built by pairing `console.timeStamp` events based on\n * their names. When a `console.timeStamp` event includes a `start`\n * argument (and optionally an `end` argument), it attempts to find\n * previously recorded `console.timeStamp` events with names matching\n * the `start` and `end` values. These matching events are then used to\n * determine the start and end times of the new entry.\n *\n * If a `console.timeStamp` event includes data for a custom track\n * (specified by the `track` argument), an extension track entry is\n * created and added to the `extensionTrackEntries` array. These entries\n * are used to visualize custom tracks in the Performance panel.\n *\n * If a `console.timeStamp` event includes data for a custom track\n * (specified by the `track` argument), an extension track entry is\n * created and added to the `extensionTrackEntries` array. These entries\n * are used to visualize custom tracks in the Performance panel.\n *\n * If a `console.timeStamp` event does not specify a custom track but\n * includes a start and/or end time (referencing other\n * `console.timeStamp` names), a synthetic console time stamp entry is\n * created and added to the `syntheticConsoleEntriesForTimingsTrack`\n * array. These entries are displayed in the \"Timings\" track.\n */\nexport function extractConsoleAPIExtensionEntries(): void {\n  const consoleTimeStamps: readonly Types.Events.ConsoleTimeStamp[] = userTimingsData().timestampEvents;\n  for (const currentTimeStamp of consoleTimeStamps) {\n    if (!currentTimeStamp.args.data) {\n      continue;\n    }\n    const timeStampName = String(currentTimeStamp.args.data.name ?? currentTimeStamp.args.data.message);\n    timeStampByName.set(timeStampName, currentTimeStamp);\n    const extensionData = extensionDataInConsoleTimeStamp(currentTimeStamp);\n    const start = currentTimeStamp.args.data.start;\n    const end = currentTimeStamp.args.data.end;\n    if (!extensionData && !start && !end) {\n      continue;\n    }\n    // If the start or end is a number, it's assumed to be a timestamp\n    // from the tracing clock, so we use that directly, otherwise we\n    // assume it's the label of a previous console timestamp, in which\n    // case we use its corresponding timestamp.\n    const startTimeStamp =\n        typeof start === 'number' ? Types.Timing.Micro(start) : timeStampByName.get(String(start))?.ts;\n    const endTimeStamp = typeof end === 'number' ? Types.Timing.Micro(end) : timeStampByName.get(String(end))?.ts;\n    if (endTimeStamp !== undefined && startTimeStamp === undefined) {\n      // Invalid data\n      continue;\n    }\n    const entryStartTime = startTimeStamp ?? currentTimeStamp.ts;\n    const entryEndTime = endTimeStamp ?? currentTimeStamp.ts;\n    if (extensionData) {\n      const unregisteredExtensionEntry: Omit<Types.Extensions.SyntheticExtensionTrackEntry, '_tag'> = {\n        ...currentTimeStamp,\n        name: timeStampName,\n        cat: 'devtools.extension',\n        args: extensionData,\n        rawSourceEvent: currentTimeStamp,\n        dur: Types.Timing.Micro(entryEndTime - entryStartTime),\n        ts: entryStartTime,\n        ph: Types.Events.Phase.COMPLETE,\n      };\n      const extensionEntry =\n          Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionTrackEntry>(unregisteredExtensionEntry);\n      extensionTrackEntries.push(extensionEntry);\n      continue;\n    }\n    // If no extension data is found in the entry (no custom track name\n    // was passed), but the entry has a duration. we still save it here\n    // to be added in the timings track. Note that timings w/o duration\n    // and extension data are already handled by the UserTimingsHandler.\n    const unregisteredSyntheticTimeStamp: Omit<Types.Events.SyntheticConsoleTimeStamp, '_tag'> = {\n      ...currentTimeStamp,\n      name: timeStampName,\n      cat: 'disabled-by-default-v8.inspector',\n      ph: Types.Events.Phase.COMPLETE,\n      ts: entryStartTime,\n      dur: Types.Timing.Micro(entryEndTime - entryStartTime),\n      rawSourceEvent: currentTimeStamp\n    };\n    const syntheticTimeStamp =\n        Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n            .registerSyntheticEvent<Types.Events.SyntheticConsoleTimeStamp>(unregisteredSyntheticTimeStamp);\n    syntheticConsoleEntriesForTimingsTrack.push(syntheticTimeStamp);\n  }\n}\n\n/**\n * Extracts extension entries from Performance API events (marks and\n * measures).\n * It specifically looks for events that contain extension-specific data\n * within their `detail` property.\n *\n * If an event's `detail` property can be parsed as a JSON object and\n * contains a `devtools` field with a valid extension payload, a\n * synthetic extension entry is created. The type of extension entry\n * created depends on the payload:\n *\n * - If the payload conforms to `ExtensionPayloadMarker`, a\n *   `SyntheticExtensionMarker` is created and added to the\n *   `extensionMarkers` array. These markers represent single points in\n *   time.\n * - If the payload conforms to `ExtensionPayloadTrackEntry`, a\n *   `SyntheticExtensionTrackEntry` is created and added to the\n *   `extensionTrackEntries` array. These entries represent events with\n *   a duration and are displayed on custom tracks in the Performance\n *   panel.\n *\n * **Note:** Only events with a `detail` property that contains valid\n * extension data are processed. Other `performance.mark` and\n * `performance.measure` events are ignored.\n *\n * @param timings An array of `SyntheticUserTimingPair` or\n *                `PerformanceMark` events, typically obtained from the\n *                `UserTimingsHandler`.\n */\nexport function extractPerformanceAPIExtensionEntries(\n    timings: Array<Types.Events.SyntheticUserTimingPair|Types.Events.PerformanceMark>): void {\n  for (const timing of timings) {\n    const extensionPayload = extensionDataInPerformanceTiming(timing);\n    if (!extensionPayload) {\n      // Not an extension user timing.\n      continue;\n    }\n\n    const extensionSyntheticEntry = {\n      name: timing.name,\n      ph: Types.Extensions.isExtensionPayloadMarker(extensionPayload) ? Types.Events.Phase.INSTANT :\n                                                                        Types.Events.Phase.COMPLETE,\n      pid: timing.pid,\n      tid: timing.tid,\n      ts: timing.ts,\n      dur: timing.dur as Types.Timing.Micro,\n      cat: 'devtools.extension',\n      args: extensionPayload,\n      rawSourceEvent: Types.Events.isSyntheticUserTiming(timing) ? timing.rawSourceEvent : timing,\n    };\n\n    if (Types.Extensions.isExtensionPayloadMarker(extensionPayload)) {\n      const extensionMarker =\n          Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionMarker>(\n                  extensionSyntheticEntry as Omit<Types.Extensions.SyntheticExtensionMarker, '_tag'>);\n      extensionMarkers.push(extensionMarker);\n      continue;\n    }\n\n    if (Types.Extensions.isExtensionPayloadTrackEntry(extensionSyntheticEntry.args)) {\n      const extensionTrackEntry =\n          Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionTrackEntry>(\n                  extensionSyntheticEntry as Omit<Types.Extensions.SyntheticExtensionTrackEntry, '_tag'>);\n      extensionTrackEntries.push(extensionTrackEntry);\n      continue;\n    }\n  }\n}\n\nexport function extensionDataInPerformanceTiming(\n    timing: Types.Events.SyntheticUserTimingPair|Types.Events.PerformanceMark): Types.Extensions.ExtensionDataPayload|\n    null {\n  const timingDetail =\n      Types.Events.isPerformanceMark(timing) ? timing.args.data?.detail : timing.args.data.beginEvent.args.detail;\n  if (!timingDetail) {\n    return null;\n  }\n  try {\n    // Attempt to parse the detail as an object that might be coming from a\n    // DevTools Perf extension.\n    // Wrapped in a try-catch because timingDetail might either:\n    // 1. Not be `json.parse`-able (it should, but just in case...)\n    // 2.Not be an object - in which case the `in` check will error.\n    // If we hit either of these cases, we just ignore this mark and move on.\n    const detailObj = JSON.parse(timingDetail);\n    if (!('devtools' in detailObj)) {\n      return null;\n    }\n    if (!Types.Extensions.isValidExtensionPayload(detailObj.devtools)) {\n      return null;\n    }\n    return detailObj.devtools;\n  } catch {\n    // No need to worry about this error, just discard this event and don't\n    // treat it as having any useful information for the purposes of extensions\n    return null;\n  }\n}\n/**\n * Extracts extension data from a `console.timeStamp` event.\n *\n * Checks if a `console.timeStamp` event contains data intended for\n * creating a custom track entry in the DevTools Performance panel. It\n * specifically looks for a `track` argument within the event's data.\n *\n * If a `track` argument is present (and not an empty string), the\n * function constructs an `ExtensionTrackEntryPayload` object containing\n * the track name, an optional color, an optional track group. This\n * payload is then used to create a `SyntheticExtensionTrackEntry`.\n *\n * **Note:** The `color` argument is optional and its type is validated\n * against a predefined palette (see\n * `ExtensionUI::extensionEntryColor`).\n *\n * @param timeStamp The `ConsoleTimeStamp` event to extract data from.\n * @return An `ExtensionTrackEntryPayload` object if the event contains\n *         valid extension data for a track entry, or `null` otherwise.\n */\nexport function extensionDataInConsoleTimeStamp(timeStamp: Types.Events.ConsoleTimeStamp):\n    Types.Extensions.ExtensionTrackEntryPayload|null {\n  if (!timeStamp.args.data) {\n    return null;\n  }\n  const trackName = timeStamp.args.data.track;\n  if (trackName === '' || trackName === undefined) {\n    return null;\n  }\n  return {\n    // the color is defaulted to primary if it's value isn't one from\n    // the defined palette (see ExtensionUI::extensionEntryColor) so\n    // we don't need to check the value is valid here.\n    color: String(timeStamp.args.data.color) as Types.Extensions.ExtensionTrackEntryPayload['color'],\n    track: String(trackName),\n    dataType: 'track-entry',\n    trackGroup: timeStamp.args.data.trackGroup !== undefined ? String(timeStamp.args.data.trackGroup) : undefined\n  };\n}\n\nexport function data(): ExtensionTraceData {\n  return {\n    entryToNode,\n    extensionTrackData,\n    extensionMarkers,\n    syntheticConsoleEntriesForTimingsTrack,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['UserTimings'];\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * IMPORTANT!\n * See UserTimings.md in this directory for some handy documentation on\n * UserTimings and the trace events we parse currently.\n **/\nlet syntheticEvents: Array<Types.Events.SyntheticEventPair<Types.Events.PairableAsync>> = [];\n\n// There are two events dispatched for performance.measure calls: one to\n// represent the measured timing in the tracing clock (which we type as\n// PerformanceMeasure) and another one for the call itself (which we\n// type as UserTimingMeasure). The two events corresponding to the same\n// call are linked together by a common trace_id. The reason two events\n// are dispatched is because the first was originally added with the\n// implementation of the performance.measure API and it uses an\n// overridden timestamp and duration. To prevent breaking potential deps\n// created since then, a second event was added instead of changing the\n// params of the first.\nconst measureTraceByTraceId = new Map<number, Types.Events.UserTimingMeasure>();\nconst performanceMeasureEvents: Types.Events.PerformanceMeasure[] = [];\nconst performanceMarkEvents: Types.Events.PerformanceMark[] = [];\n\nconst consoleTimings: Array<Types.Events.ConsoleTimeBegin|Types.Events.ConsoleTimeEnd> = [];\n\nconst timestampEvents: Types.Events.ConsoleTimeStamp[] = [];\n\nexport interface UserTimingsData {\n  /**\n   * Events triggered with the performance.measure() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure\n   */\n  performanceMeasures: readonly Types.Events.SyntheticUserTimingPair[];\n  /**\n   * Events triggered with the performance.mark() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n   */\n  performanceMarks: readonly Types.Events.PerformanceMark[];\n  /**\n   * Events triggered with the console.time(), console.timeEnd() and\n   * console.timeLog() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/time\n   */\n  consoleTimings: readonly Types.Events.SyntheticConsoleTimingPair[];\n  /**\n   * Events triggered with the console.timeStamp() API\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/timeStamp\n   */\n  timestampEvents: readonly Types.Events.ConsoleTimeStamp[];\n  /**\n   * Events triggered to trace the call to performance.measure itself,\n   * cached by trace_id.\n   */\n  measureTraceByTraceId: Map<number, Types.Events.UserTimingMeasure>;\n}\n\nexport function reset(): void {\n  syntheticEvents.length = 0;\n  performanceMeasureEvents.length = 0;\n  performanceMarkEvents.length = 0;\n  consoleTimings.length = 0;\n  timestampEvents.length = 0;\n  measureTraceByTraceId.clear();\n}\n\nconst resourceTimingNames = [\n  'workerStart',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n];\nconst navTimingNames = [\n  'navigationStart',\n  'unloadEventStart',\n  'unloadEventEnd',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'commitNavigationEnd',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n  'domLoading',\n  'domInteractive',\n  'domContentLoadedEventStart',\n  'domContentLoadedEventEnd',\n  'domComplete',\n  'loadEventStart',\n  'loadEventEnd',\n];\n// These are events dispatched under the blink.user_timing category\n// but that the user didn't add. Filter them out so that they do not\n// Appear in the timings track (they still appear in the main thread\n// flame chart).\nconst ignoredNames = [...resourceTimingNames, ...navTimingNames];\n\n/**\n * Similar to the default {@see Helpers.Trace.eventTimeComparator}\n * but with a twist:\n * In case of equal start and end times, always put the second event\n * first.\n *\n * Explanation:\n * User timing entries come as trace events dispatched when\n * performance.measure/mark is called. The trace events buffered in\n * devtools frontend are sorted by the start time. If their start time\n * is the same, then the event for the first call will appear first.\n *\n * When entries are meant to be stacked, the corresponding\n * performance.measure calls usually are done in bottom-up direction:\n * calls for children first and for parent later (because the call\n * is usually done when the measured task is over). This means that\n * when two user timing events have the start and end time, usually the\n * second event is the parent of the first. Hence the switch.\n *\n */\nfunction userTimingComparator(\n    a: Helpers.Trace.TimeSpan, b: Helpers.Trace.TimeSpan, originalArray: Helpers.Trace.TimeSpan[]): number {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n  // Prefer the event located in a further position in the original array.\n  return originalArray.indexOf(b) - originalArray.indexOf(a);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (ignoredNames.includes(event.name)) {\n    return;\n  }\n  if (Types.Events.isUserTimingMeasure(event)) {\n    measureTraceByTraceId.set(event.args.traceId, event);\n  }\n  if (Types.Events.isPerformanceMeasure(event)) {\n    performanceMeasureEvents.push(event);\n    return;\n  }\n  if (Types.Events.isPerformanceMark(event)) {\n    performanceMarkEvents.push(event);\n  }\n  if (Types.Events.isConsoleTime(event)) {\n    consoleTimings.push(event);\n  }\n  if (Types.Events.isConsoleTimeStamp(event)) {\n    timestampEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const asyncEvents = [...performanceMeasureEvents, ...consoleTimings];\n  syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(asyncEvents);\n  syntheticEvents = syntheticEvents.sort((a, b) => userTimingComparator(a, b, [...syntheticEvents]));\n}\n\nexport function data(): UserTimingsData {\n  return {\n    performanceMeasures: syntheticEvents.filter(e => e.cat === 'blink.user_timing') as\n        Types.Events.SyntheticUserTimingPair[],\n    consoleTimings: syntheticEvents.filter(e => e.cat === 'blink.console') as Types.Events.SyntheticConsoleTimingPair[],\n    // TODO(crbug/41484172): UserTimingsHandler.test.ts fails if this is not copied.\n    performanceMarks: [...performanceMarkEvents],\n    timestampEvents: [...timestampEvents],\n    measureTraceByTraceId: new Map(measureTraceByTraceId),\n  };\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {type AuctionWorkletsData, data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport {data as layerTreeHandlerData, type LayerTreeData} from './LayerTreeHandler.js';\nimport {data as metaHandlerData, type MetaHandlerData} from './MetaHandler.js';\nimport {data as rendererHandlerData, type RendererHandlerData} from './RendererHandler.js';\nimport * as Threads from './Threads.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * IMPORTANT: this handler is slightly different to the rest. This is because\n * it is an adaptation of the TimelineFrameModel that has been used in DevTools\n * for many years. Rather than re-implement all the logic from scratch, instead\n * this handler gathers up the events and instantitates the class in the\n * finalize() method. Once the class has parsed all events, it is used to then\n * return the array of frames.\n *\n * In time we expect to migrate this code to a more \"typical\" handler.\n */\n\nconst allEvents: Types.Events.Event[] = [];\nlet model: TimelineFrameModel|null = null;\n\nexport function reset(): void {\n  allEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  allEvents.push(event);\n}\n\nexport async function finalize(): Promise<void> {\n  // Snapshot events can be emitted out of order, so we need to sort before\n  // building the frames model.\n  Helpers.Trace.sortTraceEventsInPlace(allEvents);\n\n  const modelForTrace = new TimelineFrameModel(\n      allEvents,\n      rendererHandlerData(),\n      auctionWorkletsData(),\n      metaHandlerData(),\n      layerTreeHandlerData(),\n  );\n  model = modelForTrace;\n}\n\nexport interface FramesData {\n  frames: readonly Types.Events.LegacyTimelineFrame[];\n  framesById: Readonly<Record<number, Types.Events.LegacyTimelineFrame|undefined>>;\n}\n\nexport function data(): FramesData {\n  return {\n    frames: model ? Array.from(model.frames()) : [],\n    framesById: model ? {...model.framesById()} : {},\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Renderer', 'AuctionWorklets', 'LayerTree'];\n}\n\ntype FrameEvent = Types.Events.BeginFrame|Types.Events.DroppedFrame|Types.Events.RequestMainThreadFrame|\n                  Types.Events.BeginMainThreadFrame|Types.Events.Commit|Types.Events.CompositeLayers|\n                  Types.Events.ActivateLayerTree|Types.Events.NeedsBeginFrameChanged|Types.Events.DrawFrame;\n\nfunction isFrameEvent(event: Types.Events.Event): event is FrameEvent {\n  return (\n      Types.Events.isSetLayerId(event) || Types.Events.isBeginFrame(event) || Types.Events.isDroppedFrame(event) ||\n      Types.Events.isRequestMainThreadFrame(event) || Types.Events.isBeginMainThreadFrame(event) ||\n      Types.Events.isNeedsBeginFrameChanged(event) ||\n      // Note that \"Commit\" is the replacement for \"CompositeLayers\" so in a trace\n      // we wouldn't expect to see a combination of these. All \"new\" trace\n      // recordings use \"Commit\", but we can easily support \"CompositeLayers\" too\n      // to not break older traces being imported.\n      Types.Events.isCommit(event) || Types.Events.isCompositeLayers(event) ||\n      Types.Events.isActivateLayerTree(event) || Types.Events.isDrawFrame(event));\n}\n\nfunction entryIsTopLevel(entry: Types.Events.Event): boolean {\n  const devtoolsTimelineCategory = 'disabled-by-default-devtools.timeline';\n  return entry.name === Types.Events.Name.RUN_TASK && entry.cat.includes(devtoolsTimelineCategory);\n}\n\nexport class TimelineFrameModel {\n  #frames: TimelineFrame[] = [];\n  #frameById: Record<number, TimelineFrame> = {};\n  #beginFrameQueue: TimelineFrameBeginFrameQueue = new TimelineFrameBeginFrameQueue();\n  #lastFrame: TimelineFrame|null = null;\n  #mainFrameCommitted = false;\n  #mainFrameRequested = false;\n  #lastLayerTree: Types.Events.LegacyFrameLayerTreeData|null = null;\n  #framePendingActivation: PendingFrame|null = null;\n  #framePendingCommit: PendingFrame|null = null;\n  #lastBeginFrame: number|null = null;\n  #lastNeedsBeginFrame: number|null = null;\n  #lastTaskBeginTime: Types.Timing.Micro|null = null;\n  #layerTreeId: number|null = null;\n  #activeProcessId: Types.Events.ProcessID|null = null;\n  #activeThreadId: Types.Events.ThreadID|null = null;\n  #layerTreeData: LayerTreeData;\n\n  constructor(\n      allEvents: readonly Types.Events.Event[], rendererData: RendererHandlerData,\n      auctionWorkletsData: AuctionWorkletsData, metaData: MetaHandlerData, layerTreeData: LayerTreeData) {\n    // We only care about getting threads from the Renderer, not Samples,\n    // because Frames don't exist in a CPU Profile (which won't have Renderer\n    // threads.)\n    const mainThreads = Threads.threadsInRenderer(rendererData, auctionWorkletsData).filter(thread => {\n      return thread.type === Threads.ThreadType.MAIN_THREAD && thread.processIsOnMainFrame;\n    });\n    const threadData = mainThreads.map(thread => {\n      return {\n        tid: thread.tid,\n        pid: thread.pid,\n        startTime: thread.entries[0].ts,\n      };\n    });\n\n    this.#layerTreeData = layerTreeData;\n    this.#addTraceEvents(allEvents, threadData, metaData.mainFrameId);\n  }\n\n  framesById(): Readonly<Record<number, TimelineFrame|undefined>> {\n    return this.#frameById;\n  }\n\n  frames(): TimelineFrame[] {\n    return this.#frames;\n  }\n\n  #handleBeginFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n    this.#lastBeginFrame = startTime;\n\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);\n  }\n\n  #handleDroppedFrame(startTime: Types.Timing.Micro, seqId: number, isPartial: boolean): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n\n    // This line handles the case where no BeginFrame event is issued for\n    // the dropped frame. In this situation, add a BeginFrame to the queue\n    // as if it actually occurred.\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);\n    this.#beginFrameQueue.setDropped(seqId, true);\n    this.#beginFrameQueue.setPartial(seqId, isPartial);\n  }\n\n  #handleDrawFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n      return;\n    }\n\n    // - if it wasn't drawn, it didn't happen!\n    // - only show frames that either did not wait for the main thread frame or had one committed.\n    if (this.#mainFrameCommitted || !this.#mainFrameRequested) {\n      if (this.#lastNeedsBeginFrame) {\n        const idleTimeEnd = this.#framePendingActivation ? this.#framePendingActivation.triggerTime :\n                                                           (this.#lastBeginFrame || this.#lastNeedsBeginFrame);\n        if (idleTimeEnd > this.#lastFrame.startTime) {\n          this.#lastFrame.idle = true;\n          this.#lastBeginFrame = null;\n        }\n        this.#lastNeedsBeginFrame = null;\n      }\n\n      const framesToVisualize = this.#beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);\n\n      // Visualize the current frame and all pending frames before it.\n      for (const frame of framesToVisualize) {\n        const isLastFrameIdle = this.#lastFrame.idle;\n\n        // If |frame| is the first frame after an idle period, the CPU time\n        // will be logged (\"committed\") under |frame| if applicable.\n        this.#startFrame(frame.startTime, seqId);\n        if (isLastFrameIdle && this.#framePendingActivation) {\n          this.#commitPendingFrame();\n        }\n        if (frame.isDropped) {\n          this.#lastFrame.dropped = true;\n        }\n        if (frame.isPartial) {\n          this.#lastFrame.isPartial = true;\n        }\n      }\n    }\n    this.#mainFrameCommitted = false;\n  }\n\n  #handleActivateLayerTree(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    if (this.#framePendingActivation && !this.#lastNeedsBeginFrame) {\n      this.#commitPendingFrame();\n    }\n  }\n\n  #handleRequestMainThreadFrame(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    this.#mainFrameRequested = true;\n  }\n\n  #handleCommit(): void {\n    if (!this.#framePendingCommit) {\n      return;\n    }\n    this.#framePendingActivation = this.#framePendingCommit;\n    this.#framePendingCommit = null;\n    this.#mainFrameRequested = false;\n    this.#mainFrameCommitted = true;\n  }\n\n  #handleLayerTreeSnapshot(layerTree: Types.Events.LegacyFrameLayerTreeData): void {\n    this.#lastLayerTree = layerTree;\n  }\n\n  #handleNeedFrameChanged(startTime: Types.Timing.Micro, needsBeginFrame: boolean): void {\n    if (needsBeginFrame) {\n      this.#lastNeedsBeginFrame = startTime;\n    }\n  }\n\n  #startFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (this.#lastFrame) {\n      this.#flushFrame(this.#lastFrame, startTime);\n    }\n    this.#lastFrame =\n        new TimelineFrame(seqId, startTime, Types.Timing.Micro(startTime - metaHandlerData().traceBounds.min));\n  }\n\n  #flushFrame(frame: TimelineFrame, endTime: Types.Timing.Micro): void {\n    frame.setLayerTree(this.#lastLayerTree);\n    frame.setEndTime(endTime);\n    if (this.#lastLayerTree) {\n      this.#lastLayerTree.paints = frame.paints;\n    }\n    const lastFrame = this.#frames[this.#frames.length - 1];\n    if (this.#frames.length && lastFrame &&\n        (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {\n      console.assert(\n          false, `Inconsistent frame time for frame ${this.#frames.length} (${frame.startTime} - ${frame.endTime})`);\n    }\n    const newFramesLength = this.#frames.push(frame);\n    frame.setIndex(newFramesLength - 1);\n    if (typeof frame.mainFrameId === 'number') {\n      this.#frameById[frame.mainFrameId] = frame;\n    }\n  }\n\n  #commitPendingFrame(): void {\n    if (!this.#framePendingActivation || !this.#lastFrame) {\n      return;\n    }\n\n    this.#lastFrame.paints = this.#framePendingActivation.paints;\n    this.#lastFrame.mainFrameId = this.#framePendingActivation.mainFrameId;\n    this.#framePendingActivation = null;\n  }\n\n  #addTraceEvents(\n      events: readonly Types.Events.Event[], threadData: Array<{\n        pid: Types.Events.ProcessID,\n        tid: Types.Events.ThreadID,\n        startTime: Types.Timing.Micro,\n      }>,\n      mainFrameId: string): void {\n    let j = 0;\n    this.#activeThreadId = threadData.length && threadData[0].tid || null;\n    this.#activeProcessId = threadData.length && threadData[0].pid || null;\n    for (let i = 0; i < events.length; ++i) {\n      while (j + 1 < threadData.length && threadData[j + 1].startTime <= events[i].ts) {\n        this.#activeThreadId = threadData[++j].tid;\n        this.#activeProcessId = threadData[j].pid;\n      }\n      this.#addTraceEvent(events[i], mainFrameId);\n    }\n    this.#activeThreadId = null;\n    this.#activeProcessId = null;\n  }\n\n  #addTraceEvent(event: Types.Events.Event, mainFrameId: string): void {\n    if (Types.Events.isSetLayerId(event) && event.args.data.frame === mainFrameId) {\n      this.#layerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isLayerTreeHostImplSnapshot(event) && Number(event.id) === this.#layerTreeId) {\n      this.#handleLayerTreeSnapshot({\n        entry: event,\n        paints: [],\n      });\n    } else {\n      if (isFrameEvent(event)) {\n        this.#processCompositorEvents(event);\n      }\n      // Make sure we only use events from the main thread: we check the PID as\n      // well in case two processes have a thread with the same TID.\n      if (event.tid === this.#activeThreadId && event.pid === this.#activeProcessId) {\n        this.#addMainThreadTraceEvent(event);\n      }\n    }\n  }\n\n  #processCompositorEvents(entry: FrameEvent): void {\n    if (entry.args['layerTreeId'] !== this.#layerTreeId) {\n      return;\n    }\n    if (Types.Events.isBeginFrame(entry)) {\n      this.#handleBeginFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isDrawFrame(entry)) {\n      this.#handleDrawFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isActivateLayerTree(entry)) {\n      this.#handleActivateLayerTree();\n    } else if (Types.Events.isRequestMainThreadFrame(entry)) {\n      this.#handleRequestMainThreadFrame();\n    } else if (Types.Events.isNeedsBeginFrameChanged(entry)) {\n      // needsBeginFrame property will either be 0 or 1, which represents\n      // true/false in this case, hence the Boolean() wrapper.\n      this.#handleNeedFrameChanged(entry.ts, entry.args['data'] && Boolean(entry.args['data']['needsBeginFrame']));\n    } else if (Types.Events.isDroppedFrame(entry)) {\n      this.#handleDroppedFrame(entry.ts, entry.args['frameSeqId'], Boolean(entry.args['hasPartialUpdate']));\n    }\n  }\n\n  #addMainThreadTraceEvent(entry: Types.Events.Event): void {\n    if (entryIsTopLevel(entry)) {\n      this.#lastTaskBeginTime = entry.ts;\n    }\n    if (!this.#framePendingCommit && MAIN_FRAME_MARKERS.has(entry.name as Types.Events.Name)) {\n      this.#framePendingCommit = new PendingFrame(this.#lastTaskBeginTime || entry.ts);\n    }\n    if (!this.#framePendingCommit) {\n      return;\n    }\n\n    if (Types.Events.isBeginMainThreadFrame(entry) && entry.args.data.frameId) {\n      this.#framePendingCommit.mainFrameId = entry.args.data.frameId;\n    }\n    if (Types.Events.isPaint(entry)) {\n      const snapshot = this.#layerTreeData.paintsToSnapshots.get(entry);\n      if (snapshot) {\n        this.#framePendingCommit.paints.push(new LayerPaintEvent(entry, snapshot));\n      }\n    }\n    // Commit will be replacing CompositeLayers but CompositeLayers is kept\n    // around for backwards compatibility.\n    if ((Types.Events.isCompositeLayers(entry) || Types.Events.isCommit(entry)) &&\n        entry.args['layerTreeId'] === this.#layerTreeId) {\n      this.#handleCommit();\n    }\n  }\n}\n\nconst MAIN_FRAME_MARKERS = new Set<Types.Events.Name>([\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.INVALIDATE_LAYOUT,\n  Types.Events.Name.BEGIN_MAIN_THREAD_FRAME,\n  Types.Events.Name.SCROLL_LAYER,\n]);\n\n/**\n * Legacy class that represents TimelineFrames that was ported from the old SDK.\n * This class is purposefully not exported as it breaks the abstraction that\n * every event shown on the timeline is a trace event. Instead, we use the Type\n * LegacyTimelineFrame to represent frames in the codebase. These do implement\n * the right interface to be treated just like they were a trace event.\n */\nclass TimelineFrame implements Types.Events.LegacyTimelineFrame {\n  // These fields exist to satisfy the base Event type which all\n  // \"trace events\" must implement. They aren't used, but doing this means we\n  // can pass `TimelineFrame` instances into places that expect\n  // Types.Events.Event.\n  cat = 'devtools.legacy_frame';\n  name = 'frame';\n  ph = Types.Events.Phase.COMPLETE;\n  ts: Types.Timing.Micro;\n  pid = Types.Events.ProcessID(-1);\n  tid = Types.Events.ThreadID(-1);\n\n  index = -1;\n  startTime: Types.Timing.Micro;\n  startTimeOffset: Types.Timing.Micro;\n  endTime: Types.Timing.Micro;\n  duration: Types.Timing.Micro;\n  idle: boolean;\n  dropped: boolean;\n  isPartial: boolean;\n  layerTree: Types.Events.LegacyFrameLayerTreeData|null;\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  readonly seqId: number;\n\n  constructor(seqId: number, startTime: Types.Timing.Micro, startTimeOffset: Types.Timing.Micro) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.ts = startTime;\n    this.startTimeOffset = startTimeOffset;\n    this.endTime = this.startTime;\n    this.duration = Types.Timing.Micro(0);\n    this.idle = false;\n    this.dropped = false;\n    this.isPartial = false;\n    this.layerTree = null;\n    this.paints = [];\n    this.mainFrameId = undefined;\n  }\n\n  setIndex(i: number): void {\n    this.index = i;\n  }\n\n  setEndTime(endTime: Types.Timing.Micro): void {\n    this.endTime = endTime;\n    this.duration = Types.Timing.Micro(this.endTime - this.startTime);\n  }\n\n  setLayerTree(layerTree: Types.Events.LegacyFrameLayerTreeData|null): void {\n    this.layerTree = layerTree;\n  }\n\n  /**\n   * Fake the `dur` field to meet the expected value given that we pretend\n   * these TimelineFrame classes are trace events across the codebase.\n   */\n  get dur(): Types.Timing.Micro {\n    return this.duration;\n  }\n}\n\nexport class LayerPaintEvent implements Types.Events.LegacyLayerPaintEvent {\n  readonly #event: Types.Events.Paint;\n  #snapshot: Types.Events.DisplayItemListSnapshot;\n\n  constructor(event: Types.Events.Paint, snapshot: Types.Events.DisplayItemListSnapshot) {\n    this.#event = event;\n    this.#snapshot = snapshot;\n  }\n\n  layerId(): number {\n    return this.#event.args.data.layerId;\n  }\n\n  event(): Types.Events.Paint {\n    return this.#event;\n  }\n\n  picture(): Types.Events.LegacyLayerPaintEventPicture|null {\n    const rect = this.#snapshot.args.snapshot.params?.layer_rect;\n    const pictureData = this.#snapshot.args.snapshot.skp64;\n    return rect && pictureData ? {rect, serializedPicture: pictureData} : null;\n  }\n}\n\nexport class PendingFrame {\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  triggerTime: number;\n  constructor(triggerTime: number) {\n    this.paints = [];\n    this.mainFrameId = undefined;\n    this.triggerTime = triggerTime;\n  }\n}\n\n// The parameters of an impl-side BeginFrame.\nclass BeginFrameInfo {\n  seqId: number;\n  startTime: Types.Timing.Micro;\n  isDropped: boolean;\n  isPartial: boolean;\n  constructor(seqId: number, startTime: Types.Timing.Micro, isDropped: boolean, isPartial: boolean) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.isDropped = isDropped;\n    this.isPartial = isPartial;\n  }\n}\n\n// A queue of BeginFrames pending visualization.\n// BeginFrames are added into this queue as they occur; later when their\n// corresponding DrawFrames occur (or lack thereof), the BeginFrames are removed\n// from the queue and their timestamps are used for visualization.\nexport class TimelineFrameBeginFrameQueue {\n  private queueFrames: number[] = [];\n\n  // Maps frameSeqId to BeginFrameInfo.\n  private mapFrames: Record<number, BeginFrameInfo> = {};\n\n  // Add a BeginFrame to the queue, if it does not already exit.\n  addFrameIfNotExists(seqId: number, startTime: Types.Timing.Micro, isDropped: boolean, isPartial: boolean): void {\n    if (!(seqId in this.mapFrames)) {\n      this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);\n      this.queueFrames.push(seqId);\n    }\n  }\n\n  // Set a BeginFrame in queue as dropped.\n  setDropped(seqId: number, isDropped: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isDropped = isDropped;\n    }\n  }\n\n  setPartial(seqId: number, isPartial: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isPartial = isPartial;\n    }\n  }\n\n  processPendingBeginFramesOnDrawFrame(seqId: number): BeginFrameInfo[] {\n    const framesToVisualize: BeginFrameInfo[] = [];\n\n    // Do not visualize this frame in the rare case where the current DrawFrame\n    // does not have a corresponding BeginFrame.\n    if (seqId in this.mapFrames) {\n      // Pop all BeginFrames before the current frame, and add only the dropped\n      // ones in |frames_to_visualize|.\n      // Non-dropped frames popped here are BeginFrames that are never\n      // drawn (but not considered dropped either for some reason).\n      // Those frames do not require an proactive visualization effort and will\n      // be naturally presented as continuationss of other frames.\n      while (this.queueFrames[0] !== seqId) {\n        const currentSeqId = this.queueFrames[0];\n        if (this.mapFrames[currentSeqId].isDropped) {\n          framesToVisualize.push(this.mapFrames[currentSeqId]);\n        }\n\n        delete this.mapFrames[currentSeqId];\n        this.queueFrames.shift();\n      }\n\n      // Pop the BeginFrame associated with the current DrawFrame.\n      framesToVisualize.push(this.mapFrames[seqId]);\n      delete this.mapFrames[seqId];\n      this.queueFrames.shift();\n    }\n    return framesToVisualize;\n  }\n}\n\nexport function framesWithinWindow(\n    frames: readonly Types.Events.LegacyTimelineFrame[], startTime: Types.Timing.Micro,\n    endTime: Types.Timing.Micro): Types.Events.LegacyTimelineFrame[] {\n  const firstFrame = Platform.ArrayUtilities.lowerBound(frames, startTime || 0, (time, frame) => time - frame.endTime);\n  const lastFrame =\n      Platform.ArrayUtilities.lowerBound(frames, endTime || Infinity, (time, frame) => time - frame.startTime);\n  return frames.slice(firstFrame, lastFrame);\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst paintEvents: Types.Events.Paint[] = [];\nconst snapshotEvents: Types.Events.DisplayItemListSnapshot[] = [];\nconst paintToSnapshotMap = new Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>();\n\nlet lastPaintForLayerId: Record<number, Types.Events.Paint> = {};\n\nlet currentMainFrameLayerTreeId: number|null = null;\nconst updateLayerEvents: Types.Events.UpdateLayer[] = [];\n\ntype RelevantLayerTreeEvent =\n    Types.Events.Paint|Types.Events.DisplayItemListSnapshot|Types.Events.UpdateLayer|Types.Events.SetLayerTreeId;\n\nconst relevantEvents: RelevantLayerTreeEvent[] = [];\nexport function reset(): void {\n  paintEvents.length = 0;\n  snapshotEvents.length = 0;\n  paintToSnapshotMap.clear();\n\n  lastPaintForLayerId = {};\n  currentMainFrameLayerTreeId = null;\n  updateLayerEvents.length = 0;\n  relevantEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // We gather up the events here but do all the processing in finalize(). This\n  // is because we need to have all the events before we process them, and we\n  // need the Meta handler to be finalized() so we can use its data as we need\n  // the mainFrameId to know which Layer(s) to care about.\n  if (Types.Events.isPaint(event) || Types.Events.isDisplayListItemListSnapshot(event) ||\n      Types.Events.isUpdateLayer(event) || Types.Events.isSetLayerId(event)) {\n    relevantEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const metaData = metaHandlerData();\n  Helpers.Trace.sortTraceEventsInPlace(relevantEvents);\n\n  for (const event of relevantEvents) {\n    if (Types.Events.isSetLayerId(event)) {\n      if (metaData.mainFrameId !== event.args.data.frame) {\n        // We only care about LayerId changes that affect the main frame.\n        continue;\n      }\n      currentMainFrameLayerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isUpdateLayer(event)) {\n      // We don't do anything with this event, but we need to store it because\n      // the information in it determines if we need to care about future\n      // snapshot events - we need to know what the active layer is when we see a\n      // snapshot.\n      updateLayerEvents.push(event);\n    } else if (Types.Events.isPaint(event)) {\n      if (!event.args.data.layerId) {\n        // Note that this check purposefully includes excluding an event with a layerId of 0.\n        // 0 indicates that this paint was for a subframe - we do not want these\n        // as we only care about paints for top level frames.\n        continue;\n      }\n      paintEvents.push(event);\n      lastPaintForLayerId[event.args.data.layerId] = event;\n      continue;\n    } else if (Types.Events.isDisplayListItemListSnapshot(event)) {\n      // First we figure out which layer is active for this event's thread. To\n      // do this we work backwards through the list of UpdateLayerEvents,\n      // finding the first one (i.e. the most recent one) with the same pid and\n      // tid.\n      let lastUpdateLayerEventForThread: Types.Events.UpdateLayer|null = null;\n      for (let i = updateLayerEvents.length - 1; i > -1; i--) {\n        const updateEvent = updateLayerEvents[i];\n        if (updateEvent.pid === event.pid && updateEvent.tid === event.tid) {\n          lastUpdateLayerEventForThread = updateEvent;\n          break;\n        }\n      }\n      if (!lastUpdateLayerEventForThread) {\n        // No active layer, so this snapshot is not relevant.\n        continue;\n      }\n      if (lastUpdateLayerEventForThread.args.layerTreeId !== currentMainFrameLayerTreeId) {\n        // Snapshot applies to a layer that is not the main frame, so discard.\n        continue;\n      }\n      const paintEvent = lastPaintForLayerId[lastUpdateLayerEventForThread.args.layerId];\n      if (!paintEvent) {\n        // No paint event for this layer, so discard.\n        continue;\n      }\n      snapshotEvents.push(event);\n\n      // Store the relationship between the paint and the snapshot.\n      paintToSnapshotMap.set(paintEvent, event);\n    }\n  }\n}\n\nexport interface LayerTreeData {\n  paints: Types.Events.Paint[];\n  snapshots: Types.Events.DisplayItemListSnapshot[];\n  paintsToSnapshots: Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>;\n}\n\nexport function data(): LayerTreeData {\n  return {\n    paints: paintEvents,\n    snapshots: snapshotEvents,\n    paintsToSnapshots: paintToSnapshotMap,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport type * as Helpers from '../helpers/helpers.js';\nimport type * as Types from '../types/types.js';\n\nimport type {AuctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport type * as Renderer from './RendererHandler.js';\nimport type {ParsedTrace} from './types.js';\n\nexport interface ThreadData {\n  pid: Types.Events.ProcessID;\n  tid: Types.Events.ThreadID;\n  entries: readonly Types.Events.Event[];\n  processIsOnMainFrame: boolean;\n  tree: Helpers.TreeHelpers.TraceEntryTree;\n  type: ThreadType;\n  name: string|null;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n}\n\nexport const enum ThreadType {\n  MAIN_THREAD = 'MAIN_THREAD',\n  WORKER = 'WORKER',\n  RASTERIZER = 'RASTERIZER',\n  AUCTION_WORKLET = 'AUCTION_WORKLET',\n  OTHER = 'OTHER',\n  CPU_PROFILE = 'CPU_PROFILE',\n  THREAD_POOL = 'THREAD_POOL',\n}\n\nfunction getThreadTypeForRendererThread(\n    pid: Types.Events.ProcessID, thread: Renderer.RendererThread,\n    auctionWorkletsData: AuctionWorkletsData): ThreadType {\n  let threadType = ThreadType.OTHER;\n  if (thread.name === 'CrRendererMain') {\n    threadType = ThreadType.MAIN_THREAD;\n  } else if (thread.name === 'DedicatedWorker thread') {\n    threadType = ThreadType.WORKER;\n  } else if (thread.name?.startsWith('CompositorTileWorker')) {\n    threadType = ThreadType.RASTERIZER;\n  } else if (auctionWorkletsData.worklets.has(pid)) {\n    threadType = ThreadType.AUCTION_WORKLET;\n  } else if (thread.name?.startsWith('ThreadPool')) {\n    // TODO(paulirish): perhaps exclude ThreadPoolServiceThread entirely\n    threadType = ThreadType.THREAD_POOL;\n  }\n  return threadType;\n}\n\nexport function threadsInRenderer(\n    rendererData: Renderer.RendererHandlerData, auctionWorkletsData: AuctionWorkletsData): readonly ThreadData[] {\n  const foundThreads: ThreadData[] = [];\n  // If we have Renderer threads, we prefer to use those. In the event that a\n  // trace is a CPU Profile trace, we will never have Renderer threads, so we\n  // know if there are no Renderer threads that we can fallback to using the\n  // data from the SamplesHandler.\n  if (rendererData.processes.size) {\n    for (const [pid, process] of rendererData.processes) {\n      for (const [tid, thread] of process.threads) {\n        if (!thread.tree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n        const threadType = getThreadTypeForRendererThread(pid, thread, auctionWorkletsData);\n        foundThreads.push({\n          name: thread.name,\n          pid,\n          tid,\n          processIsOnMainFrame: process.isOnMainFrame,\n          entries: thread.entries,\n          tree: thread.tree,\n          type: threadType,\n          entryToNode: rendererData.entryToNode,\n        });\n      }\n    }\n  }\n  return foundThreads;\n}\n\nconst threadsInTraceCache = new WeakMap<ParsedTrace, readonly ThreadData[]>();\n\n/**\n * Given trace parsed data, this helper will return a high level array of\n * ThreadData. This is useful because it allows you to get a list of threads\n * regardless of if the trace is a CPU Profile or a Tracing profile. Thus you\n * can use this helper to iterate over threads in confidence that it will work\n * for both trace types.\n * The resulting data is cached per-trace, so you can safely call this multiple times.\n */\nexport function threadsInTrace(parsedTrace: ParsedTrace): readonly ThreadData[] {\n  const cached = threadsInTraceCache.get(parsedTrace);\n  if (cached) {\n    return cached;\n  }\n\n  // If we have Renderer threads, we prefer to use those.\n  const threadsFromRenderer = threadsInRenderer(parsedTrace.Renderer, parsedTrace.AuctionWorklets);\n  if (threadsFromRenderer.length) {\n    threadsInTraceCache.set(parsedTrace, threadsFromRenderer);\n    return threadsFromRenderer;\n  }\n\n  // If it's a CPU Profile trace, there will be no Renderer threads.\n  // We can fallback to using the data from the SamplesHandler.\n  const foundThreads: ThreadData[] = [];\n  if (parsedTrace.Samples.profilesInProcess.size) {\n    for (const [pid, process] of parsedTrace.Samples.profilesInProcess) {\n      for (const [tid, thread] of process) {\n        if (!thread.profileTree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n\n        foundThreads.push({\n          pid,\n          tid,\n          // CPU Profile threads do not have a name.\n          name: null,\n          entries: thread.profileCalls,\n          // There is no concept of a \"Main Frame\" in a CPU profile.\n          processIsOnMainFrame: false,\n          tree: thread.profileTree,\n          type: ThreadType.CPU_PROFILE,\n          entryToNode: parsedTrace.Samples.entryToNode,\n        });\n      }\n    }\n  }\n\n  threadsInTraceCache.set(parsedTrace, foundThreads);\n  return foundThreads;\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nconst eventsInProcessThread = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.GPUTask[]>>();\n\nlet mainGPUThreadTasks: Types.Events.GPUTask[] = [];\n\nexport function reset(): void {\n  eventsInProcessThread.clear();\n  mainGPUThreadTasks = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isGPUTask(event)) {\n    return;\n  }\n\n  Helpers.Trace.addEventToProcessThread(event, eventsInProcessThread);\n}\n\nexport async function finalize(): Promise<void> {\n  const {gpuProcessId, gpuThreadId} = metaHandlerData();\n  const gpuThreadsForProcess = eventsInProcessThread.get(gpuProcessId);\n  if (gpuThreadsForProcess && gpuThreadId) {\n    mainGPUThreadTasks = gpuThreadsForProcess.get(gpuThreadId) || [];\n  }\n}\n\nexport interface GPUHandlerReturnData {\n  mainGPUThreadTasks: readonly Types.Events.GPUTask[];\n}\n\nexport function data(): GPUHandlerReturnData {\n  return {\n    mainGPUThreadTasks,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\n\n/**\n * This handler is responsible for the relationships between:\n * DecodeImage/ResizeImage, PaintImage and DrawLazyPixelRef events.\n *\n * When we get a DecodeImage event, we want to associate it to a PaintImage\n * event, primarily so we can determine the NodeID of the image that was\n * decoded.\n * We can do this in two ways:\n *\n * 1. If there is a PaintImage event on the same thread, use that\n *    (if there are multiple, use the latest one).\n *\n * 2. If not, we can find the DecodeLazyPixelRef event on the same thread, and\n *    use the PaintImage event associated with it via the `LazyPixelRef` key.\n */\n\n// Track paintImageEvents across threads.\nconst paintImageEvents = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.PaintImage[]>>();\nconst decodeLazyPixelRefEvents =\n    new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>>();\n\n// A DrawLazyPixelRef event will contain a numerical reference in\n// args.LazyPixelRef. As we parse each DrawLazyPixelRef, we can assign it to a\n// paint event. Later we want to look up paint events by this reference, so we\n// store them in this map.\nconst paintImageByLazyPixelRef = new Map<number, Types.Events.PaintImage>();\n\n// When we find events that we want to tie to a particular PaintImage event, we add them to this map.\n// These are currently only DecodeImage and ResizeImage events, but the type is\n// deliberately generic as in the future we might want to add more events that\n// have a relationship to a individual PaintImage event.\nconst eventToPaintImage = new Map<Types.Events.Event, Types.Events.PaintImage>();\n\nconst urlToPaintImage = new Map<string, Types.Events.PaintImage[]>();\n\nconst paintEventToCorrectedDisplaySize = new Map<Types.Events.PaintImage, {width: number, height: number}>();\n\nlet didCorrectForHostDpr = false;\n\nexport function reset(): void {\n  paintImageEvents.clear();\n  decodeLazyPixelRefEvents.clear();\n  paintImageByLazyPixelRef.clear();\n  eventToPaintImage.clear();\n  urlToPaintImage.clear();\n  paintEventToCorrectedDisplaySize.clear();\n  didCorrectForHostDpr = false;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isPaintImage(event)) {\n    const forProcess = paintImageEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.PaintImage[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    paintImageEvents.set(event.pid, forProcess);\n\n    if (event.args.data.url) {\n      const paintsForUrl = Platform.MapUtilities.getWithDefault(urlToPaintImage, event.args.data.url, () => []);\n      paintsForUrl.push(event);\n    }\n\n    return;\n  }\n\n  if (Types.Events.isDecodeLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    // Store these because we use them to tie DecodeImage to a PaintEvent.\n    const forProcess =\n        decodeLazyPixelRefEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    decodeLazyPixelRefEvents.set(event.pid, forProcess);\n  }\n\n  // If we see a DrawLazyPixelRef event, we need to find the last PaintImage\n  // event on the thread and associate it to the LazyPixelRef that is supplied\n  // in the DrawLazyPixelRef event.\n  // This means that later on if we see a DecodeLazyPixelRef event with the\n  // same LazyPixelRef key, we can find its associated PaintImage event by\n  // looking it up.\n  if (Types.Events.isDrawLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    const lastPaintEvent = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (!lastPaintEvent) {\n      return;\n    }\n    paintImageByLazyPixelRef.set(event.args.LazyPixelRef, lastPaintEvent);\n    return;\n  }\n\n  if (Types.Events.isDecodeImage(event)) {\n    // When we see a DecodeImage, we want to associate it to a PaintImage\n    // event. We try two approaches:\n    //\n    // 1. If the thread of the DecodeImage event has a previous PaintImage\n    // event, that is the associated event.\n    //\n    // 2. If that is false, we then look on the thread for a DecodeLazyPixelRef\n    // event. If we find that, we then look for its associated PaintImage\n    // event, which we associate via DrawLazyPixelRef events (the code block\n    // above this one)\n    //\n    // 1. Find a PaintImage event on the same thread. If we find it, that's our association done.\n    const lastPaintImageEventOnThread = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (lastPaintImageEventOnThread) {\n      eventToPaintImage.set(event, lastPaintImageEventOnThread);\n      return;\n    }\n\n    // 2. Find the last DecodeLazyPixelRef event and, if we find it, find its associated PaintImage event.\n    const lastDecodeLazyPixelRef = decodeLazyPixelRefEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (typeof lastDecodeLazyPixelRef?.args?.LazyPixelRef === 'undefined') {\n      return;\n    }\n\n    const paintEvent = paintImageByLazyPixelRef.get(lastDecodeLazyPixelRef.args.LazyPixelRef);\n    if (!paintEvent) {\n      return;\n    }\n    eventToPaintImage.set(event, paintEvent);\n  }\n}\n\nexport async function finalize(options: Types.Configuration.ParseOptions): Promise<void> {\n  // Painting in Chrome never uses the emulated DPR, but instead used the host's DPR.\n  // We need to correct for that for our responsive image checks in the ImageDelivery\n  // insight.\n  // See: crbug.com/427552461 crbug.com/416580500#comment5\n\n  if (!options.metadata?.hostDPR) {\n    return;\n  }\n\n  // Note: this isn't necessarily emulated (for desktop+no DPR emulation, it's equal\n  // to host DPR).\n  const {devicePixelRatio: emulatedDpr} = metaHandlerData();\n  if (!emulatedDpr) {\n    return;\n  }\n\n  for (const byThread of paintImageEvents.values()) {\n    for (const paintEvents of byThread.values()) {\n      for (const paintEvent of paintEvents) {\n        const cssPixelsWidth = paintEvent.args.data.width / options.metadata.hostDPR;\n        const cssPixelsHeight = paintEvent.args.data.height / options.metadata.hostDPR;\n        const width = cssPixelsWidth * emulatedDpr;\n        const height = cssPixelsHeight * emulatedDpr;\n        paintEventToCorrectedDisplaySize.set(paintEvent, {width, height});\n      }\n    }\n  }\n\n  didCorrectForHostDpr = true;\n}\n\nexport interface ImagePaintData {\n  paintImageByDrawLazyPixelRef: Map<number, Types.Events.PaintImage>;\n  paintImageForEvent: Map<Types.Events.Event, Types.Events.PaintImage>;\n  paintImageEventForUrl: Map<string, Types.Events.PaintImage[]>;\n  paintEventToCorrectedDisplaySize: Map<Types.Events.PaintImage, {width: number, height: number}>;\n  /** Go read the comment in finalize(). */\n  didCorrectForHostDpr: boolean;\n}\n\nexport function data(): ImagePaintData {\n  return {\n    paintImageByDrawLazyPixelRef: paintImageByLazyPixelRef,\n    paintImageForEvent: eventToPaintImage,\n    paintImageEventForUrl: urlToPaintImage,\n    paintEventToCorrectedDisplaySize,\n    didCorrectForHostDpr,\n  };\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as AsyncJSCallsHandlerData} from './AsyncJSCallsHandler.js';\nimport {data as flowsHandlerData} from './FlowsHandler.js';\n\nconst lastScheduleStyleRecalcByFrame = new Map<string, Types.Events.ScheduleStyleRecalculation>();\n\n// This tracks the last event that is considered to have invalidated the layout\n// for a given frame.\n// Note that although there is an InvalidateLayout event, there are also other\n// events (ScheduleStyleRecalculation) that could be the reason a layout was\n// invalidated.\nconst lastInvalidationEventForFrame = new Map<string, Types.Events.Event>();\n\n// Important: although the event is called UpdateLayoutTree, in the UI we\n// present these to the user as \"Recalculate Style\". So don't get confused!\n// These are the same - just UpdateLayoutTree is what the event from Chromium\n// is called.\nconst lastUpdateLayoutTreeByFrame = new Map<string, Types.Events.UpdateLayoutTree>();\n\n// These two maps store the same data but in different directions.\n// For a given event, tell me what its initiator was. An event can only have one initiator.\nconst eventToInitiatorMap = new Map<Types.Events.Event, Types.Events.Event>();\n// For a given event, tell me what events it initiated. An event can initiate\n// multiple events, hence why the value for this map is an array.\nconst initiatorToEventsMap = new Map<Types.Events.Event, Types.Events.Event[]>();\n\nconst webSocketCreateEventsById = new Map<number, Types.Events.WebSocketCreate>();\nconst schedulePostTaskCallbackEventsById = new Map<number, Types.Events.SchedulePostTaskCallback>();\n\nexport function reset(): void {\n  lastScheduleStyleRecalcByFrame.clear();\n  lastInvalidationEventForFrame.clear();\n  lastUpdateLayoutTreeByFrame.clear();\n  eventToInitiatorMap.clear();\n  initiatorToEventsMap.clear();\n  webSocketCreateEventsById.clear();\n  schedulePostTaskCallbackEventsById.clear();\n}\n\nfunction storeInitiator(data: {initiator: Types.Events.Event, event: Types.Events.Event}): void {\n  eventToInitiatorMap.set(data.event, data.initiator);\n  const eventsForInitiator = initiatorToEventsMap.get(data.initiator) || [];\n  eventsForInitiator.push(data.event);\n  initiatorToEventsMap.set(data.initiator, eventsForInitiator);\n}\n\n/**\n * IMPORTANT: Before adding support for new initiator relationships in\n * trace events consider using Perfetto's flow API on the events in\n * question, so that they get automatically computed.\n * @see {@link flowsHandlerData}\n *\n * The events manually computed here were added before we had support\n * for flow events. As such they should be migrated to use the flow\n * API so that no manual parsing is needed.\n */\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isScheduleStyleRecalculation(event)) {\n    lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);\n  } else if (Types.Events.isUpdateLayoutTree(event)) {\n    // IMPORTANT: although the trace event is called UpdateLayoutTree, this\n    // represents a Styles Recalculation. This event in the timeline is shown to\n    // the user as \"Recalculate Styles.\"\n    if (event.args.beginData) {\n      // Store the last UpdateLayout event: we use this when we see an\n      // InvalidateLayout and try to figure out its initiator.\n      lastUpdateLayoutTreeByFrame.set(event.args.beginData.frame, event);\n\n      // If this frame has seen a ScheduleStyleRecalc event, then that event is\n      // considered to be the initiator of this StylesRecalc.\n      const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);\n      if (scheduledStyleForFrame) {\n        storeInitiator({\n          event,\n          initiator: scheduledStyleForFrame,\n        });\n      }\n    }\n  } else if (Types.Events.isInvalidateLayout(event)) {\n    // By default, the InvalidateLayout event is what triggered the layout invalidation for this frame.\n    let invalidationInitiator: Types.Events.Event = event;\n\n    // However, if we have not had any prior invalidations for this frame, we\n    // want to consider StyleRecalculation events as they might be the actual\n    // cause of this layout invalidation.\n    if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {\n      // 1. If we have not had an invalidation event for this frame\n      // 2. AND we have had an UpdateLayoutTree for this frame\n      // 3. AND the UpdateLayoutTree event ended AFTER the InvalidateLayout startTime\n      // 4. AND we have an initiator for the UpdateLayoutTree event\n      // 5. Then we set the last invalidation event for this frame to be the UpdateLayoutTree's initiator.\n      const lastUpdateLayoutTreeForFrame = lastUpdateLayoutTreeByFrame.get(event.args.data.frame);\n      if (lastUpdateLayoutTreeForFrame) {\n        const {endTime} = Helpers.Timing.eventTimingsMicroSeconds(lastUpdateLayoutTreeForFrame);\n        const initiatorOfUpdateLayout = eventToInitiatorMap.get(lastUpdateLayoutTreeForFrame);\n\n        if (initiatorOfUpdateLayout && endTime && endTime > event.ts) {\n          invalidationInitiator = initiatorOfUpdateLayout;\n        }\n      }\n    }\n    lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);\n  } else if (Types.Events.isLayout(event)) {\n    // The initiator of a Layout event is the last Invalidation event.\n    const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);\n    if (lastInvalidation) {\n      storeInitiator({\n        event,\n        initiator: lastInvalidation,\n      });\n    }\n    // Now clear the last invalidation for the frame: the last invalidation has been linked to a Layout event, so it cannot be the initiator for any future layouts.\n    lastInvalidationEventForFrame.delete(event.args.beginData.frame);\n  } else if (Types.Events.isWebSocketCreate(event)) {\n    webSocketCreateEventsById.set(event.args.data.identifier, event);\n  } else if (Types.Events.isWebSocketInfo(event) || Types.Events.isWebSocketTransfer(event)) {\n    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n    if (matchingCreateEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingCreateEvent,\n      });\n    }\n  } else if (Types.Events.isSchedulePostTaskCallback(event)) {\n    schedulePostTaskCallbackEventsById.set(event.args.data.taskId, event);\n  } else if (Types.Events.isRunPostTaskCallback(event) || Types.Events.isAbortPostTaskCallback(event)) {\n    const matchingSchedule = schedulePostTaskCallbackEventsById.get(event.args.data.taskId);\n    if (matchingSchedule) {\n      storeInitiator({event, initiator: matchingSchedule});\n    }\n  }\n}\n\nfunction createRelationshipsFromFlows(): void {\n  const flows = flowsHandlerData().flows;\n  for (let i = 0; i < flows.length; i++) {\n    const flow = flows[i];\n    for (let j = 0; j < flow.length - 1; j++) {\n      storeInitiator({event: flow[j + 1], initiator: flow[j]});\n    }\n  }\n}\n\nfunction createRelationshipsFromAsyncJSCalls(): void {\n  const asyncCallEntries = AsyncJSCallsHandlerData().schedulerToRunEntryPoints.entries();\n  for (const [asyncCaller, asyncCallees] of asyncCallEntries) {\n    for (const asyncCallee of asyncCallees) {\n      storeInitiator({event: asyncCallee, initiator: asyncCaller});\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  createRelationshipsFromFlows();\n  createRelationshipsFromAsyncJSCalls();\n}\n\nexport interface InitiatorsData {\n  eventToInitiator: Map<Types.Events.Event, Types.Events.Event>;\n  initiatorToEvents: Map<Types.Events.Event, Types.Events.Event[]>;\n}\n\nexport function data(): InitiatorsData {\n  return {\n    eventToInitiator: eventToInitiatorMap,\n    initiatorToEvents: initiatorToEventsMap,\n  };\n}\n\nexport function deps(): ['Flows', 'AsyncJSCalls'] {\n  return ['Flows', 'AsyncJSCalls'];\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nconst invalidationsForEvent = new Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>();\nconst invalidationCountForEvent = new Map<Types.Events.Event, number>();\n\nlet lastRecalcStyleEvent: Types.Events.UpdateLayoutTree|null = null;\n\n// Used to track paints so we track invalidations correctly per paint.\nlet hasPainted = false;\n\nconst allInvalidationTrackingEvents: Types.Events.InvalidationTrackingEvent[] = [];\n\nexport function reset(): void {\n  invalidationsForEvent.clear();\n  invalidationCountForEvent.clear();\n  lastRecalcStyleEvent = null;\n  allInvalidationTrackingEvents.length = 0;\n  hasPainted = false;\n  maxInvalidationsPerEvent = null;\n}\n\nlet maxInvalidationsPerEvent: number|null = null;\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  maxInvalidationsPerEvent = userConfig.maxInvalidationEventsPerEvent;\n}\n\nfunction addInvalidationToEvent(event: Types.Events.Event, invalidation: Types.Events.InvalidationTrackingEvent): void {\n  const existingInvalidations = invalidationsForEvent.get(event) || [];\n  existingInvalidations.push(invalidation);\n\n  if (maxInvalidationsPerEvent !== null && existingInvalidations.length > maxInvalidationsPerEvent) {\n    existingInvalidations.shift();\n  }\n  invalidationsForEvent.set(event, existingInvalidations);\n\n  const count = invalidationCountForEvent.get(event) ?? 0;\n  invalidationCountForEvent.set(event, count + 1);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // Special case: if we have been configured to not store any invalidations,\n  // we take that as a sign that we don't even want to gather any invalidations\n  // data at all and early exit.\n  if (maxInvalidationsPerEvent === 0) {\n    return;\n  }\n\n  if (Types.Events.isUpdateLayoutTree(event)) {\n    lastRecalcStyleEvent = event;\n\n    // Associate any prior invalidations with this recalc event.\n    for (const invalidation of allInvalidationTrackingEvents) {\n      if (Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        // LayoutInvalidation events cannot be associated with a LayoutTree\n        // event.\n        continue;\n      }\n\n      const recalcFrameId = lastRecalcStyleEvent.args.beginData?.frame;\n\n      if (recalcFrameId && invalidation.args.data.frame === recalcFrameId) {\n        addInvalidationToEvent(event, invalidation);\n      }\n    }\n    return;\n  }\n\n  if (Types.Events.isInvalidationTracking(event)) {\n    if (hasPainted) {\n      // If we have painted, then we can clear out the list of all existing\n      // invalidations, as we cannot associate them across frames.\n      allInvalidationTrackingEvents.length = 0;\n      lastRecalcStyleEvent = null;\n      hasPainted = false;\n    }\n\n    // Style invalidation events can occur before and during recalc styles. When we get a recalc style event (aka UpdateLayoutTree), we check and associate any prior invalidations with it.\n    // But any invalidations that occur during a UpdateLayoutTree\n    // event would be reported in trace events after. So each time we get an\n    // invalidation that might be due to a style recalc, we check if the\n    // timings overlap and if so associate them.\n    if (lastRecalcStyleEvent &&\n        (Types.Events.isScheduleStyleInvalidationTracking(event) ||\n         Types.Events.isStyleRecalcInvalidationTracking(event) ||\n         Types.Events.isStyleInvalidatorInvalidationTracking(event))) {\n      const recalcEndTime = lastRecalcStyleEvent.ts + (lastRecalcStyleEvent.dur || 0);\n      if (event.ts >= lastRecalcStyleEvent.ts && event.ts <= recalcEndTime &&\n          lastRecalcStyleEvent.args.beginData?.frame === event.args.data.frame) {\n        addInvalidationToEvent(lastRecalcStyleEvent, event);\n      }\n    }\n\n    allInvalidationTrackingEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isPaint(event)) {\n    // Used to ensure that we do not create relationships across frames.\n    hasPainted = true;\n    return;\n  }\n\n  if (Types.Events.isLayout(event)) {\n    const layoutFrame = event.args.beginData.frame;\n    for (const invalidation of allInvalidationTrackingEvents) {\n      // The only invalidations that cause a Layout are LayoutInvalidations :)\n      if (!Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        continue;\n      }\n\n      if (invalidation.args.data.frame === layoutFrame) {\n        addInvalidationToEvent(event, invalidation);\n      }\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\ninterface InvalidationsData {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n}\n\nexport function data(): InvalidationsData {\n  return {\n    invalidationsForEvent,\n    invalidationCountForEvent,\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaData} from './MetaHandler.js';\nimport {data as networkRequestsData} from './NetworkRequestsHandler.js';\nimport {data as pageLoadMetricsData, MetricName} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * If the LCP resource was an image, and that image was fetched over the\n * network, we want to be able to find the network request in order to construct\n * the critical path for an LCP image.\n * Within the trace file there are `LargestImagePaint::Candidate` events.\n * Within their data object, they contain a `DOMNodeId` property, which maps to\n * the DOM Node ID for that image.\n *\n * This id maps exactly to the `data.nodeId` property that a\n * `LargestContentfulPaint::Candidate` will have. So, when we find an image\n * paint candidate, we can store it, keying it on the node ID.\n * Then, when it comes to finding the network request for an LCP image, we can\n * use the nodeId from the LCP candidate to find the image candidate. That image\n * candidate also contains a `imageUrl` property, which will have the full URL\n * to the image.\n *\n * `BackendNodeId`s are only unique within a given renderer process, so this is\n * also keyed on `ProcessId`.\n **/\nconst imagePaintsByNodeIdAndProcess =\n    new Map<Types.Events.ProcessID, Map<Protocol.DOM.BackendNodeId, Types.Events.LargestImagePaintCandidate>>();\nconst lcpRequestByNavigationId = new Map<string, Types.Events.SyntheticNetworkRequest>();\n\nexport function reset(): void {\n  imagePaintsByNodeIdAndProcess.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isLargestImagePaintCandidate(event) || !event.args.data) {\n    return;\n  }\n\n  const imagePaintsByNodeId =\n      Platform.MapUtilities.getWithDefault(imagePaintsByNodeIdAndProcess, event.pid, () => new Map());\n  imagePaintsByNodeId.set(event.args.data.DOMNodeId, event);\n}\n\nexport async function finalize(): Promise<void> {\n  const requests = networkRequestsData().byTime;\n  const {traceBounds, navigationsByNavigationId} = metaData();\n  const metricScoresByFrameId = pageLoadMetricsData().metricScoresByFrameId;\n\n  for (const [navigationId, navigation] of navigationsByNavigationId) {\n    const lcpMetric = metricScoresByFrameId.get(navigation.args.frame)?.get(navigationId)?.get(MetricName.LCP);\n    const lcpEvent = lcpMetric?.event;\n    if (!lcpEvent || !Types.Events.isLargestContentfulPaintCandidate(lcpEvent)) {\n      continue;\n    }\n\n    const nodeId = lcpEvent.args.data?.nodeId;\n    if (!nodeId) {\n      continue;\n    }\n\n    const lcpImagePaintEvent = imagePaintsByNodeIdAndProcess.get(lcpEvent.pid)?.get(nodeId);\n    const lcpUrl = lcpImagePaintEvent?.args.data?.imageUrl;\n    if (!lcpUrl) {\n      continue;\n    }\n\n    const startTime = navigation?.ts ?? traceBounds.min;\n    const endTime = lcpImagePaintEvent.ts;\n\n    let lcpRequest;\n    for (const request of requests) {\n      if (request.ts < startTime) {\n        continue;\n      }\n      if (request.ts >= endTime) {\n        break;\n      }\n\n      if (request.args.data.url === lcpUrl || request.args.data.redirects.some(r => r.url === lcpUrl)) {\n        lcpRequest = request;\n        break;\n      }\n    }\n\n    if (lcpRequest) {\n      lcpRequestByNavigationId.set(navigationId, lcpRequest);\n    }\n  }\n}\n\nexport interface LargestImagePaintData {\n  lcpRequestByNavigationId: Map<string, Types.Events.SyntheticNetworkRequest>;\n}\n\nexport function data(): LargestImagePaintData {\n  return {lcpRequestByNavigationId};\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'NetworkRequests', 'PageLoadMetrics'];\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This handler stores page load metrics, including web vitals,\n * and exports them in the shape of a map with the following shape:\n * Map(FrameId -> Map(navigationID -> metrics) )\n *\n * It also exports all markers in a trace in an array.\n *\n * Some metrics are taken directly from a page load events (AKA markers) like DCL.\n * Others require processing multiple events to be determined, like CLS and TBT.\n */\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\n// Small helpers to make the below type easier to read.\ntype FrameId = string;\ntype NavigationId = string;\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId = new Map<FrameId, Map<NavigationId, Map<MetricName, MetricScore>>>();\n\n/**\n * Page load events with no associated duration that happened in the\n * main frame.\n */\nlet allMarkerEvents: Types.Events.PageLoadEvent[] = [];\n\nexport function reset(): void {\n  metricScoresByFrameId.clear();\n  pageLoadEventsArray = [];\n  allMarkerEvents = [];\n  selectedLCPCandidateEvents.clear();\n}\n\nlet pageLoadEventsArray: Types.Events.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set<Types.Events.LargestContentfulPaintCandidate>();\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.Events.NavigationStart, event: Types.Events.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n\n  // If either of these pieces of data do not exist, the most likely\n  // explanation is that the page load metric we found is for a frame/process\n  // combo that the MetaHandler discarded. This typically happens if we get a\n  // navigation event with an empty URL. Therefore, we will silently return and\n  // drop this metric. If we didn't care about the navigation, we certainly do\n  // not need to care about metrics for that navigation.\n  const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);\n  if (!rendererProcessesInFrame) {\n    return;\n  }\n  const processData = rendererProcessesInFrame.get(event.pid);\n  if (!processData) {\n    return;\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    return;\n  }\n\n  if (Types.Events.isFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, metricName: MetricName.FCP, classification, navigation, timing: fcpTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isFirstPaint(event)) {\n    const paintTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const classification = ScoreClassification.UNCLASSIFIED;\n    const metricScore = {event, metricName: MetricName.FP, classification, navigation, timing: paintTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isMarkDOMContent(event)) {\n    const dclTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n      timing: dclTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isInteractiveTime(event)) {\n    const ttiValue = Types.Timing.Micro(event.ts - navigation.ts);\n    const tti = {\n      event,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n      timing: ttiValue,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue = Helpers.Timing.milliToMicro(Types.Timing.Milli(event.args.args.total_blocking_time_ms));\n    const tbt = {\n      event,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n      timing: tbtValue,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.Events.isMarkLoad(event)) {\n    const loadTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.L,\n      classification: ScoreClassification.UNCLASSIFIED,\n      navigation,\n      timing: loadTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const lcp = {\n      event,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n      timing: lcpTime,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.Events.isLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because we don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.Events.isLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nexport function getFrameIdForPageLoadEvent(event: Types.Events.PageLoadEvent): string {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLargestContentfulPaintCandidate(event) || Types.Events.isNavigationStart(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isFirstPaint(event)) {\n    return event.args.frame;\n  }\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.Events.PageLoadEvent): Types.Events.NavigationStart|null {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isLargestContentfulPaintCandidate(event) ||\n      Types.Events.isFirstPaint(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    // We don't want to compute metrics of the navigation relative to itself, so we'll avoid avoid all that.\n    return null;\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Gets all the Largest Contentful Paint scores of all the frames in the\n * trace.\n */\nfunction gatherFinalLCPEvents(): Types.Events.PageLoadEvent[] {\n  const allFinalLCPEvents: Types.Events.PageLoadEvent[] = [];\n  const dataForAllFrames = [...metricScoresByFrameId.values()];\n  const dataForAllNavigations = dataForAllFrames.flatMap(frameData => [...frameData.values()]);\n  for (let i = 0; i < dataForAllNavigations.length; i++) {\n    const navigationData = dataForAllNavigations[i];\n    const lcpInNavigation = navigationData.get(MetricName.LCP);\n    if (!lcpInNavigation?.event) {\n      continue;\n    }\n\n    allFinalLCPEvents.push(lcpInNavigation.event);\n  }\n  return allFinalLCPEvents;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  // NOTE: if you are looking for the TBT calculation, it has temporarily been\n  // removed. See crbug.com/1424335 for details.\n  const allFinalLCPEvents = gatherFinalLCPEvents();\n  const mainFrame = metaHandlerData().mainFrameId;\n  // Filter out LCP candidates to use only definitive LCP values\n  const allEventsButLCP = pageLoadEventsArray.filter(event => !Types.Events.isLargestContentfulPaintCandidate(event));\n  const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(Types.Events.isMarkerEvent);\n  // Filter by main frame and sort.\n  allMarkerEvents =\n      markerEvents.filter(event => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);\n}\n\nexport interface PageLoadMetricsData {\n  /**\n   * This represents the metric scores for all navigations, for all frames in a trace.\n   * Given a frame id, the map points to another map from navigation id to metric scores.\n   * The metric scores include the event related to the metric as well as the data regarding\n   * the score itself.\n   */\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>;\n  /**\n   * Page load events with no associated duration that happened in the\n   * main frame.\n   */\n  allMarkerEvents: Types.Events.PageLoadEvent[];\n}\n\nexport function data(): PageLoadMetricsData {\n  return {\n    metricScoresByFrameId,\n    allMarkerEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  // First Contentful Paint\n  FCP = 'FCP',\n  // First Paint\n  FP = 'FP',\n  // MarkLoad\n  L = 'L',\n  LCP = 'LCP',\n  // Mark DOM Content\n  DCL = 'DCL',\n  // Time To Interactive\n  TTI = 'TTI',\n  // Total Blocking Time\n  TBT = 'TBT',\n  // Cumulative Layout Shift\n  CLS = 'CLS',\n  // Navigation\n  NAV = 'Nav',\n  // Note: INP is handled in UserInteractionsHandler\n}\n\nexport interface MetricScore {\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.Events.PageLoadEvent;\n  // The last navigation that occurred before this metric score.\n  navigation?: Types.Events.NavigationStart;\n  estimated?: boolean;\n  timing: Types.Timing.Micro;\n}\n\nexport type LCPMetricScore = MetricScore&{\n  event: Types.Events.LargestContentfulPaintCandidate,\n  metricName: MetricName.LCP,\n};\n\nexport function metricIsLCP(metric: MetricScore): metric is LCPMetricScore {\n  return metric.metricName === MetricName.LCP;\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n/**\n * A trace file will contain all the text paints that were candidates for the\n * LargestTextPaint. If an LCP event is text, it will point to one of these\n * candidates, so we store them by their DOM Node ID.\n **/\nconst textPaintByDOMNodeId = new Map<Protocol.DOM.BackendNodeId, Types.Events.LargestTextPaintCandidate>();\n\nexport function reset(): void {\n  textPaintByDOMNodeId.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isLargestTextPaintCandidate(event)) {\n    return;\n  }\n\n  if (!event.args.data) {\n    return;\n  }\n\n  textPaintByDOMNodeId.set(event.args.data.DOMNodeId, event);\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): Map<Protocol.DOM.BackendNodeId, Types.Events.LargestTextPaintCandidate> {\n  return textPaintByDOMNodeId;\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport {data as screenshotsHandlerData} from './ScreenshotsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// We start with a score of zero and step through all Layout Shift records from\n// all renderers. Each record not only tells us which renderer it is, but also\n// the unweighted and weighted scores. The unweighted score is the score we would\n// get if the renderer were the only one in the viewport. The weighted score, on\n// the other hand, accounts for how much of the viewport that particular render\n// takes up when the shift happened. An ad frame in the corner of the viewport\n// that shifts is considered less disruptive, therefore, than if it were taking\n// up the whole viewport.\n//\n// Next, we step through all the records from all renderers and add the weighted\n// score to a running total across all of the renderers. We create a new \"cluster\"\n// and reset the running total when:\n//\n// 1. We observe a outermost frame navigation, or\n// 2. When there's a gap between records of > 1s, or\n// 3. When there's more than 5 seconds of continuous layout shifting.\n//\n// Note that for it to be Cumulative Layout Shift in the sense described in the\n// documentation we would need to guarantee that we are tracking from navigation\n// to unload. However, we don't make any such guarantees here (since a developer\n// can record and stop when they please), so we support the cluster approach,\n// and we can give them a score, but it is effectively a \"session\" score, a\n// score for the given recording, and almost certainly not the\n// navigation-to-unload CLS score.\n\ninterface LayoutShifts {\n  clusters: readonly Types.Events.SyntheticLayoutShiftCluster[];\n  clustersByNavigationId: Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>;\n  sessionMaxScore: number;\n  // The session window which contains the SessionMaxScore\n  clsWindowID: number;\n  // We use these to calculate root causes for a given LayoutShift\n  // TODO(crbug/41484172): should be readonly\n  prePaintEvents: Types.Events.PrePaint[];\n  paintImageEvents: Types.Events.PaintImage[];\n  layoutInvalidationEvents: readonly Types.Events.LayoutInvalidationTracking[];\n  scheduleStyleInvalidationEvents: readonly Types.Events.ScheduleStyleInvalidationTracking[];\n  styleRecalcInvalidationEvents: readonly Types.Events.StyleRecalcInvalidationTracking[];\n  renderFrameImplCreateChildFrameEvents: readonly Types.Events.RenderFrameImplCreateChildFrame[];\n  domLoadingEvents: readonly Types.Events.DomLoading[];\n  layoutImageUnsizedEvents: readonly Types.Events.LayoutImageUnsized[];\n  remoteFonts: readonly RemoteFont[];\n  scoreRecords: readonly ScoreRecord[];\n  // TODO(crbug/41484172): should be readonly\n  backendNodeIds: Protocol.DOM.BackendNodeId[];\n}\n\ninterface RemoteFont {\n  display: string;\n  url?: string;\n  name?: string;\n  beginRemoteFontLoadEvent: Types.Events.BeginRemoteFontLoad;\n}\n\n// This represents the maximum #time we will allow a cluster to go before we\n// reset it.\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.milliToMicro(Types.Timing.Milli(5000));\n\n// This represents the maximum #time we will allow between layout shift events\n// before considering it to be the start of a new cluster.\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.milliToMicro(Types.Timing.Milli(1000));\n\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nconst layoutShiftEvents: Types.Events.LayoutShift[] = [];\n\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nconst layoutInvalidationEvents: Types.Events.LayoutInvalidationTracking[] = [];\nconst scheduleStyleInvalidationEvents: Types.Events.ScheduleStyleInvalidationTracking[] = [];\nconst styleRecalcInvalidationEvents: Types.Events.StyleRecalcInvalidationTracking[] = [];\nconst renderFrameImplCreateChildFrameEvents: Types.Events.RenderFrameImplCreateChildFrame[] = [];\nconst domLoadingEvents: Types.Events.DomLoading[] = [];\nconst layoutImageUnsizedEvents: Types.Events.LayoutImageUnsized[] = [];\nconst remoteFonts: RemoteFont[] = [];\n\nconst backendNodeIds = new Set<Protocol.DOM.BackendNodeId>();\n\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nconst prePaintEvents: Types.Events.PrePaint[] = [];\n\nconst paintImageEvents: Types.Events.PaintImage[] = [];\n\nlet sessionMaxScore = 0;\n\nlet clsWindowID = -1;\n\nconst clusters: Types.Events.SyntheticLayoutShiftCluster[] = [];\nconst clustersByNavigationId = new Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>();\n\n// Represents a point in time in which a  LS score change\n// was recorded.\ninterface ScoreRecord {\n  ts: number;\n  score: number;\n}\n\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nconst scoreRecords: ScoreRecord[] = [];\n\nexport function reset(): void {\n  layoutShiftEvents.length = 0;\n  layoutInvalidationEvents.length = 0;\n  scheduleStyleInvalidationEvents.length = 0;\n  styleRecalcInvalidationEvents.length = 0;\n  prePaintEvents.length = 0;\n  paintImageEvents.length = 0;\n  renderFrameImplCreateChildFrameEvents.length = 0;\n  layoutImageUnsizedEvents.length = 0;\n  domLoadingEvents.length = 0;\n  remoteFonts.length = 0;\n  backendNodeIds.clear();\n  clusters.length = 0;\n  sessionMaxScore = 0;\n  scoreRecords.length = 0;\n  clsWindowID = -1;\n  clustersByNavigationId.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isLayoutShift(event) && !event.args.data?.had_recent_input) {\n    layoutShiftEvents.push(event);\n    return;\n  }\n  if (Types.Events.isLayoutInvalidationTracking(event)) {\n    layoutInvalidationEvents.push(event);\n    return;\n  }\n  if (Types.Events.isScheduleStyleInvalidationTracking(event)) {\n    scheduleStyleInvalidationEvents.push(event);\n  }\n  if (Types.Events.isStyleRecalcInvalidationTracking(event)) {\n    styleRecalcInvalidationEvents.push(event);\n  }\n  if (Types.Events.isPrePaint(event)) {\n    prePaintEvents.push(event);\n    return;\n  }\n  if (Types.Events.isRenderFrameImplCreateChildFrame(event)) {\n    renderFrameImplCreateChildFrameEvents.push(event);\n  }\n  if (Types.Events.isDomLoading(event)) {\n    domLoadingEvents.push(event);\n  }\n  if (Types.Events.isLayoutImageUnsized(event)) {\n    layoutImageUnsizedEvents.push(event);\n  }\n  if (Types.Events.isBeginRemoteFontLoad(event)) {\n    remoteFonts.push({\n      display: event.args.display,\n      url: event.args.url,\n      beginRemoteFontLoadEvent: event,\n    });\n  }\n  if (Types.Events.isRemoteFontLoaded(event)) {\n    for (const remoteFont of remoteFonts) {\n      if (remoteFont.url === event.args.url) {\n        remoteFont.name = event.args.name;\n      }\n    }\n  }\n  if (Types.Events.isPaintImage(event)) {\n    paintImageEvents.push(event);\n  }\n}\n\nfunction traceWindowFromTime(time: Types.Timing.Micro): Types.Timing.TraceWindowMicro {\n  return {\n    min: time,\n    max: time,\n    range: Types.Timing.Micro(0),\n  };\n}\n\nfunction updateTraceWindowMax(traceWindow: Types.Timing.TraceWindowMicro, newMax: Types.Timing.Micro): void {\n  traceWindow.max = newMax;\n  traceWindow.range = Types.Timing.Micro(traceWindow.max - traceWindow.min);\n}\n\nfunction findScreenshots(timestamp: Types.Timing.Micro): Types.Events.LayoutShiftParsedData['screenshots'] {\n  const data = screenshotsHandlerData();\n  if (data.screenshots) {\n    const before = Helpers.Trace.findPreviousEventBeforeTimestamp(data.screenshots, timestamp);\n    const after = before ? data.screenshots[data.screenshots.indexOf(before) + 1] : null;\n    return {before, after};\n  }\n  if (data.legacySyntheticScreenshots) {\n    const before = Helpers.Trace.findPreviousEventBeforeTimestamp(data.legacySyntheticScreenshots, timestamp);\n    const after = before ? data.legacySyntheticScreenshots[data.legacySyntheticScreenshots.indexOf(before) + 1] : null;\n    return {before, after};\n  }\n  // No screenshots\n  return {before: null, after: null};\n}\n\nfunction buildScoreRecords(): void {\n  const {traceBounds} = metaHandlerData();\n  scoreRecords.push({ts: traceBounds.min, score: 0});\n\n  for (const cluster of clusters) {\n    let clusterScore = 0;\n    if (cluster.events[0].args.data) {\n      scoreRecords.push({ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta});\n    }\n    for (let i = 0; i < cluster.events.length; i++) {\n      const event = cluster.events[i];\n      if (!event.args.data) {\n        continue;\n      }\n      clusterScore += event.args.data.weighted_score_delta;\n      scoreRecords.push({ts: event.ts, score: clusterScore});\n    }\n    scoreRecords.push({ts: cluster.clusterWindow.max, score: 0});\n  }\n}\n\n/**\n * Collects backend node ids coming from LayoutShift and LayoutInvalidation\n * events.\n */\nfunction collectNodes(): void {\n  backendNodeIds.clear();\n\n  // Collect the node ids present in the shifts.\n  for (const layoutShift of layoutShiftEvents) {\n    if (!layoutShift.args.data?.impacted_nodes) {\n      continue;\n    }\n    for (const node of layoutShift.args.data.impacted_nodes) {\n      backendNodeIds.add(node.node_id);\n    }\n  }\n\n  // Collect the node ids present in LayoutInvalidation & scheduleStyleInvalidation events.\n  for (const layoutInvalidation of layoutInvalidationEvents) {\n    if (!layoutInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(layoutInvalidation.args.data.nodeId);\n  }\n  for (const scheduleStyleInvalidation of scheduleStyleInvalidationEvents) {\n    if (!scheduleStyleInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(scheduleStyleInvalidation.args.data.nodeId);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // Ensure the events are sorted by #time ascending.\n  layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n  prePaintEvents.sort((a, b) => a.ts - b.ts);\n  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n  renderFrameImplCreateChildFrameEvents.sort((a, b) => a.ts - b.ts);\n  domLoadingEvents.sort((a, b) => a.ts - b.ts);\n  layoutImageUnsizedEvents.sort((a, b) => a.ts - b.ts);\n  remoteFonts.sort((a, b) => a.beginRemoteFontLoadEvent.ts - b.beginRemoteFontLoadEvent.ts);\n  paintImageEvents.sort((a, b) => a.ts - b.ts);\n\n  // Each function transforms the data used by the next, as such the invoke order\n  // is important.\n  await buildLayoutShiftsClusters();\n  buildScoreRecords();\n  collectNodes();\n}\n\nasync function buildLayoutShiftsClusters(): Promise<void> {\n  const {navigationsByFrameId, mainFrameId, traceBounds} = metaHandlerData();\n  const navigations = navigationsByFrameId.get(mainFrameId) || [];\n  if (layoutShiftEvents.length === 0) {\n    return;\n  }\n  let firstShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftNavigation = null;\n  // Now step through each and create clusters.\n  // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n  // To make the line chart clear, we explicitly demark the limits of each session window\n  // by starting the cumulative score of the window at the time of the first layout shift\n  // and ending it (dropping the line back to 0) when the window ends according to the\n  // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n  for (const event of layoutShiftEvents) {\n    // First detect if either the cluster duration or the #time between this and\n    // the last shift has been exceeded.\n    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n\n    // Next take a look at navigations. If between this and the last shift we have navigated,\n    // note it.\n    const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n\n    // If any of the above criteria are met or if we don't have any cluster yet we should\n    // start a new one.\n    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n      // The cluster starts #time should be the timestamp of the first layout shift in it.\n      const clusterStartTime = event.ts;\n\n      // If the last session window ended because the max delta time between shifts\n      // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n      // last shift in the session.\n      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n\n      // If the last session window ended because the max session duration was\n      // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n\n      // If there was a navigation during the last window, close it at the time\n      // of the navigation.\n      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n\n      // End the previous cluster at the time of the first of the criteria above that was met.\n      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n\n      // If there is an existing cluster update its closing time.\n      if (clusters.length > 0) {\n        const currentCluster = clusters[clusters.length - 1];\n        updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.Micro(previousClusterEndTime));\n      }\n\n      // If this cluster happened after a navigation, set the navigationId to\n      // the current navigation. This lets us easily group clusters by\n      // navigation.\n      const navigationId = currentShiftNavigation === null ?\n          Types.Events.NO_NAVIGATION :\n          navigations[currentShiftNavigation].args.data?.navigationId;\n      // TODO: `navigationId` is `string | undefined`, but the undefined portion\n      // comes from `data.navigationId`. I don't think that is possible for this\n      // event type. Can we make this typing stronger? In the meantime, we allow\n      // `navigationId` to include undefined values.\n\n      clusters.push({\n        name: 'SyntheticLayoutShiftCluster',\n        events: [],\n        clusterWindow: traceWindowFromTime(clusterStartTime),\n        clusterCumulativeScore: 0,\n        scoreWindows: {\n          good: traceWindowFromTime(clusterStartTime),\n        },\n        navigationId,\n        // Set default Event so that this event is treated accordingly for the track appender.\n        ts: event.ts,\n        pid: event.pid,\n        tid: event.tid,\n        ph: Types.Events.Phase.COMPLETE,\n        cat: '',\n        dur: Types.Timing.Micro(-1),  // This `cluster.dur` is updated below.\n      });\n\n      firstShiftTime = clusterStartTime;\n    }\n\n    // Given the above we should have a cluster available, so pick the most\n    // recent one and append the shift, bump its score and window values accordingly.\n    const currentCluster = clusters[clusters.length - 1];\n    const timeFromNavigation = currentShiftNavigation !== null ?\n        Types.Timing.Micro(event.ts - navigations[currentShiftNavigation].ts) :\n        undefined;\n\n    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n    if (!event.args.data) {\n      continue;\n    }\n    const shift =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticLayoutShift>({\n          rawSourceEvent: event,\n          ...event,\n          name: Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT,\n          args: {\n            frame: event.args.frame,\n            data: {\n              ...event.args.data,\n              rawEvent: event,\n              navigationId: currentCluster.navigationId ?? undefined,\n            },\n          },\n          parsedData: {\n            timeFromNavigation,\n            screenshots: findScreenshots(event.ts),\n            cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n            // The score of the session window is temporarily set to 0 just\n            // to initialize it. Since we need to get the score of all shifts\n            // in the session window to determine its value, its definite\n            // value is set when stepping through the built clusters.\n            sessionWindowData: {cumulativeWindowScore: 0, id: clusters.length},\n          },\n        });\n    currentCluster.events.push(shift);\n    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n\n    lastShiftTime = event.ts;\n    lastShiftNavigation = currentShiftNavigation;\n  }\n\n  // Now step through each cluster and set up the times at which the value\n  // goes from Good, to needs improvement, to Bad. Note that if there is a\n  // large jump we may go from Good to Bad without ever creating a Needs\n  // Improvement window at all.\n  for (const cluster of clusters) {\n    let weightedScore = 0;\n    let windowID = -1;\n    // If this is the last cluster update its window. The cluster duration is determined\n    // by the minimum between: time to next navigation, trace end time, time to maximum\n    // cluster duration and time to maximum gap between layout shifts.\n    if (cluster === clusters[clusters.length - 1]) {\n      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n      const nextNavigationIndex =\n          Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n      updateTraceWindowMax(cluster.clusterWindow, Types.Timing.Micro(clusterEnd));\n    }\n\n    let largestScore = 0;\n    let worstShiftEvent: Types.Events.Event|null = null;\n\n    for (const shift of cluster.events) {\n      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n      windowID = shift.parsedData.sessionWindowData.id;\n      const ts = shift.ts;\n      // Update the the CLS score of this shift's session window now that\n      // we have it.\n      shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n        // Expand the Good window.\n        updateTraceWindowMax(cluster.scoreWindows.good, ts);\n      } else if (\n          weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.needsImprovement) {\n          // Close the Good window, and open the needs improvement window.\n          updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.Micro(ts - 1));\n          cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);\n        }\n\n        // Expand the needs improvement window.\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);\n      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.bad) {\n          // We may jump from Good to Bad here, so update whichever window is open.\n          if (cluster.scoreWindows.needsImprovement) {\n            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.Micro(ts - 1));\n          } else {\n            updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.Micro(ts - 1));\n          }\n\n          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the Bad window.\n        updateTraceWindowMax(cluster.scoreWindows.bad, ts);\n      }\n\n      // At this point the windows are set by the timestamps of the events, but the\n      // next cluster begins at the timestamp of its first event. As such we now\n      // need to expand the score window to the end of the cluster, and we do so\n      // by using the Bad widow if it's there, or the NI window, or finally the\n      // Good window.\n      if (cluster.scoreWindows.bad) {\n        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n      } else if (cluster.scoreWindows.needsImprovement) {\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n      } else {\n        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n      }\n\n      // Find the worst layout shift of the cluster.\n      const score = shift.args.data?.weighted_score_delta;\n      if (score !== undefined && score > largestScore) {\n        largestScore = score;\n        worstShiftEvent = shift;\n      }\n    }\n    // Update the cluster's worst layout shift.\n    if (worstShiftEvent) {\n      cluster.worstShiftEvent = worstShiftEvent;\n    }\n\n    // layout shifts are already sorted by time ascending.\n    // Capture the time range of the cluster.\n    cluster.ts = cluster.events[0].ts;\n    const lastShiftTimings = Helpers.Timing.eventTimingsMicroSeconds(cluster.events[cluster.events.length - 1]);\n    // Add MAX_SHIFT_TIME_DELTA, the section gap after the last layout shift. This marks the end of the cluster.\n    cluster.dur = Types.Timing.Micro((lastShiftTimings.endTime - cluster.events[0].ts) + MAX_SHIFT_TIME_DELTA);\n\n    if (weightedScore > sessionMaxScore) {\n      clsWindowID = windowID;\n      sessionMaxScore = weightedScore;\n    }\n\n    if (cluster.navigationId) {\n      const clustersForId = Platform.MapUtilities.getWithDefault(clustersByNavigationId, cluster.navigationId, () => {\n        return [];\n      });\n      clustersForId.push(cluster);\n    }\n  }\n}\n\nexport function data(): LayoutShifts {\n  return {\n    clusters,\n    sessionMaxScore,\n    clsWindowID,\n    prePaintEvents,\n    layoutInvalidationEvents,\n    scheduleStyleInvalidationEvents,\n    styleRecalcInvalidationEvents: [],\n    renderFrameImplCreateChildFrameEvents,\n    domLoadingEvents,\n    layoutImageUnsizedEvents,\n    remoteFonts,\n    scoreRecords,\n    // TODO(crbug/41484172): change the type so no need to clone\n    backendNodeIds: [...backendNodeIds],\n    clustersByNavigationId: new Map(clustersByNavigationId),\n    paintImageEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Screenshots', 'Meta'];\n}\n\nexport function scoreClassificationForLayoutShift(score: number): ScoreClassification {\n  let state = ScoreClassification.GOOD;\n  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n    state = ScoreClassification.OK;\n  }\n\n  if (score >= LayoutShiftsThreshold.BAD) {\n    state = ScoreClassification.BAD;\n  }\n\n  return state;\n}\n\n// Based on https://web.dev/cls/\nexport const enum LayoutShiftsThreshold {\n  GOOD = 0,\n  NEEDS_IMPROVEMENT = 0.1,\n  BAD = 0.25,\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nconst unpairedAsyncEvents: Types.Events.PipelineReporter[] = [];\n\nconst legacyScreenshotEvents: Types.Events.LegacyScreenshot[] = [];\nconst modernScreenshotEvents: Types.Events.Screenshot[] = [];\nconst syntheticScreenshots: Types.Events.LegacySyntheticScreenshot[] = [];\nlet frameSequenceToTs: Record<string, Types.Timing.Micro> = {};\n\nexport function reset(): void {\n  unpairedAsyncEvents.length = 0;\n  legacyScreenshotEvents.length = 0;\n  syntheticScreenshots.length = 0;\n  modernScreenshotEvents.length = 0;\n  frameSequenceToTs = {};\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isLegacyScreenshot(event)) {\n    legacyScreenshotEvents.push(event);\n  } else if (Types.Events.isScreenshot(event)) {\n    modernScreenshotEvents.push(event);\n  } else if (Types.Events.isPipelineReporter(event)) {\n    unpairedAsyncEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const pipelineReporterEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(unpairedAsyncEvents);\n\n  frameSequenceToTs = Object.fromEntries(pipelineReporterEvents.map(evt => {\n    const args = evt.args.data.beginEvent.args;\n    const frameReporter = 'frame_reporter' in args ? args.frame_reporter : args.chrome_frame_reporter;\n    const frameSequenceId = frameReporter.frame_sequence;\n    const presentationTs = Types.Timing.Micro(evt.ts + evt.dur);\n    return [frameSequenceId, presentationTs];\n  }));\n\n  for (const snapshotEvent of legacyScreenshotEvents) {\n    const {cat, name, ph, pid, tid} = snapshotEvent;\n    const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<\n        Types.Events.LegacySyntheticScreenshot>({\n      rawSourceEvent: snapshotEvent,\n      cat,\n      name,\n      ph,\n      pid,\n      tid,\n      // TODO(paulirish, crbug.com/41363012): investigate why getPresentationTimestamp(snapshotEvent) seems less accurate. Resolve screenshot timing inaccuracy.\n      // `getPresentationTimestamp(snapshotEvent) - snapshotEvent.ts` is how many microsec the screenshot should be adjusted to the right/later\n      ts: snapshotEvent.ts,\n      args: {\n        dataUri: `data:image/jpg;base64,${snapshotEvent.args.snapshot}`,\n      },\n    });\n    syntheticScreenshots.push(syntheticEvent);\n  }\n}\n\nexport function screenshotImageDataUri(event: Types.Events.LegacySyntheticScreenshot|Types.Events.Screenshot): string {\n  if (Types.Events.isLegacySyntheticScreenshot(event)) {\n    return event.args.dataUri;\n  }\n  return `data:image/jpg;base64,${event.args.snapshot}`;\n}\n\n/**\n * Correct the screenshot timestamps\n * The screenshot 'snapshot object' trace event has the \"frame sequence number\" attached as an ID.\n * We match that up with the \"PipelineReporter\" trace events as they terminate at presentation.\n * Presentation == when the pixels hit the screen. AKA Swap on the GPU\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPresentationTimestamp(screenshotEvent: Types.Events.LegacyScreenshot): Types.Timing.Micro {\n  const frameSequence = parseInt(screenshotEvent.id, 16);\n  // If it's 1, then it's an old trace (before https://crrev.com/c/4957973) and cannot be corrected.\n  if (frameSequence === 1) {\n    return screenshotEvent.ts;\n  }\n  // The screenshot trace event's `ts` reflects the \"expected display time\" which is ESTIMATE.\n  // It is set by the compositor frame sink from the `expected_display_time`, which is based on a previously known\n  // frame start PLUS the vsync interval (eg 16.6ms)\n  const updatedTs = frameSequenceToTs[frameSequence];\n  // Do we always find a match? No...\n  // We generally don't match the very first screenshot and, sometimes, the last\n  // The very first screenshot is requested immediately (even if nothing is painting). As a result there's no compositor\n  // instrumentation running alongside.\n  // The last one is sometimes missing as because the trace terminates right before the associated PipelineReporter is emitted.\n  return updatedTs ?? screenshotEvent.ts;\n}\n\nexport interface Data {\n  // These are nullable because in January 2025 a CL in Chromium\n  // crrev.com/c/6197645 landed which changed the format of screenshots. For a\n  // given trace, it can have either \"legacy\" screenshot events, or \"modern\"\n  // screenshot events, but no trace can ever contain both.\n  // So, if either of these arrays are empty, we instead return `null`. This forces consumers to check the presence of the array.\n  // Traces can have no screenshots if the trace category is not enabled, so it\n  // is possible for a trace to return null for both of these arrays.\n  legacySyntheticScreenshots: Types.Events.LegacySyntheticScreenshot[]|null;\n  screenshots: Types.Events.Screenshot[]|null;\n}\n// TODO(crbug/41484172): should be readonly\nexport function data(): Data {\n  return {\n    legacySyntheticScreenshots: syntheticScreenshots.length ? syntheticScreenshots : null,\n    screenshots: modernScreenshotEvents.length ? modernScreenshotEvents : null,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nexport interface MemoryData {\n  updateCountersByProcess: Map<Types.Events.ProcessID, Types.Events.UpdateCounters[]>;\n}\n\nconst updateCountersByProcess: MemoryData['updateCountersByProcess'] = new Map();\n\nexport function reset(): void {\n  updateCountersByProcess.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isUpdateCounters(event)) {\n    const countersForProcess = Platform.MapUtilities.getWithDefault(updateCountersByProcess, event.pid, () => []);\n    countersForProcess.push(event);\n    updateCountersByProcess.set(event.pid, countersForProcess);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): MemoryData {\n  return {updateCountersByProcess};\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nconst frames = new Map<string, Types.Events.TraceFrame>();\n\nexport function reset(): void {\n  frames.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    for (const frame of event.args.data?.frames ?? []) {\n      // The ID of a frame is stored under the `frame` key.\n      frames.set(frame.frame, frame);\n    }\n    return;\n  }\n\n  // CommitLoad events can contain an updated URL or Name for a frame.\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n    // We don't want to mutate the original object, hence why\n    // we set a new object from the new and existing values.\n    const frame = frames.get(frameData.frame);\n    if (!frame) {\n      return;\n    }\n    frames.set(frameData.frame, {\n      ...frame,\n      url: frameData.url || frame.url,\n      name: frameData.name || frameData.name,\n    });\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport interface PageFrameData {\n  frames: Map<string, Types.Events.TraceFrame>;\n}\nexport function data(): PageFrameData {\n  return {\n    frames,\n  };\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData, type MetaHandlerData} from './MetaHandler.js';\nimport {data as networkRequestsHandlerData} from './NetworkRequestsHandler.js';\nimport type {HandlerName} from './types.js';\n\nexport interface ScriptsData {\n  /** Note: this is only populated when the \"Enhanced Traces\" feature is enabled. */\n  scripts: Script[];\n}\n\nexport interface Script {\n  isolate: string;\n  scriptId: Protocol.Runtime.ScriptId;\n  frame: string;\n  ts: Types.Timing.Micro;\n  inline: boolean;\n  url?: string;\n  sourceUrl?: string;\n  content?: string;\n  /** Note: this is the literal text given as the sourceMappingURL value. It has not been resolved relative to the script url.\n   * Since M138, data urls are never set here.\n   */\n  sourceMapUrl?: string;\n  /** If true, the source map url was a data URL, so it got removed from the trace event. */\n  sourceMapUrlElided?: boolean;\n  sourceMap?: SDK.SourceMap.SourceMap;\n  request?: Types.Events.SyntheticNetworkRequest;\n  /** Lazily generated - use getScriptGeneratedSizes to access. */\n  sizes?: GeneratedFileSizes;\n}\n\ntype GeneratedFileSizes = {\n  errorMessage: string,\n}|{files: Record<string, number>, unmappedBytes: number, totalBytes: number};\n\nconst scriptById = new Map<string, Script>();\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'NetworkRequests'];\n}\n\nexport function reset(): void {\n  scriptById.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  const getOrMakeScript = (isolate: string, scriptIdAsNumber: number): Script => {\n    const scriptId = String(scriptIdAsNumber) as Protocol.Runtime.ScriptId;\n    const key = `${isolate}.${scriptId}`;\n    return Platform.MapUtilities.getWithDefault(\n        scriptById, key, () => ({isolate, scriptId, frame: '', ts: 0} as Script));\n  };\n\n  if (Types.Events.isTargetRundownEvent(event) && event.args.data) {\n    const {isolate, scriptId, frame} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.frame = frame;\n    script.ts = event.ts;\n\n    return;\n  }\n\n  if (Types.Events.isV8SourceRundownEvent(event)) {\n    const {isolate, scriptId, url, sourceUrl, sourceMapUrl, sourceMapUrlElided} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.url = url;\n    if (sourceUrl) {\n      script.sourceUrl = sourceUrl;\n    }\n\n    // Older traces may have data source map urls. Those can be very large, so a change\n    // was made to elide them from the trace.\n    // If elided, a fresh trace will fetch the source map from the Script model\n    // (see TimelinePanel getExistingSourceMap). If not fresh, the source map is resolved\n    // instead in this handler via `findCachedRawSourceMap`.\n    if (sourceMapUrlElided) {\n      script.sourceMapUrlElided = true;\n    } else if (sourceMapUrl) {\n      script.sourceMapUrl = sourceMapUrl;\n    }\n    return;\n  }\n\n  if (Types.Events.isV8SourceRundownSourcesScriptCatchupEvent(event)) {\n    const {isolate, scriptId, sourceText} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.content = sourceText;\n    return;\n  }\n\n  if (Types.Events.isV8SourceRundownSourcesLargeScriptCatchupEvent(event)) {\n    const {isolate, scriptId, sourceText} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.content = (script.content ?? '') + sourceText;\n    return;\n  }\n}\n\nfunction findFrame(meta: MetaHandlerData, frameId: string): Types.Events.TraceFrame|null {\n  for (const frames of meta.frameByProcessId?.values()) {\n    const frame = frames.get(frameId);\n    if (frame) {\n      return frame;\n    }\n  }\n\n  return null;\n}\n\nfunction findNetworkRequest(networkRequests: Types.Events.SyntheticNetworkRequest[], script: Script):\n    Types.Events.SyntheticNetworkRequest|null {\n  return networkRequests.find(request => request.args.data.url === script.url) ?? null;\n}\n\nfunction computeMappingEndColumns(map: SDK.SourceMap.SourceMap): Map<SDK.SourceMap.SourceMapEntry, number> {\n  const result = new Map<SDK.SourceMap.SourceMapEntry, number>();\n\n  const mappings = map.mappings();\n  for (let i = 0; i < mappings.length - 1; i++) {\n    const mapping = mappings[i];\n    const nextMapping = mappings[i + 1];\n    if (mapping.lineNumber === nextMapping.lineNumber) {\n      result.set(mapping, nextMapping.columnNumber);\n    }\n  }\n\n  // Now, all but the last mapping on each line will have a value in this map.\n  return result;\n}\n\n/**\n * Using a script's contents and source map, attribute every generated byte to an authored source file.\n */\nfunction computeGeneratedFileSizes(script: Script): GeneratedFileSizes {\n  if (!script.sourceMap) {\n    throw new Error('expected source map');\n  }\n\n  const map = script.sourceMap;\n  const content = script.content ?? '';\n  const contentLength = content.length;\n  const lines = content.split('\\n');\n  const files: Record<string, number> = {};\n  const totalBytes = contentLength;\n  let unmappedBytes = totalBytes;\n\n  const mappingEndCols = computeMappingEndColumns(script.sourceMap);\n\n  for (const mapping of map.mappings()) {\n    const source = mapping.sourceURL;\n    const lineNum = mapping.lineNumber;\n    const colNum = mapping.columnNumber;\n    const lastColNum = mappingEndCols.get(mapping);\n\n    // Webpack sometimes emits null mappings.\n    // https://github.com/mozilla/source-map/pull/303\n    if (!source) {\n      continue;\n    }\n\n    // Lines and columns are zero-based indices. Visually, lines are shown as a 1-based index.\n\n    const line = lines[lineNum];\n    if (line === null || line === undefined) {\n      const errorMessage = `${map.url()} mapping for line out of bounds: ${lineNum + 1}`;\n      return {errorMessage};\n    }\n\n    if (colNum > line.length) {\n      const errorMessage = `${map.url()} mapping for column out of bounds: ${lineNum + 1}:${colNum}`;\n      return {errorMessage};\n    }\n\n    let mappingLength = 0;\n    if (lastColNum !== undefined) {\n      if (lastColNum > line.length) {\n        const errorMessage = `${map.url()} mapping for last column out of bounds: ${lineNum + 1}:${lastColNum}`;\n        return {errorMessage};\n      }\n      mappingLength = lastColNum - colNum;\n    } else {\n      // Add +1 to account for the newline.\n      mappingLength = line.length - colNum + 1;\n    }\n    files[source] = (files[source] || 0) + mappingLength;\n    unmappedBytes -= mappingLength;\n  }\n\n  return {\n    files,\n    unmappedBytes,\n    totalBytes,\n  };\n}\n\nexport function getScriptGeneratedSizes(script: Script): GeneratedFileSizes|null {\n  if (script.sourceMap && !script.sizes) {\n    script.sizes = computeGeneratedFileSizes(script);\n  }\n\n  return script.sizes ?? null;\n}\n\nfunction findCachedRawSourceMap(script: Script, options: Types.Configuration.ParseOptions): SDK.SourceMap.SourceMapV3|\n    undefined {\n  if (options.isFreshRecording || !options.metadata?.sourceMaps) {\n    // Exit if this is not a loaded trace w/ source maps in the metadata.\n    return;\n  }\n\n  // For elided data url source maps, search the metadata source maps by script url.\n  if (script.sourceMapUrlElided) {\n    if (!script.url) {\n      return;\n    }\n\n    const cachedSourceMap = options.metadata.sourceMaps.find(m => m.url === script.url);\n    if (cachedSourceMap) {\n      return cachedSourceMap.sourceMap;\n    }\n\n    return;\n  }\n\n  if (!script.sourceMapUrl) {\n    return;\n  }\n\n  // Otherwise, search by source map url.\n  // Note: early enhanced traces may have this field set for data urls. Ignore those,\n  // as they were never stored in metadata sourcemap.\n  const isDataUrl = script.sourceMapUrl.startsWith('data:');\n  if (!isDataUrl) {\n    const cachedSourceMap = options.metadata.sourceMaps.find(m => m.sourceMapUrl === script.sourceMapUrl);\n    if (cachedSourceMap) {\n      return cachedSourceMap.sourceMap;\n    }\n  }\n\n  return;\n}\n\nexport async function finalize(options: Types.Configuration.ParseOptions): Promise<void> {\n  const meta = metaHandlerData();\n  const networkRequests = [...networkRequestsHandlerData().byId.values()];\n\n  const documentUrls = new Set<string>();\n  for (const frames of meta.frameByProcessId.values()) {\n    for (const frame of frames.values()) {\n      documentUrls.add(frame.url);\n    }\n  }\n\n  for (const script of scriptById.values()) {\n    script.request = findNetworkRequest(networkRequests, script) ?? undefined;\n    script.inline = !!script.url && documentUrls.has(script.url);\n  }\n\n  if (!options.resolveSourceMap) {\n    return;\n  }\n\n  const promises = [];\n  for (const script of scriptById.values()) {\n    // No frame or url means the script came from somewhere we don't care about.\n    // Note: scripts from inline <SCRIPT> elements use the url of the HTML document,\n    // so aren't ignored.\n    if (!script.frame || !script.url || (!script.sourceMapUrl && !script.sourceMapUrlElided)) {\n      continue;\n    }\n\n    const frameUrl = findFrame(meta, script.frame)?.url as Platform.DevToolsPath.UrlString | undefined;\n    if (!frameUrl) {\n      continue;\n    }\n\n    // If there is a `sourceURL` magic comment, resolve the compiledUrl against the frame url.\n    // example: `// #sourceURL=foo.js` for target frame https://www.example.com/home -> https://www.example.com/home/foo.js\n    let sourceUrl = script.url;\n    if (script.sourceUrl) {\n      sourceUrl = Common.ParsedURL.ParsedURL.completeURL(frameUrl, script.sourceUrl) ?? script.sourceUrl;\n    }\n\n    let sourceMapUrl;\n    if (script.sourceMapUrl) {\n      // Resolve the source map url. The value given by v8 may be relative, so resolve it here.\n      // This process should match the one in `SourceMapManager.attachSourceMap`.\n      sourceMapUrl =\n          Common.ParsedURL.ParsedURL.completeURL(sourceUrl as Platform.DevToolsPath.UrlString, script.sourceMapUrl);\n      if (!sourceMapUrl) {\n        continue;\n      }\n\n      script.sourceMapUrl = sourceMapUrl;\n    }\n\n    const params: Types.Configuration.ResolveSourceMapParams = {\n      scriptId: script.scriptId,\n      scriptUrl: script.url as Platform.DevToolsPath.UrlString,\n      sourceUrl: sourceUrl as Platform.DevToolsPath.UrlString,\n      sourceMapUrl: sourceMapUrl ?? '' as Platform.DevToolsPath.UrlString,\n      frame: script.frame as Protocol.Page.FrameId,\n      cachedRawSourceMap: findCachedRawSourceMap(script, options),\n    };\n    const promise = options.resolveSourceMap(params).then(sourceMap => {\n      if (sourceMap) {\n        script.sourceMap = sourceMap;\n      }\n    });\n    promises.push(promise.catch(e => {\n      console.error('Uncaught error when resolving source map', params, e);\n    }));\n  }\n  await Promise.all(promises);\n}\n\nexport function data(): ScriptsData {\n  return {\n    scripts: [...scriptById.values()],\n  };\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nlet lastUpdateLayoutTreeEvent: Types.Events.UpdateLayoutTree|null = null;\n\nconst selectorDataForUpdateLayoutTree = new Map<Types.Events.UpdateLayoutTree, {\n  timings: Types.Events.SelectorTiming[],\n}>();\n\nexport function reset(): void {\n  lastUpdateLayoutTreeEvent = null;\n  selectorDataForUpdateLayoutTree.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isSelectorStats(event) && lastUpdateLayoutTreeEvent && event.args.selector_stats) {\n    selectorDataForUpdateLayoutTree.set(lastUpdateLayoutTreeEvent, {\n      timings: event.args.selector_stats.selector_timings,\n    });\n    return;\n  }\n\n  if (Types.Events.isUpdateLayoutTree(event)) {\n    lastUpdateLayoutTreeEvent = event;\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport interface SelectorStatsData {\n  dataForUpdateLayoutEvent: Map<Types.Events.UpdateLayoutTree, {\n    timings: Types.Events.SelectorTiming[],\n  }>;\n}\n\nexport function data(): SelectorStatsData {\n  return {\n    dataForUpdateLayoutEvent: selectorDataForUpdateLayoutTree,\n  };\n}\n", "// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// This handler serves two purposes. It generates a list of events that are\n// used to show user clicks in the timeline. It is also used to gather\n// EventTimings into Interactions, which we use to show interactions and\n// highlight long interactions to the user, along with INP.\n\n// We don't need to know which process / thread these events occurred in,\n// because they are effectively global, so we just track all that we find.\nconst allEvents: Types.Events.EventTimingBeginOrEnd[] = [];\n\nconst beginCommitCompositorFrameEvents: Types.Events.BeginCommitCompositorFrame[] = [];\nconst parseMetaViewportEvents: Types.Events.ParseMetaViewport[] = [];\n\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(500));\n\nexport interface UserInteractionsData {\n  /** All the user events we found in the trace */\n  allEvents: readonly Types.Events.EventTimingBeginOrEnd[];\n  /** All the BeginCommitCompositorFrame events we found in the trace */\n  beginCommitCompositorFrameEvents: readonly Types.Events.BeginCommitCompositorFrame[];\n  /** All the ParseMetaViewport events we found in the trace */\n  parseMetaViewportEvents: readonly Types.Events.ParseMetaViewport[];\n  /** All the interaction events we found in the trace that had an\n   * interactionId and a duration > 0\n   **/\n  interactionEvents: readonly Types.Events.SyntheticInteractionPair[];\n  /** If the user rapidly generates interaction events (think typing into a\n   * text box), in the UI we only really want to show the user the longest\n   * interaction in that set.\n   * For example picture interactions like this:\n   * ===[interaction A]==========\n   *       =[interaction B]======\n   *            =[interaction C]=\n   *\n   * These events all end at the same time, and so in this instance we only want\n   * to show the first interaction A on the timeline, as that is the longest one\n   * and the one the developer should be focusing on. So this array of events is\n   * all the interaction events filtered down, removing any nested interactions\n   * entirely.\n   **/\n  interactionEventsWithNoNesting: readonly Types.Events.SyntheticInteractionPair[];\n  // The longest duration interaction event. Can be null if the trace has no interaction events.\n  longestInteractionEvent: Readonly<Types.Events.SyntheticInteractionPair>|null;\n  // All interactions that went over the interaction threshold (200ms, see https://web.dev/inp/)\n  interactionsOverThreshold: Readonly<Set<Types.Events.SyntheticInteractionPair>>;\n}\n\nlet longestInteractionEvent: Types.Events.SyntheticInteractionPair|null = null;\n\nconst interactionEvents: Types.Events.SyntheticInteractionPair[] = [];\nconst interactionEventsWithNoNesting: Types.Events.SyntheticInteractionPair[] = [];\nconst eventTimingEndEventsById = new Map<string, Types.Events.EventTimingEnd>();\nconst eventTimingStartEventsForInteractions: Types.Events.EventTimingBegin[] = [];\n\nexport function reset(): void {\n  allEvents.length = 0;\n  beginCommitCompositorFrameEvents.length = 0;\n  parseMetaViewportEvents.length = 0;\n  interactionEvents.length = 0;\n  eventTimingStartEventsForInteractions.length = 0;\n  eventTimingEndEventsById.clear();\n  interactionEventsWithNoNesting.length = 0;\n  longestInteractionEvent = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isBeginCommitCompositorFrame(event)) {\n    beginCommitCompositorFrameEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isParseMetaViewport(event)) {\n    parseMetaViewportEvents.push(event);\n    return;\n  }\n\n  if (!Types.Events.isEventTiming(event)) {\n    return;\n  }\n\n  if (Types.Events.isEventTimingEnd(event)) {\n    // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n    eventTimingEndEventsById.set(event.id, event);\n  }\n\n  allEvents.push(event);\n\n  // From this point on we want to find events that represent interactions.\n  // These events are always start events - those are the ones that contain all\n  // the metadata about the interaction.\n  if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  // Store the start event. In the finalize() function we will pair this with\n  // its end event and create the synthetic interaction event.\n  eventTimingStartEventsForInteractions.push(event);\n}\n\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n  'pointerdown',\n  'touchstart',\n  'pointerup',\n  'touchend',\n  'mousedown',\n  'mouseup',\n  'click',\n]);\n\nconst keyboardEventTypes = new Set([\n  'keydown',\n  'keypress',\n  'keyup',\n]);\n\nexport type InteractionCategory = 'KEYBOARD'|'POINTER'|'OTHER';\nexport function categoryOfInteraction(interaction: Types.Events.SyntheticInteractionPair): InteractionCategory {\n  if (pointerEventTypes.has(interaction.type)) {\n    return 'POINTER';\n  }\n  if (keyboardEventTypes.has(interaction.type)) {\n    return 'KEYBOARD';\n  }\n\n  return 'OTHER';\n}\n\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n **/\nexport function removeNestedInteractions(interactions: readonly Types.Events.SyntheticInteractionPair[]):\n    readonly Types.Events.SyntheticInteractionPair[] {\n  /**\n   * Because we nest events only that are in the same category, we store the\n   * longest event for a given end time by category.\n   **/\n  const earliestEventForEndTimePerCategory:\n      Record<InteractionCategory, Map<Types.Timing.Micro, Types.Events.SyntheticInteractionPair>> = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n      };\n\n  function storeEventIfEarliestForCategoryAndEndTime(interaction: Types.Events.SyntheticInteractionPair): void {\n    const category = categoryOfInteraction(interaction);\n    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n    const endTime = Types.Timing.Micro(interaction.ts + interaction.dur);\n\n    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n    if (!earliestCurrentEvent) {\n      earliestEventForEndTime.set(endTime, interaction);\n      return;\n    }\n    if (interaction.ts < earliestCurrentEvent.ts) {\n      earliestEventForEndTime.set(endTime, interaction);\n    } else if (\n        interaction.ts === earliestCurrentEvent.ts &&\n        interaction.interactionId === earliestCurrentEvent.interactionId) {\n      // We have seen in traces that the same interaction can have multiple\n      // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n      // events will have an event handler bound to it which caused delay on\n      // the main thread, and the others will not. This leads to a situation\n      // where if we pick one of the events that had no event handler, its\n      // processing duration (processingEnd - processingStart) will be 0, but if we\n      // had picked the event that had the slow event handler, we would show\n      // correctly the main thread delay due to the event handler.\n      // So, if we find events with the same interactionId and the same\n      // begin/end times, we pick the one with the largest (processingEnd -\n      // processingStart) time in order to make sure we find the event with the\n      // worst main thread delay, as that is the one the user should care\n      // about.\n      const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n      const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n\n      // Use the new interaction if it has a longer processing duration than the existing one.\n      if (newProcessingDuration > currentProcessingDuration) {\n        earliestEventForEndTime.set(endTime, interaction);\n      }\n    }\n\n    // Maximize the processing duration based on the \"children\" interactions.\n    // We pick the earliest start processing duration, and the latest end\n    // processing duration to avoid under-reporting.\n    if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n      earliestCurrentEvent.processingStart = interaction.processingStart;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n      earliestCurrentEvent.processingEnd = interaction.processingEnd;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n  }\n\n  for (const interaction of interactions) {\n    storeEventIfEarliestForCategoryAndEndTime(interaction);\n  }\n\n  // Combine all the events that we have kept from all the per-category event\n  // maps back into an array and sort them by timestamp.\n  const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n                         .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n  keptEvents.sort((eventA, eventB) => {\n    return eventA.ts - eventB.ts;\n  });\n  return keptEvents;\n}\n\nfunction writeSyntheticTimespans(event: Types.Events.SyntheticInteractionPair): void {\n  const startEvent = event.args.data.beginEvent;\n  const endEvent = event.args.data.endEvent;\n\n  event.inputDelay = Types.Timing.Micro(event.processingStart - startEvent.ts);\n  event.mainThreadHandling = Types.Timing.Micro(event.processingEnd - event.processingStart);\n  event.presentationDelay = Types.Timing.Micro(endEvent.ts - event.processingEnd);\n}\n\nexport async function finalize(): Promise<void> {\n  const {navigationsByFrameId} = metaHandlerData();\n\n  // For each interaction start event, find the async end event by the ID, and then create the Synthetic Interaction event.\n  for (const interactionStartEvent of eventTimingStartEventsForInteractions) {\n    const endEvent = eventTimingEndEventsById.get(interactionStartEvent.id);\n    if (!endEvent) {\n      // If we cannot find an end event, bail and drop this event.\n      continue;\n    }\n    const {type, interactionId, timeStamp, processingStart, processingEnd} = interactionStartEvent.args.data;\n    if (!type || !interactionId || !timeStamp || !processingStart || !processingEnd) {\n      // A valid interaction event that we care about has to have a type (e.g. pointerdown, keyup).\n      // We also need to ensure it has an interactionId and various timings. There are edge cases where these aren't included in the trace event.\n      continue;\n    }\n\n    // In the future we will add microsecond timestamps to the trace events…\n    // (See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/window_performance.cc;l=900-901;drc=b503c262e425eae59ced4a80d59d176ed07152c7 )\n    // …but until then we can use the millisecond precision values that are in\n    // the trace event. To adjust them to be relative to the event.ts and the\n    // trace timestamps, for both processingStart and processingEnd we subtract\n    // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n    // emitted in args.data), and then add that value to the event.ts. This\n    // will give us a processingStart and processingEnd time in microseconds\n    // that is relative to event.ts, and can be used when drawing boxes.\n    // There is some inaccuracy here as we are converting milliseconds to microseconds, but it is good enough until the backend emits more accurate numbers.\n    const processingStartRelativeToTraceTime = Types.Timing.Micro(\n        Helpers.Timing.milliToMicro(processingStart) - Helpers.Timing.milliToMicro(timeStamp) +\n            interactionStartEvent.ts,\n    );\n\n    const processingEndRelativeToTraceTime = Types.Timing.Micro(\n        (Helpers.Timing.milliToMicro(processingEnd) - Helpers.Timing.milliToMicro(timeStamp)) +\n        interactionStartEvent.ts);\n\n    // Ultimate frameId fallback only needed for TSC, see comments in the type.\n    const frameId = interactionStartEvent.args.frame ?? interactionStartEvent.args.data.frame ?? '';\n    const navigation = Helpers.Trace.getNavigationForTraceEvent(interactionStartEvent, frameId, navigationsByFrameId);\n    const navigationId = navigation?.args.data?.navigationId;\n    const interactionEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticInteractionPair>({\n          // Use the start event to define the common fields.\n          rawSourceEvent: interactionStartEvent,\n          cat: interactionStartEvent.cat,\n          name: interactionStartEvent.name,\n          pid: interactionStartEvent.pid,\n          tid: interactionStartEvent.tid,\n          ph: interactionStartEvent.ph,\n          processingStart: processingStartRelativeToTraceTime,\n          processingEnd: processingEndRelativeToTraceTime,\n          // These will be set in writeSyntheticTimespans()\n          inputDelay: Types.Timing.Micro(-1),\n          mainThreadHandling: Types.Timing.Micro(-1),\n          presentationDelay: Types.Timing.Micro(-1),\n          args: {\n            data: {\n              beginEvent: interactionStartEvent,\n              endEvent,\n              frame: frameId,\n              navigationId,\n            },\n          },\n          ts: interactionStartEvent.ts,\n          dur: Types.Timing.Micro(endEvent.ts - interactionStartEvent.ts),\n          type: interactionStartEvent.args.data.type,\n          interactionId: interactionStartEvent.args.data.interactionId,\n        });\n    writeSyntheticTimespans(interactionEvent);\n\n    interactionEvents.push(interactionEvent);\n  }\n\n  interactionEventsWithNoNesting.push(...removeNestedInteractions(interactionEvents));\n\n  // Pick the longest interactions from the set that were not nested, as we\n  // know those are the set of the largest interactions.\n  for (const interactionEvent of interactionEventsWithNoNesting) {\n    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n      longestInteractionEvent = interactionEvent;\n    }\n  }\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    allEvents,\n    beginCommitCompositorFrameEvents,\n    parseMetaViewportEvents,\n    interactionEvents,\n    interactionEventsWithNoNesting,\n    longestInteractionEvent,\n    interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n      return event.dur > LONG_INTERACTION_THRESHOLD;\n    })),\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing: Types.Timing.Micro): ScoreClassification {\n  if (timing <= INP_GOOD_TIMING) {\n    return ScoreClassification.GOOD;\n  }\n\n  if (timing <= INP_MEDIUM_TIMING) {\n    return ScoreClassification.OK;\n  }\n\n  return ScoreClassification.BAD;\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\nimport {data as userInteractionsHandlerData} from './UserInteractionsHandler.js';\nimport {data as workersData} from './WorkersHandler.js';\n\nexport interface WarningsData {\n  // Tracks warnings keyed by the event.\n  perEvent: Map<Types.Events.Event, Warning[]>;\n  // The same data in reverse: for each type of warning, track the events.\n  // Useful if we need to enumerate events by type of issue\n  perWarning: Map<Warning, Types.Events.Event[]>;\n}\n\nexport type Warning = 'LONG_TASK'|'IDLE_CALLBACK_OVER_TIME'|'FORCED_REFLOW'|'LONG_INTERACTION';\n\nconst warningsPerEvent: WarningsData['perEvent'] = new Map();\nconst eventsPerWarning: WarningsData['perWarning'] = new Map();\n\n/**\n * Tracks the stack formed by nested trace events up to a given point\n */\nconst allEventsStack: Types.Events.Event[] = [];\n/**\n * Tracks the stack formed by JS invocation trace events up to a given point.\n * F.e. FunctionCall, EvaluateScript, V8Execute.\n * Not to be confused with ProfileCalls.\n */\nconst jsInvokeStack: Types.Events.Event[] = [];\n/**\n * Tracks reflow events in a task.\n */\nconst taskReflowEvents: Types.Events.Event[] = [];\n/**\n * Tracks events containing long running tasks. These are compared later against the worker thread pool to filter out long tasks from worker threads.\n */\nconst longTaskEvents: Types.Events.Event[] = [];\n\nexport const FORCED_REFLOW_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(30));\n\nexport const LONG_MAIN_THREAD_TASK_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(50));\n\nexport function reset(): void {\n  warningsPerEvent.clear();\n  eventsPerWarning.clear();\n  allEventsStack.length = 0;\n  jsInvokeStack.length = 0;\n  taskReflowEvents.length = 0;\n  longTaskEvents.length = 0;\n}\n\nfunction storeWarning(event: Types.Events.Event, warning: Warning): void {\n  const existingWarnings = Platform.MapUtilities.getWithDefault(warningsPerEvent, event, () => []);\n  existingWarnings.push(warning);\n  warningsPerEvent.set(event, existingWarnings);\n\n  const existingEvents = Platform.MapUtilities.getWithDefault(eventsPerWarning, warning, () => []);\n  existingEvents.push(event);\n  eventsPerWarning.set(warning, existingEvents);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  processForcedReflowWarning(event);\n  if (event.name === Types.Events.Name.RUN_TASK) {\n    const {duration} = Helpers.Timing.eventTimingsMicroSeconds(event);\n    if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {\n      longTaskEvents.push(event);\n    }\n    return;\n  }\n\n  if (Types.Events.isFireIdleCallback(event)) {\n    const {duration} = Helpers.Timing.eventTimingsMilliSeconds(event);\n    if (duration > event.args.data.allottedMilliseconds) {\n      storeWarning(event, 'IDLE_CALLBACK_OVER_TIME');\n    }\n    return;\n  }\n}\n\n/**\n * Reflows* are added a warning to if:\n * 1. They are forced/sync, meaning they are invoked by JS and finish\n *    during the Script execution.\n * 2. Their duration exceeds a threshold.\n * - *Reflow: The style recalculation and layout steps in a render task.\n */\nfunction processForcedReflowWarning(event: Types.Events.Event): void {\n  // Update the event and the JS invocation stacks.\n  accomodateEventInStack(event, allEventsStack);\n  accomodateEventInStack(event, jsInvokeStack, /* pushEventToStack */ Types.Events.isJSInvocationEvent(event));\n  if (jsInvokeStack.length) {\n    // Current event falls inside a JS call.\n    if (event.name === Types.Events.Name.LAYOUT || event.name === Types.Events.Name.UPDATE_LAYOUT_TREE) {\n      // A forced reflow happened. However we need to check if\n      // the threshold is surpassed to add a warning. Accumulate the\n      // event to check for this after the current Task is over.\n      taskReflowEvents.push(event);\n      return;\n    }\n  }\n  if (allEventsStack.length === 1) {\n    // We hit a new task. Check if the forced reflows in the previous\n    // task exceeded the threshold and add a warning if so.\n    const totalTime = taskReflowEvents.reduce((time, event) => time + (event.dur || 0), 0);\n    if (totalTime >= FORCED_REFLOW_THRESHOLD) {\n      taskReflowEvents.forEach(reflowEvent => storeWarning(reflowEvent, 'FORCED_REFLOW'));\n    }\n    taskReflowEvents.length = 0;\n  }\n}\n\n/**\n * Updates a given trace event stack given a new event.\n */\nfunction accomodateEventInStack(event: Types.Events.Event, stack: Types.Events.Event[], pushEventToStack = true): void {\n  let nextItem = stack.at(-1);\n  while (nextItem && event.ts > nextItem.ts + (nextItem.dur || 0)) {\n    stack.pop();\n    nextItem = stack.at(-1);\n  }\n  if (!pushEventToStack) {\n    return;\n  }\n  stack.push(event);\n}\n\nexport function deps(): HandlerName[] {\n  return ['UserInteractions', 'Workers'];\n}\n\nexport async function finalize(): Promise<void> {\n  // These events do exist on the UserInteractionsHandler, but we also put\n  // them into the WarningsHandler so that the warnings handler can be the\n  // source of truth and the way to look up all warnings for a given event.\n  // Otherwise, we would have to look up warnings across multiple handlers for\n  // a given event, which will start to get messy very quickly.\n  const longInteractions = userInteractionsHandlerData().interactionsOverThreshold;\n  for (const interaction of longInteractions) {\n    storeWarning(interaction, 'LONG_INTERACTION');\n  }\n\n  for (const event of longTaskEvents) {\n    if (!(event.tid, workersData().workerIdByThread.has(event.tid))) {\n      storeWarning(event, 'LONG_TASK');\n    }\n  }\n  longTaskEvents.length = 0;\n}\n\nexport function data(): WarningsData {\n  return {\n    perEvent: warningsPerEvent,\n    perWarning: eventsPerWarning,\n  };\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nexport interface WorkersData {\n  workerSessionIdEvents: readonly Types.Events.TracingSessionIdForWorker[];\n  workerIdByThread: Map<Types.Events.ThreadID, Types.Events.WorkerId>;\n  workerURLById: Map<Types.Events.WorkerId, string>;\n}\n\nconst sessionIdEvents: Types.Events.TracingSessionIdForWorker[] = [];\nconst workerIdByThread = new Map<Types.Events.ThreadID, Types.Events.WorkerId>();\nconst workerURLById = new Map<Types.Events.WorkerId, string>();\n\nexport function reset(): void {\n  sessionIdEvents.length = 0;\n  workerIdByThread.clear();\n  workerURLById.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isTracingSessionIdForWorker(event)) {\n    sessionIdEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  for (const sessionIdEvent of sessionIdEvents) {\n    if (!sessionIdEvent.args.data) {\n      continue;\n    }\n    workerIdByThread.set(sessionIdEvent.args.data.workerThreadId, sessionIdEvent.args.data.workerId);\n    workerURLById.set(sessionIdEvent.args.data.workerId, sessionIdEvent.args.data.url);\n  }\n}\n\nexport function data(): WorkersData {\n  return {\n    workerSessionIdEvents: sessionIdEvents,\n    workerIdByThread,\n    workerURLById,\n  };\n}\n", "export {};\n//# sourceMappingURL=types.js.map"],
  "mappings": "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",
  "names": ["entityMappings", "Types", "data", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "syntheticEvents", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "finalize", "handleEvent", "reset", "Types", "flows", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "reset", "handleEvent", "finalize", "data", "events", "deps", "traceBounds", "data", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "timeDeltas", "entityMappings", "entryToNode", "processes", "reset", "handleEvent", "finalize", "mainFrameId", "threadsInProcess", "data", "deps", "reset", "handleEvent", "finalize", "flows", "data", "entryToNode", "node", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "entryToNode", "handleEvent", "reset", "finalize", "data", "deps", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "reset", "handleEvent", "finalize", "data", "deps", "reset", "handleEvent", "finalize", "data", "deps", "allEvents", "events", "mainFrameId", "frames", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "reset", "handleEvent", "finalize", "gpuProcessId", "gpuThreadId", "data", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "reset", "handleEvent", "finalize", "data", "paintEvents", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "eventToInitiatorMap", "reset", "data", "handleEvent", "flows", "finalize", "deps", "data", "finalize", "handleEvent", "handleUserConfig", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "reset", "handleEvent", "data", "navigationsByNavigationId", "navigationsByFrameId", "finalize", "deps", "reset", "handleEvent", "finalize", "data", "traceBounds", "navigationsByNavigationId", "metricScoresByFrameId", "deps", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "deps", "paintImageEvents", "reset", "handleEvent", "data", "traceBounds", "finalize", "navigationsByFrameId", "mainFrameId", "currentCluster", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "deps", "reset", "handleEvent", "frames", "finalize", "data", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "allEvents", "reset", "handleEvent", "finalize", "navigationsByFrameId", "data", "deps", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Types", "reset", "handleEvent", "event", "deps", "finalize", "data"]
}
