{"version":3,"file":"FlowsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/FlowsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n\n// A flow is a logic connection between trace events. We display this\n// connection as arrows between trace events belonging to the same flow.\n\n// In the trace event format, flows are represented with pairing \"flow\n// phase\" events. Each flow phase event corresponds to one trace event\n// and indicates the role a trace event plays in a flow (start, step or\n// end). For each flow, one `start` and one `end` phase events are\n// included, while the amount of `step` phase events can be >= 0.\n\n// A flow phase event is assigned to a trace event when their cat, tid,\n// pid and ts are equal (see @flowPhaseBindingTokenForEvent ).\n\n// It's possible for a single event to belong to multiple flows. In that\n// case, it will have multiple corresponding flow phase events (one\n// per flow).\n\n// To parse flows, we first handle flow phase events, by creating unique\n// flows with the timestamps of each phase. Then, we place trace events\n// in the flows where their corresponding phase events were placed (if\n// there are any corresponding flow phase events at all).\nconst flowDataByGroupToken = new Map<string, {flowId: number, times: Types.Timing.MicroSeconds[]}>();\nconst flowPhaseBindingTokenToFlowId = new Map<string, Set<number>>();\nconst flowsById = new Map<number, {times: Types.Timing.MicroSeconds[], events: Types.Events.Event[]}>();\nconst flowEvents: Types.Events.FlowEvent[] = [];\nconst nonFlowEvents: Types.Events.Event[] = [];\nlet flows: Types.Events.Event[][] = [];\nconst ID_COMPONENT_SEPARATOR = '-$-';\nexport function reset(): void {\n  flows = [];\n  flowEvents.length = 0;\n  nonFlowEvents.length = 0;\n  flowDataByGroupToken.clear();\n  flowPhaseBindingTokenToFlowId.clear();\n  flowsById.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isFlowPhaseEvent(event)) {\n    flowEvents.push(event);\n    return;\n  }\n  nonFlowEvents.push(event);\n}\n\nfunction processNonFlowEvent(event: Types.Events.Event): void {\n  const flowPhaseBindingToken = flowPhaseBindingTokenForEvent(event);\n  const flowIds = flowPhaseBindingTokenToFlowId.get(flowPhaseBindingToken);\n  if (!flowIds) {\n    return;\n  }\n  for (const flowId of flowIds) {\n    const flow = flowsById.get(flowId);\n    if (!flow) {\n      continue;\n    }\n    const timeIndex = flow.times.indexOf(event.ts);\n    if (timeIndex < 0) {\n      continue;\n    }\n    flow.events[timeIndex] = event;\n  }\n}\n\n/**\n * Creates unique flows by tracking flow phase events. A new created\n * flow whenever a flow start phase event is detected.\n * Subsequent flow phase events with the same group token are added to\n * this flow until a flow end phase is detected.\n */\nfunction processFlowEvent(flowPhaseEvent: Types.Events.FlowEvent): void {\n  const flowGroup = flowGroupTokenForFlowPhaseEvent(flowPhaseEvent);\n  switch (flowPhaseEvent.ph) {\n    case (Types.Events.Phase.FLOW_START): {\n      const flowMetadata = {flowId: flowPhaseEvent.id, times: [flowPhaseEvent.ts]};\n      flowDataByGroupToken.set(flowGroup, flowMetadata);\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flowMetadata.flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_STEP): {\n      const flow = flowDataByGroupToken.get(flowGroup);\n      if (!flow || flow.times.length < 0) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore problematic event.\n        return;\n      }\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flow.flowId);\n      flow.times.push(flowPhaseEvent.ts);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_END): {\n      const flow = flowDataByGroupToken.get(flowGroup);\n      if (!flow || flow.times.length < 0) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore problematic event.\n        return;\n      }\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flow.flowId);\n      flow.times.push(flowPhaseEvent.ts);\n      flowsById.set(flow.flowId, {times: flow.times, events: []});\n      // We don't need this data anymore as the flow has been finished,\n      // so we can drop it.\n      flowDataByGroupToken.delete(flowGroup);\n    }\n  }\n}\n\n/**\n * A single trace event can belong to multiple flows. This method\n * tracks which flows (flowId) an event belongs to (given\n * its flow phase binding token).\n */\nfunction addFlowIdToFlowPhaseBinding(flowPhaseBinding: string, flowId: number): void {\n  let flowIds = flowPhaseBindingTokenToFlowId.get(flowPhaseBinding);\n  if (!flowIds) {\n    flowIds = new Set();\n  }\n  flowIds.add(flowId);\n  flowPhaseBindingTokenToFlowId.set(flowPhaseBinding, flowIds);\n}\n\n/**\n * Returns a token to group flow phase events (start, step and end)\n * belonging to the same flow. Flow phase events belonging to the same\n * flow share category, thread id, process id and name.\n *\n * Note that other phase events of other flows can share these\n * attributes too. For this reason, we group flow phase events in\n * cycles. A cycle starts on a flow start phase event and finishes on a\n * flow end phase event. For this reason, flow phase events need to be\n * handled in timestamp order.\n */\nfunction flowGroupTokenForFlowPhaseEvent(event: Types.Events.FlowEvent): string {\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.name}${ID_COMPONENT_SEPARATOR}${event.id}`;\n}\n\n/**\n * A flow phase binding is a token that allows us to associate a flow\n * phase event to its corresponding event. This association indicates\n * what role a trace event plays in a flow.\n * We can assign a trace event with a flow phase when its category,\n * thread id, process id and timestamp matches those of a flow phase\n * event.\n */\nfunction flowPhaseBindingTokenForEvent(event: Types.Events.Event): string {\n  // This function is called many times (one per event) and creating a\n  // string every time can trigger GC. If this becomes a problem, a\n  // possible optimization is to use a multi-key map with the\n  // binding token components, a trade off between memory performance\n  // and readability.\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.tid}${ID_COMPONENT_SEPARATOR}${event.pid}${\n      ID_COMPONENT_SEPARATOR}${event.ts}`;\n}\n\nexport async function finalize(): Promise<void> {\n  // Order is important: flow events need to be handled first.\n  flowEvents.forEach(processFlowEvent);\n  nonFlowEvents.forEach(processNonFlowEvent);\n  flows = [...flowsById.values()].map(f => f.events).filter(flow => flow.length > 1);\n}\n\nexport function data(): {flows: Types.Events.Event[][]} {\n  return {\n    flows,\n  };\n}\n"]}