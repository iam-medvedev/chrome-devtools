{"version":3,"file":"LayoutShiftsHandler.test.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {TraceLoader} from '../../../testing/TraceLoader.js';\nimport * as Trace from '../trace.js';\n\nasync function processTrace(context: Mocha.Suite|Mocha.Context|null, url: string): Promise<void> {\n  Trace.Handlers.ModelHandlers.Meta.reset();\n\n  Trace.Handlers.ModelHandlers.LayoutShifts.reset();\n\n  try {\n    const events = await TraceLoader.rawEvents(context, url);\n    for (const event of events) {\n      Trace.Handlers.ModelHandlers.Meta.handleEvent(event);\n      Trace.Handlers.ModelHandlers.Screenshots.handleEvent(event);\n      Trace.Handlers.ModelHandlers.LayoutShifts.handleEvent(event);\n    }\n  } catch (error) {\n    assert.fail(error);\n  }\n  await Trace.Handlers.ModelHandlers.Meta.finalize();\n  await Trace.Handlers.ModelHandlers.Screenshots.finalize();\n  await Trace.Handlers.ModelHandlers.LayoutShifts.finalize();\n}\n\ndescribe('LayoutShiftsHandler', function() {\n  beforeEach(async () => {\n    // The layout shifts handler stores by process, so to make life easier we\n    // run the meta handler here, too, so that later on we can get the IDs of\n    // the main renderer process and thread.\n    Trace.Handlers.ModelHandlers.Meta.reset();\n\n    Trace.Handlers.ModelHandlers.LayoutShifts.reset();\n  });\n\n  it('clusters a single frame correctly', async function() {\n    await processTrace(this, 'cls-single-frame.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.lengthOf(layoutShifts.clusters, 1);\n    assert.strictEqual(layoutShifts.clusters[0].clusterCumulativeScore, 0.29522728495836237);\n  });\n\n  it('creates a cluster after the maximum time gap between shifts', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.lengthOf(layoutShifts.clusters, 3);\n    // The first cluster should end because the maximum time gap between\n    // shifts ends, and thus the time between the last shift and the window\n    // end should be exactly MAX_SHIFT_TIME_DELTA;\n    const firstCluster = layoutShifts.clusters[0];\n    const firstClusterEvents = layoutShifts.clusters[0].events;\n\n    assert.strictEqual(\n        firstCluster.clusterWindow.max - firstClusterEvents[firstClusterEvents.length - 1].ts,\n        Trace.Handlers.ModelHandlers.LayoutShifts.MAX_SHIFT_TIME_DELTA);\n\n    // There are seven shifts in quick succession in the first cluster,\n    // only one shift in the second cluster and only one shift in the\n    // third cluster.\n    assert.lengthOf(layoutShifts.clusters[0].events, 7);\n    assert.lengthOf(layoutShifts.clusters[1].events, 1);\n    assert.lengthOf(layoutShifts.clusters[2].events, 1);\n  });\n\n  it('creates a cluster after a navigation', async function() {\n    await processTrace(this, 'cls-cluster-navigation.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    const {navigationsByFrameId, mainFrameId} = Trace.Handlers.ModelHandlers.Meta.data();\n\n    const navigations = navigationsByFrameId.get(mainFrameId);\n    if (!navigations || navigations.length === 0) {\n      assert.fail('No navigations found');\n    }\n\n    assert.strictEqual(layoutShifts.clusters[0].clusterWindow.max, navigations[0].ts);\n    // The first cluster happens before any navigation\n    assert.strictEqual(layoutShifts.clusters[0].navigationId, Trace.Types.Events.NO_NAVIGATION);\n\n    // We should see an initial cluster here from the first layout shifts,\n    // followed by 1 for each of the navigations themselves.\n    assert.strictEqual(layoutShifts.clusters.length, navigations.length + 1);\n\n    const secondCluster = layoutShifts.clusters[1];\n    // The second cluster should be marked to start at the first shift timestamp.\n    assert.strictEqual(secondCluster.clusterWindow.min, secondCluster.events[0].ts);\n\n    // The second cluster happened after the first navigation, so it should\n    // have navigationId set to the ID of the first navigation\n    assert.isDefined(secondCluster.navigationId);\n    assert.strictEqual(secondCluster.navigationId, navigations[0].args.data?.navigationId);\n  });\n\n  it('creates a cluster after exceeding the continuous shift limit', async function() {\n    await processTrace(this, 'cls-cluster-max-duration.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.lengthOf(layoutShifts.clusters, 2);\n    // Cluster must be closed as soon as MAX_CLUSTER_DURATION is reached, even if\n    // there is a gap greater than MAX_SHIFT_TIME_DELTA right after the max window\n    // length happens.\n    assert.strictEqual(\n        layoutShifts.clusters[0].clusterWindow.max - layoutShifts.clusters[0].clusterWindow.min,\n        Trace.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n  it('sets the end of the last session window to the trace end time correctly', async function() {\n    await processTrace(this, 'cls-cluster-max-duration.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(\n        layoutShifts.clusters.at(-1)?.clusterWindow.max, Trace.Handlers.ModelHandlers.Meta.data().traceBounds.max);\n  });\n\n  it('sets the end of the last session window to the max gap between duration correctly', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    const lastWindow = layoutShifts.clusters.at(-1)?.clusterWindow;\n    const lastShiftInWindow = layoutShifts.clusters.at(-1)?.events.at(-1);\n    if (!lastWindow) {\n      assert.fail('Session window not found.');\n    }\n\n    if (!lastShiftInWindow) {\n      assert.fail('Session window not found.');\n    }\n    assert.strictEqual(\n        lastWindow.max, lastShiftInWindow.ts + Trace.Handlers.ModelHandlers.LayoutShifts.MAX_SHIFT_TIME_DELTA);\n    assert.isBelow(lastWindow.range, Trace.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n  it('sets the end of the last session window to the max session duration correctly', async function() {\n    await processTrace(this, 'cls-last-cluster-max-duration.json.gz');\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    const lastWindow = layoutShifts.clusters.at(-1)?.clusterWindow;\n    const lastShiftInWindow = layoutShifts.clusters.at(-1)?.events.at(-1);\n    if (!lastWindow) {\n      assert.fail('Session window not found.');\n    }\n\n    if (!lastShiftInWindow) {\n      assert.fail('Session window not found.');\n    }\n    assert.strictEqual(lastWindow.range, Trace.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n\n  it('demarcates cluster score windows correctly', async function() {\n    await processTrace(this, 'cls-multiple-frames.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.lengthOf(layoutShifts.clusters, 5);\n\n    for (const cluster of layoutShifts.clusters) {\n      let clusterScore = 0;\n      for (const event of cluster.events) {\n        const scoreBeforeEvent = clusterScore;\n        clusterScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n\n        // Here we've crossed the threshold from Good to NI (but not Bad) so\n        // check that both the Good and NI windows values are set as expected.\n        if (scoreBeforeEvent < Trace.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.NEEDS_IMPROVEMENT &&\n            clusterScore >= Trace.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.NEEDS_IMPROVEMENT &&\n            clusterScore < Trace.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD) {\n          assert.strictEqual(cluster.scoreWindows.good.max, event.ts - 1);\n          if (!cluster.scoreWindows.needsImprovement) {\n            assert.fail('No Needs Improvement window');\n          }\n          assert.strictEqual(cluster.scoreWindows.needsImprovement.min, event.ts);\n        }\n\n        // Here we have transitioned from either Good or NI to Bad, so\n        // again we assert that the Bad window starts when expected,\n        // and that either the NI or Good window finishes just prior.\n        if (scoreBeforeEvent < Trace.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD &&\n            clusterScore >= Trace.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD) {\n          if (!cluster.scoreWindows.bad) {\n            assert.fail('No Bad window');\n          }\n\n          if (cluster.scoreWindows.needsImprovement) {\n            assert.strictEqual(cluster.scoreWindows.needsImprovement.max, event.ts - 1);\n          } else {\n            assert.strictEqual(cluster.scoreWindows.good.max, event.ts - 1);\n          }\n          assert.strictEqual(cluster.scoreWindows.bad.min, event.ts);\n        }\n      }\n    }\n  });\n\n  it('calculates Cumulative Layout Shift correctly for multiple session windows', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = Trace.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.lengthOf(layoutShifts.clusters, 3);\n\n    let globalCLS = 0;\n    let clusterCount = 1;\n    let clusterWithCLS = 0;\n    for (const cluster of layoutShifts.clusters) {\n      let clusterCumulativeScore = 0;\n      for (const shift of cluster.events) {\n        clusterCumulativeScore += shift.args.data?.weighted_score_delta || 0;\n        // Test the cumulative score until this shift.\n        assert.strictEqual(shift.parsedData.cumulativeWeightedScoreInWindow, clusterCumulativeScore);\n        // Test the score of this shift's session window.\n        assert.strictEqual(shift.parsedData.sessionWindowData.cumulativeWindowScore, cluster.clusterCumulativeScore);\n        // Test the id of this shift's session window.\n        assert.strictEqual(shift.parsedData.sessionWindowData.id, clusterCount);\n      }\n      clusterCount++;\n      // Test the accumulated\n      assert.strictEqual(cluster.clusterCumulativeScore, clusterCumulativeScore);\n      if (cluster.clusterCumulativeScore > globalCLS) {\n        globalCLS = cluster.clusterCumulativeScore;\n        clusterWithCLS = clusterCount - 1;\n      }\n    }\n    // Test the calculated CLS.\n    assert.strictEqual(layoutShifts.sessionMaxScore, globalCLS);\n    assert.strictEqual(layoutShifts.clsWindowID, clusterWithCLS);\n  });\n\n  it('calculates worst shift correctly for clusters', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const clusters = Trace.Handlers.ModelHandlers.LayoutShifts.data().clusters;\n    assert.isNotEmpty(clusters);\n\n    for (const cluster of clusters) {\n      // Get the max shift score from the list of layout shifts.\n      const maxShiftScore = Math.max(...cluster.events.map(s => s.args.data?.weighted_score_delta ?? 0));\n      const gotShift = cluster.worstShiftEvent as Trace.Types.Events.SyntheticLayoutShift;\n      assert.isNotNull(gotShift);\n      // Make sure the worstShiftEvent's data matches the maxShiftScore.\n      assert.strictEqual(gotShift.args.data?.weighted_score_delta ?? 0, maxShiftScore);\n    }\n  });\n\n  it('correctly calculates the duration and start time of the clusters', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const clusters = Trace.Handlers.ModelHandlers.LayoutShifts.data().clusters;\n    assert.isNotEmpty(clusters);\n\n    for (const cluster of clusters) {\n      // Earliest and latest layout shifts should match.\n      const earliestLayoutShiftTs = Math.min(...cluster.events.map(s => s.ts));\n      assert.strictEqual(cluster.events[0].ts, earliestLayoutShiftTs);\n      const latestLayoutShiftTs = Math.max(...cluster.events.map(s => s.ts));\n      assert.strictEqual(cluster.events[cluster.events.length - 1].ts, latestLayoutShiftTs);\n      // earliest layout shift ts should be the cluster's ts.\n      assert.strictEqual(cluster.ts, earliestLayoutShiftTs);\n\n      const lastShiftTimings = Trace.Helpers.Timing.eventTimingsMicroSeconds(cluster.events[cluster.events.length - 1]);\n      const wantEndTime = lastShiftTimings.endTime + Trace.Handlers.ModelHandlers.LayoutShifts.MAX_SHIFT_TIME_DELTA;\n      const dur = Trace.Types.Timing.Micro(wantEndTime - earliestLayoutShiftTs);\n      assert.strictEqual(cluster.dur || 0, dur);\n    }\n  });\n});\n"]}