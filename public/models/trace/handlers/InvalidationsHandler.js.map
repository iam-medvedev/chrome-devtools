{"version":3,"file":"InvalidationsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/InvalidationsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\n/**\n * @file Associates invalidation to recalc/layout events; mostly used in \"invalidation tracking\" experiment.\n * \"Invalidations\" == \"mutations\" == \"damage\".\n * A DOM change that means we need to recompute style or layout is an invalidation that's tracked here.\n * If the experiment `timeline-invalidation-tracking` is enabled, the `disabledByDefault('devtools.timeline.invalidationTracking')` trace category is enabled, which contains most of these events.\n */\n\ninterface InvalidationsStatePerFrame {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n  lastRecalcStyleEvent: Types.Events.RecalcStyle|null;\n  hasPainted: boolean;\n  pendingInvalidations: Types.Events.InvalidationTrackingEvent[];\n}\n\nconst frameStateByFrame = new Map<string, InvalidationsStatePerFrame>();\nlet maxInvalidationsPerEvent: number|null = null;\n\nexport function reset(): void {\n  frameStateByFrame.clear();\n  maxInvalidationsPerEvent = null;\n}\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  maxInvalidationsPerEvent = userConfig.maxInvalidationEventsPerEvent;\n}\n\nfunction getState(frameId: string): InvalidationsStatePerFrame {\n  let frameState = frameStateByFrame.get(frameId);\n  if (!frameState) {\n    frameState = {\n      invalidationsForEvent: new Map(),\n      invalidationCountForEvent: new Map(),\n      lastRecalcStyleEvent: null,\n      pendingInvalidations: [],\n      hasPainted: false,\n    };\n    frameStateByFrame.set(frameId, frameState);\n  }\n  return frameState;\n}\n\nfunction getFrameId(event: Types.Events.Event): string|null {\n  if (Types.Events.isRecalcStyle(event) || Types.Events.isLayout(event)) {\n    return event.args.beginData?.frame ?? null;\n  }\n  return event.args?.data?.frame ?? null;\n}\n\nfunction addInvalidationToEvent(\n    frameState: InvalidationsStatePerFrame, event: Types.Events.Event,\n    invalidation: Types.Events.InvalidationTrackingEvent): void {\n  const existingInvalidations = frameState.invalidationsForEvent.get(event) || [];\n  existingInvalidations.push(invalidation);\n\n  if (maxInvalidationsPerEvent !== null && existingInvalidations.length > maxInvalidationsPerEvent) {\n    existingInvalidations.shift();\n  }\n  frameState.invalidationsForEvent.set(event, existingInvalidations);\n\n  const count = frameState.invalidationCountForEvent.get(event) ?? 0;\n  frameState.invalidationCountForEvent.set(event, count + 1);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // Special case: if we have been configured to not store any invalidations,\n  // we take that as a sign that we don't even want to gather any invalidations\n  // data at all and early exit.\n  if (maxInvalidationsPerEvent === 0) {\n    return;\n  }\n\n  const frameId = getFrameId(event);\n  if (!frameId) {\n    return;\n  }\n  const thisFrame = getState(frameId);\n\n  if (Types.Events.isRecalcStyle(event)) {\n    thisFrame.lastRecalcStyleEvent = event;\n\n    // Associate any prior invalidations with this recalc event.\n    for (const invalidation of thisFrame.pendingInvalidations) {\n      if (Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        // LayoutInvalidation events cannot be associated with a LayoutTree\n        // event.\n        continue;\n      }\n      addInvalidationToEvent(thisFrame, event, invalidation);\n    }\n    return;\n  }\n\n  if (Types.Events.isInvalidationTracking(event)) {\n    if (thisFrame.hasPainted) {\n      // If we have painted, then we can clear out the list of all existing\n      // invalidations, as we cannot associate them across frames.\n      thisFrame.pendingInvalidations.length = 0;\n      thisFrame.lastRecalcStyleEvent = null;\n      thisFrame.hasPainted = false;\n    }\n\n    // Style invalidation events can occur before and during recalc styles. When we get a recalc style event, we check and associate any prior invalidations with it.\n    // But any invalidations that occur during a RecalcStyle\n    // event would be reported in trace events after. So each time we get an\n    // invalidation that might be due to a style recalc, we check if the\n    // timings overlap and if so associate them.\n    if (thisFrame.lastRecalcStyleEvent &&\n        (Types.Events.isScheduleStyleInvalidationTracking(event) ||\n         Types.Events.isStyleRecalcInvalidationTracking(event) ||\n         Types.Events.isStyleInvalidatorInvalidationTracking(event))) {\n      const recalcLastRecalc = thisFrame.lastRecalcStyleEvent;\n      const recalcEndTime = recalcLastRecalc.ts + (recalcLastRecalc.dur || 0);\n      if (event.ts >= recalcLastRecalc.ts && event.ts <= recalcEndTime) {\n        addInvalidationToEvent(thisFrame, recalcLastRecalc, event);\n      }\n    }\n\n    thisFrame.pendingInvalidations.push(event);\n    return;\n  }\n\n  if (Types.Events.isPaint(event)) {\n    thisFrame.hasPainted = true;\n    return;\n  }\n\n  if (Types.Events.isLayout(event)) {\n    for (const invalidation of thisFrame.pendingInvalidations) {\n      // The only invalidations that cause a Layout are LayoutInvalidations :)\n      if (!Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        continue;\n      }\n      addInvalidationToEvent(thisFrame, event, invalidation);\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\ninterface InvalidationsData {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n}\n\nexport function data(): InvalidationsData {\n  const invalidationsForEvent = new Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>();\n  const invalidationCountForEvent = new Map<Types.Events.Event, number>();\n  for (const frame of frameStateByFrame.values()) {\n    for (const [event, invalidations] of frame.invalidationsForEvent.entries()) {\n      invalidationsForEvent.set(event, invalidations);\n    }\n    for (const [event, count] of frame.invalidationCountForEvent.entries()) {\n      invalidationCountForEvent.set(event, count);\n    }\n  }\n  return {\n    invalidationsForEvent,\n    invalidationCountForEvent,\n  };\n}\n"]}