{"version":3,"file":"UserInteractionsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/UserInteractionsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// This handler gathers EventTimings into Interactions, which we use to show\n// interactions and highlight long interactions to the user, along with INP.\n\nlet beginCommitCompositorFrameEvents: Types.Events.BeginCommitCompositorFrame[] = [];\nlet parseMetaViewportEvents: Types.Events.ParseMetaViewport[] = [];\n\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(500));\n\nexport interface UserInteractionsData {\n  /** All the BeginCommitCompositorFrame events we found in the trace */\n  beginCommitCompositorFrameEvents: readonly Types.Events.BeginCommitCompositorFrame[];\n  /** All the ParseMetaViewport events we found in the trace */\n  parseMetaViewportEvents: readonly Types.Events.ParseMetaViewport[];\n  /**\n   * All the interaction events we found in the trace that had an\n   * interactionId and a duration > 0\n   **/\n  interactionEvents: readonly Types.Events.SyntheticInteractionPair[];\n  /**\n   * If the user rapidly generates interaction events (think typing into a\n   * text box), in the UI we only really want to show the user the longest\n   * interaction in that set.\n   * For example picture interactions like this:\n   * ===[interaction A]==========\n   *       =[interaction B]======\n   *            =[interaction C]=\n   *\n   * These events all end at the same time, and so in this instance we only want\n   * to show the first interaction A on the timeline, as that is the longest one\n   * and the one the developer should be focusing on. So this array of events is\n   * all the interaction events filtered down, removing any nested interactions\n   * entirely.\n   **/\n  interactionEventsWithNoNesting: readonly Types.Events.SyntheticInteractionPair[];\n  // The longest duration interaction event. Can be null if the trace has no interaction events.\n  longestInteractionEvent: Readonly<Types.Events.SyntheticInteractionPair>|null;\n  // All interactions that went over the interaction threshold (200ms, see https://web.dev/inp/)\n  interactionsOverThreshold: Readonly<Set<Types.Events.SyntheticInteractionPair>>;\n}\n\nlet longestInteractionEvent: Types.Events.SyntheticInteractionPair|null = null;\n\nlet interactionEvents: Types.Events.SyntheticInteractionPair[] = [];\nlet interactionEventsWithNoNesting: Types.Events.SyntheticInteractionPair[] = [];\nlet eventTimingStartEventsForInteractions: Types.Events.EventTimingBegin[] = [];\nlet eventTimingEndEventsForInteractions: Types.Events.EventTimingEnd[] = [];\n\nexport function reset(): void {\n  beginCommitCompositorFrameEvents = [];\n  parseMetaViewportEvents = [];\n  interactionEvents = [];\n  eventTimingStartEventsForInteractions = [];\n  eventTimingEndEventsForInteractions = [];\n  interactionEventsWithNoNesting = [];\n  longestInteractionEvent = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isBeginCommitCompositorFrame(event)) {\n    beginCommitCompositorFrameEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isParseMetaViewport(event)) {\n    parseMetaViewportEvents.push(event);\n    return;\n  }\n\n  if (!Types.Events.isEventTiming(event)) {\n    return;\n  }\n\n  if (Types.Events.isEventTimingEnd(event)) {\n    // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n    eventTimingEndEventsForInteractions.push(event);\n  }\n\n  // From this point on we want to find events that represent interactions.\n  // These events are always start events - those are the ones that contain all\n  // the metadata about the interaction.\n  if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  // Store the start event. In the finalize() function we will pair this with\n  // its end event and create the synthetic interaction event.\n  eventTimingStartEventsForInteractions.push(event);\n}\n\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n  'pointerdown',\n  'touchstart',\n  'pointerup',\n  'touchend',\n  'mousedown',\n  'mouseup',\n  'click',\n]);\n\nconst keyboardEventTypes = new Set([\n  'keydown',\n  'keypress',\n  'keyup',\n]);\n\nexport type InteractionCategory = 'KEYBOARD'|'POINTER'|'OTHER';\nexport function categoryOfInteraction(interaction: Types.Events.SyntheticInteractionPair): InteractionCategory {\n  if (pointerEventTypes.has(interaction.type)) {\n    return 'POINTER';\n  }\n  if (keyboardEventTypes.has(interaction.type)) {\n    return 'KEYBOARD';\n  }\n\n  return 'OTHER';\n}\n\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n *\n * Additionally, this method will also maximise the processing duration of the\n * events that we keep as non-nested. We want to make sure we give an accurate\n * representation of main thread activity, so if we keep an event + hide its\n * nested children, we set the top level event's processing start &\n * processing end to be the earliest processing start & the latest processing\n * end of its children. This ensures we report a more accurate main thread\n * activity time which is important as we want developers to focus on fixing\n * this.\n **/\nexport function removeNestedInteractionsAndSetProcessingTime(\n    interactions: readonly Types.Events.SyntheticInteractionPair[]): readonly Types.Events.SyntheticInteractionPair[] {\n  /**\n   * Because we nest events only that are in the same category, we store the\n   * longest event for a given end time by category.\n   **/\n  const earliestEventForEndTimePerCategory:\n      Record<InteractionCategory, Map<Types.Timing.Micro, Types.Events.SyntheticInteractionPair>> = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n      };\n\n  function storeEventIfEarliestForCategoryAndEndTime(interaction: Types.Events.SyntheticInteractionPair): void {\n    const category = categoryOfInteraction(interaction);\n    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n    const endTime = Types.Timing.Micro(interaction.ts + interaction.dur);\n\n    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n    if (!earliestCurrentEvent) {\n      earliestEventForEndTime.set(endTime, interaction);\n      return;\n    }\n    if (interaction.ts < earliestCurrentEvent.ts) {\n      earliestEventForEndTime.set(endTime, interaction);\n    } else if (\n        interaction.ts === earliestCurrentEvent.ts &&\n        interaction.interactionId === earliestCurrentEvent.interactionId) {\n      // We have seen in traces that the same interaction can have multiple\n      // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n      // events will have an event handler bound to it which caused delay on\n      // the main thread, and the others will not. This leads to a situation\n      // where if we pick one of the events that had no event handler, its\n      // processing duration (processingEnd - processingStart) will be 0, but if we\n      // had picked the event that had the slow event handler, we would show\n      // correctly the main thread delay due to the event handler.\n      // So, if we find events with the same interactionId and the same\n      // begin/end times, we pick the one with the largest (processingEnd -\n      // processingStart) time in order to make sure we find the event with the\n      // worst main thread delay, as that is the one the user should care\n      // about.\n      const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n      const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n\n      // Use the new interaction if it has a longer processing duration than the existing one.\n      if (newProcessingDuration > currentProcessingDuration) {\n        earliestEventForEndTime.set(endTime, interaction);\n      }\n    }\n\n    // Maximize the processing duration based on the \"children\" interactions.\n    // We pick the earliest start processing duration, and the latest end\n    // processing duration to avoid under-reporting.\n    if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n      earliestCurrentEvent.processingStart = interaction.processingStart;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n      earliestCurrentEvent.processingEnd = interaction.processingEnd;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n  }\n\n  for (const interaction of interactions) {\n    storeEventIfEarliestForCategoryAndEndTime(interaction);\n  }\n\n  // Combine all the events that we have kept from all the per-category event\n  // maps back into an array and sort them by timestamp.\n  const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n                         .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n  keptEvents.sort((eventA, eventB) => {\n    return eventA.ts - eventB.ts;\n  });\n  return keptEvents;\n}\n\nfunction writeSyntheticTimespans(event: Types.Events.SyntheticInteractionPair): void {\n  const startEvent = event.args.data.beginEvent;\n  const endEvent = event.args.data.endEvent;\n\n  event.inputDelay = Types.Timing.Micro(event.processingStart - startEvent.ts);\n  event.mainThreadHandling = Types.Timing.Micro(event.processingEnd - event.processingStart);\n  event.presentationDelay = Types.Timing.Micro(endEvent.ts - event.processingEnd);\n}\n\nexport async function finalize(): Promise<void> {\n  const {navigationsByFrameId} = metaHandlerData();\n\n  const beginAndEndEvents = Platform.ArrayUtilities.mergeOrdered(\n                                eventTimingStartEventsForInteractions, eventTimingEndEventsForInteractions,\n                                Helpers.Trace.eventTimeComparator) as Types.Events.EventTimingBeginOrEnd[];\n\n  // Pair up the begin & end events and create synthetic user timing events.\n  const beginEventById = new Map<string, Types.Events.EventTimingBegin[]>();\n  for (const event of beginAndEndEvents) {\n    if (Types.Events.isEventTimingStart(event)) {\n      const forId = beginEventById.get(event.id) ?? [];\n      forId.push(event);\n      beginEventById.set(event.id, forId);\n    } else if (Types.Events.isEventTimingEnd(event)) {\n      const beginEvents = beginEventById.get(event.id) ?? [];\n      const beginEvent = beginEvents.pop();\n      if (!beginEvent) {\n        continue;\n      }\n      const {type, interactionId, timeStamp, processingStart, processingEnd} = beginEvent.args.data;\n      if (!type || !interactionId || !timeStamp || !processingStart || !processingEnd) {\n        // A valid interaction event that we care about has to have a type (e.g. pointerdown, keyup).\n        // We also need to ensure it has an interactionId and various timings. There are edge cases where these aren't included in the trace event.\n        continue;\n      }\n      // In the future we will add microsecond timestamps to the trace events…\n      // (See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/window_performance.cc;l=900-901;drc=b503c262e425eae59ced4a80d59d176ed07152c7 )\n      // …but until then we can use the millisecond precision values that are in\n      // the trace event. To adjust them to be relative to the event.ts and the\n      // trace timestamps, for both processingStart and processingEnd we subtract\n      // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n      // emitted in args.data), and then add that value to the event.ts. This\n      // will give us a processingStart and processingEnd time in microseconds\n      // that is relative to event.ts, and can be used when drawing boxes.\n      // There is some inaccuracy here as we are converting milliseconds to\n      // microseconds, but it is good enough until the backend emits more\n      // accurate numbers.\n      const processingStartRelativeToTraceTime = Types.Timing.Micro(\n          Helpers.Timing.milliToMicro(processingStart) - Helpers.Timing.milliToMicro(timeStamp) + beginEvent.ts,\n      );\n\n      const processingEndRelativeToTraceTime = Types.Timing.Micro(\n          (Helpers.Timing.milliToMicro(processingEnd) - Helpers.Timing.milliToMicro(timeStamp)) + beginEvent.ts);\n\n      // Ultimate frameId fallback only needed for TSC, see comments in the type.\n      const frameId = beginEvent.args.frame ?? beginEvent.args.data.frame ?? '';\n      const navigation = Helpers.Trace.getNavigationForTraceEvent(beginEvent, frameId, navigationsByFrameId);\n      const navigationId = navigation?.args.data?.navigationId;\n      const interactionEvent =\n          Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticInteractionPair>({\n            // Use the start event to define the common fields.\n            rawSourceEvent: beginEvent,\n            cat: beginEvent.cat,\n            name: beginEvent.name,\n            pid: beginEvent.pid,\n            tid: beginEvent.tid,\n            ph: beginEvent.ph,\n            processingStart: processingStartRelativeToTraceTime,\n            processingEnd: processingEndRelativeToTraceTime,\n            // These will be set in writeSyntheticTimespans()\n            inputDelay: Types.Timing.Micro(-1),\n            mainThreadHandling: Types.Timing.Micro(-1),\n            presentationDelay: Types.Timing.Micro(-1),\n            args: {\n              data: {\n                beginEvent,\n                endEvent: event,\n                frame: frameId,\n                navigationId,\n              },\n            },\n            ts: beginEvent.ts,\n            dur: Types.Timing.Micro(event.ts - beginEvent.ts),\n            type: beginEvent.args.data.type,\n            interactionId: beginEvent.args.data.interactionId,\n          });\n      writeSyntheticTimespans(interactionEvent);\n      interactionEvents.push(interactionEvent);\n    }\n  }\n\n  // Once we gather up all the interactions, we want to remove nested\n  // interactions. Interactions can be nested because one user action (e.g. a\n  // click) will cause a pointerdown, pointerup and click. But we don't want to\n  // fill the interactions track with lots of noise. To fix this, we go through\n  // all the events and remove any nested ones so on the timeline we focus the\n  // user on the most important events, which we define as the longest one. But\n  // this algorithm assumes the events are in ASC order, so we first sort the\n  // set of interactions.\n  Helpers.Trace.sortTraceEventsInPlace(interactionEvents);\n  interactionEventsWithNoNesting.push(...removeNestedInteractionsAndSetProcessingTime(interactionEvents));\n\n  // Pick the longest interactions from the set that were not nested, as we\n  // know those are the set of the largest interactions.\n  for (const interactionEvent of interactionEventsWithNoNesting) {\n    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n      longestInteractionEvent = interactionEvent;\n    }\n  }\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    beginCommitCompositorFrameEvents,\n    parseMetaViewportEvents,\n    interactionEvents,\n    interactionEventsWithNoNesting,\n    longestInteractionEvent,\n    interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n      return event.dur > LONG_INTERACTION_THRESHOLD;\n    })),\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing: Types.Timing.Micro): ScoreClassification {\n  if (timing <= INP_GOOD_TIMING) {\n    return ScoreClassification.GOOD;\n  }\n\n  if (timing <= INP_MEDIUM_TIMING) {\n    return ScoreClassification.OK;\n  }\n\n  return ScoreClassification.BAD;\n}\n"]}