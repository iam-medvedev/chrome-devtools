{"version":3,"file":"AsyncJSCallsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/AsyncJSCallsHandler.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAC7B,OAAO,KAAK,QAAQ,MAAM,oCAAoC,CAAC;AAE/D,OAAO,KAAK,KAAK,MAAM,mBAAmB,CAAC;AAE3C,OAAO,EAAC,IAAI,IAAI,gBAAgB,EAAC,MAAM,mBAAmB,CAAC;AAC3D,OAAO,EAAC,IAAI,IAAI,mBAAmB,EAAC,MAAM,sBAAsB,CAAC;AAEjE,MAAM,yBAAyB,GAAkD,IAAI,GAAG,EAAE,CAAC;AAC3F,MAAM,oBAAoB,GACtB,IAAI,GAAG,EAAE,CAAC;AAEd,MAAM,UAAU,KAAK;IACnB,yBAAyB,CAAC,KAAK,EAAE,CAAC;IAClC,oBAAoB,CAAC,KAAK,EAAE,CAAC;AAC/B,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,CAAqB;AACjD,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,QAAQ;IAC5B,MAAM,EAAC,KAAK,EAAC,GAAG,gBAAgB,EAAE,CAAC;IACnC,MAAM,EAAC,WAAW,EAAC,GAAG,mBAAmB,EAAE,CAAC;IAC5C,2BAA2B;IAC3B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,MAAM,kBAAkB,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACtC,IAAI,CAAC,kBAAkB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,4BAA4B,CAAC,kBAAkB,CAAC,EAAE,CAAC;YAC1F,SAAS;QACX,CAAC;QACD,MAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC;QAClD,MAAM,YAAY,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,sBAAsB,CAAC,YAAY,CAAC,EAAE,CAAC;YACxE,iCAAiC;YACjC,SAAS;QACX,CAAC;QACD,MAAM,WAAW,GAAG,qBAAqB,CAAC,kBAAkB,EAAE,WAAW,CAAC,CAAC;QAC3E,IAAI,CAAC,WAAW,EAAE,CAAC;YACjB,kDAAkD;YAClD,SAAS;QACX,CAAC;QACD,MAAM,eAAe,GAAG,oCAAoC,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;QACxF,IAAI,CAAC,eAAe,EAAE,CAAC;YACrB,kDAAkD;YAClD,SAAS;QACX,CAAC;QACD,sCAAsC;QACtC,wCAAwC;QACxC,MAAM,WAAW,GAAG,QAAQ,CAAC,YAAY,CAAC,cAAc,CAAC,yBAAyB,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;QAC3G,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAElC,sCAAsC;QACtC,mEAAmE;QACnE,gCAAgC;QAChC,MAAM,qBAAqB,GAAG,+BAA+B,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;QACzF,KAAK,MAAM,IAAI,IAAI,qBAAqB,EAAE,CAAC;YACzC,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,EAAC,QAAQ,EAAE,SAAS,EAAE,WAAW,EAAC,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;AACH,CAAC;AACD;;;;GAIG;AACH,SAAS,qBAAqB,CAC1B,kBAA2D,EAC3D,WAAwE;IAC1E,IAAI,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,kBAAkB,CAAC,EAAE,MAAM,CAAC;IACvD,OAAO,IAAI,EAAE,CAAC;QACZ,IAAI,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YACvF,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;QACD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AACD;;;;;GAKG;AACH,SAAS,4BAA4B,CAAC,KAAyB;IAC7D,MAAM,qBAAqB,GAAG,KAAK,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;IACnE,MAAM,mBAAmB,GAAG,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IACvF,OAAO,KAAK,CAAC,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,CAAC,qBAAqB,IAAI,CAAC,mBAAmB,CAAC,CAAC;AACpG,CAAC;AAED;;;GAGG;AACH,SAAS,oCAAoC,CACzC,YAA+C,EAC/C,WAAwE;IAC1E,+DAA+D;IAC/D,mEAAmE;IACnE,OAAO,0BAA0B,CACtB,YAAY,EAAE,WAAW,EAAE,4BAA4B,EAAE,KAAK,CAAC,MAAM,CAAC,sBAAsB,CAAC;SACnG,EAAE,CAAC,CAAC,CAAC,CAAC;AACb,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,SAAS,+BAA+B,CACpC,YAA+C,EAC/C,WAAwE;IAC1E,+DAA+D;IAC/D,mEAAmE;IACnE,OAAO,0BAA0B,CAC7B,YAAY,EAAE,WAAW,EAAE,KAAK,CAAC,MAAM,CAAC,aAAa,EAAE,KAAK,CAAC,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAClG,CAAC;AAED;;;;GAIG;AACH,SAAS,0BAA0B,CAC/B,IAAwB,EAAE,WAAwE,EAClG,eAA0D,EAC1D,eAAuD;IACzD,MAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,MAAM,cAAc,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5C,MAAM,gBAAgB,GAAG,EAAE,CAAC;IAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC/C,MAAM,QAAQ,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;gBAChC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpC,CAAC;iBAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;gBACxC,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC1C,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED,MAAM,UAAU,IAAI;IAWlB,OAAO;QACL,yBAAyB;QACzB,oBAAoB;KACrB,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,IAAI;IAClB,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;AAC/B,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as flowsHandlerData} from './FlowsHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\nconst schedulerToRunEntryPoints: Map<Types.Events.Event, Types.Events.Event[]> = new Map();\nconst asyncCallToScheduler: Map<Types.Events.SyntheticProfileCall, {taskName: string, scheduler: Types.Events.Event}> =\n    new Map();\n\nexport function reset(): void {\n  schedulerToRunEntryPoints.clear();\n  asyncCallToScheduler.clear();\n}\n\nexport function handleEvent(_: Types.Events.Event): void {\n}\n\nexport async function finalize(): Promise<void> {\n  const {flows} = flowsHandlerData();\n  const {entryToNode} = rendererHandlerData();\n  // Process async task flows\n  for (const flow of flows) {\n    const asyncTaskScheduled = flow.at(0);\n    if (!asyncTaskScheduled || !Types.Events.isDebuggerAsyncTaskScheduled(asyncTaskScheduled)) {\n      continue;\n    }\n    const taskName = asyncTaskScheduled.args.taskName;\n    const asyncTaskRun = flow.at(1);\n    if (!asyncTaskRun || !Types.Events.isDebuggerAsyncTaskRun(asyncTaskRun)) {\n      // Unexpected flow shape, ignore.\n      continue;\n    }\n    const asyncCaller = findNearestJSAncestor(asyncTaskScheduled, entryToNode);\n    if (!asyncCaller) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    const asyncEntryPoint = findFirstJsInvocationForAsyncTaskRun(asyncTaskRun, entryToNode);\n    if (!asyncEntryPoint) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    // Set scheduler -> schedulee mapping.\n    // The schedulee being the JS entrypoint\n    const entryPoints = Platform.MapUtilities.getWithDefault(schedulerToRunEntryPoints, asyncCaller, () => []);\n    entryPoints.push(asyncEntryPoint);\n\n    // Set schedulee -> scheduler mapping.\n    // The schedulees being the JS calls (instead of the entrypoints as\n    // above, for usage ergonomics).\n    const scheduledProfileCalls = findFirstJSCallsForAsyncTaskRun(asyncTaskRun, entryToNode);\n    for (const call of scheduledProfileCalls) {\n      asyncCallToScheduler.set(call, {taskName, scheduler: asyncCaller});\n    }\n  }\n}\n/**\n * Given a DebuggerAsyncTaskScheduled event, returns its closest\n * ProfileCall or JS invocation ancestor, which represents the JS call\n * that scheduled the async task.\n */\nfunction findNearestJSAncestor(\n    asyncTaskScheduled: Types.Events.DebuggerAsyncTaskScheduled,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|null {\n  let node = entryToNode.get(asyncTaskScheduled)?.parent;\n  while (node) {\n    if (Types.Events.isProfileCall(node.entry) || acceptJSInvocationsPredicate(node.entry)) {\n      return node.entry;\n    }\n    node = node.parent;\n  }\n  return null;\n}\n/**\n * Entrypoints to JS execution in the timeline. We ignore those starting\n * with 'v8' because they aren't shown in the timeline, and ultimately\n * this function's output results in \"initiated\" events, so ideally this\n * returns events that end up in the flame chart.\n */\nfunction acceptJSInvocationsPredicate(event: Types.Events.Event): event is Types.Events.Event {\n  const eventIsConsoleRunTask = Types.Events.isConsoleRunTask(event);\n  const eventIsV8EntryPoint = event.name.startsWith('v8') || event.name.startsWith('V8');\n  return Types.Events.isJSInvocationEvent(event) && (eventIsConsoleRunTask || !eventIsV8EntryPoint);\n}\n\n/**\n * Given a DebuggerAsyncTaskRun event, returns its closest JS entry\n * point descendant, which contains the task being scheduled.\n */\nfunction findFirstJsInvocationForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|undefined {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n             asyncTaskRun, entryToNode, acceptJSInvocationsPredicate, Types.Events.isDebuggerAsyncTaskRun)\n      .at(0);\n}\n\n/**\n * Given an async task run event, returns the top level call frames\n * (profile calls) directly called by the async task. This implies that\n * any profile calls under another async task run event are ignored.\n * These profile calls represent the JS task being scheduled, AKA\n * the other part of the async stack.\n *\n * For example, here the profile calls \"js 1\", \"js 2\" and \"js 4\" would\n * be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |--FunctionCall--|\n * |-js 1-||-js 2-|        |-js 4-|\n * |-js 3-|\n *\n * But here, only \"js 1\" and \"js 2\" would be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |------------------------|\n * |-js 1-||-js 2-|       |---Async Task Run--|\n * |-js 3-|                |--FunctionCall--|\n *                          |-js 4-|\n */\nfunction findFirstJSCallsForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.SyntheticProfileCall[] {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n      asyncTaskRun, entryToNode, Types.Events.isProfileCall, Types.Events.isDebuggerAsyncTaskRun);\n}\n\n/**\n * Given a root event returns all the first descendants that meet a\n * predicate condition (predicateAccept) while ignoring subtrees whose\n * top event meets an ignore condition (predicateIgnore).\n */\nfunction findFirstDescendantsOfType<T extends Types.Events.Event>(\n    root: Types.Events.Event, entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>,\n    predicateAccept: (event: Types.Events.Event) => event is T,\n    predicateIgnore: (event: Types.Events.Event) => boolean): T[] {\n  const node = entryToNode.get(root);\n  if (!node) {\n    return [];\n  }\n  const childrenGroups = [[...node.children]];\n  const firstDescendants = [];\n  for (let i = 0; i < childrenGroups.length; i++) {\n    const siblings = childrenGroups[i];\n    for (let j = 0; j < siblings.length; j++) {\n      const node = siblings[j];\n      if (predicateAccept(node.entry)) {\n        firstDescendants.push(node.entry);\n      } else if (!predicateIgnore(node.entry)) {\n        childrenGroups.push([...node.children]);\n      }\n    }\n  }\n  return firstDescendants;\n}\n\nexport function data(): {\n  // Given a profile call, returns the JS entrypoint it scheduled (if any).\n  // For example, given a setTimeout call, returns the JS entry point\n  // trace event for the timeout callback run event (usually a\n  // FunctionCall event).\n  schedulerToRunEntryPoints: typeof schedulerToRunEntryPoints,\n  // Given a profile call, returns the profile call that scheduled it.\n  // For example given a timeout callback run event, returns its\n  // setTimeout call event.\n  asyncCallToScheduler: typeof asyncCallToScheduler,\n} {\n  return {\n    schedulerToRunEntryPoints,\n    asyncCallToScheduler,\n  };\n}\n\nexport function deps(): ['Renderer', 'Flows'] {\n  return ['Renderer', 'Flows'];\n}\n"]}