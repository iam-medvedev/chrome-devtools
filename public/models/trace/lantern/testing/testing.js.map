{
  "version": 3,
  "sources": ["../../../../../../../../front_end/testing/TraceLoader.ts", "../../../../../../../../front_end/models/trace/lantern/testing/MetricTestUtils.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../core/common/common.js';\nimport * as SDK from '../core/sdk/sdk.js';\nimport type * as Protocol from '../generated/protocol.js';\nimport * as Trace from '../models/trace/trace.js';\nimport type * as Timeline from '../panels/timeline/timeline.js';\nimport * as TraceBounds from '../services/trace_bounds/trace_bounds.js';\n\n// We maintain two caches:\n// 1. The file contents JSON.parsed for a given trace file.\n// 2. The trace engine models for a given file (used by the traceEngine function)\n// Both the file contents and the model data are not expected to change during\n// the lifetime of an instance of DevTools, so they are safe to cache and\n// re-use across tests to avoid extra time spent loading and parsing the same\n// inputs.\n// In the future once the data layer migration is complete, we can hopefully\n// simplify this into one method that loads the new engine and none of the old\n// ones.\nconst fileContentsCache = new Map<string, Trace.Types.File.Contents>();\n\ninterface ParsedTraceAndModel {\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  model: Trace.TraceModel.Model;\n}\n\n// The new engine cache is a map of maps of:\n// trace file name => trace engine configuration => trace data\n//\n// The first map is a Map of string (which is the name of the trace file) to a\n// new map, where the key is the trace engine configuration stringified.\n// This ensures that we cache as much as we can, but if you load the same trace\n// file with different trace engine configurations, we will not use the cache\n// and will reparse. This is required as some of the settings and experiments\n// change if events are kept and dropped.\nconst traceEngineCache = new Map<string, Map<string, ParsedTraceAndModel>>();\n\nexport interface TraceEngineLoaderOptions {\n  initTraceBounds: boolean;\n}\n\n/**\n * Loads trace files defined as fixtures in front_end/panels/timeline/fixtures/traces.\n *\n * Will automatically cache the results to save time processing the same trace\n * multiple times in a run of the test suite.\n **/\nexport class TraceLoader {\n  /**\n   * Parsing some trace files easily takes up more than our default Mocha timeout\n   * which is 2seconds. So for most tests that include parsing a trace, we have to\n   * increase the timeout. We use this function to ensure we set a consistent\n   * timeout across all trace model tests.\n   **/\n  static setTestTimeout(context: Mocha.Context|Mocha.Suite): void {\n    // Some traces take a long time to process, especially on our CQ machines.\n    // The trace that takes the longest on my Mac M1 Pro is ~3s (yahoo-news.json.gz).\n    // In CQ, that same trace takes ~10s (linux), ~7.5s (mac), ~11.5s (windows).\n    if (context.timeout() > 0) {\n      context.timeout(Math.max(context.timeout(), 45000));\n    }\n  }\n\n  /**\n   * Loads a trace file into memory and returns its contents after\n   * JSON.parse-ing them\n   *\n   **/\n  static async fixtureContents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Trace.Types.File.Contents> {\n    if (context) {\n      TraceLoader.setTestTimeout(context);\n    }\n    const cached = fileContentsCache.get(name);\n    if (cached) {\n      return cached;\n    }\n    const urlForTest = new URL(`../panels/timeline/fixtures/traces/${name}`, import.meta.url);\n\n    const contents = await TraceLoader.loadTraceFileFromURL(urlForTest);\n    fileContentsCache.set(name, contents);\n    return contents;\n  }\n\n  static async traceFile(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<Trace.Types.File.TraceFile> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n    const traceEvents = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return {traceEvents, metadata} as Trace.Types.File.TraceFile;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   **/\n  static async rawEvents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<readonly Trace.Types.Events.Event[]> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    return events;\n  }\n\n  /**\n   * Load the metadata from a trace file (throws if not present).\n   **/\n  static async metadata(context: Mocha.Context|Mocha.Suite|null, name: string): Promise<Trace.Types.File.MetaData> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const metadata = 'metadata' in contents ? contents.metadata : null;\n    if (!metadata) {\n      throw new Error('expected metadata but found none');\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from Trace Engine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawCPUProfile(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Protocol.Profiler.Profile> {\n    const contents = await TraceLoader.fixtureContents(context, name) as unknown as Protocol.Profiler.Profile;\n    return contents;\n  }\n\n  /**\n   * Executes only the new trace engine on the fixture and returns the resulting parsed data.\n   *\n   * @param context The Mocha test context. Processing a trace can easily\n   * takes up longer than the default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example. See TraceLoader.setTestTimeout.\n   * @param file The name of the trace file to be loaded.\n   * The trace file should be in ../panels/timeline/fixtures/traces folder.\n   * @param options Additional trace options.\n   * @param options.initTraceBounds (defaults to `true`) after the trace is\n   * loaded, the TraceBounds manager will automatically be initialised using\n   * the bounds from the trace.\n   * @param config The config the new trace engine should run with. Optional,\n   * will fall back to the Default config if not provided.\n   */\n  static async traceEngine(\n      context: Mocha.Context|Mocha.Suite|null, name: string,\n      config: Trace.Types.Configuration.Configuration = Trace.Types.Configuration.defaults(), opts = {\n        withTimelinePanel: true,\n      }): Promise<Trace.TraceModel.ParsedTrace> {\n    if (context) {\n      TraceLoader.setTestTimeout(context);\n    }\n    let timelineModule: typeof Timeline|undefined;\n    if (opts.withTimelinePanel) {\n      timelineModule = await import('../panels/timeline/timeline.js');\n    }\n    // Force the TraceBounds to be reset to empty. This ensures that in\n    // tests where we are using the new engine data we don't accidentally\n    // rely on the fact that a previous test has set the BoundsManager.\n    TraceBounds.TraceBounds.BoundsManager.instance({forceNew: true});\n\n    const configCacheKey = Trace.Types.Configuration.configToCacheKey(config);\n\n    const fromCache = traceEngineCache.get(name)?.get(configCacheKey);\n\n    // If we have results from the cache, we use those to ensure we keep the\n    // tests speedy and don't re-parse trace files over and over again.\n    if (fromCache) {\n      const parsedTrace = fromCache.parsedTrace;\n      await wrapInTimeout(context, () => {\n        const syntheticEventsManager = fromCache.model.syntheticTraceEventsManager(0);\n        if (!syntheticEventsManager) {\n          throw new Error('Cached trace engine result did not have a synthetic events manager instance');\n        }\n        Trace.Helpers.SyntheticEvents.SyntheticEventsManager.activate(syntheticEventsManager);\n        TraceLoader.initTraceBoundsManager(parsedTrace);\n        if (timelineModule) {\n          timelineModule.ModificationsManager.ModificationsManager.reset();\n          timelineModule.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(\n              fromCache.model, 0);\n        }\n      }, 4_000, 'Initializing state for cached trace');\n      return parsedTrace;\n    }\n\n    const fileContents = await wrapInTimeout(context, async () => {\n      return await TraceLoader.fixtureContents(context, name);\n    }, 30_000, `Loading fixtureContents for ${name}`);\n\n    const parsedTraceFileAndModel = await wrapInTimeout(context, async () => {\n      return await TraceLoader.executeTraceEngineOnFileContents(\n          fileContents, /* emulate fresh recording */ false, config);\n    }, 30_000, `Executing traceEngine for ${name}`);\n\n    const cacheByName = traceEngineCache.get(name) ?? new Map<string, ParsedTraceAndModel>();\n    cacheByName.set(configCacheKey, parsedTraceFileAndModel);\n    traceEngineCache.set(name, cacheByName);\n\n    TraceLoader.initTraceBoundsManager(parsedTraceFileAndModel.parsedTrace);\n    if (timelineModule) {\n      await wrapInTimeout(context, () => {\n        timelineModule.ModificationsManager.ModificationsManager.reset();\n        timelineModule.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(\n            parsedTraceFileAndModel.model, 0);\n      }, 5_000, `Creating modification manager for ${name}`);\n    }\n    return parsedTraceFileAndModel.parsedTrace;\n  }\n\n  /**\n   * Initialise the BoundsManager with the bounds from a trace.\n   * This isn't always required, but some of our code - particularly at the UI\n   * level - rely on this being set. This is always set in the actual panel, but\n   * parsing a trace in a test does not automatically set it.\n   **/\n  static initTraceBoundsManager(parsedTrace: Trace.TraceModel.ParsedTrace): void {\n    TraceBounds.TraceBounds.BoundsManager\n        .instance({\n          forceNew: true,\n        })\n        .resetWithNewBounds(parsedTrace.data.Meta.traceBounds);\n  }\n\n  static async executeTraceEngineOnFileContents(\n      contents: Trace.Types.File.Contents, emulateFreshRecording = false,\n      traceEngineConfig?: Trace.Types.Configuration.Configuration): Promise<ParsedTraceAndModel> {\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return await new Promise((resolve, reject) => {\n      const model = Trace.TraceModel.Model.createWithAllHandlers(traceEngineConfig);\n      model.addEventListener(Trace.TraceModel.ModelUpdateEvent.eventName, (event: Event) => {\n        const {data} = event as Trace.TraceModel.ModelUpdateEvent;\n\n        // When we receive the final update from the model, update the recording\n        // state back to waiting.\n        if (Trace.TraceModel.isModelUpdateDataComplete(data)) {\n          const parsedTrace = model.parsedTrace(0);\n          if (!parsedTrace) {\n            reject(new Error('Unable to load trace'));\n            return;\n          }\n\n          resolve({\n            model,\n            parsedTrace,\n          });\n        }\n      });\n\n      void model\n          .parse(events, {\n            metadata,\n            isFreshRecording: emulateFreshRecording,\n            async resolveSourceMap(params) {\n              const {sourceUrl, sourceMapUrl, cachedRawSourceMap} = params;\n\n              if (cachedRawSourceMap) {\n                return new SDK.SourceMap.SourceMap(sourceUrl, sourceMapUrl, cachedRawSourceMap);\n              }\n\n              if (sourceMapUrl.startsWith('data:')) {\n                const rawSourceMap = await (await fetch(sourceMapUrl)).json();\n                return new SDK.SourceMap.SourceMap(sourceUrl, sourceMapUrl, rawSourceMap);\n              }\n\n              return null;\n            },\n          })\n          .catch(e => console.error(e));\n    });\n  }\n\n  static async loadTraceFileFromURL(url: URL): Promise<Trace.Types.File.TraceFile> {\n    const contents = await fetchFileAsText(url);\n    const traceContents = JSON.parse(contents) as Trace.Types.File.TraceFile;\n    return traceContents;\n  }\n\n  /**\n   * Karma test run in a single context if we load all the traces\n   * we risk getting out of memory\n   */\n  static resetCache() {\n    fileContentsCache.clear();\n    traceEngineCache.clear();\n  }\n}\n\nexport async function fetchFileAsText(url: URL): Promise<string> {\n  if (typeof window === 'undefined') {\n    // @ts-expect-error no node types here.\n    const fs = await import('node:fs/promises');\n    // @ts-expect-error no node types here.\n    const {fileURLToPath} = await import('node:url');\n    const path = fileURLToPath(url);\n    const buffer = await fs.readFile(path);\n    const contents = await Common.Gzip.arrayBufferToString(buffer);\n    return contents;\n  }\n  const response = await fetch(url);\n  if (response.status !== 200) {\n    throw new Error(`Unable to load ${url}`);\n  }\n\n  const buffer = await response.arrayBuffer();\n  const contents = await Common.Gzip.arrayBufferToString(buffer);\n  return contents;\n}\n\n// Below this point are private methods used in the TraceLoader class. These\n// are purposefully not exported, you should use one of the static methods\n// defined above.\n\n/**\n * Wraps an async Promise with a timeout. We use this to break down and\n * instrument `TraceLoader` to understand on CQ where timeouts occur.\n *\n * @param asyncPromise The Promise representing the async operation to be timed.\n * @param timeoutMs The timeout in milliseconds.\n * @param stepName An identifier for the step (for logging).\n * @returns A promise that resolves with the operation's result, or rejects if it times out.\n */\nasync function wrapInTimeout<T>(\n    mochaContext: Mocha.Context|Mocha.Suite|null, callback: () => Promise<T>| T, timeoutMs: number,\n    stepName: string): Promise<T> {\n  const timeout = Promise.withResolvers<void>();\n  const timeoutId = setTimeout(() => {\n    let testTitle = '(unknown test)';\n    if (mochaContext) {\n      try {\n        if (isMochaContext(mochaContext)) {\n          testTitle = mochaContext.currentTest?.fullTitle() ?? testTitle;\n        } else {\n          // For unknown reasons, we cannot trust the Mocha.Suite types in TS.\n          // They may be out of sync with the karma-mocha plugin.\n          // But, `suite.test.title` is present.\n          testTitle = (mochaContext as unknown as {test: {title: string}}).test.title;\n        }\n      } catch (e) {\n        console.error('Determining Mocha test context for trace timeout failed', e);\n      }\n    }\n    console.error(`TraceLoader: [${stepName}]: took longer than ${timeoutMs}ms in test \"${testTitle}\"`);\n    timeout.reject(new Error(`Timeout for TraceLoader: '${stepName}' after ${timeoutMs}ms.`));\n  }, timeoutMs);\n\n  // Race the original promise against the timeout promise\n  try {\n    const cbResult = await Promise.race([callback(), timeout.promise]);\n    timeout.resolve();\n    return cbResult as T;\n  } finally {\n    // Clear the timeout if the original promise resolves/rejects,\n    // or if the timeout promise wins the race.\n    clearTimeout(timeoutId);\n  }\n}\n\nfunction isMochaContext(arg: unknown): arg is Mocha.Context {\n  return typeof arg === 'object' && arg !== null && 'currentTest' in arg;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Unsure why this lint is failing, given `lantern/metrics/SpeedIndex.test.ts` does the same\n// and is fine. Maybe `*.test.*` files are excluded from this rule?\n// eslint-disable-next-line @devtools/es-modules-import\nimport * as TraceLoader from '../../../../testing/TraceLoader.js';\nimport * as Trace from '../../trace.js';\nimport * as Lantern from '../lantern.js';\n\nfunction toLanternTrace(traceEvents: readonly Trace.Types.Events.Event[]): Lantern.Types.Trace {\n  return {\n    traceEvents: traceEvents as unknown as Lantern.Types.TraceEvent[],\n  };\n}\n\nasync function runTraceProcessor(context: Mocha.Suite|Mocha.Context, trace: Lantern.Types.Trace) {\n  TraceLoader.TraceLoader.setTestTimeout(context);\n\n  const processor = Trace.Processor.TraceProcessor.createWithAllHandlers();\n  await processor.parse(trace.traceEvents as Trace.Types.Events.Event[], {isCPUProfile: false, isFreshRecording: true});\n  if (!processor.data) {\n    throw new Error('No data');\n  }\n  return processor.data;\n}\n\nasync function getComputationDataFromFixture(context: Mocha.Suite|Mocha.Context, {trace, settings, url}: {\n  trace: Lantern.Types.Trace,\n  settings?: Lantern.Types.Simulation.Settings,\n  url?: Lantern.Types.Simulation.URL,\n}) {\n  settings = settings ?? {} as Lantern.Types.Simulation.Settings;\n  if (!settings.throttlingMethod) {\n    settings.throttlingMethod = 'simulate';\n  }\n  const data = await runTraceProcessor(context, trace);\n  const requests = Trace.LanternComputationData.createNetworkRequests(trace, data);\n  const networkAnalysis = Lantern.Core.NetworkAnalyzer.analyze(requests);\n  if (!networkAnalysis) {\n    throw new Error('no networkAnalysis');\n  }\n\n  const frameId = data.Meta.mainFrameId;\n  const navigationId = data.Meta.mainFrameNavigations[0].args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('no navigation id found');\n  }\n\n  return {\n    simulator: Lantern.Simulation.Simulator.createSimulator({...settings, networkAnalysis}),\n    graph: Trace.LanternComputationData.createGraph(requests, trace, data, url),\n    processedNavigation: Trace.LanternComputationData.createProcessedNavigation(data, frameId, navigationId),\n  };\n}\n\nexport {\n  getComputationDataFromFixture,\n  runTraceProcessor as runTrace,\n  toLanternTrace,\n};\n"],
  "mappings": "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",
  "names": ["buffer", "contents", "Trace"]
}
