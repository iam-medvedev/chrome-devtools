{"version":3,"file":"Simulator.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/simulation/Simulator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Lantern from '../types/types.js';\n\nimport {ConnectionPool} from './ConnectionPool.js';\nimport {Constants} from './Constants.js';\nimport {DNSCache} from './DNSCache.js';\nimport {type CompleteNodeTiming, type ConnectionTiming, SimulatorTimingMap} from './SimulationTimingMap.js';\nimport {TCPConnection} from './TCPConnection.js';\n\nexport interface Result<T = Lantern.AnyNetworkObject> {\n  timeInMs: number;\n  nodeTimings: Map<Graph.Node<T>, Lantern.Simulation.NodeTiming>;\n}\n\nconst defaultThrottling = Constants.throttling.mobileSlow4G;\n\n// see https://cs.chromium.org/search/?q=kDefaultMaxNumDelayableRequestsPerClient&sq=package:chromium&type=cs\nconst DEFAULT_MAXIMUM_CONCURRENT_REQUESTS = 10;\n// layout tasks tend to be less CPU-bound and do not experience the same increase in duration\nconst DEFAULT_LAYOUT_TASK_MULTIPLIER = 0.5;\n// if a task takes more than 10 seconds it's usually a sign it isn't actually CPU bound and we're overestimating\nconst DEFAULT_MAXIMUM_CPU_TASK_DURATION = 10000;\n\nconst NodeState = {\n  NotReadyToStart: 0,\n  ReadyToStart: 1,\n  InProgress: 2,\n  Complete: 3,\n};\n\nconst PriorityStartTimePenalty: Record<Lantern.ResourcePriority, number> = {\n  VeryHigh: 0,\n  High: 0.25,\n  Medium: 0.5,\n  Low: 1,\n  VeryLow: 2,\n};\n\nconst ALL_SIMULATION_NODE_TIMINGS = new Map<string, Map<Graph.Node, CompleteNodeTiming>>();\n\nclass Simulator<T = Lantern.AnyNetworkObject> {\n  static createSimulator(settings: Lantern.Simulation.Settings): Simulator {\n    const {throttlingMethod, throttling, precomputedLanternData, networkAnalysis} = settings;\n\n    const options: Lantern.Simulation.Options = {\n      additionalRttByOrigin: networkAnalysis.additionalRttByOrigin,\n      serverResponseTimeByOrigin: networkAnalysis.serverResponseTimeByOrigin,\n      observedThroughput: networkAnalysis.throughput,\n    };\n\n    // If we have precomputed lantern data, overwrite our observed estimates and use precomputed instead\n    // for increased stability.\n    if (precomputedLanternData) {\n      options.additionalRttByOrigin = new Map(Object.entries(precomputedLanternData.additionalRttByOrigin));\n      options.serverResponseTimeByOrigin = new Map(Object.entries(precomputedLanternData.serverResponseTimeByOrigin));\n    }\n\n    switch (throttlingMethod) {\n      case 'provided':\n        options.rtt = networkAnalysis.rtt;\n        options.throughput = networkAnalysis.throughput;\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'devtools':\n        if (throttling) {\n          options.rtt = throttling.requestLatencyMs / Constants.throttling.DEVTOOLS_RTT_ADJUSTMENT_FACTOR;\n          options.throughput =\n              throttling.downloadThroughputKbps * 1024 / Constants.throttling.DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR;\n        }\n\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'simulate':\n        if (throttling) {\n          options.rtt = throttling.rttMs;\n          options.throughput = throttling.throughputKbps * 1024;\n          options.cpuSlowdownMultiplier = throttling.cpuSlowdownMultiplier;\n        }\n        break;\n      default:\n        // intentionally fallback to simulator defaults\n        break;\n    }\n\n    return new Simulator(options);\n  }\n\n  _options: Required<Lantern.Simulation.Options>;\n  _rtt: number;\n  _throughput: number;\n  _maximumConcurrentRequests: number;\n  _cpuSlowdownMultiplier: number;\n  _layoutTaskMultiplier: number;\n  _cachedNodeListByStartPosition: Graph.Node[];\n  _nodeTimings: SimulatorTimingMap;\n  _numberInProgressByType: Map<string, number>;\n  _nodes: Record<number, Set<Graph.Node>>;\n  _dns: DNSCache;\n  _connectionPool: ConnectionPool;\n\n  constructor(options?: Lantern.Simulation.Options) {\n    this._options = Object.assign(\n        {\n          rtt: defaultThrottling.rttMs,\n          throughput: defaultThrottling.throughputKbps * 1024,\n          maximumConcurrentRequests: DEFAULT_MAXIMUM_CONCURRENT_REQUESTS,\n          cpuSlowdownMultiplier: defaultThrottling.cpuSlowdownMultiplier,\n          layoutTaskMultiplier: DEFAULT_LAYOUT_TASK_MULTIPLIER,\n          additionalRttByOrigin: new Map(),\n          serverResponseTimeByOrigin: new Map(),\n        },\n        options,\n    );\n\n    this._rtt = this._options.rtt;\n    this._throughput = this._options.throughput;\n    this._maximumConcurrentRequests = Math.max(\n        Math.min(\n            TCPConnection.maximumSaturatedConnections(this._rtt, this._throughput),\n            this._options.maximumConcurrentRequests,\n            ),\n        1);\n    this._cpuSlowdownMultiplier = this._options.cpuSlowdownMultiplier;\n    this._layoutTaskMultiplier = this._cpuSlowdownMultiplier * this._options.layoutTaskMultiplier;\n    this._cachedNodeListByStartPosition = [];\n\n    // Properties reset on every `.simulate` call but duplicated here for type checking\n    this._nodeTimings = new SimulatorTimingMap();\n    this._numberInProgressByType = new Map<string, number>();\n    this._nodes = {};\n    this._dns = new DNSCache({rtt: this._rtt});\n    // @ts-expect-error\n    this._connectionPool = null;\n\n    if (!Number.isFinite(this._rtt)) {\n      throw new Core.LanternError(`Invalid rtt ${this._rtt}`);\n    }\n    if (!Number.isFinite(this._throughput)) {\n      throw new Core.LanternError(`Invalid rtt ${this._throughput}`);\n    }\n  }\n\n  get rtt(): number {\n    return this._rtt;\n  }\n\n  _initializeConnectionPool(graph: Graph.Node): void {\n    const records: Lantern.NetworkRequest[] = [];\n    graph.getRootNode().traverse(node => {\n      if (node.type === Graph.BaseNode.types.NETWORK) {\n        records.push(node.request);\n      }\n    });\n\n    this._connectionPool = new ConnectionPool(records, this._options);\n  }\n\n  /**\n   * Initializes the various state data structures such _nodeTimings and the _node Sets by state.\n   */\n  _initializeAuxiliaryData(): void {\n    this._nodeTimings = new SimulatorTimingMap();\n    this._numberInProgressByType = new Map();\n\n    this._nodes = {};\n    this._cachedNodeListByStartPosition = [];\n    // NOTE: We don't actually need *all* of these sets, but the clarity that each node progresses\n    // through the system is quite nice.\n    for (const state of Object.values(NodeState)) {\n      this._nodes[state] = new Set();\n    }\n  }\n\n  _numberInProgress(type: string): number {\n    return this._numberInProgressByType.get(type) || 0;\n  }\n\n  _markNodeAsReadyToStart(node: Graph.Node, queuedTime: number): void {\n    const nodeStartPosition = Simulator._computeNodeStartPosition(node);\n    const firstNodeIndexWithGreaterStartPosition = this._cachedNodeListByStartPosition.findIndex(\n        candidate => Simulator._computeNodeStartPosition(candidate) > nodeStartPosition);\n    const insertionIndex = firstNodeIndexWithGreaterStartPosition === -1 ? this._cachedNodeListByStartPosition.length :\n                                                                           firstNodeIndexWithGreaterStartPosition;\n    this._cachedNodeListByStartPosition.splice(insertionIndex, 0, node);\n\n    this._nodes[NodeState.ReadyToStart].add(node);\n    this._nodes[NodeState.NotReadyToStart].delete(node);\n    this._nodeTimings.setReadyToStart(node, {queuedTime});\n  }\n\n  _markNodeAsInProgress(node: Graph.Node, startTime: number): void {\n    const indexOfNodeToStart = this._cachedNodeListByStartPosition.indexOf(node);\n    this._cachedNodeListByStartPosition.splice(indexOfNodeToStart, 1);\n\n    this._nodes[NodeState.InProgress].add(node);\n    this._nodes[NodeState.ReadyToStart].delete(node);\n    this._numberInProgressByType.set(node.type, this._numberInProgress(node.type) + 1);\n    this._nodeTimings.setInProgress(node, {startTime});\n  }\n\n  _markNodeAsComplete(node: Graph.Node, endTime: number, connectionTiming?: ConnectionTiming): void {\n    this._nodes[NodeState.Complete].add(node);\n    this._nodes[NodeState.InProgress].delete(node);\n    this._numberInProgressByType.set(node.type, this._numberInProgress(node.type) - 1);\n    this._nodeTimings.setCompleted(node, {endTime, connectionTiming});\n\n    // Try to add all its dependents to the queue\n    for (const dependent of node.getDependents()) {\n      // Skip dependent node if one of its dependencies hasn't finished yet\n      const dependencies = dependent.getDependencies();\n      if (dependencies.some(dep => !this._nodes[NodeState.Complete].has(dep))) {\n        continue;\n      }\n\n      // Otherwise add it to the queue\n      this._markNodeAsReadyToStart(dependent, endTime);\n    }\n  }\n\n  _acquireConnection(request: Lantern.NetworkRequest): TCPConnection|null {\n    return this._connectionPool.acquire(request);\n  }\n\n  _getNodesSortedByStartPosition(): Graph.Node[] {\n    // Make a copy so we don't skip nodes due to concurrent modification\n    return Array.from(this._cachedNodeListByStartPosition);\n  }\n\n  _startNodeIfPossible(node: Graph.Node, totalElapsedTime: number): void {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      // Start a CPU task if there's no other CPU task in process\n      if (this._numberInProgress(node.type) === 0) {\n        this._markNodeAsInProgress(node, totalElapsedTime);\n      }\n\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n\n    // If a network request is connectionless, we can always start it, so skip the connection checks\n    if (!node.isConnectionless) {\n      // Start a network request if we're not at max requests and a connection is available\n      const numberOfActiveRequests = this._numberInProgress(node.type);\n      if (numberOfActiveRequests >= this._maximumConcurrentRequests) {\n        return;\n      }\n      const connection = this._acquireConnection(node.request);\n      if (!connection) {\n        return;\n      }\n    }\n\n    this._markNodeAsInProgress(node, totalElapsedTime);\n  }\n\n  /**\n   * Updates each connection in use with the available throughput based on the number of network requests\n   * currently in flight.\n   */\n  _updateNetworkCapacity(): void {\n    const inFlight = this._numberInProgress(Graph.BaseNode.types.NETWORK);\n    if (inFlight === 0) {\n      return;\n    }\n\n    for (const connection of this._connectionPool.connectionsInUse()) {\n      connection.setThroughput(this._throughput / inFlight);\n    }\n  }\n\n  /**\n   * Estimates the number of milliseconds remaining given current condidtions before the node is complete.\n   */\n  _estimateTimeRemaining(node: Graph.Node): number {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      return this._estimateCPUTimeRemaining(node);\n    }\n    if (node.type === Graph.BaseNode.types.NETWORK) {\n      return this._estimateNetworkTimeRemaining(node);\n    }\n    throw new Core.LanternError('Unsupported');\n  }\n\n  _estimateCPUTimeRemaining(cpuNode: Graph.CPUNode): number {\n    const timingData = this._nodeTimings.getCpuStarted(cpuNode);\n    const multiplier = cpuNode.didPerformLayout() ? this._layoutTaskMultiplier : this._cpuSlowdownMultiplier;\n    const totalDuration = Math.min(\n        Math.round(cpuNode.duration / 1000 * multiplier),\n        DEFAULT_MAXIMUM_CPU_TASK_DURATION,\n    );\n    const estimatedTimeElapsed = totalDuration - timingData.timeElapsed;\n    this._nodeTimings.setCpuEstimated(cpuNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  _estimateNetworkTimeRemaining(networkNode: Graph.NetworkNode): number {\n    const request = networkNode.request;\n    const timingData = this._nodeTimings.getNetworkStarted(networkNode);\n\n    let timeElapsed = 0;\n    if (networkNode.fromDiskCache) {\n      // Rough access time for seeking to location on disk and reading sequentially.\n      // 8ms per seek + 20ms/MB\n      // @see http://norvig.com/21-days.html#answers\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 8 + 20 * sizeInMb - timingData.timeElapsed;\n    } else if (networkNode.isNonNetworkProtocol) {\n      // Estimates for the overhead of a data URL in Chromium and the decoding time for base64-encoded data.\n      // 2ms per request + 10ms/MB\n      // @see traces on https://dopiaza.org/tools/datauri/examples/index.php\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 2 + 10 * sizeInMb - timingData.timeElapsed;\n    } else {\n      const connection = this._connectionPool.acquireActiveConnectionFromRequest(request);\n      const dnsResolutionTime = this._dns.getTimeUntilResolution(request, {\n        requestedAt: timingData.startTime,\n        shouldUpdateCache: true,\n      });\n      const timeAlreadyElapsed = timingData.timeElapsed;\n      const calculation = connection.simulateDownloadUntil(\n          request.transferSize - timingData.bytesDownloaded,\n          {timeAlreadyElapsed, dnsResolutionTime, maximumTimeToElapse: Infinity},\n      );\n\n      timeElapsed = calculation.timeElapsed;\n    }\n\n    const estimatedTimeElapsed = timeElapsed + timingData.timeElapsedOvershoot;\n    this._nodeTimings.setNetworkEstimated(networkNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  /**\n   * Computes and returns the minimum estimated completion time of the nodes currently in progress.\n   */\n  _findNextNodeCompletionTime(): number {\n    let minimumTime = Infinity;\n    for (const node of this._nodes[NodeState.InProgress]) {\n      minimumTime = Math.min(minimumTime, this._estimateTimeRemaining(node));\n    }\n\n    return minimumTime;\n  }\n\n  /**\n   * Given a time period, computes the progress toward completion that the node made durin that time.\n   */\n  _updateProgressMadeInTimePeriod(node: Graph.Node, timePeriodLength: number, totalElapsedTime: number): void {\n    const timingData = this._nodeTimings.getInProgress(node);\n    const isFinished = timingData.estimatedTimeElapsed === timePeriodLength;\n\n    if (node.type === Graph.BaseNode.types.CPU || node.isConnectionless) {\n      if (isFinished) {\n        this._markNodeAsComplete(node, totalElapsedTime);\n      } else {\n        timingData.timeElapsed += timePeriodLength;\n      }\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n    if (!('bytesDownloaded' in timingData)) {\n      throw new Core.LanternError('Invalid timing data');\n    }\n\n    const request = node.request;\n    const connection = this._connectionPool.acquireActiveConnectionFromRequest(request);\n    const dnsResolutionTime = this._dns.getTimeUntilResolution(request, {\n      requestedAt: timingData.startTime,\n      shouldUpdateCache: true,\n    });\n    const calculation = connection.simulateDownloadUntil(\n        request.transferSize - timingData.bytesDownloaded,\n        {\n          dnsResolutionTime,\n          timeAlreadyElapsed: timingData.timeElapsed,\n          maximumTimeToElapse: timePeriodLength - timingData.timeElapsedOvershoot,\n        },\n    );\n\n    connection.setCongestionWindow(calculation.congestionWindow);\n    connection.setH2OverflowBytesDownloaded(calculation.extraBytesDownloaded);\n\n    if (isFinished) {\n      connection.setWarmed(true);\n      this._connectionPool.release(request);\n      this._markNodeAsComplete(node, totalElapsedTime, calculation.connectionTiming);\n    } else {\n      timingData.timeElapsed += calculation.timeElapsed;\n      timingData.timeElapsedOvershoot += calculation.timeElapsed - timePeriodLength;\n      timingData.bytesDownloaded += calculation.bytesDownloaded;\n    }\n  }\n\n  _computeFinalNodeTimings(): {\n    nodeTimings: Map<Graph.Node, Lantern.Simulation.NodeTiming>,\n    completeNodeTimings: Map<Graph.Node, CompleteNodeTiming>,\n  } {\n    const completeNodeTimingEntries: Array<[Graph.Node, CompleteNodeTiming]> =\n        this._nodeTimings.getNodes().map(node => {\n          return [node, this._nodeTimings.getCompleted(node)];\n        });\n\n    // Most consumers will want the entries sorted by startTime, so insert them in that order\n    completeNodeTimingEntries.sort((a, b) => a[1].startTime - b[1].startTime);\n\n    // Trimmed version of type `Lantern.Simulation.NodeTiming`.\n    const nodeTimingEntries: Array<[Graph.Node, Lantern.Simulation.NodeTiming]> =\n        completeNodeTimingEntries.map(([node, timing]) => {\n          return [\n            node,\n            {\n              startTime: timing.startTime,\n              endTime: timing.endTime,\n              duration: timing.endTime - timing.startTime,\n            },\n          ];\n        });\n\n    return {\n      nodeTimings: new Map(nodeTimingEntries),\n      completeNodeTimings: new Map(completeNodeTimingEntries),\n    };\n  }\n\n  getOptions(): Required<Lantern.Simulation.Options> {\n    return this._options;\n  }\n\n  /**\n   * Estimates the time taken to process all of the graph's nodes, returns the overall time along with\n   * each node annotated by start/end times.\n   *\n   * Simulator/connection pool are allowed to deviate from what was\n   * observed in the trace/devtoolsLog and start requests as soon as they are queued (i.e. do not\n   * wait around for a warm connection to be available if the original request was fetched on a warm\n   * connection).\n   */\n  simulate(graph: Graph.Node, options?: {label?: string}): Result<T> {\n    if (Graph.BaseNode.hasCycle(graph)) {\n      throw new Core.LanternError('Cannot simulate graph with cycle');\n    }\n\n    options = Object.assign(\n        {\n          label: undefined,\n        },\n        options);\n\n    // initialize the necessary data containers\n    this._dns = new DNSCache({rtt: this._rtt});\n    this._initializeConnectionPool(graph);\n    this._initializeAuxiliaryData();\n\n    const nodesNotReadyToStart = this._nodes[NodeState.NotReadyToStart];\n    const nodesReadyToStart = this._nodes[NodeState.ReadyToStart];\n    const nodesInProgress = this._nodes[NodeState.InProgress];\n\n    const rootNode = graph.getRootNode();\n    rootNode.traverse(node => nodesNotReadyToStart.add(node));\n    let totalElapsedTime = 0;\n    let iteration = 0;\n\n    // root node is always ready to start\n    this._markNodeAsReadyToStart(rootNode, totalElapsedTime);\n\n    // loop as long as we have nodes in the queue or currently in progress\n    while (nodesReadyToStart.size || nodesInProgress.size) {\n      // move all possible queued nodes to in progress\n      for (const node of this._getNodesSortedByStartPosition()) {\n        this._startNodeIfPossible(node, totalElapsedTime);\n      }\n\n      if (!nodesInProgress.size) {\n        // Interplay between fromDiskCache and connectionReused can be incorrect,\n        // have to give up.\n        throw new Core.LanternError('Failed to start a node');\n      }\n\n      // set the available throughput for all connections based on # inflight\n      this._updateNetworkCapacity();\n\n      // find the time that the next node will finish\n      const minimumTime = this._findNextNodeCompletionTime();\n      totalElapsedTime += minimumTime;\n\n      // While this is no longer strictly necessary, it's always better than hanging\n      if (!Number.isFinite(minimumTime) || iteration > 100000) {\n        throw new Core.LanternError('Simulation failed, depth exceeded');\n      }\n\n      iteration++;\n      // update how far each node will progress until that point\n      for (const node of nodesInProgress) {\n        this._updateProgressMadeInTimePeriod(node, minimumTime, totalElapsedTime);\n      }\n    }\n\n    // `nodeTimings` are used for simulator consumers, `completeNodeTimings` kept for debugging.\n    const {nodeTimings, completeNodeTimings} = this._computeFinalNodeTimings();\n    ALL_SIMULATION_NODE_TIMINGS.set(options.label || 'unlabeled', completeNodeTimings);\n\n    return {\n      timeInMs: totalElapsedTime,\n      nodeTimings,\n    };\n  }\n\n  computeWastedMsFromWastedBytes(wastedBytes: number): number {\n    const {throughput, observedThroughput} = this._options;\n\n    // https://github.com/GoogleChrome/lighthouse/pull/13323#issuecomment-962031709\n    // 0 throughput means the no (additional) throttling is expected.\n    // This is common for desktop + devtools throttling where throttling is additive and we don't want any additional.\n    const bitsPerSecond = throughput === 0 ? observedThroughput : throughput;\n    if (bitsPerSecond === 0) {\n      return 0;\n    }\n\n    const wastedBits = wastedBytes * 8;\n    const wastedMs = wastedBits / bitsPerSecond * 1000;\n\n    // This is an estimate of wasted time, so we won't be more precise than 10ms.\n    return Math.round(wastedMs / 10) * 10;\n  }\n\n  static get allNodeTimings(): Map<string, Map<Graph.Node, CompleteNodeTiming>> {\n    return ALL_SIMULATION_NODE_TIMINGS;\n  }\n\n  /**\n   * We attempt to start nodes by their observed start time using the request priority as a tie breaker.\n   * When simulating, just because a low priority image started 5ms before a high priority image doesn't mean\n   * it would have happened like that when the network was slower.\n   */\n  static _computeNodeStartPosition(node: Graph.Node): number {\n    if (node.type === 'cpu') {\n      return node.startTime;\n    }\n    return node.startTime + (PriorityStartTimePenalty[node.request.priority] * 1000 * 1000 || 0);\n  }\n}\n\nexport {Simulator};\n"]}