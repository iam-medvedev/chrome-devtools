{"version":3,"file":"TCPConnection.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/simulation/TCPConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {type ConnectionTiming} from './SimulationTimingMap.js';\n\ninterface DownloadOptions {\n  dnsResolutionTime?: number;\n  timeAlreadyElapsed?: number;\n  maximumTimeToElapse?: number;\n}\n\ninterface DownloadResults {\n  roundTrips: number;\n  timeElapsed: number;\n  bytesDownloaded: number;\n  extraBytesDownloaded: number;\n  congestionWindow: number;\n  connectionTiming: ConnectionTiming;\n}\n\nconst INITIAL_CONGESTION_WINDOW = 10;\nconst TCP_SEGMENT_SIZE = 1460;\n\nclass TCPConnection {\n  _warmed: boolean;\n  _ssl: boolean;\n  _h2: boolean;\n  _rtt: number;\n  _throughput: number;\n  _serverLatency: number;\n  _congestionWindow: number;\n  _h2OverflowBytesDownloaded: number;\n\n  constructor(rtt: number, throughput: number, serverLatency = 0, ssl = true, h2 = false) {\n    this._warmed = false;\n    this._ssl = ssl;\n    this._h2 = h2;\n    this._rtt = rtt;\n    this._throughput = throughput;\n    this._serverLatency = serverLatency;\n    this._congestionWindow = INITIAL_CONGESTION_WINDOW;\n    this._h2OverflowBytesDownloaded = 0;\n  }\n\n  static maximumSaturatedConnections(rtt: number, availableThroughput: number): number {\n    const roundTripsPerSecond = 1000 / rtt;\n    const bytesPerRoundTrip = TCP_SEGMENT_SIZE;\n    const bytesPerSecond = roundTripsPerSecond * bytesPerRoundTrip;\n    const minimumThroughputRequiredPerRequest = bytesPerSecond * 8;\n    return Math.floor(availableThroughput / minimumThroughputRequiredPerRequest);\n  }\n\n  _computeMaximumCongestionWindowInSegments(): number {\n    const bytesPerSecond = this._throughput / 8;\n    const secondsPerRoundTrip = this._rtt / 1000;\n    const bytesPerRoundTrip = bytesPerSecond * secondsPerRoundTrip;\n    return Math.floor(bytesPerRoundTrip / TCP_SEGMENT_SIZE);\n  }\n\n  setThroughput(throughput: number): void {\n    this._throughput = throughput;\n  }\n\n  setCongestionWindow(congestion: number): void {\n    this._congestionWindow = congestion;\n  }\n\n  setWarmed(warmed: boolean): void {\n    this._warmed = warmed;\n  }\n\n  isWarm(): boolean {\n    return this._warmed;\n  }\n\n  isH2(): boolean {\n    return this._h2;\n  }\n\n  get congestionWindow(): number {\n    return this._congestionWindow;\n  }\n\n  /**\n   * Sets the number of excess bytes that are available to this connection on future downloads, only\n   * applies to H2 connections.\n   */\n  setH2OverflowBytesDownloaded(bytes: number): void {\n    if (!this._h2) {\n      return;\n    }\n    this._h2OverflowBytesDownloaded = bytes;\n  }\n\n  clone(): TCPConnection {\n    return Object.assign(new TCPConnection(this._rtt, this._throughput), this);\n  }\n\n  /**\n   * Simulates a network download of a particular number of bytes over an optional maximum amount of time\n   * and returns information about the ending state.\n   *\n   * See https://hpbn.co/building-blocks-of-tcp/#three-way-handshake and\n   *  https://hpbn.co/transport-layer-security-tls/#tls-handshake for details.\n   */\n  simulateDownloadUntil(bytesToDownload: number, options?: DownloadOptions): DownloadResults {\n    const {timeAlreadyElapsed = 0, maximumTimeToElapse = Infinity, dnsResolutionTime = 0} = options || {};\n\n    if (this._warmed && this._h2) {\n      bytesToDownload -= this._h2OverflowBytesDownloaded;\n    }\n    const twoWayLatency = this._rtt;\n    const oneWayLatency = twoWayLatency / 2;\n    const maximumCongestionWindow = this._computeMaximumCongestionWindowInSegments();\n\n    let handshakeAndRequest = oneWayLatency;\n    if (!this._warmed) {\n      handshakeAndRequest =\n          // DNS lookup\n          dnsResolutionTime +\n          // SYN\n          oneWayLatency +\n          // SYN ACK\n          oneWayLatency +\n          // ACK + initial request\n          oneWayLatency +\n          // ClientHello/ServerHello assuming TLS False Start is enabled (https://istlsfastyet.com/#server-performance).\n          (this._ssl ? twoWayLatency : 0);\n    }\n\n    let roundTrips = Math.ceil(handshakeAndRequest / twoWayLatency);\n    let timeToFirstByte = handshakeAndRequest + this._serverLatency + oneWayLatency;\n    if (this._warmed && this._h2) {\n      timeToFirstByte = 0;\n    }\n\n    const timeElapsedForTTFB = Math.max(timeToFirstByte - timeAlreadyElapsed, 0);\n    const maximumDownloadTimeToElapse = maximumTimeToElapse - timeElapsedForTTFB;\n\n    let congestionWindow = Math.min(this._congestionWindow, maximumCongestionWindow);\n    let totalBytesDownloaded = 0;\n    if (timeElapsedForTTFB > 0) {\n      totalBytesDownloaded = congestionWindow * TCP_SEGMENT_SIZE;\n    } else {\n      roundTrips = 0;\n    }\n\n    let downloadTimeElapsed = 0;\n    let bytesRemaining = bytesToDownload - totalBytesDownloaded;\n    while (bytesRemaining > 0 && downloadTimeElapsed <= maximumDownloadTimeToElapse) {\n      roundTrips++;\n      downloadTimeElapsed += twoWayLatency;\n      congestionWindow = Math.max(Math.min(maximumCongestionWindow, congestionWindow * 2), 1);\n\n      const bytesDownloadedInWindow = congestionWindow * TCP_SEGMENT_SIZE;\n      totalBytesDownloaded += bytesDownloadedInWindow;\n      bytesRemaining -= bytesDownloadedInWindow;\n    }\n\n    const timeElapsed = timeElapsedForTTFB + downloadTimeElapsed;\n    const extraBytesDownloaded = this._h2 ? Math.max(totalBytesDownloaded - bytesToDownload, 0) : 0;\n    const bytesDownloaded = Math.max(Math.min(totalBytesDownloaded, bytesToDownload), 0);\n\n    let connectionTiming: ConnectionTiming;\n    if (!this._warmed) {\n      connectionTiming = {\n        dnsResolutionTime,\n        connectionTime: handshakeAndRequest - dnsResolutionTime,\n        sslTime: this._ssl ? twoWayLatency : undefined,\n        timeToFirstByte,\n      };\n    } else if (this._h2) {\n      // TODO: timing information currently difficult to model for warm h2 connections.\n      connectionTiming = {\n        timeToFirstByte,\n      };\n    } else {\n      connectionTiming = {\n        connectionTime: handshakeAndRequest,\n        timeToFirstByte,\n      };\n    }\n\n    return {\n      roundTrips,\n      timeElapsed,\n      bytesDownloaded,\n      extraBytesDownloaded,\n      congestionWindow,\n      connectionTiming,\n    };\n  }\n}\n\nexport {TCPConnection};\n"]}