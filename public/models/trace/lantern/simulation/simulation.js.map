{
  "version": 3,
  "sources": ["../../../../../../../../front_end/models/trace/lantern/simulation/ConnectionPool.ts", "../../../../../../../../front_end/models/trace/lantern/simulation/TCPConnection.ts", "../../../../../../../../front_end/models/trace/lantern/simulation/Constants.ts", "../../../../../../../../front_end/models/trace/lantern/simulation/DNSCache.ts", "../../../../../../../../front_end/models/trace/lantern/simulation/SimulationTimingMap.ts", "../../../../../../../../front_end/models/trace/lantern/simulation/Simulator.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport {TCPConnection} from './TCPConnection.js';\n\nconst DEFAULT_SERVER_RESPONSE_TIME = 30;\nconst TLS_SCHEMES = ['https', 'wss'];\n\n// Each origin can have 6 simultaneous connections open\n// https://cs.chromium.org/chromium/src/net/socket/client_socket_pool_manager.cc?type=cs&q=\"int+g_max_sockets_per_group\"\nconst CONNECTIONS_PER_ORIGIN = 6;\n\nexport class ConnectionPool {\n  options: Required<Lantern.Simulation.Options>;\n  records: Lantern.NetworkRequest[];\n  connectionsByOrigin: Map<string, TCPConnection[]>;\n  connectionsByRequest: Map<Lantern.NetworkRequest, TCPConnection>;\n  _connectionsInUse: Set<TCPConnection>;\n  connectionReusedByRequestId: Map<string, boolean>;\n\n  constructor(records: Lantern.NetworkRequest[], options: Required<Lantern.Simulation.Options>) {\n    this.options = options;\n\n    this.records = records;\n    this.connectionsByOrigin = new Map();\n    this.connectionsByRequest = new Map();\n    this._connectionsInUse = new Set();\n    this.connectionReusedByRequestId = Core.NetworkAnalyzer.estimateIfConnectionWasReused(records, {\n      forceCoarseEstimates: true,\n    });\n\n    this.initializeConnections();\n  }\n\n  connectionsInUse(): TCPConnection[] {\n    return Array.from(this._connectionsInUse);\n  }\n\n  initializeConnections(): void {\n    const connectionReused = this.connectionReusedByRequestId;\n    const additionalRttByOrigin = this.options.additionalRttByOrigin;\n    const serverResponseTimeByOrigin = this.options.serverResponseTimeByOrigin;\n\n    const recordsByOrigin = Core.NetworkAnalyzer.groupByOrigin(this.records);\n    for (const [origin, requests] of recordsByOrigin.entries()) {\n      const connections = [];\n      const additionalRtt = additionalRttByOrigin.get(origin) || 0;\n      const responseTime = serverResponseTimeByOrigin.get(origin) || DEFAULT_SERVER_RESPONSE_TIME;\n\n      for (const request of requests) {\n        if (connectionReused.get(request.requestId)) {\n          continue;\n        }\n\n        const isTLS = TLS_SCHEMES.includes(request.parsedURL.scheme);\n        const isH2 = request.protocol === 'h2';\n        const connection = new TCPConnection(\n            this.options.rtt + additionalRtt,\n            this.options.throughput,\n            responseTime,\n            isTLS,\n            isH2,\n        );\n\n        connections.push(connection);\n      }\n\n      if (!connections.length) {\n        throw new Core.LanternError(`Could not find a connection for origin: ${origin}`);\n      }\n\n      // Make sure each origin has minimum number of connections available for max throughput.\n      // But only if it's not over H2 which maximizes throughput already.\n      const minConnections = connections[0].isH2() ? 1 : CONNECTIONS_PER_ORIGIN;\n      while (connections.length < minConnections) {\n        connections.push(connections[0].clone());\n      }\n\n      this.connectionsByOrigin.set(origin, connections);\n    }\n  }\n\n  findAvailableConnectionWithLargestCongestionWindow(connections: TCPConnection[]): TCPConnection|null {\n    let maxConnection: TCPConnection|null = null;\n    for (let i = 0; i < connections.length; i++) {\n      const connection = connections[i];\n\n      // Connections that are in use are never available.\n      if (this._connectionsInUse.has(connection)) {\n        continue;\n      }\n\n      // This connection is a match and is available! Update our max if it has a larger congestionWindow\n      const currentMax = (maxConnection?.congestionWindow) || -Infinity;\n      if (connection.congestionWindow > currentMax) {\n        maxConnection = connection;\n      }\n    }\n\n    return maxConnection;\n  }\n\n  /**\n   * This method finds an available connection to the origin specified by the network request or null\n   * if no connection was available. If returned, connection will not be available for other network\n   * records until release is called.\n   */\n  acquire(request: Lantern.NetworkRequest): TCPConnection|null {\n    if (this.connectionsByRequest.has(request)) {\n      throw new Core.LanternError('Record already has a connection');\n    }\n\n    const origin = request.parsedURL.securityOrigin;\n    const connections = this.connectionsByOrigin.get(origin) || [];\n    const connectionToUse = this.findAvailableConnectionWithLargestCongestionWindow(connections);\n\n    if (!connectionToUse) {\n      return null;\n    }\n\n    this._connectionsInUse.add(connectionToUse);\n    this.connectionsByRequest.set(request, connectionToUse);\n    return connectionToUse;\n  }\n\n  /**\n   * Return the connection currently being used to fetch a request. If no connection\n   * currently being used for this request, an error will be thrown.\n   */\n  acquireActiveConnectionFromRequest(request: Lantern.NetworkRequest): TCPConnection {\n    const activeConnection = this.connectionsByRequest.get(request);\n    if (!activeConnection) {\n      throw new Core.LanternError('Could not find an active connection for request');\n    }\n\n    return activeConnection;\n  }\n\n  release(request: Lantern.NetworkRequest): void {\n    const connection = this.connectionsByRequest.get(request);\n    this.connectionsByRequest.delete(request);\n    if (connection) {\n      this._connectionsInUse.delete(connection);\n    }\n  }\n}\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {ConnectionTiming} from './SimulationTimingMap.js';\n\ninterface DownloadOptions {\n  dnsResolutionTime?: number;\n  timeAlreadyElapsed?: number;\n  maximumTimeToElapse?: number;\n}\n\ninterface DownloadResults {\n  roundTrips: number;\n  timeElapsed: number;\n  bytesDownloaded: number;\n  extraBytesDownloaded: number;\n  congestionWindow: number;\n  connectionTiming: ConnectionTiming;\n}\n\nconst INITIAL_CONGESTION_WINDOW = 10;\nconst TCP_SEGMENT_SIZE = 1460;\n\nclass TCPConnection {\n  warmed: boolean;\n  ssl: boolean;\n  h2: boolean;\n  rtt: number;\n  throughput: number;\n  serverLatency: number;\n  _congestionWindow: number;\n  h2OverflowBytesDownloaded: number;\n\n  constructor(rtt: number, throughput: number, serverLatency = 0, ssl = true, h2 = false) {\n    this.warmed = false;\n    this.ssl = ssl;\n    this.h2 = h2;\n    this.rtt = rtt;\n    this.throughput = throughput;\n    this.serverLatency = serverLatency;\n    this._congestionWindow = INITIAL_CONGESTION_WINDOW;\n    this.h2OverflowBytesDownloaded = 0;\n  }\n\n  static maximumSaturatedConnections(rtt: number, availableThroughput: number): number {\n    const roundTripsPerSecond = 1000 / rtt;\n    const bytesPerRoundTrip = TCP_SEGMENT_SIZE;\n    const bytesPerSecond = roundTripsPerSecond * bytesPerRoundTrip;\n    const minimumThroughputRequiredPerRequest = bytesPerSecond * 8;\n    return Math.floor(availableThroughput / minimumThroughputRequiredPerRequest);\n  }\n\n  computeMaximumCongestionWindowInSegments(): number {\n    const bytesPerSecond = this.throughput / 8;\n    const secondsPerRoundTrip = this.rtt / 1000;\n    const bytesPerRoundTrip = bytesPerSecond * secondsPerRoundTrip;\n    return Math.floor(bytesPerRoundTrip / TCP_SEGMENT_SIZE);\n  }\n\n  setThroughput(throughput: number): void {\n    this.throughput = throughput;\n  }\n\n  setCongestionWindow(congestion: number): void {\n    this._congestionWindow = congestion;\n  }\n\n  setWarmed(warmed: boolean): void {\n    this.warmed = warmed;\n  }\n\n  isH2(): boolean {\n    return this.h2;\n  }\n\n  get congestionWindow(): number {\n    return this._congestionWindow;\n  }\n\n  /**\n   * Sets the number of excess bytes that are available to this connection on future downloads, only\n   * applies to H2 connections.\n   */\n  setH2OverflowBytesDownloaded(bytes: number): void {\n    if (!this.h2) {\n      return;\n    }\n    this.h2OverflowBytesDownloaded = bytes;\n  }\n\n  clone(): TCPConnection {\n    return Object.assign(new TCPConnection(this.rtt, this.throughput), this);\n  }\n\n  /**\n   * Simulates a network download of a particular number of bytes over an optional maximum amount of time\n   * and returns information about the ending state.\n   *\n   * See https://hpbn.co/building-blocks-of-tcp/#three-way-handshake and\n   *  https://hpbn.co/transport-layer-security-tls/#tls-handshake for details.\n   */\n  simulateDownloadUntil(bytesToDownload: number, options?: DownloadOptions): DownloadResults {\n    const {timeAlreadyElapsed = 0, maximumTimeToElapse = Infinity, dnsResolutionTime = 0} = options || {};\n\n    if (this.warmed && this.h2) {\n      bytesToDownload -= this.h2OverflowBytesDownloaded;\n    }\n    const twoWayLatency = this.rtt;\n    const oneWayLatency = twoWayLatency / 2;\n    const maximumCongestionWindow = this.computeMaximumCongestionWindowInSegments();\n\n    let handshakeAndRequest = oneWayLatency;\n    if (!this.warmed) {\n      handshakeAndRequest =\n          // DNS lookup\n          dnsResolutionTime +\n          // SYN\n          oneWayLatency +\n          // SYN ACK\n          oneWayLatency +\n          // ACK + initial request\n          oneWayLatency +\n          // ClientHello/ServerHello assuming TLS False Start is enabled (https://istlsfastyet.com/#server-performance).\n          (this.ssl ? twoWayLatency : 0);\n    }\n\n    let roundTrips = Math.ceil(handshakeAndRequest / twoWayLatency);\n    let timeToFirstByte = handshakeAndRequest + this.serverLatency + oneWayLatency;\n    if (this.warmed && this.h2) {\n      timeToFirstByte = 0;\n    }\n\n    const timeElapsedForTTFB = Math.max(timeToFirstByte - timeAlreadyElapsed, 0);\n    const maximumDownloadTimeToElapse = maximumTimeToElapse - timeElapsedForTTFB;\n\n    let congestionWindow = Math.min(this._congestionWindow, maximumCongestionWindow);\n    let totalBytesDownloaded = 0;\n    if (timeElapsedForTTFB > 0) {\n      totalBytesDownloaded = congestionWindow * TCP_SEGMENT_SIZE;\n    } else {\n      roundTrips = 0;\n    }\n\n    let downloadTimeElapsed = 0;\n    let bytesRemaining = bytesToDownload - totalBytesDownloaded;\n    while (bytesRemaining > 0 && downloadTimeElapsed <= maximumDownloadTimeToElapse) {\n      roundTrips++;\n      downloadTimeElapsed += twoWayLatency;\n      congestionWindow = Math.max(Math.min(maximumCongestionWindow, congestionWindow * 2), 1);\n\n      const bytesDownloadedInWindow = congestionWindow * TCP_SEGMENT_SIZE;\n      totalBytesDownloaded += bytesDownloadedInWindow;\n      bytesRemaining -= bytesDownloadedInWindow;\n    }\n\n    const timeElapsed = timeElapsedForTTFB + downloadTimeElapsed;\n    const extraBytesDownloaded = this.h2 ? Math.max(totalBytesDownloaded - bytesToDownload, 0) : 0;\n    const bytesDownloaded = Math.max(Math.min(totalBytesDownloaded, bytesToDownload), 0);\n\n    let connectionTiming: ConnectionTiming;\n    if (!this.warmed) {\n      connectionTiming = {\n        dnsResolutionTime,\n        connectionTime: handshakeAndRequest - dnsResolutionTime,\n        sslTime: this.ssl ? twoWayLatency : undefined,\n        timeToFirstByte,\n      };\n    } else if (this.h2) {\n      // TODO: timing information currently difficult to model for warm h2 connections.\n      connectionTiming = {\n        timeToFirstByte,\n      };\n    } else {\n      connectionTiming = {\n        connectionTime: handshakeAndRequest,\n        timeToFirstByte,\n      };\n    }\n\n    return {\n      roundTrips,\n      timeElapsed,\n      bytesDownloaded,\n      extraBytesDownloaded,\n      congestionWindow,\n      connectionTiming,\n    };\n  }\n}\n\nexport {TCPConnection};\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst DEVTOOLS_RTT_ADJUSTMENT_FACTOR = 3.75;\nconst DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR = 0.9;\n\nconst throttling = {\n  DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n  DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n  // These values align with WebPageTest's definition of \"Fast 3G\"\n  // But offer similar characteristics to roughly the 75th percentile of 4G connections.\n  mobileSlow4G: {\n    rttMs: 150,\n    throughputKbps: 1.6 * 1024,\n    requestLatencyMs: 150 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n    downloadThroughputKbps: 1.6 * 1024 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n    uploadThroughputKbps: 750 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n    cpuSlowdownMultiplier: 4,\n  },\n  // These values partially align with WebPageTest's definition of \"Regular 3G\".\n  // These values are meant to roughly align with Chrome UX report's 3G definition which are based\n  // on HTTP RTT of 300-1400ms and downlink throughput of <700kbps.\n  mobileRegular3G: {\n    rttMs: 300,\n    throughputKbps: 700,\n    requestLatencyMs: 300 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n    downloadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n    uploadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n    cpuSlowdownMultiplier: 4,\n  },\n  // Using a \"broadband\" connection type\n  // Corresponds to \"Dense 4G 25th percentile\" in https://docs.google.com/document/d/1Ft1Bnq9-t4jK5egLSOc28IL4TvR-Tt0se_1faTA4KTY/edit#heading=h.bb7nfy2x9e5v\n  desktopDense4G: {\n    rttMs: 40,\n    throughputKbps: 10 * 1024,\n    cpuSlowdownMultiplier: 1,\n    requestLatencyMs: 0,  // 0 means unset\n    downloadThroughputKbps: 0,\n    uploadThroughputKbps: 0,\n  },\n};\n\nconst Constants = {throttling};\n\nexport {Constants};\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Lantern from '../types/types.js';\n\n// A DNS lookup will usually take ~1-2 roundtrips of connection latency plus the extra DNS routing time.\n// Example: https://www.webpagetest.org/result/180703_3A_e33ec79747c002ed4d7bcbfc81462203/1/details/#waterfall_view_step1\n// Example: https://www.webpagetest.org/result/180707_1M_89673eb633b5d98386de95dfcf9b33d5/1/details/#waterfall_view_step1\n// DNS is highly variable though, many times it's a little more than 1, but can easily be 4-5x RTT.\n// We'll use 2 since it seems to give the most accurate results on average, but this can be tweaked.\nconst DNS_RESOLUTION_RTT_MULTIPLIER = 2;\n\nclass DNSCache {\n  static rttMultiplier = DNS_RESOLUTION_RTT_MULTIPLIER;\n\n  rtt: number;\n  resolvedDomainNames: Map<string, {resolvedAt: number}>;\n\n  constructor({rtt}: {rtt: number}) {\n    this.rtt = rtt;\n    this.resolvedDomainNames = new Map();\n  }\n\n  getTimeUntilResolution(\n      request: Lantern.NetworkRequest, options?: {requestedAt?: number, shouldUpdateCache?: boolean}): number {\n    const {requestedAt = 0, shouldUpdateCache = false} = options || {};\n\n    const domain = request.parsedURL.host;\n    const cacheEntry = this.resolvedDomainNames.get(domain);\n    let timeUntilResolved = this.rtt * DNSCache.rttMultiplier;\n    if (cacheEntry) {\n      const timeUntilCachedIsResolved = Math.max(cacheEntry.resolvedAt - requestedAt, 0);\n      timeUntilResolved = Math.min(timeUntilCachedIsResolved, timeUntilResolved);\n    }\n\n    const resolvedAt = requestedAt + timeUntilResolved;\n    if (shouldUpdateCache) {\n      this.updateCacheResolvedAtIfNeeded(request, resolvedAt);\n    }\n\n    return timeUntilResolved;\n  }\n\n  updateCacheResolvedAtIfNeeded(request: Lantern.NetworkRequest, resolvedAt: number): void {\n    const domain = request.parsedURL.host;\n    const cacheEntry = this.resolvedDomainNames.get(domain) || {resolvedAt};\n    cacheEntry.resolvedAt = Math.min(cacheEntry.resolvedAt, resolvedAt);\n    this.resolvedDomainNames.set(domain, cacheEntry);\n  }\n\n  /**\n   * Forcefully sets the DNS resolution time for a request.\n   * Useful for testing and alternate execution simulations.\n   */\n  setResolvedAt(domain: string, resolvedAt: number): void {\n    this.resolvedDomainNames.set(domain, {resolvedAt});\n  }\n}\n\nexport {DNSCache};\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @file\n *\n * This class encapsulates the type-related validation logic for moving timing information for nodes\n * through the different simulation phases. Methods here ensure that the invariants of simulation hold\n * as nodes are queued, partially simulated, and completed.\n */\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\n\ninterface NodeTimingComplete {\n  startTime: number;\n  endTime: number;\n  queuedTime: number;\n  estimatedTimeElapsed: number;\n  timeElapsed: number;\n  timeElapsedOvershoot: number;\n  bytesDownloaded: number;\n}\n\ntype NodeTimingQueued = Pick<NodeTimingComplete, 'queuedTime'>;\n\ntype CpuNodeTimingStarted = NodeTimingQueued&Pick<NodeTimingComplete, 'startTime'|'timeElapsed'>;\ntype NetworkNodeTimingStarted = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'timeElapsedOvershoot'|'bytesDownloaded'>;\n\ntype CpuNodeTimingInProgress = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\ntype NetworkNodeTimingInProgress = NetworkNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\n\nexport type CpuNodeTimingComplete = CpuNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>;\nexport type NetworkNodeTimingComplete =\n    NetworkNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>&{connectionTiming: ConnectionTiming};\nexport type CompleteNodeTiming = CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\ntype NodeTimingData = NodeTimingQueued|CpuNodeTimingStarted|NetworkNodeTimingStarted|CpuNodeTimingInProgress|\n    NetworkNodeTimingInProgress|CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\nexport interface ConnectionTiming {\n  dnsResolutionTime?: number;\n  connectionTime?: number;\n  sslTime?: number;\n  timeToFirstByte: number;\n}\n\nclass SimulatorTimingMap {\n  nodeTimings: Map<Graph.Node, NodeTimingData>;\n\n  constructor() {\n    this.nodeTimings = new Map<Graph.Node, NodeTimingData>();\n  }\n\n  getNodes(): Graph.Node[] {\n    return Array.from(this.nodeTimings.keys());\n  }\n\n  setReadyToStart(node: Graph.Node, values: {queuedTime: number}): void {\n    this.nodeTimings.set(node, values);\n  }\n\n  setInProgress(node: Graph.Node, values: {startTime: number}): void {\n    const nodeTiming = {\n      ...this.getQueued(node),\n      startTime: values.startTime,\n      timeElapsed: 0,\n    };\n\n    this.nodeTimings.set(\n        node,\n        node.type === Graph.BaseNode.types.NETWORK ? {...nodeTiming, timeElapsedOvershoot: 0, bytesDownloaded: 0} :\n                                                     nodeTiming,\n    );\n  }\n\n  setCompleted(node: Graph.Node, values: {endTime: number, connectionTiming?: ConnectionTiming}): void {\n    const nodeTiming = {\n      ...this.getInProgress(node),\n      endTime: values.endTime,\n      connectionTiming: values.connectionTiming,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpu(node: Graph.CPUNode, values: {timeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      timeElapsed: values.timeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpuEstimated(node: Graph.CPUNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetwork(\n      node: Graph.NetworkNode,\n      values: {timeElapsed: number, timeElapsedOvershoot: number, bytesDownloaded: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      timeElapsed: values.timeElapsed,\n      timeElapsedOvershoot: values.timeElapsedOvershoot,\n      bytesDownloaded: values.bytesDownloaded,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetworkEstimated(node: Graph.NetworkNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  getQueued(node: Graph.Node): NodeTimingData {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    return timing;\n  }\n\n  getCpuStarted(node: Graph.CPUNode): CpuNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if ('bytesDownloaded' in timing) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getNetworkStarted(node: Graph.NetworkNode): NetworkNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('bytesDownloaded' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getInProgress(node: Graph.Node): CpuNodeTimingInProgress|NetworkNodeTimingInProgress {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    return timing;\n  }\n\n  getCompleted(node: Graph.Node): CpuNodeTimingComplete|NetworkNodeTimingComplete {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    if (!('endTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet completed`);\n    }\n    return timing;\n  }\n}\n\nexport {SimulatorTimingMap};\n", "// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Lantern from '../types/types.js';\n\nimport {ConnectionPool} from './ConnectionPool.js';\nimport {Constants} from './Constants.js';\nimport {DNSCache} from './DNSCache.js';\nimport {type CompleteNodeTiming, type ConnectionTiming, SimulatorTimingMap} from './SimulationTimingMap.js';\nimport {TCPConnection} from './TCPConnection.js';\n\nexport interface Result<T = Lantern.AnyNetworkObject> {\n  timeInMs: number;\n  nodeTimings: Map<Graph.Node<T>, Lantern.Simulation.NodeTiming>;\n}\n\nconst defaultThrottling = Constants.throttling.mobileSlow4G;\n\n// see https://cs.chromium.org/search/?q=kDefaultMaxNumDelayableRequestsPerClient&sq=package:chromium&type=cs\nconst DEFAULT_MAXIMUM_CONCURRENT_REQUESTS = 10;\n// layout tasks tend to be less CPU-bound and do not experience the same increase in duration\nconst DEFAULT_LAYOUT_TASK_MULTIPLIER = 0.5;\n// if a task takes more than 10 seconds it's usually a sign it isn't actually CPU bound and we're overestimating\nconst DEFAULT_MAXIMUM_CPU_TASK_DURATION = 10000;\n\nconst NodeState = {\n  NotReadyToStart: 0,\n  ReadyToStart: 1,\n  InProgress: 2,\n  Complete: 3,\n};\n\nconst PriorityStartTimePenalty: Record<Lantern.ResourcePriority, number> = {\n  VeryHigh: 0,\n  High: 0.25,\n  Medium: 0.5,\n  Low: 1,\n  VeryLow: 2,\n};\n\nconst ALL_SIMULATION_NODE_TIMINGS = new Map<string, Map<Graph.Node, CompleteNodeTiming>>();\n\nclass Simulator<T = Lantern.AnyNetworkObject> {\n  static createSimulator(settings: Lantern.Simulation.Settings): Simulator {\n    const {throttlingMethod, throttling, precomputedLanternData, networkAnalysis} = settings;\n\n    const options: Lantern.Simulation.Options = {\n      additionalRttByOrigin: networkAnalysis.additionalRttByOrigin,\n      serverResponseTimeByOrigin: networkAnalysis.serverResponseTimeByOrigin,\n      observedThroughput: networkAnalysis.throughput,\n    };\n\n    // If we have precomputed lantern data, overwrite our observed estimates and use precomputed instead\n    // for increased stability.\n    if (precomputedLanternData) {\n      options.additionalRttByOrigin = new Map(Object.entries(precomputedLanternData.additionalRttByOrigin));\n      options.serverResponseTimeByOrigin = new Map(Object.entries(precomputedLanternData.serverResponseTimeByOrigin));\n    }\n\n    switch (throttlingMethod) {\n      case 'provided':\n        options.rtt = networkAnalysis.rtt;\n        options.throughput = networkAnalysis.throughput;\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'devtools':\n        if (throttling) {\n          options.rtt = throttling.requestLatencyMs / Constants.throttling.DEVTOOLS_RTT_ADJUSTMENT_FACTOR;\n          options.throughput =\n              throttling.downloadThroughputKbps * 1024 / Constants.throttling.DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR;\n        }\n\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'simulate':\n        if (throttling) {\n          options.rtt = throttling.rttMs;\n          options.throughput = throttling.throughputKbps * 1024;\n          options.cpuSlowdownMultiplier = throttling.cpuSlowdownMultiplier;\n        }\n        break;\n      default:\n        // intentionally fallback to simulator defaults\n        break;\n    }\n\n    return new Simulator(options);\n  }\n\n  options: Required<Lantern.Simulation.Options>;\n  _rtt: number;\n  throughput: number;\n  maximumConcurrentRequests: number;\n  cpuSlowdownMultiplier: number;\n  layoutTaskMultiplier: number;\n  cachedNodeListByStartPosition: Graph.Node[];\n  nodeTimings: SimulatorTimingMap;\n  numberInProgressByType: Map<string, number>;\n  nodes: Record<number, Set<Graph.Node>>;\n  dns: DNSCache;\n  connectionPool: ConnectionPool;\n\n  constructor(options?: Lantern.Simulation.Options) {\n    this.options = Object.assign(\n        {\n          rtt: defaultThrottling.rttMs,\n          throughput: defaultThrottling.throughputKbps * 1024,\n          maximumConcurrentRequests: DEFAULT_MAXIMUM_CONCURRENT_REQUESTS,\n          cpuSlowdownMultiplier: defaultThrottling.cpuSlowdownMultiplier,\n          layoutTaskMultiplier: DEFAULT_LAYOUT_TASK_MULTIPLIER,\n          additionalRttByOrigin: new Map(),\n          serverResponseTimeByOrigin: new Map(),\n        },\n        options,\n    );\n\n    this._rtt = this.options.rtt;\n    this.throughput = this.options.throughput;\n    this.maximumConcurrentRequests = Math.max(\n        Math.min(\n            TCPConnection.maximumSaturatedConnections(this._rtt, this.throughput),\n            this.options.maximumConcurrentRequests,\n            ),\n        1);\n    this.cpuSlowdownMultiplier = this.options.cpuSlowdownMultiplier;\n    this.layoutTaskMultiplier = this.cpuSlowdownMultiplier * this.options.layoutTaskMultiplier;\n    this.cachedNodeListByStartPosition = [];\n\n    // Properties reset on every `.simulate` call but duplicated here for type checking\n    this.nodeTimings = new SimulatorTimingMap();\n    this.numberInProgressByType = new Map<string, number>();\n    this.nodes = {};\n    this.dns = new DNSCache({rtt: this._rtt});\n    // @ts-expect-error\n    this.connectionPool = null;\n\n    if (!Number.isFinite(this._rtt)) {\n      throw new Core.LanternError(`Invalid rtt ${this._rtt}`);\n    }\n    if (!Number.isFinite(this.throughput)) {\n      throw new Core.LanternError(`Invalid throughput ${this.throughput}`);\n    }\n  }\n\n  get rtt(): number {\n    return this._rtt;\n  }\n\n  initializeConnectionPool(graph: Graph.Node): void {\n    const records: Lantern.NetworkRequest[] = [];\n    graph.getRootNode().traverse(node => {\n      if (node.type === Graph.BaseNode.types.NETWORK) {\n        records.push(node.request);\n      }\n    });\n\n    this.connectionPool = new ConnectionPool(records, this.options);\n  }\n\n  /**\n   * Initializes the various state data structures such _nodeTimings and the _node Sets by state.\n   */\n  initializeAuxiliaryData(): void {\n    this.nodeTimings = new SimulatorTimingMap();\n    this.numberInProgressByType = new Map();\n\n    this.nodes = {};\n    this.cachedNodeListByStartPosition = [];\n    // NOTE: We don't actually need *all* of these sets, but the clarity that each node progresses\n    // through the system is quite nice.\n    for (const state of Object.values(NodeState)) {\n      this.nodes[state] = new Set();\n    }\n  }\n\n  numberInProgress(type: string): number {\n    return this.numberInProgressByType.get(type) || 0;\n  }\n\n  markNodeAsReadyToStart(node: Graph.Node, queuedTime: number): void {\n    const nodeStartPosition = Simulator.computeNodeStartPosition(node);\n    const firstNodeIndexWithGreaterStartPosition = this.cachedNodeListByStartPosition.findIndex(\n        candidate => Simulator.computeNodeStartPosition(candidate) > nodeStartPosition);\n    const insertionIndex = firstNodeIndexWithGreaterStartPosition === -1 ? this.cachedNodeListByStartPosition.length :\n                                                                           firstNodeIndexWithGreaterStartPosition;\n    this.cachedNodeListByStartPosition.splice(insertionIndex, 0, node);\n\n    this.nodes[NodeState.ReadyToStart].add(node);\n    this.nodes[NodeState.NotReadyToStart].delete(node);\n    this.nodeTimings.setReadyToStart(node, {queuedTime});\n  }\n\n  markNodeAsInProgress(node: Graph.Node, startTime: number): void {\n    const indexOfNodeToStart = this.cachedNodeListByStartPosition.indexOf(node);\n    this.cachedNodeListByStartPosition.splice(indexOfNodeToStart, 1);\n\n    this.nodes[NodeState.InProgress].add(node);\n    this.nodes[NodeState.ReadyToStart].delete(node);\n    this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) + 1);\n    this.nodeTimings.setInProgress(node, {startTime});\n  }\n\n  markNodeAsComplete(node: Graph.Node, endTime: number, connectionTiming?: ConnectionTiming): void {\n    this.nodes[NodeState.Complete].add(node);\n    this.nodes[NodeState.InProgress].delete(node);\n    this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) - 1);\n    this.nodeTimings.setCompleted(node, {endTime, connectionTiming});\n\n    // Try to add all its dependents to the queue\n    for (const dependent of node.getDependents()) {\n      // Skip dependent node if one of its dependencies hasn't finished yet\n      const dependencies = dependent.getDependencies();\n      if (dependencies.some(dep => !this.nodes[NodeState.Complete].has(dep))) {\n        continue;\n      }\n\n      // Otherwise add it to the queue\n      this.markNodeAsReadyToStart(dependent, endTime);\n    }\n  }\n\n  acquireConnection(request: Lantern.NetworkRequest): TCPConnection|null {\n    return this.connectionPool.acquire(request);\n  }\n\n  getNodesSortedByStartPosition(): Graph.Node[] {\n    // Make a copy so we don't skip nodes due to concurrent modification\n    return Array.from(this.cachedNodeListByStartPosition);\n  }\n\n  startNodeIfPossible(node: Graph.Node, totalElapsedTime: number): void {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      // Start a CPU task if there's no other CPU task in process\n      if (this.numberInProgress(node.type) === 0) {\n        this.markNodeAsInProgress(node, totalElapsedTime);\n      }\n\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n\n    // If a network request is connectionless, we can always start it, so skip the connection checks\n    if (!node.isConnectionless) {\n      // Start a network request if we're not at max requests and a connection is available\n      const numberOfActiveRequests = this.numberInProgress(node.type);\n      if (numberOfActiveRequests >= this.maximumConcurrentRequests) {\n        return;\n      }\n      const connection = this.acquireConnection(node.request);\n      if (!connection) {\n        return;\n      }\n    }\n\n    this.markNodeAsInProgress(node, totalElapsedTime);\n  }\n\n  /**\n   * Updates each connection in use with the available throughput based on the number of network requests\n   * currently in flight.\n   */\n  updateNetworkCapacity(): void {\n    const inFlight = this.numberInProgress(Graph.BaseNode.types.NETWORK);\n    if (inFlight === 0) {\n      return;\n    }\n\n    for (const connection of this.connectionPool.connectionsInUse()) {\n      connection.setThroughput(this.throughput / inFlight);\n    }\n  }\n\n  /**\n   * Estimates the number of milliseconds remaining given current conditions before the node is complete.\n   */\n  estimateTimeRemaining(node: Graph.Node): number {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      return this.estimateCPUTimeRemaining(node);\n    }\n    if (node.type === Graph.BaseNode.types.NETWORK) {\n      return this.estimateNetworkTimeRemaining(node);\n    }\n    throw new Core.LanternError('Unsupported');\n  }\n\n  estimateCPUTimeRemaining(cpuNode: Graph.CPUNode): number {\n    const timingData = this.nodeTimings.getCpuStarted(cpuNode);\n    const multiplier = cpuNode.didPerformLayout() ? this.layoutTaskMultiplier : this.cpuSlowdownMultiplier;\n    const totalDuration = Math.min(\n        Math.round(cpuNode.duration / 1000 * multiplier),\n        DEFAULT_MAXIMUM_CPU_TASK_DURATION,\n    );\n    const estimatedTimeElapsed = totalDuration - timingData.timeElapsed;\n    this.nodeTimings.setCpuEstimated(cpuNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  estimateNetworkTimeRemaining(networkNode: Graph.NetworkNode): number {\n    const request = networkNode.request;\n    const timingData = this.nodeTimings.getNetworkStarted(networkNode);\n\n    let timeElapsed = 0;\n    if (networkNode.fromDiskCache) {\n      // Rough access time for seeking to location on disk and reading sequentially.\n      // 8ms per seek + 20ms/MB\n      // @see http://norvig.com/21-days.html#answers\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 8 + 20 * sizeInMb - timingData.timeElapsed;\n    } else if (networkNode.isNonNetworkProtocol) {\n      // Estimates for the overhead of a data URL in Chromium and the decoding time for base64-encoded data.\n      // 2ms per request + 10ms/MB\n      // @see traces on https://dopiaza.org/tools/datauri/examples/index.php\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 2 + 10 * sizeInMb - timingData.timeElapsed;\n    } else {\n      const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n      const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n        requestedAt: timingData.startTime,\n        shouldUpdateCache: true,\n      });\n      const timeAlreadyElapsed = timingData.timeElapsed;\n      const calculation = connection.simulateDownloadUntil(\n          request.transferSize - timingData.bytesDownloaded,\n          {timeAlreadyElapsed, dnsResolutionTime, maximumTimeToElapse: Infinity},\n      );\n\n      timeElapsed = calculation.timeElapsed;\n    }\n\n    const estimatedTimeElapsed = timeElapsed + timingData.timeElapsedOvershoot;\n    this.nodeTimings.setNetworkEstimated(networkNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  /**\n   * Computes and returns the minimum estimated completion time of the nodes currently in progress.\n   */\n  findNextNodeCompletionTime(): number {\n    let minimumTime = Infinity;\n    for (const node of this.nodes[NodeState.InProgress]) {\n      minimumTime = Math.min(minimumTime, this.estimateTimeRemaining(node));\n    }\n\n    return minimumTime;\n  }\n\n  /**\n   * Given a time period, computes the progress toward completion that the node made during that time.\n   */\n  updateProgressMadeInTimePeriod(node: Graph.Node, timePeriodLength: number, totalElapsedTime: number): void {\n    const timingData = this.nodeTimings.getInProgress(node);\n    const isFinished = timingData.estimatedTimeElapsed === timePeriodLength;\n\n    if (node.type === Graph.BaseNode.types.CPU || node.isConnectionless) {\n      if (isFinished) {\n        this.markNodeAsComplete(node, totalElapsedTime);\n      } else {\n        timingData.timeElapsed += timePeriodLength;\n      }\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n    if (!('bytesDownloaded' in timingData)) {\n      throw new Core.LanternError('Invalid timing data');\n    }\n\n    const request = node.request;\n    const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n    const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n      requestedAt: timingData.startTime,\n      shouldUpdateCache: true,\n    });\n    const calculation = connection.simulateDownloadUntil(\n        request.transferSize - timingData.bytesDownloaded,\n        {\n          dnsResolutionTime,\n          timeAlreadyElapsed: timingData.timeElapsed,\n          maximumTimeToElapse: timePeriodLength - timingData.timeElapsedOvershoot,\n        },\n    );\n\n    connection.setCongestionWindow(calculation.congestionWindow);\n    connection.setH2OverflowBytesDownloaded(calculation.extraBytesDownloaded);\n\n    if (isFinished) {\n      connection.setWarmed(true);\n      this.connectionPool.release(request);\n      this.markNodeAsComplete(node, totalElapsedTime, calculation.connectionTiming);\n    } else {\n      timingData.timeElapsed += calculation.timeElapsed;\n      timingData.timeElapsedOvershoot += calculation.timeElapsed - timePeriodLength;\n      timingData.bytesDownloaded += calculation.bytesDownloaded;\n    }\n  }\n\n  computeFinalNodeTimings(): {\n    nodeTimings: Map<Graph.Node, Lantern.Simulation.NodeTiming>,\n    completeNodeTimings: Map<Graph.Node, CompleteNodeTiming>,\n  } {\n    const completeNodeTimingEntries: Array<[Graph.Node, CompleteNodeTiming]> = this.nodeTimings.getNodes().map(node => {\n      return [node, this.nodeTimings.getCompleted(node)];\n    });\n\n    // Most consumers will want the entries sorted by startTime, so insert them in that order\n    completeNodeTimingEntries.sort((a, b) => a[1].startTime - b[1].startTime);\n\n    // Trimmed version of type `Lantern.Simulation.NodeTiming`.\n    const nodeTimingEntries: Array<[Graph.Node, Lantern.Simulation.NodeTiming]> =\n        completeNodeTimingEntries.map(([node, timing]) => {\n          return [\n            node,\n            {\n              startTime: timing.startTime,\n              endTime: timing.endTime,\n              duration: timing.endTime - timing.startTime,\n            },\n          ];\n        });\n\n    return {\n      nodeTimings: new Map(nodeTimingEntries),\n      completeNodeTimings: new Map(completeNodeTimingEntries),\n    };\n  }\n\n  getOptions(): Required<Lantern.Simulation.Options> {\n    return this.options;\n  }\n\n  /**\n   * Estimates the time taken to process all of the graph's nodes, returns the overall time along with\n   * each node annotated by start/end times.\n   *\n   * Simulator/connection pool are allowed to deviate from what was\n   * observed in the trace/devtoolsLog and start requests as soon as they are queued (i.e. do not\n   * wait around for a warm connection to be available if the original request was fetched on a warm\n   * connection).\n   */\n  simulate(graph: Graph.Node, options?: {label?: string}): Result<T> {\n    if (Graph.BaseNode.findCycle(graph)) {\n      throw new Core.LanternError('Cannot simulate graph with cycle');\n    }\n\n    options = Object.assign(\n        {\n          label: undefined,\n        },\n        options);\n\n    // initialize the necessary data containers\n    this.dns = new DNSCache({rtt: this._rtt});\n    this.initializeConnectionPool(graph);\n    this.initializeAuxiliaryData();\n\n    const nodesNotReadyToStart = this.nodes[NodeState.NotReadyToStart];\n    const nodesReadyToStart = this.nodes[NodeState.ReadyToStart];\n    const nodesInProgress = this.nodes[NodeState.InProgress];\n\n    const rootNode = graph.getRootNode();\n    rootNode.traverse(node => nodesNotReadyToStart.add(node));\n    let totalElapsedTime = 0;\n    let iteration = 0;\n\n    // root node is always ready to start\n    this.markNodeAsReadyToStart(rootNode, totalElapsedTime);\n\n    // loop as long as we have nodes in the queue or currently in progress\n    while (nodesReadyToStart.size || nodesInProgress.size) {\n      // move all possible queued nodes to in progress\n      for (const node of this.getNodesSortedByStartPosition()) {\n        this.startNodeIfPossible(node, totalElapsedTime);\n      }\n\n      if (!nodesInProgress.size) {\n        // Interplay between fromDiskCache and connectionReused can be incorrect,\n        // have to give up.\n        throw new Core.LanternError('Failed to start a node');\n      }\n\n      // set the available throughput for all connections based on # in-flight\n      this.updateNetworkCapacity();\n\n      // find the time that the next node will finish\n      const minimumTime = this.findNextNodeCompletionTime();\n      totalElapsedTime += minimumTime;\n\n      // While this is no longer strictly necessary, it's always better than hanging\n      if (!Number.isFinite(minimumTime) || iteration > 100000) {\n        throw new Core.LanternError('Simulation failed, depth exceeded');\n      }\n\n      iteration++;\n      // update how far each node will progress until that point\n      for (const node of nodesInProgress) {\n        this.updateProgressMadeInTimePeriod(node, minimumTime, totalElapsedTime);\n      }\n    }\n\n    // `nodeTimings` are used for simulator consumers, `completeNodeTimings` kept for debugging.\n    const {nodeTimings, completeNodeTimings} = this.computeFinalNodeTimings();\n    ALL_SIMULATION_NODE_TIMINGS.set(options.label || 'unlabeled', completeNodeTimings);\n\n    return {\n      timeInMs: totalElapsedTime,\n      nodeTimings,\n    };\n  }\n\n  computeWastedMsFromWastedBytes(wastedBytes: number): number {\n    const {throughput, observedThroughput} = this.options;\n\n    // https://github.com/GoogleChrome/lighthouse/pull/13323#issuecomment-962031709\n    // 0 throughput means the no (additional) throttling is expected.\n    // This is common for desktop + devtools throttling where throttling is additive and we don't want any additional.\n    const bitsPerSecond = throughput === 0 ? observedThroughput : throughput;\n    if (bitsPerSecond === 0) {\n      return 0;\n    }\n\n    const wastedBits = wastedBytes * 8;\n    const wastedMs = wastedBits / bitsPerSecond * 1000;\n\n    // This is an estimate of wasted time, so we won't be more precise than 10ms.\n    return Math.round(wastedMs / 10) * 10;\n  }\n\n  // Used by Lighthouse asset-saver\n  static get allNodeTimings(): Map<string, Map<Graph.Node, CompleteNodeTiming>> {\n    return ALL_SIMULATION_NODE_TIMINGS;\n  }\n\n  /**\n   * We attempt to start nodes by their observed start time using the request priority as a tie breaker.\n   * When simulating, just because a low priority image started 5ms before a high priority image doesn't mean\n   * it would have happened like that when the network was slower.\n   */\n  static computeNodeStartPosition(node: Graph.Node): number {\n    if (node.type === 'cpu') {\n      return node.startTime;\n    }\n    return node.startTime + (PriorityStartTimePenalty[node.request.priority] * 1000 * 1000 || 0);\n  }\n}\n\nexport {Simulator};\n"],
  "mappings": "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",
  "names": ["Core", "Core", "Graph", "throttling"]
}
