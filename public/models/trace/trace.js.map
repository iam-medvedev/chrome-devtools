{
  "version": 3,
  "sources": ["../../../../../../front_end/models/trace/EntityMapper.ts", "../../../../../../front_end/models/trace/EventsSerializer.ts", "trace.prebundle.ts", "../../../../../../front_end/models/trace/LanternComputationData.ts", "../../../../../../front_end/models/trace/ModelImpl.ts", "../../../../../../front_end/models/trace/Processor.ts", "../../../../../../front_end/models/trace/Name.ts", "../../../../../../front_end/models/trace/Styles.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport type {ParsedTrace} from './ModelImpl.js';\nimport type * as Types from './types/types.js';\n\nexport class EntityMapper {\n  #parsedTrace: ParsedTrace;\n  #entityMappings: Handlers.Helpers.EntityMappings;\n  #firstPartyEntity: Handlers.Helpers.Entity|null;\n  #thirdPartyEvents: Types.Events.Event[] = [];\n  /**\n   * When resolving urls and updating our entity mapping in the\n   * SourceMapsResolver, a single call frame can appear multiple times\n   * as different cpu profile nodes. To avoid duplicate work on the\n   * same CallFrame, we can keep track of them.\n   */\n  #resolvedCallFrames = new Set<Protocol.Runtime.CallFrame>();\n\n  constructor(parsedTrace: ParsedTrace) {\n    this.#parsedTrace = parsedTrace;\n    this.#entityMappings = this.#parsedTrace.data.Renderer.entityMappings;\n    this.#firstPartyEntity = this.#findFirstPartyEntity();\n    this.#thirdPartyEvents = this.#getThirdPartyEvents();\n  }\n\n  #findFirstPartyEntity(): Handlers.Helpers.Entity|null {\n    // As a starting point, we consider the first navigation as the 1P.\n    const nav =\n        Array.from(this.#parsedTrace.data.Meta.navigationsByNavigationId.values()).sort((a, b) => a.ts - b.ts)[0];\n    const firstPartyUrl = nav?.args.data?.documentLoaderURL ?? this.#parsedTrace.data.Meta.mainFrameURL;\n    if (!firstPartyUrl) {\n      return null;\n    }\n    return Handlers.Helpers.getEntityForUrl(firstPartyUrl, this.#entityMappings) ?? null;\n  }\n\n  #getThirdPartyEvents(): Types.Events.Event[] {\n    const entries = Array.from(this.#entityMappings.eventsByEntity.entries());\n    const thirdPartyEvents = entries.flatMap(([entity, events]) => {\n      return entity !== this.#firstPartyEntity ? events : [];\n    });\n    return thirdPartyEvents;\n  }\n\n  /**\n   * Returns an entity for a given event if any.\n   */\n  entityForEvent(event: Types.Events.Event): Handlers.Helpers.Entity|null {\n    return this.#entityMappings.entityByEvent.get(event) ?? null;\n  }\n\n  /**\n   * Returns trace events that correspond with a given entity if any.\n   */\n  eventsForEntity(entity: Handlers.Helpers.Entity): Types.Events.Event[] {\n    return this.#entityMappings.eventsByEntity.get(entity) ?? [];\n  }\n\n  firstPartyEntity(): Handlers.Helpers.Entity|null {\n    return this.#firstPartyEntity;\n  }\n\n  thirdPartyEvents(): Types.Events.Event[] {\n    return this.#thirdPartyEvents;\n  }\n\n  mappings(): Handlers.Helpers.EntityMappings {\n    return this.#entityMappings;\n  }\n\n  /**\n   * This updates entity mapping given a callFrame and sourceURL (newly resolved),\n   * updating both eventsByEntity and entityByEvent. The call frame provides us the\n   * URL and sourcemap source location that events map to. This describes the exact events we\n   * want to update. We then update the events with the new sourceURL.\n   *\n   * compiledURLs -> the actual file's url (e.g. my-big-bundle.min.js)\n   * sourceURLs -> the resolved urls (e.g. react.development.js, my-app.ts)\n   * @param callFrame\n   * @param sourceURL\n   */\n  updateSourceMapEntities(callFrame: Protocol.Runtime.CallFrame, sourceURL: string): void {\n    // Avoid the extra work, if we have already resolved this callFrame.\n    if (this.#resolvedCallFrames.has(callFrame)) {\n      return;\n    }\n\n    const compiledURL = callFrame.url;\n    const currentEntity = Handlers.Helpers.getEntityForUrl(compiledURL, this.#entityMappings);\n    const resolvedEntity = Handlers.Helpers.getEntityForUrl(sourceURL, this.#entityMappings);\n    // If the entity changed, then we should update our caches. If we don't have a currentEntity,\n    // we can't do much with that. Additionally without our current entity, we don't have a reference to the related\n    // events so there are no relationships to be made.\n    if ((resolvedEntity === currentEntity) || (!currentEntity || !resolvedEntity)) {\n      return;\n    }\n    const currentEntityEvents = (currentEntity && this.#entityMappings.eventsByEntity.get(currentEntity)) ?? [];\n    // The events of the entity that match said source location.\n    const sourceLocationEvents: Types.Events.Event[] = [];\n    // The events that don't match the source location, but that we should keep mapped to its current entity.\n    const unrelatedEvents: Types.Events.Event[] = [];\n    currentEntityEvents?.forEach(e => {\n      const cf = Helpers.Trace.getStackTraceTopCallFrameInEventPayload(e);\n\n      const matchesCallFrame = cf && Helpers.Trace.isMatchingCallFrame(cf, callFrame);\n      if (matchesCallFrame) {\n        sourceLocationEvents.push(e);\n      } else {\n        unrelatedEvents.push(e);\n      }\n    });\n    // Update current entity.\n    this.#entityMappings.eventsByEntity.set(currentEntity, unrelatedEvents);\n    // Map the source location events to the new entity.\n    this.#entityMappings.eventsByEntity.set(resolvedEntity, sourceLocationEvents);\n    sourceLocationEvents.forEach(e => {\n      this.#entityMappings.entityByEvent.set(e, resolvedEntity);\n    });\n    // Update our CallFrame cache when we've got a resolved entity.\n    this.#resolvedCallFrames.add(callFrame);\n  }\n\n  // Update entities with proper Chrome Extension names.\n  updateExtensionEntitiesWithName(executionContextNamesByOrigin: Map<Platform.DevToolsPath.UrlString, string>): void {\n    const entities = Array.from(this.#entityMappings.eventsByEntity.keys());\n    for (const [origin, name] of executionContextNamesByOrigin) {\n      // In makeUpChromeExtensionEntity, the extension origin is set as the only domain for the entity.\n      const entity = entities.find(e => e.domains[0] === origin);\n      if (entity) {\n        entity.name = entity.company = name;\n      }\n    }\n  }\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from './helpers/helpers.js';\nimport type {ParsedTrace} from './ModelImpl.js';\nimport * as Types from './types/types.js';\n\nexport class EventsSerializer {\n  #modifiedProfileCallByKey = new Map<Types.File.ProfileCallKeyValues, Types.Events.SyntheticProfileCall>();\n\n  keyForEvent(event: Types.Events.Event): Types.File.SerializableKey|null {\n    if (Types.Events.isProfileCall(event)) {\n      return `${Types.File.EventKeyType.PROFILE_CALL}-${event.pid}-${event.tid}-${\n          Types.Events.SampleIndex(event.sampleIndex)}-${event.nodeId}`;\n    }\n\n    if (Types.Events.isLegacyTimelineFrame(event)) {\n      return `${Types.File.EventKeyType.LEGACY_TIMELINE_FRAME}-${event.index}`;\n    }\n\n    const rawEvents = Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager().getRawTraceEvents();\n    const key: Types.File.SyntheticEventKey|Types.File.RawEventKey = Types.Events.isSyntheticBased(event) ?\n        `${Types.File.EventKeyType.SYNTHETIC_EVENT}-${rawEvents.indexOf(event.rawSourceEvent)}` :\n        `${Types.File.EventKeyType.RAW_EVENT}-${rawEvents.indexOf(event)}`;\n    if (key.length < 3) {\n      return null;\n    }\n    return key;\n  }\n\n  eventForKey(key: Types.File.SerializableKey, parsedTrace: ParsedTrace): Types.Events.Event {\n    const eventValues = Types.File.traceEventKeyToValues(key);\n\n    if (EventsSerializer.isProfileCallKey(eventValues)) {\n      return this.#getModifiedProfileCallByKeyValues(eventValues, parsedTrace);\n    }\n\n    if (EventsSerializer.isLegacyTimelineFrameKey(eventValues)) {\n      const event = parsedTrace.data.Frames.frames.at(eventValues.rawIndex);\n      if (!event) {\n        throw new Error(`Could not find frame with index ${eventValues.rawIndex}`);\n      }\n      return event;\n    }\n\n    if (EventsSerializer.isSyntheticEventKey(eventValues)) {\n      const syntheticEvents = Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager().getSyntheticTraces();\n      const syntheticEvent = syntheticEvents.at(eventValues.rawIndex);\n      if (!syntheticEvent) {\n        throw new Error(`Attempted to get a synthetic event from an unknown raw event index: ${eventValues.rawIndex}`);\n      }\n      return syntheticEvent;\n    }\n\n    if (EventsSerializer.isRawEventKey(eventValues)) {\n      const rawEvents = Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager().getRawTraceEvents();\n      return rawEvents[eventValues.rawIndex];\n    }\n    throw new Error(`Unknown trace event serializable key values: ${(eventValues as unknown[]).join('-')}`);\n  }\n\n  static isProfileCallKey(key: Types.File.SerializableKeyValues): key is Types.File.ProfileCallKeyValues {\n    return key.type === Types.File.EventKeyType.PROFILE_CALL;\n  }\n  static isLegacyTimelineFrameKey(key: Types.File.SerializableKeyValues):\n      key is Types.File.LegacyTimelineFrameKeyValues {\n    return key.type === Types.File.EventKeyType.LEGACY_TIMELINE_FRAME;\n  }\n\n  static isRawEventKey(key: Types.File.SerializableKeyValues): key is Types.File.RawEventKeyValues {\n    return key.type === Types.File.EventKeyType.RAW_EVENT;\n  }\n  static isSyntheticEventKey(key: Types.File.SerializableKeyValues): key is Types.File.SyntheticEventKeyValues {\n    return key.type === Types.File.EventKeyType.SYNTHETIC_EVENT;\n  }\n\n  #getModifiedProfileCallByKeyValues(key: Types.File.ProfileCallKeyValues, parsedTrace: ParsedTrace):\n      Types.Events.SyntheticProfileCall {\n    const cacheResult = this.#modifiedProfileCallByKey.get(key);\n    if (cacheResult) {\n      return cacheResult;\n    }\n    const profileCallsInThread =\n        parsedTrace.data.Renderer.processes.get(key.processID)?.threads.get(key.threadID)?.profileCalls;\n    if (!profileCallsInThread) {\n      throw new Error(`Unknown profile call serializable key: ${(key)}`);\n    }\n\n    const match = profileCallsInThread?.find((e: Types.Events.SyntheticProfileCall) => {\n      return e.sampleIndex === key.sampleIndex && e.nodeId === key.protocol;\n    });\n    if (!match) {\n      throw new Error(`Unknown profile call serializable key: ${(JSON.stringify(key))}`);\n    }\n    // Cache to avoid looking up in subsequent calls.\n    this.#modifiedProfileCallByKey.set(key, match);\n    return match;\n  }\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as EntityMapper from './EntityMapper.js';\nimport * as EventsSerializer from './EventsSerializer.js';\nimport * as Extras from './extras/extras.js';\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport * as Insights from './insights/insights.js';\nimport * as Lantern from './lantern/lantern.js';\nimport * as LanternComputationData from './LanternComputationData.js';\nimport * as TraceModel from './ModelImpl.js';\nimport * as Name from './Name.js';\nimport * as Processor from './Processor.js';\nimport * as Styles from './Styles.js';\nimport * as Types from './types/types.js';\n\nexport {\n  EntityMapper,\n  EventsSerializer,\n  Extras,\n  Handlers,\n  Helpers,\n  Insights,\n  Lantern,\n  LanternComputationData,\n  Name,\n  Processor,\n  Styles,\n  TraceModel,\n  Types,\n};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Lantern from './lantern/lantern.js';\nimport type * as Types from './types/types.js';\n\ntype NetworkRequest = Lantern.Types.NetworkRequest<Types.Events.SyntheticNetworkRequest>;\n\nfunction createProcessedNavigation(data: Handlers.Types.HandlerData, frameId: string, navigationId: string):\n    Lantern.Types.Simulation.ProcessedNavigation {\n  const scoresByNav = data.PageLoadMetrics.metricScoresByFrameId.get(frameId);\n  if (!scoresByNav) {\n    throw new Lantern.Core.LanternError('missing metric scores for frame');\n  }\n\n  const scores = scoresByNav.get(navigationId);\n  if (!scores) {\n    throw new Lantern.Core.LanternError('missing metric scores for specified navigation');\n  }\n\n  const getTimestampOrUndefined =\n      (metric: Handlers.ModelHandlers.PageLoadMetrics.MetricName): Types.Timing.Micro|undefined => {\n        const metricScore = scores.get(metric);\n        if (!metricScore?.event) {\n          return;\n        }\n        return metricScore.event.ts;\n      };\n  const getTimestamp = (metric: Handlers.ModelHandlers.PageLoadMetrics.MetricName): Types.Timing.Micro => {\n    const metricScore = scores.get(metric);\n    if (!metricScore?.event) {\n      throw new Lantern.Core.LanternError(`missing metric: ${metric}`);\n    }\n    return metricScore.event.ts;\n  };\n  return {\n    timestamps: {\n      firstContentfulPaint: getTimestamp(Handlers.ModelHandlers.PageLoadMetrics.MetricName.FCP),\n      largestContentfulPaint: getTimestampOrUndefined(Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP),\n    },\n  };\n}\n\nfunction createParsedUrl(url: URL|string): Lantern.Types.ParsedURL {\n  if (typeof url === 'string') {\n    url = new URL(url);\n  }\n  return {\n    scheme: url.protocol.split(':')[0],\n    // Intentional, DevTools uses different terminology\n    host: url.hostname,\n    securityOrigin: url.origin,\n  };\n}\n\n/**\n * Returns a map of `pid` -> `tid[]`.\n */\nfunction findWorkerThreads(trace: Lantern.Types.Trace): Map<number, number[]> {\n  // TODO: WorkersHandler in Trace Engine needs to be updated to also include `pid` (only had `tid`).\n  const workerThreads = new Map();\n  const workerCreationEvents = ['ServiceWorker thread', 'DedicatedWorker thread'];\n\n  for (const event of trace.traceEvents) {\n    if (event.name !== 'thread_name' || !event.args.name) {\n      continue;\n    }\n    if (!workerCreationEvents.includes(event.args.name)) {\n      continue;\n    }\n\n    const tids = workerThreads.get(event.pid);\n    if (tids) {\n      tids.push(event.tid);\n    } else {\n      workerThreads.set(event.pid, [event.tid]);\n    }\n  }\n\n  return workerThreads;\n}\n\nfunction createLanternRequest(\n    parsedTrace: Readonly<Handlers.Types.HandlerData>, workerThreads: Map<number, number[]>,\n    request: Types.Events.SyntheticNetworkRequest): NetworkRequest|undefined {\n  if (request.args.data.hasResponse && request.args.data.connectionId === undefined) {\n    throw new Lantern.Core.LanternError('Trace is too old');\n  }\n\n  let url;\n  try {\n    url = new URL(request.args.data.url);\n  } catch {\n    return;\n  }\n\n  const timing = request.args.data.timing ? {\n    // These two timings are not included in the trace.\n    workerFetchStart: -1,\n    workerRespondWithSettled: -1,\n    receiveHeadersStart: -1,\n    ...request.args.data.timing,\n  } :\n                                            undefined;\n\n  const networkRequestTime = timing ? timing.requestTime * 1000 : request.args.data.syntheticData.downloadStart / 1000;\n\n  let fromWorker = false;\n  const tids = workerThreads.get(request.pid);\n  if (tids?.includes(request.tid)) {\n    fromWorker = true;\n  }\n\n  // Trace Engine collects worker thread ids in a different manner than `workerThreads` does.\n  // AFAIK these should be equivalent, but in case they are not let's also check this for now.\n  if (parsedTrace.Workers.workerIdByThread.has(request.tid)) {\n    fromWorker = true;\n  }\n\n  // `initiator` in the trace does not contain the stack trace for JS-initiated\n  // requests. Instead, that is stored in the `stackTrace` property of the SyntheticNetworkRequest.\n  // There are some minor differences in the fields, accounted for here.\n  // Most importantly, there seems to be fewer frames in the trace than the equivalent\n  // events over the CDP. This results in less accuracy in determining the initiator request,\n  // which means less edges in the graph, which mean worse results.\n  // TODO: Should fix in Chromium.\n  const initiator: Lantern.Types.NetworkRequest['initiator'] =\n      request.args.data.initiator ?? {type: Protocol.Network.InitiatorType.Other};\n  if (request.args.data.stackTrace) {\n    const callFrames = request.args.data.stackTrace.map(f => {\n      return {\n        scriptId: String(f.scriptId) as Protocol.Runtime.ScriptId,\n        url: f.url,\n        lineNumber: f.lineNumber - 1,\n        columnNumber: f.columnNumber - 1,\n        functionName: f.functionName,\n      };\n    });\n    initiator.stack = {callFrames};\n    // Note: there is no `parent` to set ...\n  }\n\n  let resourceType = request.args.data.resourceType;\n  if (request.args.data.initiator?.fetchType === 'xmlhttprequest') {\n    // @ts-expect-error yes XHR is a valid ResourceType. TypeScript const enums are so unhelpful.\n    resourceType = 'XHR';\n  } else if (request.args.data.initiator?.fetchType === 'fetch') {\n    // @ts-expect-error yes Fetch is a valid ResourceType. TypeScript const enums are so unhelpful.\n    resourceType = 'Fetch';\n  }\n\n  // TODO: set decodedBodyLength for data urls in Trace Engine.\n  let resourceSize = request.args.data.decodedBodyLength ?? 0;\n  if (url.protocol === 'data:' && resourceSize === 0) {\n    const commaIndex = url.pathname.indexOf(',');\n    if (url.pathname.substring(0, commaIndex).includes(';base64')) {\n      resourceSize = atob(url.pathname.substring(commaIndex + 1)).length;\n    } else {\n      resourceSize = url.pathname.length - commaIndex - 1;\n    }\n  }\n\n  return {\n    rawRequest: request,\n    requestId: request.args.data.requestId,\n    connectionId: request.args.data.connectionId ?? 0,\n    connectionReused: request.args.data.connectionReused ?? false,\n    url: request.args.data.url,\n    protocol: request.args.data.protocol,\n    parsedURL: createParsedUrl(url),\n    documentURL: request.args.data.requestingFrameUrl,\n    rendererStartTime: request.ts / 1000,\n    networkRequestTime,\n    responseHeadersEndTime: request.args.data.syntheticData.downloadStart / 1000,\n    networkEndTime: request.args.data.syntheticData.finishTime / 1000,\n    transferSize: request.args.data.encodedDataLength,\n    resourceSize,\n    fromDiskCache: request.args.data.syntheticData.isDiskCached,\n    fromMemoryCache: request.args.data.syntheticData.isMemoryCached,\n    isLinkPreload: request.args.data.isLinkPreload,\n    finished: request.args.data.finished,\n    failed: request.args.data.failed,\n    statusCode: request.args.data.statusCode,\n    initiator,\n    timing,\n    resourceType,\n    mimeType: request.args.data.mimeType,\n    priority: request.args.data.priority,\n    frameId: request.args.data.frame,\n    fromWorker,\n    // Set later.\n    redirects: undefined,\n    redirectSource: undefined,\n    redirectDestination: undefined,\n    initiatorRequest: undefined,\n  };\n}\n\n/**\n * @param request The request to find the initiator of\n */\nfunction chooseInitiatorRequest(request: NetworkRequest, requestsByURL: Map<string, NetworkRequest[]>): NetworkRequest|\n    null {\n  if (request.redirectSource) {\n    return request.redirectSource;\n  }\n\n  const initiatorURL = Lantern.Graph.PageDependencyGraph.getNetworkInitiators(request)[0];\n  let candidates = requestsByURL.get(initiatorURL) || [];\n  // The (valid) initiator must come before the initiated request.\n  candidates = candidates.filter(c => {\n    return c.responseHeadersEndTime <= request.rendererStartTime && c.finished && !c.failed;\n  });\n  if (candidates.length > 1) {\n    // Disambiguate based on prefetch. Prefetch requests have type 'Other' and cannot\n    // initiate requests, so we drop them here.\n    const nonPrefetchCandidates =\n        candidates.filter(cand => cand.resourceType !== Lantern.Types.NetworkRequestTypes.Other);\n    if (nonPrefetchCandidates.length) {\n      candidates = nonPrefetchCandidates;\n    }\n  }\n  if (candidates.length > 1) {\n    // Disambiguate based on frame. It's likely that the initiator comes from the same frame.\n    const sameFrameCandidates = candidates.filter(cand => cand.frameId === request.frameId);\n    if (sameFrameCandidates.length) {\n      candidates = sameFrameCandidates;\n    }\n  }\n  if (candidates.length > 1 && request.initiator.type === 'parser') {\n    // Filter to just Documents when initiator type is parser.\n    const documentCandidates =\n        candidates.filter(cand => cand.resourceType === Lantern.Types.NetworkRequestTypes.Document);\n    if (documentCandidates.length) {\n      candidates = documentCandidates;\n    }\n  }\n  if (candidates.length > 1) {\n    // If all real loads came from successful preloads (url preloaded and\n    // loads came from the cache), filter to link rel=preload request(s).\n    const linkPreloadCandidates = candidates.filter(c => c.isLinkPreload);\n    if (linkPreloadCandidates.length) {\n      const nonPreloadCandidates = candidates.filter(c => !c.isLinkPreload);\n      const allPreloaded = nonPreloadCandidates.every(c => c.fromDiskCache || c.fromMemoryCache);\n      if (nonPreloadCandidates.length && allPreloaded) {\n        candidates = linkPreloadCandidates;\n      }\n    }\n  }\n\n  // Only return an initiator if the result is unambiguous.\n  return candidates.length === 1 ? candidates[0] : null;\n}\n\nfunction linkInitiators(lanternRequests: NetworkRequest[]): void {\n  const requestsByURL = new Map<string, NetworkRequest[]>();\n  for (const request of lanternRequests) {\n    const requests = requestsByURL.get(request.url) || [];\n    requests.push(request);\n    requestsByURL.set(request.url, requests);\n  }\n\n  for (const request of lanternRequests) {\n    const initiatorRequest = chooseInitiatorRequest(request, requestsByURL);\n    if (initiatorRequest) {\n      request.initiatorRequest = initiatorRequest;\n    }\n  }\n}\n\nfunction createNetworkRequests(\n    trace: Lantern.Types.Trace, data: Handlers.Types.HandlerData, startTime = 0,\n    endTime = Number.POSITIVE_INFINITY): NetworkRequest[] {\n  const workerThreads = findWorkerThreads(trace);\n\n  const lanternRequestsNoRedirects: NetworkRequest[] = [];\n  for (const request of data.NetworkRequests.byTime) {\n    if (request.ts >= startTime && request.ts < endTime) {\n      const lanternRequest = createLanternRequest(data, workerThreads, request);\n      if (lanternRequest) {\n        lanternRequestsNoRedirects.push(lanternRequest);\n      }\n    }\n  }\n\n  const lanternRequests: NetworkRequest[] = [];\n\n  // Trace Engine consolidates all redirects into a single request object, but lantern needs\n  // an entry for each redirected request.\n  for (const request of [...lanternRequestsNoRedirects]) {\n    if (!request.rawRequest) {\n      continue;\n    }\n\n    const redirects = request.rawRequest.args.data.redirects;\n    if (!redirects.length) {\n      lanternRequests.push(request);\n      continue;\n    }\n\n    const requestChain = [];\n    for (const redirect of redirects) {\n      const redirectedRequest = structuredClone(request);\n\n      redirectedRequest.networkRequestTime = redirect.ts / 1000;\n      redirectedRequest.rendererStartTime = redirectedRequest.networkRequestTime;\n\n      redirectedRequest.networkEndTime = (redirect.ts + redirect.dur) / 1000;\n      redirectedRequest.responseHeadersEndTime = redirectedRequest.networkEndTime;\n\n      redirectedRequest.timing = {\n        requestTime: redirectedRequest.networkRequestTime / 1000,\n        receiveHeadersStart: redirectedRequest.responseHeadersEndTime,\n        receiveHeadersEnd: redirectedRequest.responseHeadersEndTime,\n        proxyStart: -1,\n        proxyEnd: -1,\n        dnsStart: -1,\n        dnsEnd: -1,\n        connectStart: -1,\n        connectEnd: -1,\n        sslStart: -1,\n        sslEnd: -1,\n        sendStart: -1,\n        sendEnd: -1,\n        workerStart: -1,\n        workerReady: -1,\n        workerFetchStart: -1,\n        workerRespondWithSettled: -1,\n        pushStart: -1,\n        pushEnd: -1,\n      };\n\n      redirectedRequest.url = redirect.url;\n      redirectedRequest.parsedURL = createParsedUrl(redirect.url);\n      // TODO: Trace Engine is not retaining the actual status code.\n      redirectedRequest.statusCode = 302;\n      redirectedRequest.resourceType = undefined;\n      // TODO: Trace Engine is not retaining transfer size of redirected request.\n      redirectedRequest.transferSize = 400;\n      requestChain.push(redirectedRequest);\n      lanternRequests.push(redirectedRequest);\n    }\n    requestChain.push(request);\n    lanternRequests.push(request);\n\n    for (let i = 0; i < requestChain.length; i++) {\n      const request = requestChain[i];\n      if (i > 0) {\n        request.redirectSource = requestChain[i - 1];\n        request.redirects = requestChain.slice(0, i);\n      }\n      if (i !== requestChain.length - 1) {\n        request.redirectDestination = requestChain[i + 1];\n      }\n    }\n\n    // Apply the `:redirect` requestId convention: only redirects[0].requestId is the actual\n    // requestId, all the rest have n occurrences of `:redirect` as a suffix.\n    for (let i = 1; i < requestChain.length; i++) {\n      requestChain[i].requestId = `${requestChain[i - 1].requestId}:redirect`;\n    }\n  }\n\n  linkInitiators(lanternRequests);\n\n  return lanternRequests;\n}\n\nfunction collectMainThreadEvents(\n    trace: Lantern.Types.Trace, data: Handlers.Types.HandlerData): Lantern.Types.TraceEvent[] {\n  const Meta = data.Meta;\n  const mainFramePids = Meta.mainFrameNavigations.length ? new Set(Meta.mainFrameNavigations.map(nav => nav.pid)) :\n                                                           Meta.topLevelRendererIds;\n\n  const rendererPidToTid = new Map();\n  for (const pid of mainFramePids) {\n    const threads = Meta.threadsInProcess.get(pid) ?? [];\n\n    let found = false;\n    for (const [tid, thread] of threads) {\n      if (thread.args.name === 'CrRendererMain') {\n        rendererPidToTid.set(pid, tid);\n        found = true;\n        break;\n      }\n    }\n\n    if (found) {\n      continue;\n    }\n\n    // `CrRendererMain` can be missing if chrome is launched with the `--single-process` flag.\n    // In this case, page tasks will be run in the browser thread.\n    for (const [tid, thread] of threads) {\n      if (thread.args.name === 'CrBrowserMain') {\n        rendererPidToTid.set(pid, tid);\n        found = true;\n        break;\n      }\n    }\n  }\n\n  return trace.traceEvents.filter(e => rendererPidToTid.get(e.pid) === e.tid);\n}\n\nfunction createGraph(\n    requests: Lantern.Types.NetworkRequest[], trace: Lantern.Types.Trace, data: Handlers.Types.HandlerData,\n    url?: Lantern.Types.Simulation.URL): Lantern.Graph.Node<Types.Events.SyntheticNetworkRequest> {\n  const mainThreadEvents = collectMainThreadEvents(trace, data);\n\n  // url defines the initial request that the Lantern graph starts at (the root node) and the\n  // main document request. These are equal if there are no redirects.\n  if (!url) {\n    url = {\n      requestedUrl: requests[0].url,\n      mainDocumentUrl: '',\n    };\n\n    let request = requests[0];\n    while (request.redirectDestination) {\n      request = request.redirectDestination;\n    }\n    url.mainDocumentUrl = request.url;\n  }\n\n  return Lantern.Graph.PageDependencyGraph.createGraph(mainThreadEvents, requests, url);\n}\n\nexport {\n  createGraph,\n  createNetworkRequests,\n  createProcessedNavigation,\n};\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport type * as Insights from './insights/insights.js';\nimport {TraceParseProgressEvent, TraceProcessor} from './Processor.js';\nimport * as Types from './types/types.js';\n\n// Note: this model is implemented in a way that can support multiple trace\n// processors. Currently there is only one implemented, but you will see\n// references to \"processors\" plural because it can easily be extended in the future.\n\n/**\n * The Model is responsible for parsing arrays of raw trace events and storing the\n * resulting data. It can store multiple traces at once, and can return the data for\n * any of them.\n *\n * Most uses of this class should be through `createWithAllHandlers`, but\n * `createWithSubsetOfHandlers` can be used to run just some handlers.\n **/\nexport class Model extends EventTarget {\n  readonly #traces: ParsedTrace[] = [];\n  readonly #nextNumberByDomain = new Map<string, number>();\n\n  readonly #recordingsAvailable: string[] = [];\n  #lastRecordingIndex = 0;\n  #processor: TraceProcessor;\n  #config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\n  static createWithAllHandlers(config?: Types.Configuration.Configuration): Model {\n    return new Model(Handlers.ModelHandlers, config);\n  }\n\n  /**\n   * Runs only the provided handlers.\n   *\n   * Callers must ensure they are providing all dependant handlers (although Meta is included automatically),\n   * and must know that the result of `.parsedTrace` will be limited to the handlers provided, even though\n   * the type won't reflect that.\n   */\n  static createWithSubsetOfHandlers(\n      traceHandlers: Partial<Handlers.Types.Handlers>, config?: Types.Configuration.Configuration): Model {\n    return new Model(traceHandlers as Handlers.Types.Handlers, config);\n  }\n\n  constructor(handlers: Handlers.Types.Handlers, config?: Types.Configuration.Configuration) {\n    super();\n    if (config) {\n      this.#config = config;\n    }\n    this.#processor = new TraceProcessor(handlers, this.#config);\n  }\n\n  /**\n   * Parses an array of trace events into a structured object containing all the\n   * information parsed by the trace handlers.\n   * You can `await` this function to pause execution until parsing is complete,\n   * or instead rely on the `ModuleUpdateEvent` that is dispatched when the\n   * parsing is finished.\n   *\n   * Once parsed, you then have to call the `parsedTrace` method, providing an\n   * index of the trace you want to have the data for. This is because any model\n   * can store a number of traces. Each trace is given an index, which starts at 0\n   * and increments by one as a new trace is parsed.\n   *\n   * @example\n   * // Awaiting the parse method() to block until parsing complete\n   * await this.traceModel.parse(events);\n   * const data = this.traceModel.parsedTrace(0)\n   * @example\n   * // Using an event listener to be notified when tracing is complete.\n   * this.traceModel.addEventListener(Trace.ModelUpdateEvent.eventName, (event) => {\n   *   if(event.data.data === 'done') {\n   *     // trace complete\n   *     const data = this.traceModel.parsedTrace(0);\n   *   }\n   * });\n   * void this.traceModel.parse(events);\n   **/\n  async parse(traceEvents: readonly Types.Events.Event[], config?: Types.Configuration.ParseOptions): Promise<void> {\n    const metadata = config?.metadata || {};\n    // During parsing, periodically update any listeners on each processors'\n    // progress (if they have any updates).\n    const onTraceUpdate = (event: Event): void => {\n      const {data} = event as TraceParseProgressEvent;\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.PROGRESS_UPDATE, data}));\n    };\n\n    this.#processor.addEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n\n    // TODO(cjamcl): this.#processor.parse needs this to work. So it should either take it as input, or create it itself.\n    const syntheticEventsManager = Helpers.SyntheticEvents.SyntheticEventsManager.createAndActivate(traceEvents);\n\n    try {\n      // Wait for all outstanding promises before finishing the async execution,\n      // but perform all tasks in parallel.\n      await this.#processor.parse(traceEvents, config ?? {});\n      if (!this.#processor.data) {\n        throw new Error('processor did not parse trace');\n      }\n      const file = this.#storeAndCreateParsedTraceFile(\n          syntheticEventsManager, traceEvents, metadata, this.#processor.data, this.#processor.insights);\n      // We only push the file onto this.#traces here once we know it's valid\n      // and there's been no errors in the parsing.\n      this.#traces.push(file);\n    } catch (e) {\n      throw e;\n    } finally {\n      // All processors have finished parsing, no more updates are expected.\n      this.#processor.removeEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n      // Finally, update any listeners that all processors are 'done'.\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.COMPLETE, data: 'done'}));\n    }\n  }\n\n  #storeAndCreateParsedTraceFile(\n      syntheticEventsManager: Helpers.SyntheticEvents.SyntheticEventsManager,\n      traceEvents: readonly Types.Events.Event[], metadata: Types.File.MetaData, data: Handlers.Types.HandlerData,\n      traceInsights: Insights.Types.TraceInsightSets|null): ParsedTrace {\n    this.#lastRecordingIndex++;\n    let recordingName = `Trace ${this.#lastRecordingIndex}`;\n    const origin = Helpers.Trace.extractOriginFromTrace(data.Meta.mainFrameURL);\n    if (origin) {\n      const nextSequenceForDomain = Platform.MapUtilities.getWithDefault(this.#nextNumberByDomain, origin, () => 1);\n      recordingName = `${origin} (${nextSequenceForDomain})`;\n      this.#nextNumberByDomain.set(origin, nextSequenceForDomain + 1);\n    }\n    this.#recordingsAvailable.push(recordingName);\n\n    return {\n      traceEvents,\n      metadata,\n      data,\n      insights: traceInsights,\n      syntheticEventsManager,\n    };\n  }\n\n  lastTraceIndex(): number {\n    return this.size() - 1;\n  }\n\n  /**\n   * Returns the parsed trace data indexed by the order in which it was stored.\n   * If no index is given, the last stored parsed data is returned.\n   */\n  parsedTrace(index: number = this.#traces.length - 1): ParsedTrace|null {\n    return this.#traces.at(index) ?? null;\n  }\n\n  overrideModifications(index: number, newModifications: Types.File.Modifications): void {\n    if (this.#traces[index]) {\n      this.#traces[index].metadata.modifications = newModifications;\n    }\n  }\n\n  syntheticTraceEventsManager(index: number = this.#traces.length - 1): Helpers.SyntheticEvents.SyntheticEventsManager\n      |null {\n    return this.#traces.at(index)?.syntheticEventsManager ?? null;\n  }\n\n  size(): number {\n    return this.#traces.length;\n  }\n\n  deleteTraceByIndex(recordingIndex: number): void {\n    this.#traces.splice(recordingIndex, 1);\n    this.#recordingsAvailable.splice(recordingIndex, 1);\n  }\n\n  getRecordingsAvailable(): string[] {\n    return this.#recordingsAvailable;\n  }\n\n  resetProcessor(): void {\n    this.#processor.reset();\n  }\n}\n\n/**\n * This parsed trace is used by the Model. It keeps multiple instances\n * of these so that the user can swap between them. The key is that it is\n * essentially the TraceFile plus whatever the model has parsed from it.\n */\nexport type ParsedTrace = Types.File.TraceFile&{\n  data: Handlers.Types.HandlerData,\n  /** Is null for CPU profiles. */\n  insights: Insights.Types.TraceInsightSets | null,\n  syntheticEventsManager: Helpers.SyntheticEvents.SyntheticEventsManager,\n};\n\nexport const enum ModelUpdateType {\n  COMPLETE = 'COMPLETE',\n  PROGRESS_UPDATE = 'PROGRESS_UPDATE',\n}\n\nexport type ModelUpdateEventData = ModelUpdateEventComplete|ModelUpdateEventProgress;\n\nexport interface ModelUpdateEventComplete {\n  type: ModelUpdateType.COMPLETE;\n  data: 'done';\n}\nexport interface ModelUpdateEventProgress {\n  type: ModelUpdateType.PROGRESS_UPDATE;\n  data: TraceParseEventProgressData;\n}\n\nexport interface TraceParseEventProgressData {\n  percent: number;\n}\n\nexport class ModelUpdateEvent extends Event {\n  static readonly eventName = 'modelupdate';\n  constructor(public data: ModelUpdateEventData) {\n    super(ModelUpdateEvent.eventName);\n  }\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [ModelUpdateEvent.eventName]: ModelUpdateEvent;\n  }\n}\n\nexport function isModelUpdateDataComplete(eventData: ModelUpdateEventData): eventData is ModelUpdateEventComplete {\n  return eventData.type === ModelUpdateType.COMPLETE;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport * as Insights from './insights/insights.js';\nimport * as Lantern from './lantern/lantern.js';\nimport * as LanternComputationData from './LanternComputationData.js';\nimport type * as Model from './ModelImpl.js';\nimport * as Types from './types/types.js';\n\nconst enum Status {\n  IDLE = 'IDLE',\n  PARSING = 'PARSING',\n  FINISHED_PARSING = 'FINISHED_PARSING',\n  ERRORED_WHILE_PARSING = 'ERRORED_WHILE_PARSING',\n}\n\nexport class TraceParseProgressEvent extends Event {\n  static readonly eventName = 'traceparseprogress';\n  constructor(public data: Model.TraceParseEventProgressData, init: EventInit = {bubbles: true}) {\n    super(TraceParseProgressEvent.eventName, init);\n  }\n}\n\n/**\n * Parsing a trace can take time. On large traces we see a breakdown of time like so:\n *   - handleEvent() loop:  ~20%\n *   - finalize() loop:     ~60%\n *   - shallowClone calls:  ~20%\n * The numbers below are set so we can report a progress percentage of [0...1]\n */\nconst enum ProgressPhase {\n  HANDLE_EVENT = 0.2,\n  FINALIZE = 0.8,\n  CLONE = 1.0,\n}\nfunction calculateProgress(value: number, phase: ProgressPhase): number {\n  // Finalize values should be [0.2...0.8]\n  if (phase === ProgressPhase.FINALIZE) {\n    return (value * (ProgressPhase.FINALIZE - ProgressPhase.HANDLE_EVENT)) + ProgressPhase.HANDLE_EVENT;\n  }\n  return value * phase;\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [TraceParseProgressEvent.eventName]: TraceParseProgressEvent;\n  }\n}\n\nexport class TraceProcessor extends EventTarget {\n  // We force the Meta handler to be enabled, so the TraceHandlers type here is\n  // the model handlers the user passes in and the Meta handler.\n  readonly #traceHandlers: Partial<Handlers.Types.Handlers>;\n  #status = Status.IDLE;\n  #modelConfiguration = Types.Configuration.defaults();\n  #data: Handlers.Types.HandlerData|null = null;\n  #insights: Insights.Types.TraceInsightSets|null = null;\n\n  static createWithAllHandlers(): TraceProcessor {\n    return new TraceProcessor(Handlers.ModelHandlers, Types.Configuration.defaults());\n  }\n\n  /**\n   * This function is kept for testing with `stub`.\n   */\n  static getInsightRunners(): Insights.Types.InsightModelsType {\n    return {...Insights.Models};\n  }\n\n  constructor(traceHandlers: Partial<Handlers.Types.Handlers>, modelConfiguration?: Types.Configuration.Configuration) {\n    super();\n\n    this.#verifyHandlers(traceHandlers);\n    this.#traceHandlers = {\n      Meta: Handlers.ModelHandlers.Meta,\n      ...traceHandlers,\n    };\n    if (modelConfiguration) {\n      this.#modelConfiguration = modelConfiguration;\n    }\n    this.#passConfigToHandlers();\n  }\n\n  #passConfigToHandlers(): void {\n    for (const handler of Object.values(this.#traceHandlers)) {\n      // Bit of an odd double check, but without this TypeScript refuses to let\n      // you call the function as it thinks it might be undefined.\n      if ('handleUserConfig' in handler && handler.handleUserConfig) {\n        handler.handleUserConfig(this.#modelConfiguration);\n      }\n    }\n  }\n\n  /**\n   * When the user passes in a set of handlers, we want to ensure that we have all\n   * the required handlers. Handlers can depend on other handlers, so if the user\n   * passes in FooHandler which depends on BarHandler, they must also pass in\n   * BarHandler too. This method verifies that all dependencies are met, and\n   * throws if not.\n   **/\n  #verifyHandlers(providedHandlers: Partial<Handlers.Types.Handlers>): void {\n    // Tiny optimisation: if the amount of provided handlers matches the amount\n    // of handlers in the Handlers.ModelHandlers object, that means that the\n    // user has passed in every handler we have. So therefore they cannot have\n    // missed any, and there is no need to iterate through the handlers and\n    // check the dependencies.\n    if (Object.keys(providedHandlers).length === Object.keys(Handlers.ModelHandlers).length) {\n      return;\n    }\n    const requiredHandlerKeys = new Set<Handlers.Types.HandlerName>();\n    for (const [handlerName, handler] of Object.entries(providedHandlers)) {\n      requiredHandlerKeys.add(handlerName as Handlers.Types.HandlerName);\n      const deps = 'deps' in handler ? handler.deps() : [];\n      for (const depName of deps) {\n        requiredHandlerKeys.add(depName);\n      }\n    }\n\n    const providedHandlerKeys = new Set(Object.keys(providedHandlers));\n    // We always force the Meta handler to be enabled when creating the\n    // Processor, so if it is missing from the set the user gave us that is OK,\n    // as we will have enabled it anyway.\n    requiredHandlerKeys.delete('Meta');\n\n    for (const requiredKey of requiredHandlerKeys) {\n      if (!providedHandlerKeys.has(requiredKey)) {\n        throw new Error(`Required handler ${requiredKey} not provided.`);\n      }\n    }\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#data = null;\n    this.#insights = null;\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.Events.Event[], options: Types.Configuration.ParseOptions): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);\n    }\n\n    if (typeof options.isCPUProfile === 'undefined' && options.metadata) {\n      options.isCPUProfile = options.metadata.dataOrigin === Types.File.DataOrigin.CPU_PROFILE;\n    }\n\n    options.logger?.start('total');\n    try {\n      this.#status = Status.PARSING;\n      options.logger?.start('parse');\n      await this.#computeParsedTrace(traceEvents, options);\n      options.logger?.end('parse');\n      if (this.#data && !options.isCPUProfile) {  // We do not calculate insights for CPU Profiles.\n        options.logger?.start('insights');\n        this.#computeInsights(this.#data, traceEvents, options);\n        options.logger?.end('insights');\n      }\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    } finally {\n      options.logger?.end('total');\n    }\n  }\n\n  /**\n   * Run all the handlers and set the result to `#data`.\n   */\n  async #computeParsedTrace(traceEvents: readonly Types.Events.Event[], options: Types.Configuration.ParseOptions):\n      Promise<void> {\n    /**\n     * We want to yield regularly to maintain responsiveness. If we yield too often, we're wasting idle time.\n     * We could do this by checking `performance.now()` regularly, but it's an expensive call in such a hot loop.\n     * `eventsPerChunk` is an approximated proxy metric.\n     * But how big a chunk? We're aiming for long tasks that are no smaller than 100ms and not bigger than 200ms.\n     * It's CPU dependent, so it should be calibrated on oldish hardware.\n     * Illustration of a previous change to `eventsPerChunk`: https://imgur.com/wzp8BnR\n     */\n    const eventsPerChunk = 50_000;\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).entries()];\n\n    // Reset.\n    for (const [, handler] of sortedHandlers) {\n      handler.reset();\n    }\n\n    options.logger?.start('parse:handleEvent');\n\n    // Handle each event.\n    for (let i = 0; i < traceEvents.length; ++i) {\n      // Every so often we take a break just to render.\n      if (i % eventsPerChunk === 0 && i) {\n        // Take the opportunity to provide status update events.\n        const percent = calculateProgress(i / traceEvents.length, ProgressPhase.HANDLE_EVENT);\n        this.dispatchEvent(new TraceParseProgressEvent({percent}));\n        // TODO(paulirish): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n      const event = traceEvents[i];\n      for (let j = 0; j < sortedHandlers.length; ++j) {\n        const [, handler] = sortedHandlers[j];\n        handler.handleEvent(event);\n      }\n    }\n\n    options.logger?.end('parse:handleEvent');\n\n    // Finalize.\n    const finalizeOptions: Handlers.Types.FinalizeOptions = {\n      ...options,\n      allTraceEvents: traceEvents,\n    };\n    for (let i = 0; i < sortedHandlers.length; i++) {\n      const [name, handler] = sortedHandlers[i];\n      if (handler.finalize) {\n        options.logger?.start(`parse:${name}:finalize`);\n        // Yield to the UI because finalize() calls can be expensive\n        // TODO(jacktfranklin): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n        await handler.finalize(finalizeOptions);\n        options.logger?.end(`parse:${name}:finalize`);\n      }\n      const percent = calculateProgress(i / sortedHandlers.length, ProgressPhase.FINALIZE);\n      this.dispatchEvent(new TraceParseProgressEvent({percent}));\n    }\n\n    options.logger?.start('parse:handler.data()');\n    const parsedTrace = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      Object.assign(parsedTrace, {[name]: handler.data()});\n    }\n    options.logger?.end('parse:handler.data()');\n\n    this.dispatchEvent(new TraceParseProgressEvent({percent: ProgressPhase.CLONE}));\n\n    this.#data = parsedTrace as Handlers.Types.HandlerData;\n  }\n\n  get data(): Handlers.Types.HandlerData|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    return this.#data;\n  }\n\n  get insights(): Insights.Types.TraceInsightSets|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    return this.#insights;\n  }\n\n  #createLanternContext(\n      data: Handlers.Types.HandlerData, traceEvents: readonly Types.Events.Event[], frameId: string,\n      navigationId: string, options: Types.Configuration.ParseOptions): Insights.Types.LanternContext|undefined {\n    // Check for required handlers.\n    if (!data.NetworkRequests || !data.Workers || !data.PageLoadMetrics) {\n      return;\n    }\n    if (!data.NetworkRequests.byTime.length) {\n      throw new Lantern.Core.LanternError('No network requests found in trace');\n    }\n\n    const navStarts = data.Meta.navigationsByFrameId.get(frameId);\n    const navStartIndex = navStarts?.findIndex(n => n.args.data?.navigationId === navigationId);\n    if (!navStarts || navStartIndex === undefined || navStartIndex === -1) {\n      throw new Lantern.Core.LanternError('Could not find navigation start');\n    }\n\n    const startTime = navStarts[navStartIndex].ts;\n    const endTime = navStartIndex + 1 < navStarts.length ? navStarts[navStartIndex + 1].ts : Number.POSITIVE_INFINITY;\n    const boundedTraceEvents = traceEvents.filter(e => e.ts >= startTime && e.ts < endTime);\n\n    // Lantern.Types.TraceEvent and Types.Events.Event represent the same\n    // object - a trace event - but one is more flexible than the other. It should be safe to cast between them.\n    const trace: Lantern.Types.Trace = {\n      traceEvents: boundedTraceEvents as unknown as Lantern.Types.TraceEvent[],\n    };\n\n    const requests = LanternComputationData.createNetworkRequests(trace, data, startTime, endTime);\n    const graph = LanternComputationData.createGraph(requests, trace, data);\n    const processedNavigation = LanternComputationData.createProcessedNavigation(data, frameId, navigationId);\n\n    const networkAnalysis = Lantern.Core.NetworkAnalyzer.analyze(requests);\n    if (!networkAnalysis) {\n      return;\n    }\n\n    const lanternSettings: Lantern.Types.Simulation.Settings = {\n      // TODO(crbug.com/372674229): if devtools throttling was on, does this network analysis capture\n      // that? Do we need to set 'devtools' throttlingMethod?\n      networkAnalysis,\n      throttlingMethod: 'provided',\n      ...options.lanternSettings,\n    };\n    const simulator: Lantern.Simulation.Simulator<Types.Events.SyntheticNetworkRequest> =\n        Lantern.Simulation.Simulator.createSimulator(lanternSettings);\n\n    const computeData = {graph, simulator, processedNavigation};\n    const fcpResult = Lantern.Metrics.FirstContentfulPaint.compute(computeData);\n    const lcpResult = Lantern.Metrics.LargestContentfulPaint.compute(computeData, {fcpResult});\n    const interactiveResult = Lantern.Metrics.Interactive.compute(computeData, {lcpResult});\n    const tbtResult = Lantern.Metrics.TotalBlockingTime.compute(computeData, {fcpResult, interactiveResult});\n    const metrics = {\n      firstContentfulPaint: fcpResult,\n      interactive: interactiveResult,\n      largestContentfulPaint: lcpResult,\n      totalBlockingTime: tbtResult,\n    };\n\n    return {requests, graph, simulator, metrics};\n  }\n\n  /**\n   * Sort the insight models based on the impact of each insight's estimated savings, additionally weighted by the\n   * worst metrics according to field data (if present).\n   */\n  sortInsightSet(insightSet: Insights.Types.InsightSet, metadata: Types.File.MetaData|null): void {\n    // The initial order of the insights is alphabetical, based on `front_end/models/trace/insights/Models.ts`.\n    // The order here provides a baseline that groups insights in a more logical way.\n    const baselineOrder: Record<keyof Insights.Types.InsightModels, null> = {\n      INPBreakdown: null,\n      LCPBreakdown: null,\n      LCPDiscovery: null,\n      CLSCulprits: null,\n      RenderBlocking: null,\n      NetworkDependencyTree: null,\n      ImageDelivery: null,\n      DocumentLatency: null,\n      FontDisplay: null,\n      Viewport: null,\n      DOMSize: null,\n      ThirdParties: null,\n      DuplicatedJavaScript: null,\n      SlowCSSSelector: null,\n      ForcedReflow: null,\n      Cache: null,\n      ModernHTTP: null,\n      LegacyJavaScript: null,\n    };\n\n    // Determine the weights for each metric based on field data, utilizing the same scoring curve that Lighthouse uses.\n    const weights = Insights.Common.calculateMetricWeightsForSorting(insightSet, metadata);\n\n    // Normalize the estimated savings to a single number, weighted by its relative impact\n    // to the page experience based on the same scoring curve that Lighthouse uses.\n    const observedLcpMicro = Insights.Common.getLCP(insightSet)?.value;\n    const observedLcp = observedLcpMicro ? Helpers.Timing.microToMilli(observedLcpMicro) : Types.Timing.Milli(0);\n    const observedCls = Insights.Common.getCLS(insightSet).value;\n\n    // INP is special - if users did not interact with the page, we'll have no INP, but we should still\n    // be able to prioritize insights based on this metric. When we observe no interaction, instead use\n    // a default value for the baseline INP.\n    const observedInpMicro = Insights.Common.getINP(insightSet)?.value;\n    const observedInp = observedInpMicro ? Helpers.Timing.microToMilli(observedInpMicro) : Types.Timing.Milli(200);\n\n    const observedLcpScore =\n        observedLcp !== undefined ? Insights.Common.evaluateLCPMetricScore(observedLcp) : undefined;\n    const observedInpScore = Insights.Common.evaluateINPMetricScore(observedInp);\n    const observedClsScore = Insights.Common.evaluateCLSMetricScore(observedCls);\n\n    const insightToSortingRank = new Map<string, number>();\n    for (const [name, model] of Object.entries(insightSet.model)) {\n      const lcp = model.metricSavings?.LCP ?? 0;\n      const inp = model.metricSavings?.INP ?? 0;\n      const cls = model.metricSavings?.CLS ?? 0;\n\n      const lcpPostSavings =\n          observedLcp !== undefined ? Math.max(0, observedLcp - lcp) as Types.Timing.Milli : undefined;\n      const inpPostSavings = Math.max(0, observedInp - inp) as Types.Timing.Milli;\n      const clsPostSavings = Math.max(0, observedCls - cls);\n\n      let score = 0;\n      if (weights.lcp && lcp && observedLcpScore !== undefined && lcpPostSavings !== undefined) {\n        score += weights.lcp * (Insights.Common.evaluateLCPMetricScore(lcpPostSavings) - observedLcpScore);\n      }\n      if (weights.inp && inp && observedInpScore !== undefined) {\n        score += weights.inp * (Insights.Common.evaluateINPMetricScore(inpPostSavings) - observedInpScore);\n      }\n      if (weights.cls && cls && observedClsScore !== undefined) {\n        score += weights.cls * (Insights.Common.evaluateCLSMetricScore(clsPostSavings) - observedClsScore);\n      }\n\n      insightToSortingRank.set(name, score);\n    }\n\n    // Now perform the actual sorting.\n    const baselineOrderKeys = Object.keys(baselineOrder);\n    const orderedKeys = Object.keys(insightSet.model);\n    orderedKeys.sort((a, b) => {\n      const a1 = baselineOrderKeys.indexOf(a);\n      const b1 = baselineOrderKeys.indexOf(b);\n      if (a1 >= 0 && b1 >= 0) {\n        return a1 - b1;\n      }\n      if (a1 >= 0) {\n        return -1;\n      }\n      if (b1 >= 0) {\n        return 1;\n      }\n      return 0;\n    });\n    orderedKeys.sort((a, b) => (insightToSortingRank.get(b) ?? 0) - (insightToSortingRank.get(a) ?? 0));\n\n    const newModel = {} as Insights.Types.InsightModels;\n    for (const key of orderedKeys as Array<keyof Insights.Types.InsightModels>) {\n      const model = insightSet.model[key];\n      // @ts-expect-error Maybe someday typescript will be powerful enough to handle this.\n      newModel[key] = model;\n    }\n    insightSet.model = newModel;\n  }\n\n  #computeInsightSet(data: Handlers.Types.HandlerData, context: Insights.Types.InsightSetContext): void {\n    const logger = context.options.logger;\n\n    let id, urlString, navigation;\n    if (context.navigation) {\n      id = context.navigationId;\n      urlString = data.Meta.finalDisplayUrlByNavigationId.get(context.navigationId) ?? data.Meta.mainFrameURL;\n      navigation = context.navigation;\n    } else {\n      id = Types.Events.NO_NAVIGATION;\n      urlString = data.Meta.finalDisplayUrlByNavigationId.get('') ?? data.Meta.mainFrameURL;\n    }\n\n    const insightSetModel = {} as Insights.Types.InsightSet['model'];\n\n    for (const [name, insight] of Object.entries(TraceProcessor.getInsightRunners())) {\n      let model: Insights.Types.InsightModel|Error;\n      try {\n        logger?.start(`insights:${name}`);\n        model = insight.generateInsight(data, context);\n        model.frameId = context.frameId;\n        const navId = context.navigation?.args.data?.navigationId;\n        if (navId) {\n          model.navigationId = navId;\n        }\n        model.createOverlays = () => {\n          // @ts-expect-error: model is a union of all possible insight model types.\n          return insight.createOverlays(model);\n        };\n      } catch (err) {\n        model = err;\n      } finally {\n        logger?.end(`insights:${name}`);\n      }\n      Object.assign(insightSetModel, {[name]: model});\n    }\n\n    // We may choose to exclude the insightSet if it's trivial. Trivial means:\n    //   1. There's no navigation (it's an initial trace period)\n    //   2. The duration is short.\n    //   3. All the insights are passing (aka no insights to show the user)\n    //   4. It has no metrics to report (apart from a CLS of 0, which is default)\n    // Generally, these cases are the short time ranges before a page reload starts.\n    const isNavigation = id === Types.Events.NO_NAVIGATION;\n    const trivialThreshold = Helpers.Timing.milliToMicro(Types.Timing.Milli(5000));\n    const everyInsightPasses = Object.values(insightSetModel)\n                                   .filter(model => !(model instanceof Error))\n                                   .every(model => model.state === 'pass');\n\n    const noLcp = !insightSetModel.LCPBreakdown.lcpEvent;\n    const noInp = !insightSetModel.INPBreakdown.longestInteractionEvent;\n    const noLayoutShifts = insightSetModel.CLSCulprits.shifts?.size === 0;\n    const shouldExclude = isNavigation && context.bounds.range < trivialThreshold && everyInsightPasses && noLcp &&\n        noInp && noLayoutShifts;\n    if (shouldExclude) {\n      return;\n    }\n\n    let url;\n    try {\n      url = new URL(urlString);\n    } catch {\n      // We're pretty sure this only happens for our test fixture: missing-url.json.gz. Shouldn't\n      // happen for real traces.\n      return;\n    }\n\n    const insightSet: Insights.Types.InsightSet = {\n      id,\n      url,\n      navigation,\n      frameId: context.frameId,\n      bounds: context.bounds,\n      model: insightSetModel,\n    };\n    if (!this.#insights) {\n      this.#insights = new Map();\n    }\n    this.#insights.set(insightSet.id, insightSet);\n    this.sortInsightSet(insightSet, context.options.metadata ?? null);\n  }\n\n  /**\n   * Run all the insights and set the result to `#insights`.\n   */\n  #computeInsights(\n      data: Handlers.Types.HandlerData, traceEvents: readonly Types.Events.Event[],\n      options: Types.Configuration.ParseOptions): void {\n    // This insights map will be populated by the helper methods.\n    this.#insights = new Map();\n\n    // Filter main frame navigations to those that have the necessary data (frameId and navigationId).\n    // TODO(cjamcl): Does this filtering makes the \"use the next nav as the end time\" logic potentially broken? Are navs without nav id or frame even real?\n    const navigations = data.Meta.mainFrameNavigations.filter(\n        navigation => navigation.args.frame && navigation.args.data?.navigationId);\n\n    this.#computeInsightsForInitialTracePeriod(data, navigations, options);\n\n    for (const [index, navigation] of navigations.entries()) {\n      const min = navigation.ts;\n      // Use trace end for the last navigation, otherwise use the start of the next navigation.\n      const max = index + 1 < navigations.length ? navigations[index + 1].ts : data.Meta.traceBounds.max;\n      const bounds = Helpers.Timing.traceWindowFromMicroSeconds(min, max);\n      this.#computeInsightsForNavigation(navigation, bounds, data, traceEvents, options);\n    }\n  }\n\n  /**\n   * Computes insights for the period before the first navigation, or for the entire trace if no navigations exist.\n   */\n  #computeInsightsForInitialTracePeriod(\n      data: Handlers.Types.HandlerData, navigations: readonly Types.Events.NavigationStart[],\n      options: Types.Configuration.ParseOptions): void {\n    // Determine bounds: Use the period before the first navigation if navigations exist, otherwise use the entire trace bounds.\n    const bounds = navigations.length > 0 ?\n        Helpers.Timing.traceWindowFromMicroSeconds(data.Meta.traceBounds.min, navigations[0].ts) :\n        data.Meta.traceBounds;\n\n    const context: Insights.Types.InsightSetContext = {\n      options,\n      bounds,\n      frameId: data.Meta.mainFrameId,\n      // No navigation or lantern context applies to this initial/no-navigation period.\n    };\n    this.#computeInsightSet(data, context);\n  }\n\n  /**\n   * Computes insights for a specific navigation event.\n   */\n  #computeInsightsForNavigation(\n      navigation: Types.Events.NavigationStart, bounds: Types.Timing.TraceWindowMicro, data: Handlers.Types.HandlerData,\n      traceEvents: readonly Types.Events.Event[], options: Types.Configuration.ParseOptions): void {\n    const frameId = navigation.args.frame;\n    // Guaranteed by the filter in #computeInsights\n    const navigationId = navigation.args.data?.navigationId as string;\n\n    // The lantern sub-context is optional on InsightSetContext, so not setting it is OK.\n    // This is also a hedge against an error inside Lantern resulting in breaking the entire performance panel.\n    // Additionally, many trace fixtures are too old to be processed by Lantern.\n    let lantern: Insights.Types.LanternContext|undefined;\n    try {\n      options.logger?.start('insights:createLanternContext');\n      lantern = this.#createLanternContext(data, traceEvents, frameId, navigationId, options);\n    } catch (e) {\n      // Handle Lantern errors gracefully\n      // Don't allow an error in constructing the Lantern graphs to break the rest of the trace processor.\n      // Log unexpected errors, but suppress anything that occurs from a trace being too old.\n      // Otherwise tests using old fixtures become way too noisy.\n      const expectedErrors = [\n        'mainDocumentRequest not found',\n        'missing metric scores for main frame',\n        'missing metric: FCP',\n        'missing metric: LCP',\n        'No network requests found in trace',\n        'Trace is too old',\n      ];\n      if (!(e instanceof Lantern.Core.LanternError)) {\n        // If this wasn't a managed LanternError, the stack trace is likely needed for debugging.\n        console.error(e);\n      } else if (!expectedErrors.some(err => e.message === err)) {\n        // To reduce noise from tests, only print errors that are not expected to occur because a trace is\n        // too old (for which there is no single check).\n        console.error(e);\n      }\n    } finally {\n      options.logger?.end('insights:createLanternContext');\n    }\n\n    const context: Insights.Types.InsightSetContext = {\n      options,\n      bounds,\n      frameId,\n      navigation,\n      navigationId,\n      lantern,\n    };\n    this.#computeInsightSet(data, context);\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event handler whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(traceHandlers: Partial<Record<Handlers.Types.HandlerName, Handlers.Types.Handler>>):\n    Map<Handlers.Types.HandlerName, Handlers.Types.Handler> {\n  const sortedMap = new Map<Handlers.Types.HandlerName, Handlers.Types.Handler>();\n  const visited = new Set<Handlers.Types.HandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.HandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.HandlerName);\n  }\n  return sortedMap;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport type {ParsedTrace} from './ModelImpl.js';\nimport {getEventStyle} from './Styles.js';\nimport * as Types from './types/types.js';\n\nconst UIStrings = {\n  /**\n   * @description Text shown for an entry in the flame chart that has no explicit name.\n   */\n  anonymous: '(anonymous)',\n  /**\n   * @description Text used to show an EventDispatch event which has a type associated with it\n   * @example {click} PH1\n   */\n  eventDispatchS: 'Event: {PH1}',\n  /**\n   * @description Text shown for an entry in the flame chart that represents a frame.\n   */\n  frame: 'Frame',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   */\n  wsConnectionOpened: 'WebSocket opened',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   * @example {ws://example.com} PH1\n   */\n  wsConnectionOpenedWithUrl: 'WebSocket opened: {PH1}',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   */\n  wsConnectionClosed: 'WebSocket closed',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   */\n  layoutShift: 'Layout shift',\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('models/trace/Name.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\n/**\n * Calculates the display name for a given entry.\n * @param parsedTrace If the trace data is provided\n * as the second argument it can be used to find source map resolved names for\n * profile calls.\n * Use this function to customize the user visible name for an entry. If no\n * custom name is found, we will fallback to the `name` property in the trace\n * entry.\n */\nexport function forEntry(\n    entry: Types.Events.Event,\n    parsedTrace?: ParsedTrace,\n    ): string {\n  if (Types.Events.isProfileCall(entry)) {\n    if (parsedTrace) {\n      const potentialCallName =\n          Handlers.ModelHandlers.Samples.getProfileCallFunctionName(parsedTrace.data.Samples, entry);\n      // We need this extra check because the call name could be the empty\n      // string. If it is, we want to fallback.\n      if (potentialCallName) {\n        return potentialCallName;\n      }\n    }\n    return entry.callFrame.functionName || i18nString(UIStrings.anonymous);\n  }\n\n  if (Types.Events.isLegacyTimelineFrame(entry)) {\n    return i18n.i18n.lockedString(UIStrings.frame);\n  }\n\n  if (Types.Events.isDispatch(entry)) {\n    // EventDispatch represent user actions such as clicks, so in this case\n    // rather than show the event title (which is always just \"Event\"), we\n    // add the type (\"click\") to help the user understand the event.\n    return i18nString(UIStrings.eventDispatchS, {PH1: entry.args.data.type});\n  }\n  if (Types.Events.isSyntheticNetworkRequest(entry)) {\n    const parsedURL = new Common.ParsedURL.ParsedURL(entry.args.data.url);\n    const text =\n        parsedURL.isValid ? `${parsedURL.displayName} (${parsedURL.host})` : entry.args.data.url || 'Network request';\n    return text;\n  }\n\n  if (Types.Events.isWebSocketCreate(entry)) {\n    if (entry.args.data.url) {\n      return i18nString(UIStrings.wsConnectionOpenedWithUrl, {PH1: entry.args.data.url});\n    }\n\n    return i18nString(UIStrings.wsConnectionOpened);\n  }\n\n  if (Types.Events.isWebSocketDestroy(entry)) {\n    return i18nString(UIStrings.wsConnectionClosed);\n  }\n\n  if (Types.Events.isSyntheticInteraction(entry)) {\n    return nameForInteractionEvent(entry);\n  }\n\n  if (Types.Events.isSyntheticLayoutShift(entry)) {\n    return i18nString(UIStrings.layoutShift);\n  }\n\n  if (Types.Events.isSyntheticAnimation(entry) && entry.args.data.beginEvent.args.data.displayName) {\n    return entry.args.data.beginEvent.args.data.displayName;\n  }\n\n  const eventStyleCustomName = getEventStyle(entry.name as Types.Events.Name)?.title;\n\n  return eventStyleCustomName || entry.name;\n}\n\nfunction nameForInteractionEvent(event: Types.Events.SyntheticInteractionPair): string {\n  const category = Handlers.ModelHandlers.UserInteractions.categoryOfInteraction(event);\n  // Because we hide nested interactions, we do not want to show the\n  // specific type of the interaction that was not hidden, so instead we\n  // show just the category of that interaction.\n  if (category === 'OTHER') {\n    return 'Other';\n  }\n  if (category === 'KEYBOARD') {\n    return 'Keyboard';\n  }\n  if (category === 'POINTER') {\n    return 'Pointer';\n  }\n  return event.type;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as Platform from '../../core/platform/platform.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport * as Types from './types/types.js';\n\nconst UIStrings = {\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate time spent to load resources\n   */\n  loading: 'Loading',\n  /**\n   * @description Text in Timeline for the Experience title\n   */\n  experience: 'Experience',\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate time spent in script execution\n   */\n  scripting: 'Scripting',\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate time spent in rendering the web page\n   */\n  rendering: 'Rendering',\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate time spent to visually represent the web page\n   */\n  painting: 'Painting',\n  /**\n   * @description Event category in the Performance panel for time spent in the GPU\n   */\n  gpu: 'GPU',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  async: 'Async',\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate time spent in the rest of the system\n   */\n  system: 'System',\n  /**\n   * @description Category in the Summary view of the Performance panel to indicate idle time\n   */\n  idle: 'Idle',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  task: 'Task',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  consoleTaskRun: 'Run console task',\n  /**\n   * @description Text for other types of items\n   */\n  other: 'Other',\n  /**\n   * @description Text that refers to the animation of the web page\n   */\n  animation: 'Animation',\n  /**\n   * @description Text that refers to some events\n   */\n  event: 'Event',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  requestMainThreadFrame: 'Request main thread frame',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  frameStart: 'Frame start',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  onMessage: 'On message',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  schedulePostMessage: 'Schedule postMessage',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  messaging: 'Messaging',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  frameStartMainThread: 'Frame start (main thread)',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  drawFrame: 'Draw frame',\n  /**\n   * @description Noun for an event in the Performance panel. This marks time\n   * spent in an operation that only happens when the profiler is active.\n   */\n  profilingOverhead: 'Profiling overhead',\n  /**\n   * @description The process the browser uses to determine a target element for a\n   *pointer event. Typically, this is determined by considering the pointer's\n   *location and also the visual layout of elements on the screen.\n   */\n  hitTest: 'Hit test',\n  /**\n   * @description Noun for an event in the Performance panel. The browser has decided\n   *that the styles for some elements need to be recalculated and scheduled that\n   *recalculation process at some time in the future.\n   */\n  scheduleStyleRecalculation: 'Schedule style recalculation',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  recalculateStyle: 'Recalculate style',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  invalidateLayout: 'Invalidate Layout',\n  /**\n   * @description Noun for an event in the Performance panel. Layerize is a step\n   *where we calculate which layers to create.\n   */\n  layerize: 'Layerize',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  layout: 'Layout',\n  /**\n   * @description Noun for an event in the Performance panel. Paint setup is a\n   *step before the 'Paint' event. A paint event is when the browser draws pixels\n   *to the screen. This step is the setup beforehand.\n   */\n  paintSetup: 'Paint setup',\n  /**\n   * @description Noun for a paint event in the Performance panel, where an image\n   *was being painted. A paint event is when the browser draws pixels to the\n   *screen, in this case specifically for an image in a website.\n   */\n  paintImage: 'Paint image',\n  /**\n   * @description Noun for an event in the Performance panel. Pre-paint is a\n   *step before the 'Paint' event. A paint event is when the browser records the\n   *instructions for drawing the page. This step is the setup beforehand.\n   */\n  prePaint: 'Pre-paint',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  updateLayer: 'Update layer',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  updateLayerTree: 'Update layer tree',\n  /**\n   * @description Noun for a paint event in the Performance panel. A paint event is when the browser draws pixels to the screen.\n   */\n  paint: 'Paint',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  rasterizePaint: 'Rasterize paint',\n  /**\n   * @description The action to scroll\n   */\n  scroll: 'Scroll',\n  /**\n   * @description Noun for an event in the Performance panel. Commit is a step\n   *where we send (also known as \"commit\") layers to the compositor thread. This\n   *step follows the \"Layerize\" step which is what calculates which layers to\n   *create.\n   */\n  commit: 'Commit',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  compositeLayers: 'Composite layers',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  computeIntersections: 'Compute intersections',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  parseHtml: 'Parse HTML',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  parseStylesheet: 'Parse stylesheet',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  installTimer: 'Install timer',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  removeTimer: 'Remove timer',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  timerFired: 'Timer fired',\n  /**\n   * @description Text for an event. Shown in the timeline in the Performance panel.\n   * XHR refers to XmlHttpRequest, a Web API. This particular Web API has a property\n   * named 'readyState' (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState). When\n   * the 'readyState' property changes the text is shown.\n   */\n  xhrReadyStateChange: '`XHR` `readyState` change',\n  /**\n   * @description Text for an event. Shown in the timeline in the Performance panel.\n   * XHR refers to XmlHttpRequest, a Web API. (see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n   * The text is shown when a XmlHttpRequest load event happens on the inspected page.\n   */\n  xhrLoad: '`XHR` load',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  compileScript: 'Compile script',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  cacheScript: 'Cache script code',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  compileCode: 'Compile code',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  optimizeCode: 'Optimize code',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  evaluateScript: 'Evaluate script',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  compileModule: 'Compile module',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  cacheModule: 'Cache module code',\n  /**\n   * @description Text for an event. Shown in the timeline in the Performance panel.\n   * \"Module\" refers to JavaScript modules: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\n   * JavaScript modules are a way to organize JavaScript code.\n   * \"Evaluate\" is the phase when the JavaScript code of a module is executed.\n   */\n  evaluateModule: 'Evaluate module',\n  /**\n   * @description Noun indicating that a compile task (type: streaming) happened.\n   */\n  streamingCompileTask: 'Streaming compile task',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  waitingForNetwork: 'Waiting for network',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  parseAndCompile: 'Parse and compile',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel.\n   * \"Code Cache\" refers to JavaScript bytecode cache: https://v8.dev/blog/code-caching-for-devs\n   * \"Deserialize\" refers to the process of reading the code cache.\n   */\n  deserializeCodeCache: 'Deserialize code cache',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  streamingWasmResponse: 'Streaming Wasm response',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  compiledWasmModule: 'Compiled Wasm module',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  cachedWasmModule: 'Cached Wasm module',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  wasmModuleCacheHit: 'Wasm module cache hit',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  wasmModuleCacheInvalid: 'Wasm module cache invalid',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  frameStartedLoading: 'Frame started loading',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  onloadEvent: 'Onload event',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  domcontentloadedEvent: 'DOMContentLoaded event',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  firstPaint: 'First Paint',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  firstContentfulPaint: 'First Contentful Paint',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  largestContentfulPaint: 'Largest Contentful Paint',\n  /**\n   * @description Text for timestamps of items\n   */\n  timestamp: 'Timestamp',\n  /**\n   * @description Noun for a 'time' event that happens in the Console (a tool in\n   * DevTools). The user can trigger console time events from their code, and\n   * they will show up in the Performance panel. Time events are used to measure\n   * the duration of something, e.g. the user will emit two time events at the\n   * start and end of some interesting task.\n   */\n  consoleTime: 'Console time',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  userTiming: 'User timing',\n  /**\n   * @description Name for an event shown in the Performance panel. When a network\n   * request is about to be sent by the browser, the time is recorded and DevTools\n   * is notified that a network request will be sent momentarily.\n   */\n  willSendRequest: 'Will send request',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  sendRequest: 'Send request',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  receiveResponse: 'Receive response',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  finishLoading: 'Finish loading',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  receiveData: 'Receive data',\n  /**\n   * @description Event category in the Performance panel for time spent to execute microtasks in JavaScript\n   */\n  runMicrotasks: 'Run microtasks',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  functionCall: 'Function call',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  gcEvent: 'GC event',\n  /**\n   * @description Event category in the Performance panel for time spent to perform a full Garbage Collection pass\n   */\n  majorGc: 'Major GC',\n  /**\n   * @description Event category in the Performance panel for time spent to perform a quick Garbage Collection pass\n   */\n  minorGc: 'Minor GC',\n  /**\n   * @description Text for the request animation frame event\n   */\n  requestAnimationFrame: 'Request animation frame',\n  /**\n   * @description Text to cancel the animation frame\n   */\n  cancelAnimationFrame: 'Cancel animation frame',\n  /**\n   * @description Text for the event that an animation frame is fired\n   */\n  animationFrameFired: 'Animation frame fired',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  requestIdleCallback: 'Request idle callback',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  cancelIdleCallback: 'Cancel idle callback',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  fireIdleCallback: 'Fire idle callback',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  createWebsocket: 'Create WebSocket',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  sendWebsocketHandshake: 'Send WebSocket handshake',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  receiveWebsocketHandshake: 'Receive WebSocket handshake',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   */\n  wsMessageReceived: 'Receive WebSocket message',\n  /**\n   * @description Text in Timeline Flame Chart Data Provider of the Performance panel\n   */\n  wsMessageSent: 'Send WebSocket message',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  destroyWebsocket: 'Destroy WebSocket',\n  /**\n   * @description Event category in the Performance panel for time spent in the embedder of the WebView\n   */\n  embedderCallback: 'Embedder callback',\n  /**\n   * @description Event category in the Performance panel for time spent decoding an image\n   */\n  imageDecode: 'Image decode',\n  /**\n   * @description Event category in the Performance panel for time spent to perform Garbage Collection for the Document Object Model\n   */\n  domGc: 'DOM GC',\n  /**\n   * @description Event category in the Performance panel for time spent to perform Garbage Collection for C++: https://chromium.googlesource.com/v8/v8/+/main/include/cppgc/README.md\n   */\n  cppGc: 'CPP GC',\n  /**\n   * @description Event category in the Performance panel for time spent to perform encryption\n   */\n  encrypt: 'Encrypt',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  encryptReply: 'Encrypt reply',\n  /**\n   * @description Event category in the Performance panel for time spent to perform decryption\n   */\n  decrypt: 'Decrypt',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  decryptReply: 'Decrypt reply',\n  /**\n   * @description Noun phrase meaning 'the browser was preparing the digest'.\n   * Digest: https://developer.mozilla.org/en-US/docs/Glossary/Digest\n   */\n  digest: 'Digest',\n  /**\n   * @description Noun phrase meaning 'the browser was preparing the digest\n   *reply'. Digest: https://developer.mozilla.org/en-US/docs/Glossary/Digest\n   */\n  digestReply: 'Digest reply',\n  /**\n   * @description The 'sign' stage of a web crypto event. Shown when displaying what the website was doing at a particular point in time.\n   */\n  sign: 'Sign',\n  /**\n   * @description Noun phrase for an event of the Web Crypto API. The event is recorded when the signing process is concluded.\n   * Signature: https://developer.mozilla.org/en-US/docs/Glossary/Signature/Security\n   */\n  signReply: 'Sign reply',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  verify: 'Verify',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  verifyReply: 'Verify reply',\n  /**\n   * @description Text in Timeline UIUtils of the Performance panel\n   */\n  asyncTask: 'Async task',\n  /**\n   * @description Text in Timeline for Layout Shift records\n   */\n  layoutShift: 'Layout shift',\n  /**\n   * @description Text in Timeline for Layout Shift records\n   */\n  layoutShiftCluster: 'Layout shift cluster',\n  /**\n   * @description Text in Timeline for an Event Timing record\n   */\n  eventTiming: 'Event timing',\n  /**\n   * @description Event category in the Performance panel for JavaScript nodes in CPUProfile\n   */\n  jsFrame: 'JS frame',\n  /**\n   * @description Text in UIDevtools Utils of the Performance panel\n   */\n  rasterizing: 'Rasterizing',\n  /**\n   * @description Text in UIDevtools Utils of the Performance panel\n   */\n  drawing: 'Drawing',\n  /**\n   * @description Label for an event in the Performance panel indicating that a\n   * callback function has been scheduled to run at a later time using the\n   * postTask API.\n   */\n  schedulePostTaskCallback: 'Schedule postTask',\n  /**\n   * @description Label for an event in the Performance panel indicating that a\n   * callback function that was scheduled to run using the postTask API was\n   * fired (invoked).\n   */\n  runPostTaskCallback: 'Fire postTask',\n  /**\n   * @description Label for an event in the Performance panel indicating that a\n   * callback function that was scheduled to run at a later time using the\n   * postTask API was cancelled, so will no longer run.\n   */\n  abortPostTaskCallback: 'Cancel postTask',\n} as const;\n\nexport enum EventCategory {\n  DRAWING = 'drawing',\n  RASTERIZING = 'rasterizing',\n  LAYOUT = 'layout',\n  LOADING = 'loading',\n  EXPERIENCE = 'experience',\n  SCRIPTING = 'scripting',\n  MESSAGING = 'messaging',\n  RENDERING = 'rendering',\n  PAINTING = 'painting',\n  GPU = 'gpu',\n  ASYNC = 'async',\n  OTHER = 'other',\n  IDLE = 'idle',\n}\n\nlet mainEventCategories: EventCategory[];\n\nconst str_ = i18n.i18n.registerUIStrings('models/trace/Styles.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class TimelineRecordStyle {\n  title: string;\n  category: TimelineCategory;\n  hidden: boolean;\n\n  constructor(title: string, category: TimelineCategory, hidden: boolean|undefined = false) {\n    this.title = title;\n    this.category = category;\n    this.hidden = hidden;\n  }\n}\nexport class TimelineCategory {\n  name: EventCategory;\n  title: Platform.UIString.LocalizedString;\n  visible: boolean;\n  #hidden?: boolean;\n  #cssVariable: `--app-color-${string}`;\n\n  constructor(\n      name: EventCategory, title: Platform.UIString.LocalizedString, visible: boolean,\n      cssVariable: `--app-color-${string}`) {\n    this.name = name;\n    this.title = title;\n    this.visible = visible;\n    this.#cssVariable = cssVariable;\n    this.hidden = false;\n  }\n\n  get hidden(): boolean {\n    return Boolean(this.#hidden);\n  }\n\n  get cssVariable(): string {\n    return this.#cssVariable;\n  }\n\n  getCSSValue(): string {\n    return `var(${this.#cssVariable})`;\n  }\n\n  set hidden(hidden: boolean) {\n    this.#hidden = hidden;\n  }\n}\n\nexport type CategoryPalette = Record<EventCategory, TimelineCategory>;\n\ntype EventStylesMap = Partial<Record<Types.Events.Name, TimelineRecordStyle>>;\n\n/**\n * This object defines the styles for the categories used in the\n * timeline (loading, rendering, scripting, etc.).\n */\nlet categoryStyles: CategoryPalette|null;\n\n/**\n * This map defines the styles for events shown in the panel. This\n * includes its color (which on the event's category, the label it's\n * displayed with and flag to know weather it's visible in the flamechart\n * or not).\n * The thread appenders use this map to determine if an event should be\n * shown in the flame chart. If an event is not in the map, then it\n * won't be shown, but it also won't be shown if it's marked as \"hidden\"\n * in its styles.\n *\n * The map is also used in other places, like the event's details view.\n */\nlet eventStylesMap: EventStylesMap|null;\n\nexport function getEventStyle(eventName: Types.Events.Name): TimelineRecordStyle|undefined {\n  return maybeInitSylesMap()[eventName];\n}\n\nexport function stringIsEventCategory(it: string): it is EventCategory {\n  return (Object.values(EventCategory) as string[]).includes(it);\n}\n\nexport function getCategoryStyles(): CategoryPalette {\n  if (categoryStyles) {\n    return categoryStyles;\n  }\n  categoryStyles = {\n    loading: new TimelineCategory(EventCategory.LOADING, i18nString(UIStrings.loading), true, '--app-color-loading'),\n    experience: new TimelineCategory(\n        EventCategory.EXPERIENCE, i18nString(UIStrings.experience), false, '--app-color-rendering'),\n    messaging:\n        new TimelineCategory(EventCategory.MESSAGING, i18nString(UIStrings.messaging), true, '--app-color-messaging'),\n    scripting:\n        new TimelineCategory(EventCategory.SCRIPTING, i18nString(UIStrings.scripting), true, '--app-color-scripting'),\n    rendering:\n        new TimelineCategory(EventCategory.RENDERING, i18nString(UIStrings.rendering), true, '--app-color-rendering'),\n    painting:\n        new TimelineCategory(EventCategory.PAINTING, i18nString(UIStrings.painting), true, '--app-color-painting'),\n    gpu: new TimelineCategory(EventCategory.GPU, i18nString(UIStrings.gpu), false, '--app-color-painting'),\n    async: new TimelineCategory(EventCategory.ASYNC, i18nString(UIStrings.async), false, '--app-color-async'),\n    other: new TimelineCategory(EventCategory.OTHER, i18nString(UIStrings.system), false, '--app-color-system'),\n    idle: new TimelineCategory(EventCategory.IDLE, i18nString(UIStrings.idle), false, '--app-color-idle'),\n    layout: new TimelineCategory(EventCategory.LAYOUT, i18nString(UIStrings.layout), false, '--app-color-loading'),\n    rasterizing: new TimelineCategory(\n        EventCategory.RASTERIZING, i18nString(UIStrings.rasterizing), false, '--app-color-scripting'),\n    drawing: new TimelineCategory(EventCategory.DRAWING, i18nString(UIStrings.drawing), false, '--app-color-rendering'),\n  };\n  return categoryStyles;\n}\n\nexport function maybeInitSylesMap(): EventStylesMap {\n  if (eventStylesMap) {\n    return eventStylesMap;\n  }\n  const defaultCategoryStyles = getCategoryStyles();\n\n  eventStylesMap = {\n    [Types.Events.Name.RUN_TASK]: new TimelineRecordStyle(i18nString(UIStrings.task), defaultCategoryStyles.other),\n\n    [Types.Events.Name.PROFILE_CALL]:\n        new TimelineRecordStyle(i18nString(UIStrings.jsFrame), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.JS_SAMPLE]:\n        new TimelineRecordStyle(Types.Events.Name.JS_SAMPLE, defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.PROGRAM]: new TimelineRecordStyle(i18nString(UIStrings.other), defaultCategoryStyles.other),\n\n    [Types.Events.Name.START_PROFILING]:\n        new TimelineRecordStyle(i18nString(UIStrings.profilingOverhead), defaultCategoryStyles.other),\n\n    [Types.Events.Name.ANIMATION]:\n        new TimelineRecordStyle(i18nString(UIStrings.animation), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.EVENT_DISPATCH]:\n        new TimelineRecordStyle(i18nString(UIStrings.event), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.REQUEST_MAIN_THREAD_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.requestMainThreadFrame),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.BEGIN_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.frameStart),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.BEGIN_MAIN_THREAD_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.frameStartMainThread),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.DRAW_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.drawFrame),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.HIT_TEST]:\n        new TimelineRecordStyle(i18nString(UIStrings.hitTest), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.SCHEDULE_STYLE_RECALCULATION]: new TimelineRecordStyle(\n        i18nString(UIStrings.scheduleStyleRecalculation),\n        defaultCategoryStyles.rendering,\n        ),\n\n    [Types.Events.Name.RECALC_STYLE]:\n        new TimelineRecordStyle(i18nString(UIStrings.recalculateStyle), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.INVALIDATE_LAYOUT]: new TimelineRecordStyle(\n        i18nString(UIStrings.invalidateLayout),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.LAYERIZE]:\n        new TimelineRecordStyle(i18nString(UIStrings.layerize), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.LAYOUT]: new TimelineRecordStyle(i18nString(UIStrings.layout), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.PAINT_SETUP]:\n        new TimelineRecordStyle(i18nString(UIStrings.paintSetup), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.PAINT_IMAGE]: new TimelineRecordStyle(\n        i18nString(UIStrings.paintImage),\n        defaultCategoryStyles.painting,\n        true,\n        ),\n\n    [Types.Events.Name.UPDATE_LAYER]: new TimelineRecordStyle(\n        i18nString(UIStrings.updateLayer),\n        defaultCategoryStyles.painting,\n        true,\n        ),\n\n    [Types.Events.Name.UPDATE_LAYER_TREE]:\n        new TimelineRecordStyle(i18nString(UIStrings.updateLayerTree), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.PAINT]: new TimelineRecordStyle(i18nString(UIStrings.paint), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.PRE_PAINT]:\n        new TimelineRecordStyle(i18nString(UIStrings.prePaint), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.RASTER_TASK]:\n        new TimelineRecordStyle(i18nString(UIStrings.rasterizePaint), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.SCROLL_LAYER]:\n        new TimelineRecordStyle(i18nString(UIStrings.scroll), defaultCategoryStyles.rendering),\n\n    [Types.Events.Name.COMMIT]: new TimelineRecordStyle(i18nString(UIStrings.commit), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.COMPOSITE_LAYERS]:\n        new TimelineRecordStyle(i18nString(UIStrings.compositeLayers), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.COMPUTE_INTERSECTION]: new TimelineRecordStyle(\n        i18nString(UIStrings.computeIntersections),\n        defaultCategoryStyles.rendering,\n        ),\n\n    [Types.Events.Name.PARSE_HTML]:\n        new TimelineRecordStyle(i18nString(UIStrings.parseHtml), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.PARSE_AUTHOR_STYLE_SHEET]:\n        new TimelineRecordStyle(i18nString(UIStrings.parseStylesheet), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.TIMER_INSTALL]:\n        new TimelineRecordStyle(i18nString(UIStrings.installTimer), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.TIMER_REMOVE]:\n        new TimelineRecordStyle(i18nString(UIStrings.removeTimer), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.TIMER_FIRE]:\n        new TimelineRecordStyle(i18nString(UIStrings.timerFired), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.XHR_READY_STATE_CHANGED]: new TimelineRecordStyle(\n        i18nString(UIStrings.xhrReadyStateChange),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.XHR_LOAD]:\n        new TimelineRecordStyle(i18nString(UIStrings.xhrLoad), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.COMPILE]:\n        new TimelineRecordStyle(i18nString(UIStrings.compileScript), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CACHE_SCRIPT]:\n        new TimelineRecordStyle(i18nString(UIStrings.cacheScript), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.COMPILE_CODE]:\n        new TimelineRecordStyle(i18nString(UIStrings.compileCode), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.OPTIMIZE_CODE]:\n        new TimelineRecordStyle(i18nString(UIStrings.optimizeCode), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.EVALUATE_SCRIPT]:\n        new TimelineRecordStyle(i18nString(UIStrings.evaluateScript), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.COMPILE_MODULE]:\n        new TimelineRecordStyle(i18nString(UIStrings.compileModule), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CACHE_MODULE]:\n        new TimelineRecordStyle(i18nString(UIStrings.cacheModule), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.EVALUATE_MODULE]:\n        new TimelineRecordStyle(i18nString(UIStrings.evaluateModule), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.STREAMING_COMPILE_SCRIPT]:\n        new TimelineRecordStyle(i18nString(UIStrings.streamingCompileTask), defaultCategoryStyles.other),\n\n    [Types.Events.Name.STREAMING_COMPILE_SCRIPT_WAITING]:\n        new TimelineRecordStyle(i18nString(UIStrings.waitingForNetwork), defaultCategoryStyles.idle),\n\n    [Types.Events.Name.STREAMING_COMPILE_SCRIPT_PARSING]:\n        new TimelineRecordStyle(i18nString(UIStrings.parseAndCompile), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.BACKGROUND_DESERIALIZE]: new TimelineRecordStyle(\n        i18nString(UIStrings.deserializeCodeCache),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.FINALIZE_DESERIALIZATION]:\n        new TimelineRecordStyle(i18nString(UIStrings.profilingOverhead), defaultCategoryStyles.other),\n\n    [Types.Events.Name.WASM_STREAM_FROM_RESPONSE_CALLBACK]: new TimelineRecordStyle(\n        i18nString(UIStrings.streamingWasmResponse),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.WASM_COMPILED_MODULE]:\n        new TimelineRecordStyle(i18nString(UIStrings.compiledWasmModule), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.WASM_CACHED_MODULE]:\n        new TimelineRecordStyle(i18nString(UIStrings.cachedWasmModule), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.WASM_MODULE_CACHE_HIT]:\n        new TimelineRecordStyle(i18nString(UIStrings.wasmModuleCacheHit), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.WASM_MODULE_CACHE_INVALID]: new TimelineRecordStyle(\n        i18nString(UIStrings.wasmModuleCacheInvalid),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.FRAME_STARTED_LOADING]: new TimelineRecordStyle(\n        i18nString(UIStrings.frameStartedLoading),\n        defaultCategoryStyles.loading,\n        true,\n        ),\n\n    [Types.Events.Name.MARK_LOAD]: new TimelineRecordStyle(\n        i18nString(UIStrings.onloadEvent),\n        defaultCategoryStyles.scripting,\n        true,\n        ),\n\n    [Types.Events.Name.MARK_DOM_CONTENT]: new TimelineRecordStyle(\n        i18nString(UIStrings.domcontentloadedEvent),\n        defaultCategoryStyles.scripting,\n        true,\n        ),\n\n    [Types.Events.Name.MARK_FIRST_PAINT]: new TimelineRecordStyle(\n        i18nString(UIStrings.firstPaint),\n        defaultCategoryStyles.painting,\n        true,\n        ),\n\n    [Types.Events.Name.MARK_FCP]: new TimelineRecordStyle(\n        i18nString(UIStrings.firstContentfulPaint),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.MARK_LCP_CANDIDATE]: new TimelineRecordStyle(\n        i18nString(UIStrings.largestContentfulPaint),\n        defaultCategoryStyles.rendering,\n        true,\n        ),\n\n    [Types.Events.Name.TIME_STAMP]:\n        new TimelineRecordStyle(i18nString(UIStrings.timestamp), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CONSOLE_TIME]:\n        new TimelineRecordStyle(i18nString(UIStrings.consoleTime), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.USER_TIMING]:\n        new TimelineRecordStyle(i18nString(UIStrings.userTiming), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.RESOURCE_WILL_SEND_REQUEST]:\n        new TimelineRecordStyle(i18nString(UIStrings.willSendRequest), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.RESOURCE_SEND_REQUEST]:\n        new TimelineRecordStyle(i18nString(UIStrings.sendRequest), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.RESOURCE_RECEIVE_RESPONSE]:\n        new TimelineRecordStyle(i18nString(UIStrings.receiveResponse), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.RESOURCE_FINISH]:\n        new TimelineRecordStyle(i18nString(UIStrings.finishLoading), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.RESOURCE_RECEIVE_DATA]:\n        new TimelineRecordStyle(i18nString(UIStrings.receiveData), defaultCategoryStyles.loading),\n\n    [Types.Events.Name.RUN_MICROTASKS]:\n        new TimelineRecordStyle(i18nString(UIStrings.runMicrotasks), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.FUNCTION_CALL]:\n        new TimelineRecordStyle(i18nString(UIStrings.functionCall), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.GC]: new TimelineRecordStyle(i18nString(UIStrings.gcEvent), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.MAJOR_GC]:\n        new TimelineRecordStyle(i18nString(UIStrings.majorGc), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.MINOR_GC]:\n        new TimelineRecordStyle(i18nString(UIStrings.minorGc), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CPPGC_SWEEP]:\n        new TimelineRecordStyle(i18nString(UIStrings.cppGc), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.REQUEST_ANIMATION_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.requestAnimationFrame),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.CANCEL_ANIMATION_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.cancelAnimationFrame),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.FIRE_ANIMATION_FRAME]: new TimelineRecordStyle(\n        i18nString(UIStrings.animationFrameFired),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.REQUEST_IDLE_CALLBACK]: new TimelineRecordStyle(\n        i18nString(UIStrings.requestIdleCallback),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.CANCEL_IDLE_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.cancelIdleCallback), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.FIRE_IDLE_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.fireIdleCallback), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.WEB_SOCKET_CREATE]:\n        new TimelineRecordStyle(i18nString(UIStrings.createWebsocket), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.WEB_SOCKET_SEND_HANDSHAKE_REQUEST]: new TimelineRecordStyle(\n        i18nString(UIStrings.sendWebsocketHandshake),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.WEB_SOCKET_RECEIVE_HANDSHAKE_REQUEST]: new TimelineRecordStyle(\n        i18nString(UIStrings.receiveWebsocketHandshake),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.WEB_SOCKET_DESTROY]:\n        new TimelineRecordStyle(i18nString(UIStrings.destroyWebsocket), defaultCategoryStyles.scripting),\n    [Types.Events.Name.WEB_SOCKET_SEND]: new TimelineRecordStyle(\n        i18nString(UIStrings.wsMessageSent),\n        defaultCategoryStyles.scripting,\n        ),\n    [Types.Events.Name.WEB_SOCKET_RECEIVE]: new TimelineRecordStyle(\n        i18nString(UIStrings.wsMessageReceived),\n        defaultCategoryStyles.scripting,\n        ),\n\n    [Types.Events.Name.EMBEDDER_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.embedderCallback), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.DECODE_IMAGE]:\n        new TimelineRecordStyle(i18nString(UIStrings.imageDecode), defaultCategoryStyles.painting),\n\n    [Types.Events.Name.GPU_TASK]: new TimelineRecordStyle(i18nString(UIStrings.gpu), defaultCategoryStyles.gpu),\n\n    [Types.Events.Name.GC_COLLECT_GARBARGE]:\n        new TimelineRecordStyle(i18nString(UIStrings.domGc), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_ENCRYPT]:\n        new TimelineRecordStyle(i18nString(UIStrings.encrypt), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_ENCRYPT_REPLY]:\n        new TimelineRecordStyle(i18nString(UIStrings.encryptReply), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_DECRYPT]:\n        new TimelineRecordStyle(i18nString(UIStrings.decrypt), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_DECRYPT_REPLY]:\n        new TimelineRecordStyle(i18nString(UIStrings.decryptReply), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_DIGEST]:\n        new TimelineRecordStyle(i18nString(UIStrings.digest), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_DIGEST_REPLY]:\n        new TimelineRecordStyle(i18nString(UIStrings.digestReply), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_SIGN]:\n        new TimelineRecordStyle(i18nString(UIStrings.sign), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_SIGN_REPLY]:\n        new TimelineRecordStyle(i18nString(UIStrings.signReply), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_VERIFY]:\n        new TimelineRecordStyle(i18nString(UIStrings.verify), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.CRYPTO_DO_VERIFY_REPLY]:\n        new TimelineRecordStyle(i18nString(UIStrings.verifyReply), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.ASYNC_TASK]:\n        new TimelineRecordStyle(i18nString(UIStrings.asyncTask), defaultCategoryStyles.async),\n\n    [Types.Events.Name.LAYOUT_SHIFT]: new TimelineRecordStyle(\n        i18nString(UIStrings.layoutShift), defaultCategoryStyles.experience,\n        /* Mark LayoutShifts as hidden; in the timeline we render\n        * SyntheticLayoutShifts so those are the ones visible to the user */\n        true),\n\n    [Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT]:\n        new TimelineRecordStyle(i18nString(UIStrings.layoutShift), defaultCategoryStyles.experience),\n\n    [Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT_CLUSTER]:\n        new TimelineRecordStyle(i18nString(UIStrings.layoutShiftCluster), defaultCategoryStyles.experience),\n\n    [Types.Events.Name.EVENT_TIMING]:\n        new TimelineRecordStyle(i18nString(UIStrings.eventTiming), defaultCategoryStyles.experience),\n\n    [Types.Events.Name.HANDLE_POST_MESSAGE]:\n        new TimelineRecordStyle(i18nString(UIStrings.onMessage), defaultCategoryStyles.messaging),\n\n    [Types.Events.Name.SCHEDULE_POST_MESSAGE]:\n        new TimelineRecordStyle(i18nString(UIStrings.schedulePostMessage), defaultCategoryStyles.messaging),\n\n    [Types.Events.Name.SCHEDULE_POST_TASK_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.schedulePostTaskCallback), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.RUN_POST_TASK_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.runPostTaskCallback), defaultCategoryStyles.scripting),\n\n    [Types.Events.Name.ABORT_POST_TASK_CALLBACK]:\n        new TimelineRecordStyle(i18nString(UIStrings.abortPostTaskCallback), defaultCategoryStyles.scripting),\n    [Types.Events.Name.V8_CONSOLE_RUN_TASK]:\n        new TimelineRecordStyle(i18nString(UIStrings.consoleTaskRun), defaultCategoryStyles.scripting),\n  };\n\n  // TODO(crbug.com/410884528): remove assertion after deduped eventStylesMap for VISIBLE_TRACE_EVENT_TYPES.\n  const visibleEventStyles =\n      Object.entries(eventStylesMap).filter(([, style]) => style.hidden === false).map(([\n                                                                                         key,\n                                                                                       ]) => key);\n  const visibleTraceEventsComplete = visibleEventStyles.every(eventType => {\n    return Helpers.Trace.VISIBLE_TRACE_EVENT_TYPES.has(eventType as Types.Events.Name);\n  });\n\n  const eventStylesMapKeys = Object.keys(eventStylesMap) as Types.Events.Name[];\n  const eventStylesComplete = Array.from(Helpers.Trace.VISIBLE_TRACE_EVENT_TYPES).every(eventType => {\n    return eventStylesMapKeys.includes(eventType);\n  });\n\n  if (!visibleTraceEventsComplete || !eventStylesComplete) {\n    throw new Error('eventStylesMap and VISIBLE_TRACE_EVENT_TYPES are out of sync!');\n  }\n  return eventStylesMap;\n}\n\nexport function setEventStylesMap(eventStyles: EventStylesMap): void {\n  eventStylesMap = eventStyles;\n}\n\nexport function setCategories(cats: CategoryPalette): void {\n  categoryStyles = cats;\n}\n\nexport function visibleTypes(): string[] {\n  const eventStyles = maybeInitSylesMap();\n  const result = [];\n  for (const name in eventStyles) {\n    // Typescript cannot infer that `name` is a key of eventStyles\n    const nameAsKey = name as keyof typeof eventStyles;\n    if (!eventStyles[nameAsKey]?.hidden) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\nexport function getTimelineMainEventCategories(): EventCategory[] {\n  if (mainEventCategories) {\n    return mainEventCategories;\n  }\n  mainEventCategories = [\n    EventCategory.IDLE,\n    EventCategory.LOADING,\n    EventCategory.PAINTING,\n    EventCategory.RENDERING,\n    EventCategory.SCRIPTING,\n    EventCategory.OTHER,\n  ];\n  return mainEventCategories;\n}\n\nexport function setTimelineMainEventCategories(categories: EventCategory[]): void {\n  mainEventCategories = categories;\n}\n\nexport function markerDetailsForEvent(event: Types.Events.Event): {\n  color: string,\n  title: string,\n} {\n  let title = '';\n  let color = 'var(--color-text-primary)';\n  if (Types.Events.isFirstContentfulPaint(event)) {\n    color = 'var(--sys-color-green-bright)';\n    title = Handlers.ModelHandlers.PageLoadMetrics.MetricName.FCP;\n  }\n  if (Types.Events.isLargestContentfulPaintCandidate(event)) {\n    color = 'var(--sys-color-green)';\n    title = Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP;\n  }\n  if (Types.Events.isNavigationStart(event)) {\n    color = 'var(--color-text-primary)';\n    title = Handlers.ModelHandlers.PageLoadMetrics.MetricName.NAV;\n  }\n  if (Types.Events.isMarkDOMContent(event)) {\n    color = 'var(--color-text-disabled)';\n    title = Handlers.ModelHandlers.PageLoadMetrics.MetricName.DCL;\n  }\n  if (Types.Events.isMarkLoad(event)) {\n    color = 'var(--color-text-disabled)';\n    title = Handlers.ModelHandlers.PageLoadMetrics.MetricName.L;\n  }\n  return {color, title};\n}\n"],
  "mappings": "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",
  "names": ["Helpers", "Helpers", "Handlers", "Helpers", "Insights", "Lantern", "Handlers", "request", "Handlers", "Helpers", "Handlers", "Helpers", "Lantern", "Types", "handler", "Types", "Common", "i18n", "Handlers", "Handlers", "Helpers", "Types", "EventCategory", "Types", "UIStrings", "str_", "i18nString", "Types"]
}
