{"version":3,"file":"AutomaticFileSystemManager.js","sourceRoot":"","sources":["../../../../../../front_end/models/persistence/AutomaticFileSystemManager.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,6BAA6B,CAAC;AAItD,OAAO,KAAK,eAAe,MAAM,yCAAyC,CAAC;AAW3E,IAAI,kCAAwE,CAAC;AAE7E;;;;GAIG;AACH,MAAM,OAAO,0BAA2B,SAAQ,MAAM,CAAC,aAAa,CAAC,aAAyB;IAC5F,oBAAoB,CAA2B;IAC/C,sBAAsB,CAAyD;IAC/E,qBAAqB,CAA4D;IAEjF;;;;OAIG;IACH,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,YACI,UAAmC,EACnC,qBAA6E,EAC7E,oBAA+E;QACjF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;QACjC,IAAI,CAAC,sBAAsB,GAAG,qBAAqB,CAAC;QACpD,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;QAClD,IAAI,UAAU,CAAC,4BAA4B,EAAE,OAAO,EAAE,CAAC;YACrD,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,sGAC+B,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;YAC9G,IAAI,CAAC,uBAAuB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,qBAAqB,CAAC,eAAe,EAAC,CAAC,CAAC;QACnF,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,QAAQ,CAAC,EAAC,QAAQ,EAAE,UAAU,EAAE,qBAAqB,EAAE,oBAAoB,KAK9E,EAAC,QAAQ,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,qBAAqB,EAAE,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAC;QAE9F,IAAI,CAAC,kCAAkC,IAAI,QAAQ,EAAE,CAAC;YACpD,IAAI,CAAC,UAAU,IAAI,CAAC,qBAAqB,IAAI,CAAC,oBAAoB,EAAE,CAAC;gBACnE,MAAM,IAAI,KAAK,CACX,8CAA8C;oBAC9C,8EAA8E,CAAC,CAAC;YACtF,CAAC;YACD,kCAAkC,GAAG,IAAI,0BAA0B,CAC/D,UAAU,EACV,qBAAqB,EACrB,oBAAoB,CACvB,CAAC;QACJ,CAAC;QACD,OAAO,kCAAkC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,cAAc;QACnB,IAAI,kCAAkC,EAAE,CAAC;YACvC,kCAAkC,CAAC,QAAQ,EAAE,CAAC;YAC9C,kCAAkC,GAAG,SAAS,CAAC;QACjD,CAAC;IACH,CAAC;IAED,QAAQ;QACN,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,sGAC4B,IAAI,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;IAChH,CAAC;IAED,uBAAuB,CACnB,KAAgG;QAClG,MAAM,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC;QACnC,IAAI,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC;QACpD,IAAI,eAAe,CAAC,SAAS,EAAE,CAAC;YAC9B,MAAM,EAAC,IAAI,EAAE,IAAI,EAAC,GAAG,eAAe,CAAC,SAAS,CAAC;YAC/C,IAAI,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,CAAC,IAAI,KAAK,IAAI,IAAI,mBAAmB,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;gBAC3G,mBAAmB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,cAAc,EAAC,CAAC,CAAC;YAC3E,CAAC;QACH,CAAC;aAAM,IAAI,mBAAmB,KAAK,IAAI,EAAE,CAAC;YACxC,mBAAmB,GAAG,IAAI,CAAC;QAC7B,CAAC;QAED,IAAI,IAAI,CAAC,oBAAoB,KAAK,mBAAmB,EAAE,CAAC;YACtD,IAAI,CAAC,+BAA+B,EAAE,CAAC;YACvC,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC;YAChD,IAAI,CAAC,wBAAwB,0EAAuC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAC/F,KAAK,IAAI,CAAC,0BAA0B,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAClE,CAAC;IACH,CAAC;IAED;;;;;;;;;;;OAWG;IACH,KAAK,CAAC,0BAA0B,CAAC,YAAY,GAAG,KAAK;QACnD,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC/B,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,EAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAC,GAAG,IAAI,CAAC,oBAAoB,CAAC;QACtD,IAAI,KAAK,KAAK,cAAc,EAAE,CAAC;YAC7B,MAAM,mBAAmB,GAAG,IAAI,CAAC,oBAAoB;gBACjD,MAAM,CAAC,MAAM,CAAC,EAAC,GAAG,IAAI,CAAC,oBAAoB,EAAE,KAAK,EAAE,YAAY,EAAC,CAAC,CAAC;YACvE,IAAI,CAAC,wBAAwB,0EAAuC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAC/F,MAAM,EAAC,OAAO,EAAC,GAAG,MAAM,IAAI,OAAO,CAC/B,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,0BAA0B,CAAC,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;YAC1G,IAAI,IAAI,CAAC,oBAAoB,KAAK,mBAAmB,EAAE,CAAC;gBACtD,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC;gBACrD,IAAI,CAAC,oBAAoB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAC,GAAG,mBAAmB,EAAE,KAAK,EAAC,CAAC,CAAC;gBAC3E,IAAI,CAAC,wBAAwB,0EAAuC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACjG,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC,oBAAoB,EAAE,KAAK,KAAK,WAAW,CAAC;IAC1D,CAAC;IAED;;OAEG;IACH,+BAA+B;QAC7B,IAAI,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,KAAK,cAAc,EAAE,CAAC;YACpF,IAAI,CAAC,sBAAsB,CAAC,6BAA6B,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;YAC1F,IAAI,CAAC,oBAAoB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAC,GAAG,IAAI,CAAC,oBAAoB,EAAE,KAAK,EAAE,cAAc,EAAC,CAAC,CAAC;YACjG,IAAI,CAAC,wBAAwB,0EAAuC,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACjG,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Host from '../../core/host/host.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as Root from '../../core/root/root.js';\nimport * as ProjectSettings from '../project_settings/project_settings.js';\n\n/**\n * Description and state of the automatic file system.\n */\nexport interface AutomaticFileSystem {\n  root: Platform.DevToolsPath.RawPathString;\n  uuid: string;\n  state: 'disconnected'|'connecting'|'connected';\n}\n\nlet automaticFileSystemManagerInstance: AutomaticFileSystemManager|undefined;\n\n/**\n * Automatically connects and disconnects workspace folders.\n *\n * @see http://go/chrome-devtools:automatic-workspace-folders-design\n */\nexport class AutomaticFileSystemManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  #automaticFileSystem: AutomaticFileSystem|null;\n  #inspectorFrontendHost: Host.InspectorFrontendHostAPI.InspectorFrontendHostAPI;\n  #projectSettingsModel: ProjectSettings.ProjectSettingsModel.ProjectSettingsModel;\n\n  /**\n   * Yields the current `AutomaticFileSystem` (if any).\n   *\n   * @return the current automatic file system or `null`.\n   */\n  get automaticFileSystem(): Readonly<AutomaticFileSystem>|null {\n    return this.#automaticFileSystem;\n  }\n\n  /**\n   * @internal\n   */\n  private constructor(\n      hostConfig: Root.Runtime.HostConfig,\n      inspectorFrontendHost: Host.InspectorFrontendHostAPI.InspectorFrontendHostAPI,\n      projectSettingsModel: ProjectSettings.ProjectSettingsModel.ProjectSettingsModel) {\n    super();\n    this.#automaticFileSystem = null;\n    this.#inspectorFrontendHost = inspectorFrontendHost;\n    this.#projectSettingsModel = projectSettingsModel;\n    if (hostConfig.devToolsAutomaticFileSystems?.enabled) {\n      this.#projectSettingsModel.addEventListener(\n          ProjectSettings.ProjectSettingsModel.Events.PROJECT_SETTINGS_CHANGED, this.#projectSettingsChanged, this);\n      this.#projectSettingsChanged({data: this.#projectSettingsModel.projectSettings});\n    }\n  }\n\n  /**\n   * Yields the `AutomaticFileSystemManager` singleton.\n   *\n   * @returns the singleton.\n   */\n  static instance({forceNew, hostConfig, inspectorFrontendHost, projectSettingsModel}: {\n    forceNew: boolean|null,\n    hostConfig: Root.Runtime.HostConfig|null,\n    inspectorFrontendHost: Host.InspectorFrontendHostAPI.InspectorFrontendHostAPI|null,\n    projectSettingsModel: ProjectSettings.ProjectSettingsModel.ProjectSettingsModel|null,\n  } = {forceNew: false, hostConfig: null, inspectorFrontendHost: null, projectSettingsModel: null}):\n      AutomaticFileSystemManager {\n    if (!automaticFileSystemManagerInstance || forceNew) {\n      if (!hostConfig || !inspectorFrontendHost || !projectSettingsModel) {\n        throw new Error(\n            'Unable to create AutomaticFileSysteManager: ' +\n            'hostConfig, inspectorFrontendHost, and projectSettingsModel must be provided');\n      }\n      automaticFileSystemManagerInstance = new AutomaticFileSystemManager(\n          hostConfig,\n          inspectorFrontendHost,\n          projectSettingsModel,\n      );\n    }\n    return automaticFileSystemManagerInstance;\n  }\n\n  /**\n   * Clears the `AutomaticFileSystemManager` singleton (if any);\n   */\n  static removeInstance(): void {\n    if (automaticFileSystemManagerInstance) {\n      automaticFileSystemManagerInstance.#dispose();\n      automaticFileSystemManagerInstance = undefined;\n    }\n  }\n\n  #dispose(): void {\n    this.#projectSettingsModel.removeEventListener(\n        ProjectSettings.ProjectSettingsModel.Events.PROJECT_SETTINGS_CHANGED, this.#projectSettingsChanged, this);\n  }\n\n  #projectSettingsChanged(\n      event: Common.EventTarget.EventTargetEvent<ProjectSettings.ProjectSettingsModel.ProjectSettings>): void {\n    const projectSettings = event.data;\n    let automaticFileSystem = this.#automaticFileSystem;\n    if (projectSettings.workspace) {\n      const {root, uuid} = projectSettings.workspace;\n      if (automaticFileSystem === null || automaticFileSystem.root !== root || automaticFileSystem.uuid !== uuid) {\n        automaticFileSystem = Object.freeze({root, uuid, state: 'disconnected'});\n      }\n    } else if (automaticFileSystem !== null) {\n      automaticFileSystem = null;\n    }\n\n    if (this.#automaticFileSystem !== automaticFileSystem) {\n      this.disconnectedAutomaticFileSystem();\n      this.#automaticFileSystem = automaticFileSystem;\n      this.dispatchEventToListeners(Events.AUTOMATIC_FILE_SYSTEM_CHANGED, this.#automaticFileSystem);\n      void this.connectAutomaticFileSystem(/* addIfMissing= */ false);\n    }\n  }\n\n  /**\n   * Attempt to connect the automatic workspace folder (if any).\n   *\n   * @param addIfMissing if `false` (the default), this will only try to connect\n   *                     to a previously connected automatic workspace folder.\n   *                     If the folder was never connected before and `true` is\n   *                     specified, the user will be asked to grant permission\n   *                     to allow Chrome DevTools to access the folder first.\n   * @returns `true` if the automatic workspace folder was connected, `false`\n   *          if there wasn't any, or the connection attempt failed (e.g. the\n   *          user did not grant permission).\n   */\n  async connectAutomaticFileSystem(addIfMissing = false): Promise<boolean> {\n    if (!this.#automaticFileSystem) {\n      return false;\n    }\n    const {root, uuid, state} = this.#automaticFileSystem;\n    if (state === 'disconnected') {\n      const automaticFileSystem = this.#automaticFileSystem =\n          Object.freeze({...this.#automaticFileSystem, state: 'connecting'});\n      this.dispatchEventToListeners(Events.AUTOMATIC_FILE_SYSTEM_CHANGED, this.#automaticFileSystem);\n      const {success} = await new Promise<{success: boolean}>(\n          resolve => this.#inspectorFrontendHost.connectAutomaticFileSystem(root, uuid, addIfMissing, resolve));\n      if (this.#automaticFileSystem === automaticFileSystem) {\n        const state = success ? 'connected' : 'disconnected';\n        this.#automaticFileSystem = Object.freeze({...automaticFileSystem, state});\n        this.dispatchEventToListeners(Events.AUTOMATIC_FILE_SYSTEM_CHANGED, this.#automaticFileSystem);\n      }\n    }\n    return this.#automaticFileSystem?.state === 'connected';\n  }\n\n  /**\n   * Disconnects any automatic workspace folder.\n   */\n  disconnectedAutomaticFileSystem(): void {\n    if (this.#automaticFileSystem && this.#automaticFileSystem.state !== 'disconnected') {\n      this.#inspectorFrontendHost.disconnectAutomaticFileSystem(this.#automaticFileSystem.root);\n      this.#automaticFileSystem = Object.freeze({...this.#automaticFileSystem, state: 'disconnected'});\n      this.dispatchEventToListeners(Events.AUTOMATIC_FILE_SYSTEM_CHANGED, this.#automaticFileSystem);\n    }\n  }\n}\n\n/**\n * Events emitted by the `AutomaticFileSystemManager`.\n */\nexport const enum Events {\n  /**\n   * Emitted whenever the `automaticFileSystem` property of the\n   * `AutomaticFileSystemManager` changes.\n   */\n  AUTOMATIC_FILE_SYSTEM_CHANGED = 'AutomaticFileSystemChanged',\n}\n\n/**\n * @internal\n */\nexport interface EventTypes {\n  [Events.AUTOMATIC_FILE_SYSTEM_CHANGED]: Readonly<AutomaticFileSystem>|null;\n}\n"]}