{
  "version": 3,
  "sources": ["../../../../../../front_end/models/trace_source_maps_resolver/SourceMapsResolver.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as SourceMapScopes from '../source_map_scopes/source_map_scopes.js';\nimport * as Trace from '../trace/trace.js';\nimport * as Workspace from '../workspace/workspace.js';\n\ninterface ResolvedCodeLocationData {\n  name: string|null;\n  devtoolsLocation: Workspace.UISourceCode.UILocation|null;\n  script: SDK.Script.Script|null;\n}\nexport class SourceMappingsUpdated extends Event {\n  static readonly eventName = 'sourcemappingsupdated';\n  constructor() {\n    super(SourceMappingsUpdated.eventName, {composed: true, bubbles: true});\n  }\n}\n\n// The code location key is created as a concatenation of its fields.\nexport const resolvedCodeLocationDataNames = new Map<string, ResolvedCodeLocationData|null>();\n\nexport class SourceMapsResolver extends EventTarget {\n  private executionContextNamesByOrigin = new Map<Platform.DevToolsPath.UrlString, string>();\n  #parsedTrace: Trace.TraceModel.ParsedTrace;\n  #entityMapper: Trace.EntityMapper.EntityMapper|null = null;\n\n  #isResolving = false;\n\n  // We need to gather up a list of all the DebuggerModels that we should\n  // listen to for source map attached events. For most pages this will be\n  // the debugger model for the primary page target, but if a trace has\n  // workers, we would also need to gather up the DebuggerModel instances for\n  // those workers too.\n  #debuggerModelsToListen = new Set<SDK.DebuggerModel.DebuggerModel>();\n\n  constructor(parsedTrace: Trace.TraceModel.ParsedTrace, entityMapper?: Trace.EntityMapper.EntityMapper) {\n    super();\n    this.#parsedTrace = parsedTrace;\n    this.#entityMapper = entityMapper ?? null;\n  }\n\n  static clearResolvedNodeNames(): void {\n    resolvedCodeLocationDataNames.clear();\n  }\n  static keyForCodeLocation(callFrame: Protocol.Runtime.CallFrame): string {\n    return `${callFrame.url}$$$${callFrame.scriptId}$$$${callFrame.functionName}$$$${callFrame.lineNumber}$$$${\n        callFrame.columnNumber}`;\n  }\n\n  /**\n   * For trace events containing a call frame / source location\n   * (f.e. a stack trace), attempts to obtain the resolved source\n   * location based on the those that have been resolved so far from\n   * listened source maps.\n   *\n   * Note that a single deployed URL can map to multiple authored URLs\n   * (f.e. if an app is bundled). Thus, beyond a URL we can use code\n   * location data like line and column numbers to obtain the specific\n   * authored code according to the source mappings.\n   *\n   * TODO(andoli): This can return incorrect scripts if the target page has been reloaded since the trace.\n   */\n  static resolvedCodeLocationForCallFrame(callFrame: Protocol.Runtime.CallFrame): ResolvedCodeLocationData|null {\n    const codeLocationKey = this.keyForCodeLocation(callFrame);\n    return resolvedCodeLocationDataNames.get(codeLocationKey) ?? null;\n  }\n\n  static resolvedCodeLocationForEntry(entry: Trace.Types.Events.Event): ResolvedCodeLocationData|null {\n    let callFrame = null;\n    if (Trace.Types.Events.isProfileCall(entry)) {\n      callFrame = entry.callFrame;\n    } else {\n      const topCallFrame = Trace.Helpers.Trace.getStackTraceTopCallFrameInEventPayload(entry);\n      if (!topCallFrame) {\n        return null;\n      }\n      callFrame = topCallFrame;\n    }\n    return SourceMapsResolver.resolvedCodeLocationForCallFrame(callFrame as Protocol.Runtime.CallFrame);\n  }\n\n  static resolvedURLForEntry(parsedTrace: Trace.TraceModel.ParsedTrace, entry: Trace.Types.Events.Event):\n      Platform.DevToolsPath.UrlString|null {\n    const resolvedCallFrameURL =\n        SourceMapsResolver.resolvedCodeLocationForEntry(entry)?.devtoolsLocation?.uiSourceCode.url();\n    if (resolvedCallFrameURL) {\n      return resolvedCallFrameURL;\n    }\n    // If no source mapping was found for an entry's URL, then default\n    // to the URL value contained in the event itself, if any.\n    const url = Trace.Handlers.Helpers.getNonResolvedURL(entry, parsedTrace.data);\n    if (url) {\n      return Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url)?.url() ?? url;\n    }\n    return null;\n  }\n\n  static storeResolvedCodeDataForCallFrame(\n      callFrame: Protocol.Runtime.CallFrame, resolvedCodeLocationData: ResolvedCodeLocationData): void {\n    const keyForCallFrame = this.keyForCodeLocation(callFrame);\n    resolvedCodeLocationDataNames.set(keyForCallFrame, resolvedCodeLocationData);\n  }\n\n  async install(): Promise<void> {\n    for (const threadToProfileMap of this.#parsedTrace.data.Samples.profilesInProcess.values()) {\n      for (const [tid, profile] of threadToProfileMap) {\n        const nodes = profile.parsedProfile.nodes();\n        if (!nodes || nodes.length === 0) {\n          continue;\n        }\n\n        const target = this.#targetForThread(tid);\n        const debuggerModel = target?.model(SDK.DebuggerModel.DebuggerModel);\n        if (!debuggerModel) {\n          continue;\n        }\n        for (const node of nodes) {\n          const script = debuggerModel.scriptForId(String(node.callFrame.scriptId));\n          const shouldListenToSourceMap = !script || script.sourceMapURL;\n          if (!shouldListenToSourceMap) {\n            continue;\n          }\n          this.#debuggerModelsToListen.add(debuggerModel);\n        }\n      }\n    }\n\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().addEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n\n    this.#updateExtensionNames();\n\n    // Although we have added listeners for SourceMapAttached events, we also\n    // immediately try to resolve function names. This ensures we use any\n    // sourcemaps that were attached before we bound our event listener.\n    await this.#resolveMappingsForProfileNodes();\n  }\n\n  /**\n   * Removes the event listeners and stops tracking newly added sourcemaps.\n   * Should be called before destroying an instance of this class to avoid leaks\n   * with listeners.\n   */\n  uninstall(): void {\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().removeEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n    this.#debuggerModelsToListen.clear();\n  }\n\n  async #resolveMappingsForProfileNodes(): Promise<void> {\n    // Used to track if source mappings were updated when a source map\n    // is attach. If not, we do not notify the flamechart that mappings\n    // were updated, since that would trigger a rerender.\n    let updatedMappings = false;\n    for (const [, threadsInProcess] of this.#parsedTrace.data.Samples.profilesInProcess) {\n      for (const [tid, threadProfile] of threadsInProcess) {\n        const nodes = threadProfile.parsedProfile.nodes() ?? [];\n        const target = this.#targetForThread(tid);\n        if (!target) {\n          continue;\n        }\n        for (const node of nodes) {\n          const resolvedFunctionName =\n              await SourceMapScopes.NamesResolver.resolveProfileFrameFunctionName(node.callFrame, target);\n          updatedMappings ||= Boolean(resolvedFunctionName);\n          node.setFunctionName(resolvedFunctionName);\n\n          const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n          const script = debuggerModel?.scriptForId(node.scriptId) || null;\n          const location = debuggerModel &&\n              new SDK.DebuggerModel.Location(\n                  debuggerModel, node.callFrame.scriptId, node.callFrame.lineNumber, node.callFrame.columnNumber);\n          const uiLocation = location &&\n              await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().rawLocationToUILocation(\n                  location);\n          updatedMappings ||= Boolean(uiLocation);\n          if (uiLocation?.uiSourceCode.url() && this.#entityMapper) {\n            // Update mappings for the related events of the entity.\n            this.#entityMapper.updateSourceMapEntities(node.callFrame, uiLocation.uiSourceCode.url());\n          }\n\n          SourceMapsResolver.storeResolvedCodeDataForCallFrame(\n              node.callFrame, {name: resolvedFunctionName, devtoolsLocation: uiLocation, script});\n        }\n      }\n    }\n    if (!updatedMappings) {\n      return;\n    }\n    this.dispatchEvent(new SourceMappingsUpdated());\n  }\n\n  #onAttachedSourceMap(): void {\n    // Exit if we are already resolving so that we batch requests; if pages\n    // have a lot of sourcemaps we can get a lot of events at once.\n    if (this.#isResolving) {\n      return;\n    }\n\n    this.#isResolving = true;\n    // Resolving names triggers a repaint of the flame chart. Instead of attempting to resolve\n    // names every time a source map is attached, wait for some time once the first source map is\n    // attached. This way we allow for other source maps to be parsed before attempting a name\n    // resolving using the available source maps. Otherwise the UI is blocked when the number\n    // of source maps is particularly large.\n    setTimeout(async () => {\n      this.#isResolving = false;\n      await this.#resolveMappingsForProfileNodes();\n    }, 500);\n  }\n\n  // Figure out the target for the node. If it is in a worker thread,\n  // that is the target, otherwise we use the primary page target.\n  #targetForThread(tid: Trace.Types.Events.ThreadID): SDK.Target.Target|null {\n    const maybeWorkerId = this.#parsedTrace.data.Workers.workerIdByThread.get(tid);\n    if (maybeWorkerId) {\n      return SDK.TargetManager.TargetManager.instance().targetById(maybeWorkerId);\n    }\n    return SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  }\n\n  #updateExtensionNames(): void {\n    for (const runtimeModel of SDK.TargetManager.TargetManager.instance().models(SDK.RuntimeModel.RuntimeModel)) {\n      for (const context of runtimeModel.executionContexts()) {\n        this.executionContextNamesByOrigin.set(context.origin, context.name);\n      }\n    }\n    this.#entityMapper?.updateExtensionEntitiesWithName(this.executionContextNamesByOrigin);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
