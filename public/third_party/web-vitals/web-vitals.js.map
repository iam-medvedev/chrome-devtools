{
  "version": 3,
  "sources": ["package/dist/modules/lib/bfcache.js", "package/dist/modules/lib/generateUniqueID.js", "package/dist/modules/lib/getNavigationEntry.js", "package/dist/modules/lib/getActivationStart.js", "package/dist/modules/lib/initMetric.js", "package/dist/modules/lib/observe.js", "package/dist/modules/lib/bindReporter.js", "package/dist/modules/lib/doubleRAF.js", "package/dist/modules/lib/onHidden.js", "package/dist/modules/lib/runOnce.js", "package/dist/modules/lib/getVisibilityWatcher.js", "package/dist/modules/lib/whenActivated.js", "package/dist/modules/onFCP.js", "package/dist/modules/onCLS.js", "package/dist/modules/lib/polyfills/interactionCountPolyfill.js", "package/dist/modules/lib/interactions.js", "package/dist/modules/lib/whenIdle.js", "package/dist/modules/onINP.js", "package/dist/modules/onLCP.js", "package/dist/modules/onTTFB.js", "package/dist/modules/lib/polyfills/firstInputPolyfill.js", "package/dist/modules/onFID.js", "package/dist/modules/attribution/index.js", "package/dist/modules/lib/getLoadState.js", "package/dist/modules/lib/getSelector.js", "package/dist/modules/attribution/onCLS.js", "package/dist/modules/attribution/onFCP.js", "package/dist/modules/attribution/onINP.js", "package/dist/modules/attribution/onLCP.js", "package/dist/modules/attribution/onTTFB.js", "package/dist/modules/attribution/onFID.js"],
  "sourcesContent": ["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet bfcacheRestoreTime = -1;\nexport const getBFCacheRestoreTime = () => bfcacheRestoreTime;\nexport const onBFCacheRestore = (cb) => {\n    addEventListener('pageshow', (event) => {\n        if (event.persisted) {\n            bfcacheRestoreTime = event.timeStamp;\n            cb(event);\n        }\n    }, true);\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nexport const generateUniqueID = () => {\n    return `v4-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const getNavigationEntry = () => {\n    const navigationEntry = self.performance &&\n        performance.getEntriesByType &&\n        performance.getEntriesByType('navigation')[0];\n    // Check to ensure the `responseStart` property is present and valid.\n    // In some cases no value is reported by the browser (for\n    // privacy/security reasons), and in other cases (bugs) the value is\n    // negative or is larger than the current page time. Ignore these cases:\n    // https://github.com/GoogleChrome/web-vitals/issues/137\n    // https://github.com/GoogleChrome/web-vitals/issues/162\n    // https://github.com/GoogleChrome/web-vitals/issues/275\n    if (navigationEntry &&\n        navigationEntry.responseStart > 0 &&\n        navigationEntry.responseStart < performance.now()) {\n        return navigationEntry;\n    }\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const getActivationStart = () => {\n    const navEntry = getNavigationEntry();\n    return (navEntry && navEntry.activationStart) || 0;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getBFCacheRestoreTime } from './bfcache.js';\nimport { generateUniqueID } from './generateUniqueID.js';\nimport { getActivationStart } from './getActivationStart.js';\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const initMetric = (name, value) => {\n    const navEntry = getNavigationEntry();\n    let navigationType = 'navigate';\n    if (getBFCacheRestoreTime() >= 0) {\n        navigationType = 'back-forward-cache';\n    }\n    else if (navEntry) {\n        if (document.prerendering || getActivationStart() > 0) {\n            navigationType = 'prerender';\n        }\n        else if (document.wasDiscarded) {\n            navigationType = 'restore';\n        }\n        else if (navEntry.type) {\n            navigationType = navEntry.type.replace(/_/g, '-');\n        }\n    }\n    // Use `entries` type specific for the metric.\n    const entries = [];\n    return {\n        name,\n        value: typeof value === 'undefined' ? -1 : value,\n        rating: 'good', // If needed, will be updated when reported. `const` to keep the type from widening to `string`.\n        delta: 0,\n        entries,\n        id: generateUniqueID(),\n        navigationType,\n    };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nexport const observe = (type, callback, opts) => {\n    try {\n        if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n            const po = new PerformanceObserver((list) => {\n                // Delay by a microtask to workaround a bug in Safari where the\n                // callback is invoked immediately, rather than in a separate task.\n                // See: https://github.com/GoogleChrome/web-vitals/issues/277\n                Promise.resolve().then(() => {\n                    callback(list.getEntries());\n                });\n            });\n            po.observe(Object.assign({\n                type,\n                buffered: true,\n            }, opts || {}));\n            return po;\n        }\n    }\n    catch (e) {\n        // Do nothing.\n    }\n    return;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getRating = (value, thresholds) => {\n    if (value > thresholds[1]) {\n        return 'poor';\n    }\n    if (value > thresholds[0]) {\n        return 'needs-improvement';\n    }\n    return 'good';\n};\nexport const bindReporter = (callback, metric, thresholds, reportAllChanges) => {\n    let prevValue;\n    let delta;\n    return (forceReport) => {\n        if (metric.value >= 0) {\n            if (forceReport || reportAllChanges) {\n                delta = metric.value - (prevValue || 0);\n                // Report the metric if there's a non-zero delta or if no previous\n                // value exists (which can happen in the case of the document becoming\n                // hidden when the metric value is 0).\n                // See: https://github.com/GoogleChrome/web-vitals/issues/14\n                if (delta || prevValue === undefined) {\n                    prevValue = metric.value;\n                    metric.delta = delta;\n                    metric.rating = getRating(metric.value, thresholds);\n                    callback(metric);\n                }\n            }\n        }\n    };\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const doubleRAF = (cb) => {\n    requestAnimationFrame(() => requestAnimationFrame(() => cb()));\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const onHidden = (cb) => {\n    document.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') {\n            cb();\n        }\n    });\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const runOnce = (cb) => {\n    let called = false;\n    return () => {\n        if (!called) {\n            cb();\n            called = true;\n        }\n    };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './bfcache.js';\nlet firstHiddenTime = -1;\nconst initHiddenTime = () => {\n    // If the document is hidden when this code runs, assume it was always\n    // hidden and the page was loaded in the background, with the one exception\n    // that visibility state is always 'hidden' during prerendering, so we have\n    // to ignore that case until prerendering finishes (see: `prerenderingchange`\n    // event logic below).\n    return document.visibilityState === 'hidden' && !document.prerendering\n        ? 0\n        : Infinity;\n};\nconst onVisibilityUpdate = (event) => {\n    // If the document is 'hidden' and no previous hidden timestamp has been\n    // set, update it based on the current event data.\n    if (document.visibilityState === 'hidden' && firstHiddenTime > -1) {\n        // If the event is a 'visibilitychange' event, it means the page was\n        // visible prior to this change, so the event timestamp is the first\n        // hidden time.\n        // However, if the event is not a 'visibilitychange' event, then it must\n        // be a 'prerenderingchange' event, and the fact that the document is\n        // still 'hidden' from the above check means the tab was activated\n        // in a background state and so has always been hidden.\n        firstHiddenTime = event.type === 'visibilitychange' ? event.timeStamp : 0;\n        // Remove all listeners now that a `firstHiddenTime` value has been set.\n        removeChangeListeners();\n    }\n};\nconst addChangeListeners = () => {\n    addEventListener('visibilitychange', onVisibilityUpdate, true);\n    // IMPORTANT: when a page is prerendering, its `visibilityState` is\n    // 'hidden', so in order to account for cases where this module checks for\n    // visibility during prerendering, an additional check after prerendering\n    // completes is also required.\n    addEventListener('prerenderingchange', onVisibilityUpdate, true);\n};\nconst removeChangeListeners = () => {\n    removeEventListener('visibilitychange', onVisibilityUpdate, true);\n    removeEventListener('prerenderingchange', onVisibilityUpdate, true);\n};\nexport const getVisibilityWatcher = () => {\n    if (firstHiddenTime < 0) {\n        // If the document is hidden when this code runs, assume it was hidden\n        // since navigation start. This isn't a perfect heuristic, but it's the\n        // best we can do until an API is available to support querying past\n        // visibilityState.\n        firstHiddenTime = initHiddenTime();\n        addChangeListeners();\n        // Reset the time on bfcache restores.\n        onBFCacheRestore(() => {\n            // Schedule a task in order to track the `visibilityState` once it's\n            // had an opportunity to change to visible in all browsers.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=1133363\n            setTimeout(() => {\n                firstHiddenTime = initHiddenTime();\n                addChangeListeners();\n            }, 0);\n        });\n    }\n    return {\n        get firstHiddenTime() {\n            return firstHiddenTime;\n        },\n    };\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const whenActivated = (callback) => {\n    if (document.prerendering) {\n        addEventListener('prerenderingchange', () => callback(), true);\n    }\n    else {\n        callback();\n    }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { whenActivated } from './lib/whenActivated.js';\n/** Thresholds for FCP. See https://web.dev/articles/fcp#what_is_a_good_fcp_score */\nexport const FCPThresholds = [1800, 3000];\n/**\n * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `paint` performance entry used to determine the value. The reported\n * value is a `DOMHighResTimeStamp`.\n */\nexport const onFCP = (onReport, opts) => {\n    // Set defaults\n    opts = opts || {};\n    whenActivated(() => {\n        const visibilityWatcher = getVisibilityWatcher();\n        let metric = initMetric('FCP');\n        let report;\n        const handleEntries = (entries) => {\n            entries.forEach((entry) => {\n                if (entry.name === 'first-contentful-paint') {\n                    po.disconnect();\n                    // Only report if the page wasn't hidden prior to the first paint.\n                    if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                        // The activationStart reference is used because FCP should be\n                        // relative to page activation rather than navigation start if the\n                        // page was prerendered. But in cases where `activationStart` occurs\n                        // after the FCP, this time should be clamped at 0.\n                        metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n                        metric.entries.push(entry);\n                        report(true);\n                    }\n                }\n            });\n        };\n        const po = observe('paint', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered or the `paint` entry exists.\n            onBFCacheRestore((event) => {\n                metric = initMetric('FCP');\n                report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n                doubleRAF(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    report(true);\n                });\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { onFCP } from './onFCP.js';\n/** Thresholds for CLS. See https://web.dev/articles/cls#what_is_a_good_cls_score */\nexport const CLSThresholds = [0.1, 0.25];\n/**\n * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onCLS = (onReport, opts) => {\n    // Set defaults\n    opts = opts || {};\n    // Start monitoring FCP so we can only report CLS if FCP is also reported.\n    // Note: this is done to match the current behavior of CrUX.\n    onFCP(runOnce(() => {\n        let metric = initMetric('CLS', 0);\n        let report;\n        let sessionValue = 0;\n        let sessionEntries = [];\n        const handleEntries = (entries) => {\n            entries.forEach((entry) => {\n                // Only count layout shifts without recent user input.\n                if (!entry.hadRecentInput) {\n                    const firstSessionEntry = sessionEntries[0];\n                    const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n                    // If the entry occurred less than 1 second after the previous entry\n                    // and less than 5 seconds after the first entry in the session,\n                    // include the entry in the current session. Otherwise, start a new\n                    // session.\n                    if (sessionValue &&\n                        entry.startTime - lastSessionEntry.startTime < 1000 &&\n                        entry.startTime - firstSessionEntry.startTime < 5000) {\n                        sessionValue += entry.value;\n                        sessionEntries.push(entry);\n                    }\n                    else {\n                        sessionValue = entry.value;\n                        sessionEntries = [entry];\n                    }\n                }\n            });\n            // If the current session value is larger than the current CLS value,\n            // update CLS and the entries contributing to it.\n            if (sessionValue > metric.value) {\n                metric.value = sessionValue;\n                metric.entries = sessionEntries;\n                report();\n            }\n        };\n        const po = observe('layout-shift', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n            onHidden(() => {\n                handleEntries(po.takeRecords());\n                report(true);\n            });\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore(() => {\n                sessionValue = 0;\n                metric = initMetric('CLS', 0);\n                report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n                doubleRAF(() => report());\n            });\n            // Queue a task to report (if nothing else triggers a report first).\n            // This allows CLS to be reported as soon as FCP fires when\n            // `reportAllChanges` is true.\n            setTimeout(report, 0);\n        }\n    }));\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { observe } from '../observe.js';\nlet interactionCountEstimate = 0;\nlet minKnownInteractionId = Infinity;\nlet maxKnownInteractionId = 0;\nconst updateEstimate = (entries) => {\n    entries.forEach((e) => {\n        if (e.interactionId) {\n            minKnownInteractionId = Math.min(minKnownInteractionId, e.interactionId);\n            maxKnownInteractionId = Math.max(maxKnownInteractionId, e.interactionId);\n            interactionCountEstimate = maxKnownInteractionId\n                ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1\n                : 0;\n        }\n    });\n};\nlet po;\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport const getInteractionCount = () => {\n    return po ? interactionCountEstimate : performance.interactionCount || 0;\n};\n/**\n * Feature detects native support or initializes the polyfill if needed.\n */\nexport const initInteractionCountPolyfill = () => {\n    if ('interactionCount' in performance || po)\n        return;\n    po = observe('event', updateEstimate, {\n        type: 'event',\n        buffered: true,\n        durationThreshold: 0,\n    });\n};\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getInteractionCount } from './polyfills/interactionCountPolyfill.js';\n// A list of longest interactions on the page (by latency) sorted so the\n// longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER long.\nexport const longestInteractionList = [];\n// A mapping of longest interactions by their interaction ID.\n// This is used for faster lookup.\nexport const longestInteractionMap = new Map();\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nexport const DEFAULT_DURATION_THRESHOLD = 40;\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n    return getInteractionCount() - prevInteractionCount;\n};\nexport const resetInteractions = () => {\n    prevInteractionCount = getInteractionCount();\n    longestInteractionList.length = 0;\n    longestInteractionMap.clear();\n};\n/**\n * Returns the estimated p98 longest interaction based on the stored\n * interaction candidates and the interaction count for the current page.\n */\nexport const estimateP98LongestInteraction = () => {\n    const candidateInteractionIndex = Math.min(longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));\n    return longestInteractionList[candidateInteractionIndex];\n};\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n/**\n * A list of callback functions to run before each entry is processed.\n * Exposing this list allows the attribution build to hook into the\n * entry processing pipeline.\n */\nexport const entryPreProcessingCallbacks = [];\n/**\n * Takes a performance entry and adds it to the list of worst interactions\n * if its duration is long enough to make it among the worst. If the\n * entry is part of an existing interaction, it is merged and the latency\n * and entries list is updated as needed.\n */\nexport const processInteractionEntry = (entry) => {\n    entryPreProcessingCallbacks.forEach((cb) => cb(entry));\n    // Skip further processing for entries that cannot be INP candidates.\n    if (!(entry.interactionId || entry.entryType === 'first-input'))\n        return;\n    // The least-long of the 10 longest interactions.\n    const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n    const existingInteraction = longestInteractionMap.get(entry.interactionId);\n    // Only process the entry if it's possibly one of the ten longest,\n    // or if it's part of an existing interaction.\n    if (existingInteraction ||\n        longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||\n        entry.duration > minLongestInteraction.latency) {\n        // If the interaction already exists, update it. Otherwise create one.\n        if (existingInteraction) {\n            // If the new entry has a longer duration, replace the old entries,\n            // otherwise add to the array.\n            if (entry.duration > existingInteraction.latency) {\n                existingInteraction.entries = [entry];\n                existingInteraction.latency = entry.duration;\n            }\n            else if (entry.duration === existingInteraction.latency &&\n                entry.startTime === existingInteraction.entries[0].startTime) {\n                existingInteraction.entries.push(entry);\n            }\n        }\n        else {\n            const interaction = {\n                id: entry.interactionId,\n                latency: entry.duration,\n                entries: [entry],\n            };\n            longestInteractionMap.set(interaction.id, interaction);\n            longestInteractionList.push(interaction);\n        }\n        // Sort the entries by latency (descending) and keep only the top ten.\n        longestInteractionList.sort((a, b) => b.latency - a.latency);\n        if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n            longestInteractionList\n                .splice(MAX_INTERACTIONS_TO_CONSIDER)\n                .forEach((i) => longestInteractionMap.delete(i.id));\n        }\n    }\n};\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onHidden } from './onHidden.js';\nimport { runOnce } from './runOnce.js';\n/**\n * Runs the passed callback during the next idle period, or immediately\n * if the browser's visibility state is (or becomes) hidden.\n */\nexport const whenIdle = (cb) => {\n    const rIC = self.requestIdleCallback || self.setTimeout;\n    let handle = -1;\n    cb = runOnce(cb);\n    // If the document is hidden, run the callback immediately, otherwise\n    // race an idle callback with the next `visibilitychange` event.\n    if (document.visibilityState === 'hidden') {\n        cb();\n    }\n    else {\n        handle = rIC(cb);\n        onHidden(cb);\n    }\n    return handle;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { DEFAULT_DURATION_THRESHOLD, processInteractionEntry, estimateP98LongestInteraction, resetInteractions, } from './lib/interactions.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { initInteractionCountPolyfill } from './lib/polyfills/interactionCountPolyfill.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdle } from './lib/whenIdle.js';\n/** Thresholds for INP. See https://web.dev/articles/inp#what_is_a_good_inp_score */\nexport const INPThresholds = [200, 500];\n/**\n * Calculates the [INP](https://web.dev/articles/inp) value for the current\n * page and calls the `callback` function once the value is ready, along with\n * the `event` performance entries reported for that interaction. The reported\n * value is a `DOMHighResTimeStamp`.\n *\n * A custom `durationThreshold` configuration option can optionally be passed to\n * control what `event-timing` entries are considered for INP reporting. The\n * default threshold is `40`, which means INP scores of less than 40 are\n * reported as 0. Note that this will not affect your 75th percentile INP value\n * unless that value is also less than 40 (well below the recommended\n * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** INP should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onINP = (onReport, opts) => {\n    // Return if the browser doesn't support all APIs needed to measure INP.\n    if (!('PerformanceEventTiming' in self &&\n        'interactionId' in PerformanceEventTiming.prototype)) {\n        return;\n    }\n    // Set defaults\n    opts = opts || {};\n    whenActivated(() => {\n        // TODO(philipwalton): remove once the polyfill is no longer needed.\n        initInteractionCountPolyfill();\n        let metric = initMetric('INP');\n        let report;\n        const handleEntries = (entries) => {\n            // Queue the `handleEntries()` callback in the next idle task.\n            // This is needed to increase the chances that all event entries that\n            // occurred between the user interaction and the next paint\n            // have been dispatched. Note: there is currently an experiment\n            // running in Chrome (EventTimingKeypressAndCompositionInteractionId)\n            // 123+ that if rolled out fully may make this no longer necessary.\n            whenIdle(() => {\n                entries.forEach(processInteractionEntry);\n                const inp = estimateP98LongestInteraction();\n                if (inp && inp.latency !== metric.value) {\n                    metric.value = inp.latency;\n                    metric.entries = inp.entries;\n                    report();\n                }\n            });\n        };\n        const po = observe('event', handleEntries, {\n            // Event Timing entries have their durations rounded to the nearest 8ms,\n            // so a duration of 40ms would be any event that spans 2.5 or more frames\n            // at 60Hz. This threshold is chosen to strike a balance between usefulness\n            // and performance. Running this callback for any interaction that spans\n            // just one or two frames is likely not worth the insight that could be\n            // gained.\n            durationThreshold: opts.durationThreshold ?? DEFAULT_DURATION_THRESHOLD,\n        });\n        report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n        if (po) {\n            // Also observe entries of type `first-input`. This is useful in cases\n            // where the first interaction is less than the `durationThreshold`.\n            po.observe({ type: 'first-input', buffered: true });\n            onHidden(() => {\n                handleEntries(po.takeRecords());\n                report(true);\n            });\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore(() => {\n                resetInteractions();\n                metric = initMetric('INP');\n                report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdle } from './lib/whenIdle.js';\n/** Thresholds for LCP. See https://web.dev/articles/lcp#what_is_a_good_lcp_score */\nexport const LCPThresholds = [2500, 4000];\nconst reportedMetricIDs = {};\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nexport const onLCP = (onReport, opts) => {\n    // Set defaults\n    opts = opts || {};\n    whenActivated(() => {\n        const visibilityWatcher = getVisibilityWatcher();\n        let metric = initMetric('LCP');\n        let report;\n        const handleEntries = (entries) => {\n            // If reportAllChanges is set then call this function for each entry,\n            // otherwise only consider the last one.\n            if (!opts.reportAllChanges) {\n                entries = entries.slice(-1);\n            }\n            entries.forEach((entry) => {\n                // Only report if the page wasn't hidden prior to LCP.\n                if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                    // The startTime attribute returns the value of the renderTime if it is\n                    // not 0, and the value of the loadTime otherwise. The activationStart\n                    // reference is used because LCP should be relative to page activation\n                    // rather than navigation start if the page was prerendered. But in cases\n                    // where `activationStart` occurs after the LCP, this time should be\n                    // clamped at 0.\n                    metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n                    metric.entries = [entry];\n                    report();\n                }\n            });\n        };\n        const po = observe('largest-contentful-paint', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n            const stopListening = runOnce(() => {\n                if (!reportedMetricIDs[metric.id]) {\n                    handleEntries(po.takeRecords());\n                    po.disconnect();\n                    reportedMetricIDs[metric.id] = true;\n                    report(true);\n                }\n            });\n            // Stop listening after input. Note: while scrolling is an input that\n            // stops LCP observation, it's unreliable since it can be programmatically\n            // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n            ['keydown', 'click'].forEach((type) => {\n                // Wrap in a setTimeout so the callback is run in a separate task\n                // to avoid extending the keyboard/click handler to reduce INP impact\n                // https://github.com/GoogleChrome/web-vitals/issues/383\n                addEventListener(type, () => whenIdle(stopListening), {\n                    once: true,\n                    capture: true,\n                });\n            });\n            onHidden(stopListening);\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore((event) => {\n                metric = initMetric('LCP');\n                report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n                doubleRAF(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    reportedMetricIDs[metric.id] = true;\n                    report(true);\n                });\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { getNavigationEntry } from './lib/getNavigationEntry.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { whenActivated } from './lib/whenActivated.js';\n/** Thresholds for TTFB. See https://web.dev/articles/ttfb#what_is_a_good_ttfb_score */\nexport const TTFBThresholds = [800, 1800];\n/**\n * Runs in the next task after the page is done loading and/or prerendering.\n * @param callback\n */\nconst whenReady = (callback) => {\n    if (document.prerendering) {\n        whenActivated(() => whenReady(callback));\n    }\n    else if (document.readyState !== 'complete') {\n        addEventListener('load', () => whenReady(callback), true);\n    }\n    else {\n        // Queue a task so the callback runs after `loadEventEnd`.\n        setTimeout(callback, 0);\n    }\n};\n/**\n * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the\n * current page and calls the `callback` function once the page has loaded,\n * along with the relevant `navigation` performance entry used to determine the\n * value. The reported value is a `DOMHighResTimeStamp`.\n *\n * Note, this function waits until after the page is loaded to call `callback`\n * in order to ensure all properties of the `navigation` entry are populated.\n * This is useful if you want to report on other metrics exposed by the\n * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For\n * example, the TTFB metric starts from the page's [time\n * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it\n * includes time spent on DNS lookup, connection negotiation, network latency,\n * and server processing time.\n */\nexport const onTTFB = (onReport, opts) => {\n    // Set defaults\n    opts = opts || {};\n    let metric = initMetric('TTFB');\n    let report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n    whenReady(() => {\n        const navigationEntry = getNavigationEntry();\n        if (navigationEntry) {\n            // The activationStart reference is used because TTFB should be\n            // relative to page activation rather than navigation start if the\n            // page was prerendered. But in cases where `activationStart` occurs\n            // after the first byte is received, this time should be clamped at 0.\n            metric.value = Math.max(navigationEntry.responseStart - getActivationStart(), 0);\n            metric.entries = [navigationEntry];\n            report(true);\n            // Only report TTFB after bfcache restores if a `navigation` entry\n            // was reported for the initial load.\n            onBFCacheRestore(() => {\n                metric = initMetric('TTFB', 0);\n                report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n                report(true);\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = { passive: true, capture: true };\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\nexport const firstInputPolyfill = (onFirstInput) => {\n    callbacks.push(onFirstInput);\n    reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n    callbacks = [];\n    firstInputDelay = -1;\n    firstInputEvent = null;\n    eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\nconst recordFirstInputDelay = (delay, event) => {\n    if (!firstInputEvent) {\n        firstInputEvent = event;\n        firstInputDelay = delay;\n        firstInputTimeStamp = new Date();\n        eachEventType(removeEventListener);\n        reportFirstInputDelayIfRecordedAndValid();\n    }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n    // In some cases the recorded delay is clearly wrong, e.g. it's negative\n    // or it's larger than the delta between now and initialization.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n    if (firstInputDelay >= 0 &&\n        // @ts-ignore (subtracting two dates always returns a number)\n        firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n        const entry = {\n            entryType: 'first-input',\n            name: firstInputEvent.type,\n            target: firstInputEvent.target,\n            cancelable: firstInputEvent.cancelable,\n            startTime: firstInputEvent.timeStamp,\n            processingStart: firstInputEvent.timeStamp + firstInputDelay,\n        };\n        callbacks.forEach(function (callback) {\n            callback(entry);\n        });\n        callbacks = [];\n    }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\nconst onPointerDown = (delay, event) => {\n    /**\n     * Responds to 'pointerup' events and records a delay. If a pointer up event\n     * is the next event after a pointerdown event, then it's not a scroll or\n     * a pinch/zoom.\n     */\n    const onPointerUp = () => {\n        recordFirstInputDelay(delay, event);\n        removePointerEventListeners();\n    };\n    /**\n     * Responds to 'pointercancel' events and removes pointer listeners.\n     * If a 'pointercancel' is the next event to fire after a pointerdown event,\n     * it means this is a scroll or pinch/zoom interaction.\n     */\n    const onPointerCancel = () => {\n        removePointerEventListeners();\n    };\n    /**\n     * Removes added pointer event listeners.\n     */\n    const removePointerEventListeners = () => {\n        removeEventListener('pointerup', onPointerUp, listenerOpts);\n        removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n    };\n    addEventListener('pointerup', onPointerUp, listenerOpts);\n    addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\nconst onInput = (event) => {\n    // Only count cancelable events, which should trigger behavior\n    // important to the user.\n    if (event.cancelable) {\n        // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n        // (epoch time) instead of the newer `DOMHighResTimeStamp`\n        // (document-origin time). To check for that we assume any timestamp\n        // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n        // the `Date` object rather than `performance.now()`.\n        // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n        const isEpochTime = event.timeStamp > 1e12;\n        const now = isEpochTime ? new Date() : performance.now();\n        // Input delay is the delta between when the system received the event\n        // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n        const delay = now - event.timeStamp;\n        if (event.type == 'pointerdown') {\n            onPointerDown(delay, event);\n        }\n        else {\n            recordFirstInputDelay(delay, event);\n        }\n    }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\nconst eachEventType = (callback) => {\n    const eventTypes = ['mousedown', 'keydown', 'touchstart', 'pointerdown'];\n    eventTypes.forEach((type) => callback(type, onInput, listenerOpts));\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\nimport { firstInputPolyfill, resetFirstInputPolyfill, } from './lib/polyfills/firstInputPolyfill.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\n/** Thresholds for FID. See https://web.dev/articles/fid#what_is_a_good_fid_score */\nexport const FIDThresholds = [100, 300];\n/**\n * Calculates the [FID](https://web.dev/articles/fid) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `first-input` performance entry used to determine the value. The\n * reported value is a `DOMHighResTimeStamp`.\n *\n * _**Important:** since FID is only reported after the user interacts with the\n * page, it's possible that it will not be reported for some page loads._\n */\nexport const onFID = (onReport, opts) => {\n    // Set defaults\n    opts = opts || {};\n    whenActivated(() => {\n        const visibilityWatcher = getVisibilityWatcher();\n        let metric = initMetric('FID');\n        let report;\n        const handleEntry = (entry) => {\n            // Only report if the page wasn't hidden prior to the first input.\n            if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                metric.value = entry.processingStart - entry.startTime;\n                metric.entries.push(entry);\n                report(true);\n            }\n        };\n        const handleEntries = (entries) => {\n            entries.forEach(handleEntry);\n        };\n        const po = observe('first-input', handleEntries);\n        report = bindReporter(onReport, metric, FIDThresholds, opts.reportAllChanges);\n        if (po) {\n            onHidden(runOnce(() => {\n                handleEntries(po.takeRecords());\n                po.disconnect();\n            }));\n            onBFCacheRestore(() => {\n                metric = initMetric('FID');\n                report = bindReporter(onReport, metric, FIDThresholds, opts.reportAllChanges);\n                // Browsers don't re-emit FID on bfcache restore so fake it until you make it\n                resetFirstInputPolyfill();\n                firstInputPolyfill(handleEntry);\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { onCLS } from './onCLS.js';\nexport { onFCP } from './onFCP.js';\nexport { onINP } from './onINP.js';\nexport { onLCP } from './onLCP.js';\nexport { onTTFB } from './onTTFB.js';\nexport { CLSThresholds } from '../onCLS.js';\nexport { FCPThresholds } from '../onFCP.js';\nexport { INPThresholds } from '../onINP.js';\nexport { LCPThresholds } from '../onLCP.js';\nexport { TTFBThresholds } from '../onTTFB.js';\nexport * from './deprecated.js';\nexport * from '../types.js';\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const getLoadState = (timestamp) => {\n    if (document.readyState === 'loading') {\n        // If the `readyState` is 'loading' there's no need to look at timestamps\n        // since the timestamp has to be the current time or earlier.\n        return 'loading';\n    }\n    else {\n        const navigationEntry = getNavigationEntry();\n        if (navigationEntry) {\n            if (timestamp < navigationEntry.domInteractive) {\n                return 'loading';\n            }\n            else if (navigationEntry.domContentLoadedEventStart === 0 ||\n                timestamp < navigationEntry.domContentLoadedEventStart) {\n                // If the `domContentLoadedEventStart` timestamp has not yet been\n                // set, or if the given timestamp is less than that value.\n                return 'dom-interactive';\n            }\n            else if (navigationEntry.domComplete === 0 ||\n                timestamp < navigationEntry.domComplete) {\n                // If the `domComplete` timestamp has not yet been\n                // set, or if the given timestamp is less than that value.\n                return 'dom-content-loaded';\n            }\n        }\n    }\n    // If any of the above fail, default to loaded. This could really only\n    // happy if the browser doesn't support the performance timeline, which\n    // most likely means this code would never run anyway.\n    return 'complete';\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getName = (node) => {\n    const name = node.nodeName;\n    return node.nodeType === 1\n        ? name.toLowerCase()\n        : name.toUpperCase().replace(/^#/, '');\n};\nexport const getSelector = (node, maxLen) => {\n    let sel = '';\n    try {\n        while (node && node.nodeType !== 9) {\n            const el = node;\n            const part = el.id\n                ? '#' + el.id\n                : getName(el) +\n                    (el.classList &&\n                        el.classList.value &&\n                        el.classList.value.trim() &&\n                        el.classList.value.trim().length\n                        ? '.' + el.classList.value.trim().replace(/\\s+/g, '.')\n                        : '');\n            if (sel.length + part.length > (maxLen || 100) - 1)\n                return sel || part;\n            sel = sel ? part + '>' + sel : part;\n            if (el.id)\n                break;\n            node = el.parentNode;\n        }\n    }\n    catch (err) {\n        // Do nothing...\n    }\n    return sel;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { onCLS as unattributedOnCLS } from '../onCLS.js';\nconst getLargestLayoutShiftEntry = (entries) => {\n    return entries.reduce((a, b) => (a && a.value > b.value ? a : b));\n};\nconst getLargestLayoutShiftSource = (sources) => {\n    return sources.find((s) => s.node && s.node.nodeType === 1) || sources[0];\n};\nconst attributeCLS = (metric) => {\n    // Use an empty object if no other attribution has been set.\n    let attribution = {};\n    if (metric.entries.length) {\n        const largestEntry = getLargestLayoutShiftEntry(metric.entries);\n        if (largestEntry && largestEntry.sources && largestEntry.sources.length) {\n            const largestSource = getLargestLayoutShiftSource(largestEntry.sources);\n            if (largestSource) {\n                attribution = {\n                    largestShiftTarget: getSelector(largestSource.node),\n                    largestShiftTime: largestEntry.startTime,\n                    largestShiftValue: largestEntry.value,\n                    largestShiftSource: largestSource,\n                    largestShiftEntry: largestEntry,\n                    loadState: getLoadState(largestEntry.startTime),\n                };\n            }\n        }\n    }\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onCLS = (onReport, opts) => {\n    unattributedOnCLS((metric) => {\n        const metricWithAttribution = attributeCLS(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getBFCacheRestoreTime } from '../lib/bfcache.js';\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getNavigationEntry } from '../lib/getNavigationEntry.js';\nimport { onFCP as unattributedOnFCP } from '../onFCP.js';\nconst attributeFCP = (metric) => {\n    // Use a default object if no other attribution has been set.\n    let attribution = {\n        timeToFirstByte: 0,\n        firstByteToFCP: metric.value,\n        loadState: getLoadState(getBFCacheRestoreTime()),\n    };\n    if (metric.entries.length) {\n        const navigationEntry = getNavigationEntry();\n        const fcpEntry = metric.entries[metric.entries.length - 1];\n        if (navigationEntry) {\n            const activationStart = navigationEntry.activationStart || 0;\n            const ttfb = Math.max(0, navigationEntry.responseStart - activationStart);\n            attribution = {\n                timeToFirstByte: ttfb,\n                firstByteToFCP: metric.value - ttfb,\n                loadState: getLoadState(metric.entries[0].startTime),\n                navigationEntry,\n                fcpEntry,\n            };\n        }\n    }\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `paint` performance entry used to determine the value. The reported\n * value is a `DOMHighResTimeStamp`.\n */\nexport const onFCP = (onReport, opts) => {\n    unattributedOnFCP((metric) => {\n        const metricWithAttribution = attributeFCP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { longestInteractionList, entryPreProcessingCallbacks, longestInteractionMap, } from '../lib/interactions.js';\nimport { observe } from '../lib/observe.js';\nimport { whenIdle } from '../lib/whenIdle.js';\nimport { onINP as unattributedOnINP } from '../onINP.js';\n// The maximum number of previous frames for which data is kept.\n// Storing data about previous frames is necessary to handle cases where event\n// and LoAF entries are dispatched out of order, and so a buffer of previous\n// frame data is needed to determine various bits of INP attribution once all\n// the frame-related data has come in.\n// In most cases this out-of-order data is only off by a frame or two, so\n// keeping the most recent 50 should be more than sufficient.\nconst MAX_PREVIOUS_FRAMES = 50;\n// A PerformanceObserver, observing new `long-animation-frame` entries.\n// If this variable is defined it means the browser supports LoAF.\nlet loafObserver;\n// A list of LoAF entries that have been dispatched and could potentially\n// intersect with the INP candidate interaction. Note that periodically this\n// list is cleaned up and entries that are known to not match INP are removed.\nlet pendingLoAFs = [];\n// An array of groups of all the event timing entries that occurred within a\n// particular frame. Note that periodically this array is cleaned up and entries\n// that are known to not match INP are removed.\nlet pendingEntriesGroups = [];\n// The `processingEnd` time of most recently-processed event, chronologically.\nlet latestProcessingEnd = 0;\n// A WeakMap to look up the event-timing-entries group of a given entry.\n// Note that this only maps from \"important\" entries: either the first input or\n// those with an `interactionId`.\nconst entryToEntriesGroupMap = new WeakMap();\n// A mapping of interactionIds to the target Node.\nexport const interactionTargetMap = new Map();\n// A reference to the idle task used to clean up entries from the above\n// variables. If the value is -1 it means no task is queue, and if it's\n// greater than -1 the value corresponds to the idle callback handle.\nlet idleHandle = -1;\n/**\n * Adds new LoAF entries to the `pendingLoAFs` list.\n */\nconst handleLoAFEntries = (entries) => {\n    pendingLoAFs = pendingLoAFs.concat(entries);\n    queueCleanup();\n};\n// Get a reference to the interaction target element in case it's removed\n// from the DOM later.\nconst saveInteractionTarget = (entry) => {\n    // TODO(b/376777343): Remove this modification when web-vitals.js doesn't retain DOM nodes anymore\n    // Although it is useful for DevTools to retain nodes for diagnostic purposes, it is not preferable\n    // to retaining Nodes in memory when the user does not expect them to.\n    //\n    // if (entry.interactionId &&\n    //     entry.target &&\n    //     !interactionTargetMap.has(entry.interactionId)) {\n    //     interactionTargetMap.set(entry.interactionId, entry.target);\n    // }\n};\n/**\n * Groups entries that were presented within the same animation frame by\n * a common `renderTime`. This function works by referencing\n * `pendingEntriesGroups` and using an existing render time if one is found\n * (otherwise creating a new one). This function also adds all interaction\n * entries to an `entryToRenderTimeMap` WeakMap so that the \"grouped\" entries\n * can be looked up later.\n */\nconst groupEntriesByRenderTime = (entry) => {\n    const renderTime = entry.startTime + entry.duration;\n    let group;\n    latestProcessingEnd = Math.max(latestProcessingEnd, entry.processingEnd);\n    // Iterate over all previous render times in reverse order to find a match.\n    // Go in reverse since the most likely match will be at the end.\n    for (let i = pendingEntriesGroups.length - 1; i >= 0; i--) {\n        const potentialGroup = pendingEntriesGroups[i];\n        // If a group's render time is within 8ms of the entry's render time,\n        // assume they were part of the same frame and add it to the group.\n        if (Math.abs(renderTime - potentialGroup.renderTime) <= 8) {\n            group = potentialGroup;\n            group.startTime = Math.min(entry.startTime, group.startTime);\n            group.processingStart = Math.min(entry.processingStart, group.processingStart);\n            group.processingEnd = Math.max(entry.processingEnd, group.processingEnd);\n            group.entries.push(entry);\n            break;\n        }\n    }\n    // If there was no matching group, assume this is a new frame.\n    if (!group) {\n        group = {\n            startTime: entry.startTime,\n            processingStart: entry.processingStart,\n            processingEnd: entry.processingEnd,\n            renderTime,\n            entries: [entry],\n        };\n        pendingEntriesGroups.push(group);\n    }\n    // Store the grouped render time for this entry for reference later.\n    if (entry.interactionId || entry.entryType === 'first-input') {\n        entryToEntriesGroupMap.set(entry, group);\n    }\n    queueCleanup();\n};\nconst queueCleanup = () => {\n    // Queue cleanup of entries that are not part of any INP candidates.\n    if (idleHandle < 0) {\n        idleHandle = whenIdle(cleanupEntries);\n    }\n};\nconst cleanupEntries = () => {\n    // Delete any stored interaction target elements if they're not part of one\n    // of the 10 longest interactions.\n    if (interactionTargetMap.size > 10) {\n        interactionTargetMap.forEach((_, key) => {\n            if (!longestInteractionMap.has(key)) {\n                interactionTargetMap.delete(key);\n            }\n        });\n    }\n    // Keep all render times that are part of a pending INP candidate or\n    // that occurred within the 50 most recently-dispatched groups of events.\n    const longestInteractionGroups = longestInteractionList.map((i) => {\n        return entryToEntriesGroupMap.get(i.entries[0]);\n    });\n    const minIndex = pendingEntriesGroups.length - MAX_PREVIOUS_FRAMES;\n    pendingEntriesGroups = pendingEntriesGroups.filter((group, index) => {\n        if (index >= minIndex)\n            return true;\n        return longestInteractionGroups.includes(group);\n    });\n    // Keep all pending LoAF entries that either:\n    // 1) intersect with entries in the newly cleaned up `pendingEntriesGroups`\n    // 2) occur after the most recently-processed event entry (for up to MAX_PREVIOUS_FRAMES)\n    const loafsToKeep = new Set();\n    for (let i = 0; i < pendingEntriesGroups.length; i++) {\n        const group = pendingEntriesGroups[i];\n        getIntersectingLoAFs(group.startTime, group.processingEnd).forEach((loaf) => {\n            loafsToKeep.add(loaf);\n        });\n    }\n    const prevFrameIndexCutoff = pendingLoAFs.length - 1 - MAX_PREVIOUS_FRAMES;\n    // Filter `pendingLoAFs` to preserve LoAF order.\n    pendingLoAFs = pendingLoAFs.filter((loaf, index) => {\n        if (loaf.startTime > latestProcessingEnd && index > prevFrameIndexCutoff) {\n            return true;\n        }\n        return loafsToKeep.has(loaf);\n    });\n    // Reset the idle callback handle so it can be queued again.\n    idleHandle = -1;\n};\nentryPreProcessingCallbacks.push(saveInteractionTarget, groupEntriesByRenderTime);\nconst getIntersectingLoAFs = (start, end) => {\n    const intersectingLoAFs = [];\n    for (let i = 0, loaf; (loaf = pendingLoAFs[i]); i++) {\n        // If the LoAF ends before the given start time, ignore it.\n        if (loaf.startTime + loaf.duration < start)\n            continue;\n        // If the LoAF starts after the given end time, ignore it and all\n        // subsequent pending LoAFs (because they're in time order).\n        if (loaf.startTime > end)\n            break;\n        // Still here? If so this LoAF intersects with the interaction.\n        intersectingLoAFs.push(loaf);\n    }\n    return intersectingLoAFs;\n};\nexport const attributeINP = (metric) => {\n    const firstEntry = metric.entries[0];\n    const group = entryToEntriesGroupMap.get(firstEntry);\n    const processingStart = firstEntry.processingStart;\n    const processingEnd = group.processingEnd;\n    // Sort the entries in processing time order.\n    const processedEventEntries = group.entries.sort((a, b) => {\n        return a.processingStart - b.processingStart;\n    });\n    const longAnimationFrameEntries = getIntersectingLoAFs(firstEntry.startTime, processingEnd);\n    // The first interaction entry may not have a target defined, so use the\n    // first one found in the entry list.\n    // TODO: when the following bug is fixed just use `firstInteractionEntry`.\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1367329\n    // As a fallback, also check the interactionTargetMap (to account for\n    // cases where the element is removed from the DOM before reporting happens).\n    const firstEntryWithTarget = metric.entries.find((entry) => entry.target);\n    const interactionTargetElement = (firstEntryWithTarget && firstEntryWithTarget.target) ||\n        interactionTargetMap.get(firstEntry.interactionId);\n    // Since entry durations are rounded to the nearest 8ms, we need to clamp\n    // the `nextPaintTime` value to be higher than the `processingEnd` or\n    // end time of any LoAF entry.\n    const nextPaintTimeCandidates = [\n        firstEntry.startTime + firstEntry.duration,\n        processingEnd,\n    ].concat(longAnimationFrameEntries.map((loaf) => loaf.startTime + loaf.duration));\n    const nextPaintTime = Math.max.apply(Math, nextPaintTimeCandidates);\n    const attribution = {\n        interactionTarget: getSelector(interactionTargetElement),\n        interactionTargetElement: interactionTargetElement,\n        interactionType: firstEntry.name.startsWith('key') ? 'keyboard' : 'pointer',\n        interactionTime: firstEntry.startTime,\n        nextPaintTime: nextPaintTime,\n        processedEventEntries: processedEventEntries,\n        longAnimationFrameEntries: longAnimationFrameEntries,\n        inputDelay: processingStart - firstEntry.startTime,\n        processingDuration: processingEnd - processingStart,\n        presentationDelay: Math.max(nextPaintTime - processingEnd, 0),\n        loadState: getLoadState(firstEntry.startTime),\n    };\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [INP](https://web.dev/articles/inp) value for the current\n * page and calls the `callback` function once the value is ready, along with\n * the `event` performance entries reported for that interaction. The reported\n * value is a `DOMHighResTimeStamp`.\n *\n * A custom `durationThreshold` configuration option can optionally be passed to\n * control what `event-timing` entries are considered for INP reporting. The\n * default threshold is `40`, which means INP scores of less than 40 are\n * reported as 0. Note that this will not affect your 75th percentile INP value\n * unless that value is also less than 40 (well below the recommended\n * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** INP should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onINP = (onReport, opts) => {\n    if (!loafObserver) {\n        loafObserver = observe('long-animation-frame', handleLoAFEntries);\n    }\n    unattributedOnINP((metric) => {\n        const metricWithAttribution = attributeINP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from '../lib/getNavigationEntry.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { onLCP as unattributedOnLCP } from '../onLCP.js';\nconst attributeLCP = (metric) => {\n    // Use a default object if no other attribution has been set.\n    let attribution = {\n        timeToFirstByte: 0,\n        resourceLoadDelay: 0,\n        resourceLoadDuration: 0,\n        elementRenderDelay: metric.value,\n    };\n    if (metric.entries.length) {\n        const navigationEntry = getNavigationEntry();\n        if (navigationEntry) {\n            const activationStart = navigationEntry.activationStart || 0;\n            const lcpEntry = metric.entries[metric.entries.length - 1];\n            const lcpResourceEntry = lcpEntry.url &&\n                performance\n                    .getEntriesByType('resource')\n                    .filter((e) => e.name === lcpEntry.url)[0];\n            const ttfb = Math.max(0, navigationEntry.responseStart - activationStart);\n            const lcpRequestStart = Math.max(ttfb, \n            // Prefer `requestStart` (if TOA is set), otherwise use `startTime`.\n            lcpResourceEntry\n                ? (lcpResourceEntry.requestStart || lcpResourceEntry.startTime) -\n                    activationStart\n                : 0);\n            const lcpResponseEnd = Math.max(lcpRequestStart, lcpResourceEntry ? lcpResourceEntry.responseEnd - activationStart : 0);\n            const lcpRenderTime = Math.max(lcpResponseEnd, lcpEntry.startTime - activationStart);\n            attribution = {\n                element: getSelector(lcpEntry.element),\n                timeToFirstByte: ttfb,\n                resourceLoadDelay: lcpRequestStart - ttfb,\n                resourceLoadDuration: lcpResponseEnd - lcpRequestStart,\n                elementRenderDelay: lcpRenderTime - lcpResponseEnd,\n                navigationEntry,\n                lcpEntry,\n            };\n            // Only attribution the URL and resource entry if they exist.\n            if (lcpEntry.url) {\n                attribution.url = lcpEntry.url;\n            }\n            if (lcpResourceEntry) {\n                attribution.lcpResourceEntry = lcpResourceEntry;\n            }\n        }\n    }\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nexport const onLCP = (onReport, opts) => {\n    unattributedOnLCP((metric) => {\n        const metricWithAttribution = attributeLCP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onTTFB as unattributedOnTTFB } from '../onTTFB.js';\nconst attributeTTFB = (metric) => {\n    // Use a default object if no other attribution has been set.\n    let attribution = {\n        waitingDuration: 0,\n        cacheDuration: 0,\n        dnsDuration: 0,\n        connectionDuration: 0,\n        requestDuration: 0,\n    };\n    if (metric.entries.length) {\n        const navigationEntry = metric.entries[0];\n        const activationStart = navigationEntry.activationStart || 0;\n        // Measure from workerStart or fetchStart so any service worker startup\n        // time is included in cacheDuration (which also includes other sw time\n        // anyway, that cannot be accurately split out cross-browser).\n        const waitEnd = Math.max((navigationEntry.workerStart || navigationEntry.fetchStart) -\n            activationStart, 0);\n        const dnsStart = Math.max(navigationEntry.domainLookupStart - activationStart, 0);\n        const connectStart = Math.max(navigationEntry.connectStart - activationStart, 0);\n        const connectEnd = Math.max(navigationEntry.connectEnd - activationStart, 0);\n        attribution = {\n            waitingDuration: waitEnd,\n            cacheDuration: dnsStart - waitEnd,\n            // dnsEnd usually equals connectStart but use connectStart over dnsEnd\n            // for dnsDuration in case there ever is a gap.\n            dnsDuration: connectStart - dnsStart,\n            connectionDuration: connectEnd - connectStart,\n            // There is often a gap between connectEnd and requestStart. Attribute\n            // that to requestDuration so connectionDuration remains 0 for\n            // service worker controlled requests were connectStart and connectEnd\n            // are the same.\n            requestDuration: metric.value - connectEnd,\n            navigationEntry: navigationEntry,\n        };\n    }\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the\n * current page and calls the `callback` function once the page has loaded,\n * along with the relevant `navigation` performance entry used to determine the\n * value. The reported value is a `DOMHighResTimeStamp`.\n *\n * Note, this function waits until after the page is loaded to call `callback`\n * in order to ensure all properties of the `navigation` entry are populated.\n * This is useful if you want to report on other metrics exposed by the\n * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For\n * example, the TTFB metric starts from the page's [time\n * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it\n * includes time spent on DNS lookup, connection negotiation, network latency,\n * and server processing time.\n */\nexport const onTTFB = (onReport, opts) => {\n    unattributedOnTTFB((metric) => {\n        const metricWithAttribution = attributeTTFB(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { onFID as unattributedOnFID } from '../onFID.js';\nconst attributeFID = (metric) => {\n    const fidEntry = metric.entries[0];\n    const attribution = {\n        eventTarget: getSelector(fidEntry.target),\n        eventType: fidEntry.name,\n        eventTime: fidEntry.startTime,\n        eventEntry: fidEntry,\n        loadState: getLoadState(fidEntry.startTime),\n    };\n    // Use Object.assign to set property to keep tsc happy.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [FID](https://web.dev/articles/fid) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `first-input` performance entry used to determine the value. The\n * reported value is a `DOMHighResTimeStamp`.\n *\n * _**Important:** since FID is only reported after the user interacts with the\n * page, it's possible that it will not be reported for some page loads._\n */\nexport const onFID = (onReport, opts) => {\n    unattributedOnFID((metric) => {\n        const metricWithAttribution = attributeFID(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n"],
  "mappings": "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",
  "names": ["po", "po", "po", "po", "po", "po", "onCLS", "onFCP", "onFID", "onINP", "onLCP", "onTTFB", "onCLS", "onFCP", "onINP", "onLCP", "onTTFB", "onFID"]
}
