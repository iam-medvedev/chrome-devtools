{"version":3,"file":"parser_checks.js","sourceRoot":"","sources":["../../../../../../../../front_end/third_party/csp_evaluator/package/checks/parser_checks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileoverview Collection of CSP parser checks which can be used to find\n * common syntax mistakes like missing semicolons, invalid directives or\n * invalid keywords.\n * @author lwe@google.com (Lukas Weichselbaum)\n *\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as csp from '../csp.js';\nimport {Csp, Keyword} from '../csp.js';\n\nimport {Finding, Severity, Type} from '../finding.js';\n\n\n/**\n * Checks if the csp contains invalid directives.\n *\n * Example policy where this check would trigger:\n *  foobar-src foo.bar\n *\n * @param parsedCsp A parsed csp.\n */\nexport function checkUnknownDirective(parsedCsp: Csp): Finding[] {\n  const findings: Finding[] = [];\n\n  for (const directive of Object.keys(parsedCsp.directives)) {\n    if (csp.isDirective(directive)) {\n      // Directive is known.\n      continue;\n    }\n\n    if (directive.endsWith(':')) {\n      findings.push(new Finding(\n          Type.UNKNOWN_DIRECTIVE, 'CSP directives don\\'t end with a colon.',\n          Severity.SYNTAX, directive));\n    } else {\n      findings.push(new Finding(\n          Type.UNKNOWN_DIRECTIVE,\n          'Directive \"' + directive + '\" is not a known CSP directive.',\n          Severity.SYNTAX, directive));\n    }\n  }\n\n  return findings;\n}\n\n\n/**\n * Checks if semicolons are missing in the csp.\n *\n * Example policy where this check would trigger (missing semicolon before\n * start of object-src):\n *  script-src foo.bar object-src 'none'\n *\n * @param parsedCsp A parsed csp.\n */\nexport function checkMissingSemicolon(parsedCsp: Csp): Finding[] {\n  const findings: Finding[] = [];\n\n  for (const [directive, directiveValues] of Object.entries(\n           parsedCsp.directives)) {\n    if (directiveValues === undefined) {\n      continue;\n    }\n    for (const value of directiveValues) {\n      // If we find a known directive inside a directive value, it is very\n      // likely that a semicolon was forgoten.\n      if (csp.isDirective(value)) {\n        findings.push(new Finding(\n            Type.MISSING_SEMICOLON,\n            'Did you forget the semicolon? ' +\n                '\"' + value + '\" seems to be a directive, not a value.',\n            Severity.SYNTAX, directive, value));\n      }\n    }\n  }\n\n  return findings;\n}\n\n\n/**\n * Checks if csp contains invalid keywords.\n *\n * Example policy where this check would trigger:\n *  script-src 'notAkeyword'\n *\n * @param parsedCsp A parsed csp.\n */\nexport function checkInvalidKeyword(parsedCsp: Csp): Finding[] {\n  const findings: Finding[] = [];\n  const keywordsNoTicks =\n      Object.values(Keyword).map((k) => k.replace(/'/g, ''));\n\n  for (const [directive, directiveValues] of Object.entries(\n           parsedCsp.directives)) {\n    if (directiveValues === undefined) {\n      continue;\n    }\n    for (const value of directiveValues) {\n      // Check if single ticks have been forgotten.\n      if (keywordsNoTicks.some((k) => k === value) ||\n          value.startsWith('nonce-') ||\n          value.match(/^(sha256|sha384|sha512)-/)) {\n        findings.push(new Finding(\n            Type.INVALID_KEYWORD,\n            'Did you forget to surround \"' + value + '\" with single-ticks?',\n            Severity.SYNTAX, directive, value));\n        continue;\n      }\n\n      // Continue, if the value doesn't start with single tick.\n      // All CSP keywords start with a single tick.\n      if (!value.startsWith('\\'')) {\n        continue;\n      }\n\n      if (directive === csp.Directive.REQUIRE_TRUSTED_TYPES_FOR) {\n        // Continue, if it's an allowed Trusted Types sink.\n        if (value === csp.TrustedTypesSink.SCRIPT) {\n          continue;\n        }\n      } else if (directive === csp.Directive.TRUSTED_TYPES) {\n        // Continue, if it's an allowed Trusted Types keyword.\n        if (value === '\\'allow-duplicates\\'' || value === '\\'none\\'') {\n          continue;\n        }\n      } else {\n        // Continue, if it's a valid keyword.\n        if (csp.isKeyword(value) || csp.isHash(value) || csp.isNonce(value)) {\n          continue;\n        }\n      }\n\n      findings.push(new Finding(\n          Type.INVALID_KEYWORD, value + ' seems to be an invalid CSP keyword.',\n          Severity.SYNTAX, directive, value));\n    }\n  }\n\n  return findings;\n}\n\n"]}