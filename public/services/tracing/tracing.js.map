{
  "version": 3,
  "sources": ["../../../../../../front_end/services/tracing/ExternalRequests.ts", "../../../../../../front_end/services/tracing/PerformanceTracing.ts", "../../../../../../front_end/services/tracing/TracingManager.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../models/trace/trace.js';\nimport * as TimelineUtils from '../../panels/timeline/utils/utils.js';\n\ntype InsightResponse = {\n  focus: TimelineUtils.AIContext.AgentFocus,\n}|{error: string};\n\n/**\n * For an external request, get the insight to debug based on its user visible title.\n * Currently, this function makes some assumptions that in time we will need to\n * avoid:\n * - It assumes a trace exists that had one or zero navigations. It is unable\n *   to figure out which insight to use if there are >1 navigations -it would need\n *   some extra input data to figure it out.\n */\nexport async function getInsightAgentFocusToDebug(\n    model: Trace.TraceModel.Model, insightTitle: string): Promise<InsightResponse> {\n  const parsedTrace = model.parsedTrace();\n  const latestInsights = model.traceInsights();\n  if (!latestInsights || !parsedTrace) {\n    return {\n      error: 'No trace has been recorded, so we cannot analyze any insights',\n    };\n  }\n\n  // Right now we only support the basic Reload & Record flow and assume\n  // there is always one navigation. Longer term we need a more robust way\n  // for the request to specify which navigation it's interested in.\n  const firstNavigation = Array.from(latestInsights.keys()).find(k => k !== Trace.Types.Events.NO_NAVIGATION);\n  const insights =\n      firstNavigation ? latestInsights.get(firstNavigation) : latestInsights.get(Trace.Types.Events.NO_NAVIGATION);\n  if (!insights) {\n    return {\n      error: 'Could not find any navigation with insights.',\n    };\n  }\n\n  const insightKeys = Object.keys(insights.model) as Array<keyof Trace.Insights.Types.InsightModels>;\n  const matchingInsightKey = insightKeys.find(insightKey => {\n    const insight = insights.model[insightKey];\n    return insight.title === insightTitle;\n  });\n  if (!matchingInsightKey) {\n    return {\n      error: `Could not find matching insight for ${insightTitle}`,\n    };\n  }\n\n  const insight = insights.model[matchingInsightKey];\n  const focus = TimelineUtils.AIContext.AgentFocus.fromInsight(parsedTrace, insight, insights.bounds);\n  return {focus};\n}\n", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\n\nimport {TracingManager, type TracingManagerClient} from './TracingManager.js';\n\nexport class PerformanceTracing implements TracingManagerClient {\n  readonly #traceEvents: Object[] = [];\n  #tracingManager: TracingManager|null = null;\n  #delegate: Delegate;\n\n  constructor(target: SDK.Target.Target, delegate: Delegate) {\n    this.#tracingManager = target.model(TracingManager);\n    this.#delegate = delegate;\n  }\n\n  async start(): Promise<void> {\n    this.#traceEvents.length = 0;\n\n    if (!this.#tracingManager) {\n      throw new Error('No tracing manager');\n    }\n\n    // This panel may be opened with trace data recorded in other tools.\n    // Keep in sync with the categories arrays in:\n    // https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/panels/timeline/TimelineController.ts\n    // https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/gather/gatherers/trace.js\n    const categories = [\n      '-*',\n      'blink.console',\n      'blink.user_timing',\n      'devtools.timeline',\n      'disabled-by-default-devtools.screenshot',\n      'disabled-by-default-devtools.timeline',\n      'disabled-by-default-devtools.timeline.invalidationTracking',\n      'disabled-by-default-devtools.timeline.frame',\n      'disabled-by-default-devtools.timeline.stack',\n      'disabled-by-default-v8.cpu_profiler',\n      'disabled-by-default-v8.cpu_profiler.hires',\n      'latencyInfo',\n      'loading',\n      'disabled-by-default-lighthouse',\n      'v8.execute',\n      'v8',\n    ].join(',');\n\n    const started = await this.#tracingManager.start(this, categories);\n\n    if (!started) {\n      throw new Error('Unable to start tracing.');\n    }\n  }\n\n  async stop(): Promise<void> {\n    return this.#tracingManager?.stop();\n  }\n\n  // Start of implementation of SDK.TracingManager.TracingManagerClient\n  traceEventsCollected(events: Object[]): void {\n    this.#traceEvents.push(...events);\n  }\n\n  tracingBufferUsage(usage: number): void {\n    this.#delegate.tracingBufferUsage(usage);\n  }\n\n  eventsRetrievalProgress(progress: number): void {\n    this.#delegate.eventsRetrievalProgress(progress);\n  }\n\n  tracingComplete(): void {\n    this.#delegate.tracingComplete(this.#traceEvents);\n  }\n  // End of implementation of SDK.TracingManager.TracingManagerClient\n}\n\ninterface Delegate {\n  tracingBufferUsage(usage: number): void;\n  eventsRetrievalProgress(progress: number): void;\n  tracingComplete(events: Object[]): void;\n}\n\n// Used by an implementation of Common.Revealer to transfer data from the recorder to the performance panel.\nexport class RawTraceEvents {\n  constructor(private events: Object[]) {\n  }\n\n  getEvents(): Object[] {\n    return this.events;\n  }\n}\n", "// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport type * as Trace from '../../models/trace/trace.js';\n\nexport class TracingManager extends SDK.SDKModel.SDKModel<void> {\n  readonly #tracingAgent: ProtocolProxyApi.TracingApi;\n  #activeClient: TracingManagerClient|null;\n  #eventsRetrieved: number;\n  #finishing?: boolean;\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.#tracingAgent = target.tracingAgent();\n    target.registerTracingDispatcher(new TracingDispatcher(this));\n\n    this.#activeClient = null;\n    this.#eventsRetrieved = 0;\n  }\n\n  bufferUsage(usage?: number, percentFull?: number): void {\n    if (this.#activeClient) {\n      this.#activeClient.tracingBufferUsage(usage || percentFull || 0);\n    }\n  }\n\n  eventsCollected(events: Trace.Types.Events.Event[]): void {\n    if (!this.#activeClient) {\n      return;\n    }\n    this.#activeClient.traceEventsCollected(events);\n    this.#eventsRetrieved += events.length;\n\n    // CDP no longer provides an approximate_event_count AKA eventCount. It's always 0.\n    // To give some idea of progress we'll compare to a large (900k event) trace.\n    // And we'll clamp both sides so the user sees some progress, and never maxed at 99%\n    const progress = Math.min((this.#eventsRetrieved / 900_000) + 0.15, 0.90);\n    this.#activeClient.eventsRetrievalProgress(progress);\n  }\n\n  tracingComplete(): void {\n    this.#eventsRetrieved = 0;\n    if (this.#activeClient) {\n      this.#activeClient.tracingComplete();\n      this.#activeClient = null;\n    }\n    this.#finishing = false;\n  }\n\n  async reset(): Promise<void> {\n    // If we have an active client, we should try to stop\n    // it before resetting it, else we will leave the\n    // backend in a broken state where it thinks we are in\n    // the middle of tracing, but we think we are not.\n    // Then, any subsequent attempts to record will fail\n    // because the backend will not let us start a second\n    // tracing session.\n    if (this.#activeClient) {\n      await this.#tracingAgent.invoke_end();\n    }\n    this.#eventsRetrieved = 0;\n    this.#activeClient = null;\n    this.#finishing = false;\n  }\n\n  async start(client: TracingManagerClient, categoryFilter: string): Promise<Protocol.ProtocolResponseWithError> {\n    if (this.#activeClient) {\n      throw new Error('Tracing is already started');\n    }\n    const bufferUsageReportingIntervalMs = 500;\n    this.#activeClient = client;\n    const args = {\n      bufferUsageReportingInterval: bufferUsageReportingIntervalMs,\n      transferMode: Protocol.Tracing.StartRequestTransferMode.ReportEvents,\n      traceConfig: {\n        recordMode: Protocol.Tracing.TraceConfigRecordMode.RecordUntilFull,\n        traceBufferSizeInKb: 1200 * 1000,\n        includedCategories: categoryFilter.split(','),\n      },\n    };\n    const response = await this.#tracingAgent.invoke_start(args);\n    if (response.getError()) {\n      this.#activeClient = null;\n    }\n    return response;\n  }\n\n  stop(): void {\n    if (!this.#activeClient) {\n      throw new Error('Tracing is not started');\n    }\n    if (this.#finishing) {\n      throw new Error('Tracing is already being stopped');\n    }\n    this.#finishing = true;\n    void this.#tracingAgent.invoke_end();\n  }\n}\n\nexport interface TracingManagerClient {\n  traceEventsCollected(events: Trace.Types.Events.Event[]): void;\n\n  tracingComplete(): void;\n  tracingBufferUsage(usage: number): void;\n  eventsRetrievalProgress(progress: number): void;\n}\n\nclass TracingDispatcher implements ProtocolProxyApi.TracingDispatcher {\n  readonly #tracingManager: TracingManager;\n  constructor(tracingManager: TracingManager) {\n    this.#tracingManager = tracingManager;\n  }\n\n  // `eventCount` will always be 0 as perfetto no longer calculates `approximate_event_count`\n  bufferUsage({value, percentFull}: Protocol.Tracing.BufferUsageEvent): void {\n    this.#tracingManager.bufferUsage(value, percentFull);\n  }\n\n  dataCollected({value}: Protocol.Tracing.DataCollectedEvent): void {\n    this.#tracingManager.eventsCollected(value);\n  }\n\n  tracingComplete(): void {\n    this.#tracingManager.tracingComplete();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(TracingManager, {capabilities: SDK.Target.Capability.TRACING, autostart: false});\n"],
  "mappings": "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",
  "names": ["insight"]
}
