{"version":3,"file":"TraceBounds.js","sourceRoot":"","sources":["../../../../../../front_end/services/trace_bounds/TraceBounds.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as TraceEngine from '../../models/trace/trace.js';\n\nlet instance: BoundsManager|null = null;\n\nexport class TimelineVisibleWindowChanged extends Event {\n  static readonly eventName = 'timelinevisiblewindowchanged';\n\n  constructor(public state: Readonly<TraceWindows>, public shouldAnimate: boolean) {\n    super(TimelineVisibleWindowChanged.eventName, {composed: true, bubbles: true});\n  }\n}\n\nexport class MiniMapBoundsChanged extends Event {\n  static readonly eventName = 'minimapboundschanged';\n\n  constructor(\n      public state: Readonly<TraceWindows>,\n  ) {\n    super(MiniMapBoundsChanged.eventName, {composed: true, bubbles: true});\n  }\n}\n\nexport interface TraceWindows {\n  /**\n   * This is the bounds of the entire trace. Once a trace is imported/recorded\n   * and this is set, it cannot be changed.\n   */\n  readonly entireTraceBounds: TraceEngine.Types.Timing.TraceWindow;\n  /**\n   * This is the bounds of the minimap and represents the left and right bound\n   * being shown by the minimap. It can be changed by a user action: for\n   * example, when a user creates a breadcrumb, that breadcrumb becomes the\n   * minimap trace bounds. By default, and when a trace is first loaded, the\n   * minimapTraceBounds are equivalent to the entireTraceBounds.\n   */\n  minimapTraceBounds: TraceEngine.Types.Timing.TraceWindow;\n  /**\n   * This represents the trace window that is being shown on the main timeline.\n   * The reason this is called a \"Window\" rather than \"Bounds\" is because the\n   * user is not bound by this value - they can use their mouse to pan/zoom\n   * in/out beyond the limits of this window (the limit is the\n   * minimapTraceBounds). Another way to think of this value is that the\n   * min/max of this value is what is represented by the two drag handles on\n   * the TimelineMiniMap that the user can drag to change their current window.\n   */\n  timelineTraceWindow: TraceEngine.Types.Timing.TraceWindow;\n}\n\nexport class BoundsManager extends EventTarget {\n  static instance(opts: {\n    forceNew: boolean|null,\n    initialBounds?: TraceEngine.Types.Timing.TraceWindow,\n  } = {forceNew: null}): BoundsManager {\n    const forceNew = Boolean(opts.forceNew);\n    if (!instance || forceNew) {\n      if (!opts.initialBounds) {\n        throw new Error('Cannot construct a BoundsManager without providing the initial bounds');\n      }\n      instance = new BoundsManager(opts.initialBounds);\n    }\n    return instance;\n  }\n\n  static removeInstance(): void {\n    instance = null;\n  }\n\n  #currentState: TraceWindows;\n\n  private constructor(initialBounds: TraceEngine.Types.Timing.TraceWindow) {\n    super();\n    this.#currentState = {\n      entireTraceBounds: initialBounds,\n      minimapTraceBounds: initialBounds,\n      timelineTraceWindow: initialBounds,\n    };\n  }\n\n  get state(): Readonly<TraceWindows> {\n    return this.#currentState;\n  }\n\n  setMiniMapBounds(newBounds: TraceEngine.Types.Timing.TraceWindow): void {\n    const existingBounds = this.#currentState.minimapTraceBounds;\n    if (newBounds.min === existingBounds.min && newBounds.max === existingBounds.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (newBounds.range < 5_000) {\n      // Minimum minimap bounds range is 5 milliseconds.\n      return;\n    }\n\n    this.#currentState.minimapTraceBounds = newBounds;\n    this.dispatchEvent(new MiniMapBoundsChanged(this.#currentState));\n  }\n\n  setTimelineVisibleWindow(newWindow: TraceEngine.Types.Timing.TraceWindow, options: {\n    shouldAnimate: boolean,\n  } = {\n    shouldAnimate: false,\n  }): void {\n    const existingWindow = this.#currentState.timelineTraceWindow;\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (newWindow.range < 1_000) {\n      // Minimum timeline visible window range is 1 millisecond.\n      return;\n    }\n\n    this.#currentState.timelineTraceWindow = newWindow;\n\n    this.dispatchEvent(new TimelineVisibleWindowChanged(this.#currentState, options.shouldAnimate));\n  }\n}\n"]}