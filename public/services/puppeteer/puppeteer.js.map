{
  "version": 3,
  "sources": ["../../../../../../front_end/services/puppeteer/PuppeteerConnection.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport type {ProtocolMapping} from '../../generated/protocol-mapping.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as puppeteer from '../../third_party/puppeteer/puppeteer.js';\n\n/**\n * This class serves as a puppeteer.Connection while sending/receiving CDP messages\n * over DevTools' own SessionRouter.\n *\n * The only oddity is that we attached to a concrete target with a sessionId but make\n * it look to puppeteer like it's the default session (no session ID).\n *\n * Since we see all CDPEvents, we filter out the ones whose session we don't know about.\n */\nclass PuppeteerConnectionAdapter extends puppeteer.Connection implements\n    ProtocolClient.CDPConnection.CDPConnectionObserver {\n  readonly #connection: ProtocolClient.CDPConnection.CDPConnection;\n  readonly #sessionId: Protocol.Target.SessionID;\n\n  constructor(connection: ProtocolClient.CDPConnection.CDPConnection, sessionId: Protocol.Target.SessionID) {\n    // url is an empty string in this case parallel to:\n    // https://github.com/puppeteer/puppeteer/blob/f63a123ecef86693e6457b07437a96f108f3e3c5/src/common/BrowserConnector.ts#L72\n    // Pass a 'null' transport, it should never actually be used, otherwise we do something wrong overwriting connection.\n    super('', {close: () => undefined} as puppeteer.ConnectionTransport);\n    this.#connection = connection;\n    this.#connection.observe(this);\n    this.#sessionId = sessionId;\n  }\n\n  // eslint-disable-next-line @devtools/no-underscored-properties\n  override _rawSend(\n      _callbacks: unknown, method: string|number|symbol, params: unknown, sessionId?: string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      _options?: unknown): Promise<any> {\n    return this.#connection\n        .send(\n            method as ProtocolClient.CDPConnection.Command,\n            params as ProtocolClient.CDPConnection.CommandParams<ProtocolClient.CDPConnection.Command>,\n            sessionId ?? this.#sessionId)\n        .then(response => 'result' in response ? response.result : {});\n  }\n\n  onEvent<T extends keyof ProtocolMapping.Events>(event: ProtocolClient.CDPConnection.CDPEvent<T>): void {\n    const {sessionId} = event;\n    if (sessionId === this.#sessionId) {\n      // Puppeteer is expecting to use the default session, but we give it a non-default session in #connection.\n      // Replace that sessionId with undefined so Puppeteer treats it as default.\n      event.sessionId = undefined;\n    } else if (!sessionId || !this._sessions.has(sessionId)) {\n      // Ignore the root session, or sessions puppeteer doesn't know about.\n      return;\n    }\n\n    void super.onMessage(JSON.stringify(event));\n  }\n\n  onDisconnect(): void {\n    this.dispose();\n  }\n\n  override dispose(): void {\n    super.dispose();\n    this.#connection.unobserve(this);\n    void this.#connection.send('Target.detachFromTarget', {sessionId: this.#sessionId}, this.#sessionId);\n  }\n}\n\nexport class PuppeteerConnectionHelper {\n  static async connectPuppeteerToConnectionViaTab(options: {\n    connection: ProtocolClient.CDPConnection.CDPConnection,\n    targetId: Protocol.Target.TargetID,\n    sessionId: Protocol.Target.SessionID,\n    isPageTargetCallback: (targetInfo: Protocol.Target.TargetInfo) => boolean,\n  }): Promise<{\n    page: puppeteer.Page | null,\n    browser: puppeteer.Browser,\n    puppeteerConnection: puppeteer.Connection,\n  }> {\n    const {connection, targetId, sessionId, isPageTargetCallback} = options;\n    const puppeteerConnection = new PuppeteerConnectionAdapter(connection, sessionId);\n    const browserPromise = puppeteer.Browser._create(\n        puppeteerConnection,\n        [] /* contextIds */,\n        false /* ignoreHTTPSErrors */,\n        undefined /* defaultViewport */,\n        undefined /* DownloadBehavior */,\n        undefined /* process */,\n        undefined /* closeCallback */,\n        undefined /* targetFilterCallback */,\n        target => isPageTargetCallback((target as puppeteer.Target)._getTargetInfo()),\n        false /* waitForInitiallyDiscoveredTargets */,\n    );\n\n    const [, browser] = await Promise.all([\n      puppeteerConnection._createSession({targetId}, /* emulateAutoAttach= */ true),\n      browserPromise,\n    ]);\n\n    await browser.waitForTarget(t => t.type() === 'page');\n\n    const pages = await browser.pages();\n\n    return {page: pages[0] as puppeteer.Page, browser, puppeteerConnection};\n  }\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;AAOA,YAAY,eAAe;AAW3B,IAAM,6BAAN,cAAmD,qBAAU;EAElD;EACA;EAET,YAAY,YAAwD,WAAoC;AAItG,UAAM,IAAI,EAAC,OAAO,MAAM,OAAS,CAAkC;AACnE,SAAK,cAAc;AACnB,SAAK,YAAY,QAAQ,IAAI;AAC7B,SAAK,aAAa;EACpB;;EAGS,SACL,YAAqB,QAA8B,QAAiB,WAEpE,UAAkB;AACpB,WAAO,KAAK,YACP,KACG,QACA,QACA,aAAa,KAAK,UAAU,EAC/B,KAAK,cAAY,YAAY,WAAW,SAAS,SAAS,CAAA,CAAE;EACnE;EAEA,QAAgD,OAA+C;AAC7F,UAAM,EAAC,UAAS,IAAI;AACpB,QAAI,cAAc,KAAK,YAAY;AAGjC,YAAM,YAAY;IACpB,WAAW,CAAC,aAAa,CAAC,KAAK,UAAU,IAAI,SAAS,GAAG;AAEvD;IACF;AAEA,SAAK,MAAM,UAAU,KAAK,UAAU,KAAK,CAAC;EAC5C;EAEA,eAAY;AACV,SAAK,QAAO;EACd;EAES,UAAO;AACd,UAAM,QAAO;AACb,SAAK,YAAY,UAAU,IAAI;AAC/B,SAAK,KAAK,YAAY,KAAK,2BAA2B,EAAC,WAAW,KAAK,WAAU,GAAG,KAAK,UAAU;EACrG;;AAGI,IAAO,4BAAP,MAAgC;EACpC,aAAa,mCAAmC,SAK/C;AAKC,UAAM,EAAC,YAAY,UAAU,WAAW,qBAAoB,IAAI;AAChE,UAAM,sBAAsB,IAAI,2BAA2B,YAAY,SAAS;AAChF,UAAM,iBAA2B,kBAAQ;MACrC;MACA,CAAA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,YAAU,qBAAsB,OAA4B,eAAc,CAAE;MAC5E;;IAA6C;AAGjD,UAAM,CAAC,EAAE,OAAO,IAAI,MAAM,QAAQ,IAAI;MACpC,oBAAoB;QAAe,EAAC,SAAQ;;QAA4B;MAAI;MAC5E;KACD;AAED,UAAM,QAAQ,cAAc,OAAK,EAAE,KAAI,MAAO,MAAM;AAEpD,UAAM,QAAQ,MAAM,QAAQ,MAAK;AAEjC,WAAO,EAAC,MAAM,MAAM,CAAC,GAAqB,SAAS,oBAAmB;EACxE;;",
  "names": []
}
