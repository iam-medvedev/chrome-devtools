{"version":3,"file":"ScopeTreeCache.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/ScopeTreeCache.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAG7B,OAAO,KAAK,SAAS,MAAM,2BAA2B,CAAC;AAIvD;;;;;;GAMG;AACH,MAAM,OAAO,cAAc;IACzB,4FAA4F;IAC5F,WAAW,GAAG,IAAI,OAAO,EAAyC,CAAC;IACnE,kBAAkB,GAAG,IAAI,GAAG,EAAkD,CAAC;IAE/E,MAAM,CAAC,SAAS,CAAkB;IAElC,MAAM,CAAC,QAAQ;QACb,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE;YAC7B,cAAc,CAAC,SAAS,GAAG,IAAI,cAAc,EAAE,CAAC;SACjD;QACD,OAAO,cAAc,CAAC,SAAS,CAAC;IAClC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,MAAyB;QAChD,MAAM,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACrD,IAAI,eAAe,KAAK,SAAS,EAAE;YACjC,kFAAkF;YAClF,OAAO,eAAe,CAAC;SACxB;QAED,MAAM,EAAC,OAAO,EAAC,GAAG,MAAM,MAAM,CAAC,cAAc,EAAE,CAAC;QAChD,IAAI,OAAO,KAAK,IAAI,EAAE;YACpB,OAAO,IAAI,CAAC;SACb;QAED,kFAAkF;QAClF,iFAAiF;QACjF,iCAAiC;QACjC,2EAA2E;QAC3E,MAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACzD,IAAI,YAAY,EAAE;YAChB,OAAO,YAAY,CAAC;SACrB;QAED,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;QACzD,MAAM,gBAAgB,GAClB,SAAS,CAAC,mBAAmB,CAAC,mBAAmB,EAAE,CAAC,mBAAmB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACjG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QACtD,MAAM,SAAS,GAAG,MAAM,gBAAgB,CAAC;QACzC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACvC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QACxC,OAAO,SAAS,CAAC;IACnB,CAAC;CACF","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as Formatter from '../formatter/formatter.js';\n\ntype ScopeTreeNode = Formatter.FormatterWorkerPool.ScopeTreeNode;\n\n/**\n * Caches scope trees for whole scripts.\n *\n * We use `SDK.Script` as a key to uniquely identify scripts.\n * `SDK.Script` boils down to \"target\" + \"script ID\". This duplicates work in case of\n * identitical script running on multiple targets (e.g. workers).\n */\nexport class ScopeTreeCache {\n  /** If a script failed to parse, we stash null in order to prevent unnecessary re-parsing */\n  #scopeTrees = new WeakMap<SDK.Script.Script, ScopeTreeNode|null>();\n  #pendingScopeTrees = new Map<SDK.Script.Script, Promise<ScopeTreeNode|null>>();\n\n  static #instance?: ScopeTreeCache;\n\n  static instance(): ScopeTreeCache {\n    if (!ScopeTreeCache.#instance) {\n      ScopeTreeCache.#instance = new ScopeTreeCache();\n    }\n    return ScopeTreeCache.#instance;\n  }\n\n  async scopeTreeForScript(script: SDK.Script.Script): Promise<ScopeTreeNode|null> {\n    const maybeCachedTree = this.#scopeTrees.get(script);\n    if (maybeCachedTree !== undefined) {\n      // We intentionally return `null` here if the script already failed to parse once.\n      return maybeCachedTree;\n    }\n\n    const {content} = await script.requestContent();\n    if (content === null) {\n      return null;\n    }\n\n    // We check for pending requests for this script AFTER we load the script content.\n    // There must not be any suspension point between checking #pendingScopeTrees and\n    // the actual call to the worker.\n    // This is fine, since #requestContent does similar request de-duplication.\n    const maybePromise = this.#pendingScopeTrees.get(script);\n    if (maybePromise) {\n      return maybePromise;\n    }\n\n    const sourceType = script.isModule ? 'module' : 'script';\n    const scopeTreePromise =\n        Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptScopeTree(content, sourceType);\n    this.#pendingScopeTrees.set(script, scopeTreePromise);\n    const scopeTree = await scopeTreePromise;\n    this.#pendingScopeTrees.delete(script);\n    this.#scopeTrees.set(script, scopeTree);\n    return scopeTree;\n  }\n}\n"]}