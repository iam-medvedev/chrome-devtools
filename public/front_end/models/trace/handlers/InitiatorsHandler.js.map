{"version":3,"file":"InitiatorsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/InitiatorsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nconst lastScheduleStyleRecalcByFrame = new Map<string, Types.TraceEvents.TraceEventScheduleStyleRecalculation>();\n\n// This tracks the last event that is considered to have invalidated the layout\n// for a given frame.\n// Note that although there is an InvalidateLayout event, there are also other\n// events (ScheduleStyleRecalculation) that could be the reason a layout was\n// invalidated.\nconst lastInvalidationEventForFrame = new Map<string, Types.TraceEvents.TraceEventData>();\n\n// Important: although the event is called UpdateLayoutTree, in the UI we\n// present these to the user as \"Recalculate Style\". So don't get confused!\n// These are the same - just UpdateLayoutTree is what the event from Chromium\n// is called.\nconst lastUpdateLayoutTreeByFrame = new Map<string, Types.TraceEvents.TraceEventUpdateLayoutTree>();\n\n// These two maps store the same data but in different directions.\n//\n// For a given event, tell me what its initiator was. An event can only have one initiator.\nconst eventToInitiatorMap = new Map<Types.TraceEvents.TraceEventData, Types.TraceEvents.TraceEventData>();\n// For a given event, tell me what events it initiated. An event can initiate\n// multiple events, hence why the value for this map is an array.\nconst initiatorToEventsMap = new Map<Types.TraceEvents.TraceEventData, Types.TraceEvents.TraceEventData[]>();\n\nconst requestAnimationFrameEventsById: Map<number, Types.TraceEvents.TraceEventRequestAnimationFrame> = new Map();\nconst timerInstallEventsById: Map<number, Types.TraceEvents.TraceEventTimerInstall> = new Map();\nconst requestIdleCallbackEventsById: Map<number, Types.TraceEvents.TraceEventRequestIdleCallback> = new Map();\nconst webSocketCreateEventsById: Map<number, Types.TraceEvents.TraceEventWebSocketCreate> = new Map();\n\nexport function reset(): void {\n  lastScheduleStyleRecalcByFrame.clear();\n  lastInvalidationEventForFrame.clear();\n  lastUpdateLayoutTreeByFrame.clear();\n  timerInstallEventsById.clear();\n  eventToInitiatorMap.clear();\n  initiatorToEventsMap.clear();\n  requestAnimationFrameEventsById.clear();\n  requestIdleCallbackEventsById.clear();\n  webSocketCreateEventsById.clear();\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('InitiatorsHandler was not reset before being initialized');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nfunction storeInitiator(data: {initiator: Types.TraceEvents.TraceEventData, event: Types.TraceEvents.TraceEventData}):\n    void {\n  eventToInitiatorMap.set(data.event, data.initiator);\n  const eventsForInitiator = initiatorToEventsMap.get(data.initiator) || [];\n  eventsForInitiator.push(data.event);\n  initiatorToEventsMap.set(data.initiator, eventsForInitiator);\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (Types.TraceEvents.isTraceEventScheduleStyleRecalculation(event)) {\n    lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);\n  } else if (Types.TraceEvents.isTraceEventUpdateLayoutTree(event)) {\n    // IMPORTANT: although the trace event is called UpdateLayoutTree, this\n    // represents a Styles Recalculation. This event in the timeline is shown to\n    // the user as \"Recalculate Styles.\"\n    if (event.args.beginData) {\n      // Store the last UpdateLayout event: we use this when we see an\n      // InvalidateLayout and try to figure out its initiator.\n      lastUpdateLayoutTreeByFrame.set(event.args.beginData.frame, event);\n\n      // If this frame has seen a ScheduleStyleRecalc event, then that event is\n      // considered to be the initiator of this StylesRecalc.\n      const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);\n      if (scheduledStyleForFrame) {\n        storeInitiator({\n          event,\n          initiator: scheduledStyleForFrame,\n        });\n      }\n    }\n  } else if (Types.TraceEvents.isTraceEventInvalidateLayout(event)) {\n    // By default, the InvalidateLayout event is what triggered the layout invalidation for this frame.\n    let invalidationInitiator: Types.TraceEvents.TraceEventData = event;\n\n    // However, if we have not had any prior invalidations for this frame, we\n    // want to consider StyleRecalculation events as they might be the actual\n    // cause of this layout invalidation.\n    if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {\n      // 1. If we have not had an invalidation event for this frame\n      // 2. AND we have had an UpdateLayoutTree for this frame\n      // 3. AND the UpdateLayoutTree event ended AFTER the InvalidateLayout startTime\n      // 4. AND we have an initiator for the UpdateLayoutTree event\n      // 5. Then we set the last invalidation event for this frame to be the UpdateLayoutTree's initiator.\n      const lastUpdateLayoutTreeForFrame = lastUpdateLayoutTreeByFrame.get(event.args.data.frame);\n      if (lastUpdateLayoutTreeForFrame) {\n        const {endTime} = Helpers.Timing.eventTimingsMicroSeconds(lastUpdateLayoutTreeForFrame);\n        const initiatorOfUpdateLayout = eventToInitiatorMap.get(lastUpdateLayoutTreeForFrame);\n\n        if (initiatorOfUpdateLayout && endTime && endTime > event.ts) {\n          invalidationInitiator = initiatorOfUpdateLayout;\n        }\n      }\n    }\n    lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);\n  } else if (Types.TraceEvents.isTraceEventLayout(event)) {\n    // The initiator of a Layout event is the last Invalidation event.\n    const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);\n    if (lastInvalidation) {\n      storeInitiator({\n        event,\n        initiator: lastInvalidation,\n      });\n    }\n    // Now clear the last invalidation for the frame: the last invalidation has been linked to a Layout event, so it cannot be the initiator for any future layouts.\n    lastInvalidationEventForFrame.delete(event.args.beginData.frame);\n  } else if (Types.TraceEvents.isTraceEventRequestAnimationFrame(event)) {\n    requestAnimationFrameEventsById.set(event.args.data.id, event);\n  } else if (Types.TraceEvents.isTraceEventFireAnimationFrame(event)) {\n    // If we get a fire event, that means we should have had the\n    // RequestAnimationFrame event by now. If so, we can set that as the\n    // initiator for the fire event.\n    const matchingRequestEvent = requestAnimationFrameEventsById.get(event.args.data.id);\n    if (matchingRequestEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingRequestEvent,\n      });\n    }\n  } else if (Types.TraceEvents.isTraceEventTimerInstall(event)) {\n    timerInstallEventsById.set(event.args.data.timerId, event);\n  } else if (Types.TraceEvents.isTraceEventTimerFire(event)) {\n    const matchingInstall = timerInstallEventsById.get(event.args.data.timerId);\n    if (matchingInstall) {\n      storeInitiator({event, initiator: matchingInstall});\n    }\n  } else if (Types.TraceEvents.isTraceEventRequestIdleCallback(event)) {\n    requestIdleCallbackEventsById.set(event.args.data.id, event);\n  } else if (Types.TraceEvents.isTraceEventFireIdleCallback(event)) {\n    const matchingRequestEvent = requestIdleCallbackEventsById.get(event.args.data.id);\n    if (matchingRequestEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingRequestEvent,\n      });\n    }\n  } else if (Types.TraceEvents.isTraceEventWebSocketCreate(event)) {\n    webSocketCreateEventsById.set(event.args.data.identifier, event);\n  } else if (Types.TraceEvents.isTraceEventWebSocketSendHandshakeRequest(event)) {\n    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n    if (matchingCreateEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingCreateEvent,\n      });\n    }\n  } else if (\n      Types.TraceEvents.isTraceEventWebSocketSendHandshakeRequest(event) ||\n      Types.TraceEvents.isTraceEventWebSocketReceiveHandshakeResponse(event) ||\n      Types.TraceEvents.isTraceEventWebSocketDestroy(event)) {\n    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n    if (matchingCreateEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingCreateEvent,\n      });\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('InitiatorsHandler is not initialized');\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport interface InitiatorsData {\n  eventToInitiator: Map<Types.TraceEvents.TraceEventData, Types.TraceEvents.TraceEventData>;\n  initiatorToEvents: Map<Types.TraceEvents.TraceEventData, Types.TraceEvents.TraceEventData[]>;\n}\nexport function data(): InitiatorsData {\n  return {\n    eventToInitiator: new Map(eventToInitiatorMap),\n    initiatorToEvents: new Map(initiatorToEventsMap),\n  };\n}\n"]}