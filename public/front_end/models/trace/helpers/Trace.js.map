{"version":3,"file":"Trace.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/Trace.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = Common.ParsedURL.ParsedURL.fromString(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.TraceEvents.TraceEventData> = Map<Types.TraceEvents.ThreadID, T[]>;\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nexport function addEventToProcessThread<T extends Types.TraceEvents.TraceEventData>(\n    event: T,\n    eventsInProcessThread: Map<Types.TraceEvents.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.TraceEvents.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\ntype TimeSpan = {\n  ts: Types.Timing.MicroSeconds,\n  dur?: Types.Timing.MicroSeconds,\n};\nfunction eventTimeComparator(a: TimeSpan, b: TimeSpan): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: {ts: Types.Timing.MicroSeconds, dur?: Types.Timing.MicroSeconds}[]):\n    void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function\nmergeEventsInOrder<T1 extends Types.TraceEvents.TraceEventData, T2 extends Types.TraceEvents.TraceEventData>(\n    eventsArray1: T1[], eventsArray2: T2[]): (T1|T2)[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.TraceEvents.TraceEventData,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.TraceEvents.TraceEventNavigationStart[]>,\n    ): Types.TraceEvents.TraceEventNavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(event: Types.TraceEvents.TraceEventNestableAsync|\n                          Types.TraceEvents.TraceEventSyntheticNestableAsyncEvent): string|undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.MicroSeconds,\n    rendererProcessesByFrame: Map<\n        string,\n        Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindow}[]>>):\n    string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, ts: Types.Timing.MicroSeconds, pid: Types.TraceEvents.ProcessID,\n    tid: Types.TraceEvents.ThreadID): Types.TraceEvents.TraceEventSyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.TraceEvents.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.MicroSeconds(0),\n    selfTime: Types.Timing.MicroSeconds(0),\n    callFrame: node.callFrame,\n  };\n}\n\nexport function matchBeginningAndEndEvents(unpairedEvents: Types.TraceEvents.TraceEventNestableAsync[]): Map<string, {\n  begin: Types.TraceEvents.TraceEventNestableAsyncBegin | null,\n  end: Types.TraceEvents.TraceEventNestableAsyncEnd | null,\n}> {\n  // map to store begin and end of the event\n  const matchedPairs: Map<string, {\n    begin: Types.TraceEvents.TraceEventNestableAsyncBegin | null,\n    end: Types.TraceEvents.TraceEventNestableAsyncEnd | null,\n  }> = new Map();\n\n  // looking for start and end\n  for (const event of unpairedEvents) {\n    const id = extractId(event);\n    if (id === undefined) {\n      continue;\n    }\n    // Create a synthetic id to prevent collisions across categories.\n    // Console timings can be dispatched with the same id, so use the\n    // event name as well to generate unique ids.\n    const syntheticId = `${event.cat}:${id}:${event.name}`;\n    const otherEventsWithID = Platform.MapUtilities.getWithDefault(matchedPairs, syntheticId, () => {\n      return {begin: null, end: null};\n    });\n\n    const isStartEvent = event.ph === Types.TraceEvents.Phase.ASYNC_NESTABLE_START;\n    const isEndEvent = event.ph === Types.TraceEvents.Phase.ASYNC_NESTABLE_END;\n\n    if (isStartEvent) {\n      otherEventsWithID.begin = event;\n    } else if (isEndEvent) {\n      otherEventsWithID.end = event;\n    }\n  }\n\n  return matchedPairs;\n}\n\nexport function createSortedSyntheticEvents(matchedPairs: Map<string, {\n  begin: Types.TraceEvents.TraceEventNestableAsyncBegin | null,\n  end: Types.TraceEvents.TraceEventNestableAsyncEnd | null,\n}>): Types.TraceEvents.TraceEventSyntheticNestableAsyncEvent[] {\n  const syntheticEvents: Types.TraceEvents.TraceEventSyntheticNestableAsyncEvent[] = [];\n  for (const [id, eventsPair] of matchedPairs.entries()) {\n    if (!eventsPair.begin || !eventsPair.end) {\n      // This should never happen, the backend only creates the events once it\n      // has them both, so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n\n    const event: Types.TraceEvents.TraceEventSyntheticNestableAsyncEvent = {\n      cat: eventsPair.end.cat,\n      ph: eventsPair.end.ph,\n      pid: eventsPair.end.pid,\n      tid: eventsPair.end.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: eventsPair.begin.name,\n      dur: Types.Timing.MicroSeconds(eventsPair.end.ts - eventsPair.begin.ts),\n      ts: eventsPair.begin.ts,\n      args: {\n        data: {\n          beginEvent: eventsPair.begin,\n          endEvent: eventsPair.end,\n        },\n      },\n    };\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEvents.push(event);\n  }\n  return syntheticEvents.sort((a, b) => a.ts - b.ts);\n}\n\nexport function createMatchedSortedSyntheticEvents(unpairedAsyncEvents: Types.TraceEvents.TraceEventNestableAsync[]):\n    Types.TraceEvents.TraceEventSyntheticNestableAsyncEvent[] {\n  const matchedPairs = matchBeginningAndEndEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents(matchedPairs);\n  return syntheticEvents;\n}\n"]}