{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Initiators.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,WAAW,MAAM,6BAA6B,CAAC;AAM3D;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CACrC,eAA0D,EAC1D,aAA2D;IAE7D,MAAM,KAAK,GAAoB,EAAE,CAAC;IAElC,IAAI,YAAY,GAAsD,aAAa,CAAC;IAEpF,OAAO,YAAY,EAAE;QACnB,MAAM,gBAAgB,GAAG,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAEvF,IAAI,gBAAgB,EAAE;YACpB,wDAAwD;YACxD,oDAAoD;YACpD,uDAAuD;YACvD,QAAQ;YACR,KAAK,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,gBAAgB,EAAC,CAAC,CAAC;YAC/D,YAAY,GAAG,gBAAgB,CAAC;YAChC,SAAS;SACV;QAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,WAAW,CAAC,eAAe,CAAC,YAAY,CAAC,EAAE;YAChE,qDAAqD;YACrD,6CAA6C;YAC7C,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,MAAM,mBAAmB,GAAG,eAAe,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACnF,IAAI,CAAC,mBAAmB,EAAE;YACxB,wDAAwD;YACxD,uBAAuB;YACvB,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;SACP;QAED,uCAAuC;QACvC,YAAY,GAAG,mBAAmB,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC;KAC1D;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TraceEngine from '../../models/trace/trace.js';\n\nexport interface InitiatorPair {\n  event: TraceEngine.Types.TraceEvents.TraceEventData;\n  initiator: TraceEngine.Types.TraceEvents.TraceEventData;\n}\n/**\n * Given an event that the user has selected, this function returns all the\n * pairs of events and their initiators that need to be drawn on the flamechart.\n * The reason that this can return multiple pairs is because we draw the\n * entire chain: for each event's initiator, we see if it had an initiator, and\n * work backwards to draw each one.\n */\nexport function eventInitiatorPairsToDraw(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorPair[] {\n  const pairs: InitiatorPair[] = [];\n\n  let currentEvent: TraceEngine.Types.TraceEvents.TraceEventData|null = selectedEvent;\n\n  while (currentEvent) {\n    const currentInitiator = traceEngineData.Initiators.eventToInitiator.get(currentEvent);\n\n    if (currentInitiator) {\n      // Store the current pair, and then set the initiator to\n      // be the current event, so we work back through the\n      // trace and find the initator of the initiator, and so\n      // on...\n      pairs.push({event: currentEvent, initiator: currentInitiator});\n      currentEvent = currentInitiator;\n      continue;\n    }\n\n    if (!TraceEngine.Types.TraceEvents.isRendererEvent(currentEvent)) {\n      // If the current event is not a renderer, we have no\n      // concept of a parent event, so we can bail.\n      currentEvent = null;\n      break;\n    }\n\n    const nodeForCurrentEvent = traceEngineData.Renderer.entryToNode.get(currentEvent);\n    if (!nodeForCurrentEvent) {\n      // Should not happen - if it does something odd is going\n      // on so let's give up.\n      currentEvent = null;\n      break;\n    }\n\n    // Go up to the parent, and loop again.\n    currentEvent = nodeForCurrentEvent.parent?.entry || null;\n  }\n\n  return pairs;\n}\n"]}