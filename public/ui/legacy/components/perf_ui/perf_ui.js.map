{
  "version": 3,
  "sources": ["../../../../../../../../front_end/ui/legacy/components/perf_ui/BrickBreaker.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/ChartViewport.ts", "chartViewport.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/FlameChart.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/CanvasHelper.ts", "flameChart.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/Font.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/TimelineGrid.ts", "timelineGrid.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/FilmStripView.ts", "filmStripView.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/GCActionDelegate.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/LineLevelProfile.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/LiveHeapProfile.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/NetworkPriorities.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/OverviewGrid.ts", "overviewGrid.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/PieChart.ts", "pieChart.css.js", "../../../../../../../../front_end/ui/legacy/components/perf_ui/TimelineOverviewCalculator.ts", "../../../../../../../../front_end/ui/legacy/components/perf_ui/TimelineOverviewPane.ts", "timelineOverviewInfo.css.js"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as WindowBounds from '../../../../services/window_bounds/window_bounds.js';\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport type {FlameChart} from './FlameChart.js';\n\nconst UIStrings = {\n  /**\n   *@description Message congratulating the user for having won a game.\n   */\n  congrats: 'Congrats, you win!',\n  /**\n   *@description A Postscript hinting the user the possibility to open the game using a keycombo.\n   */\n  ps: 'PS: You can also open the game by typing `fixme`',\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/BrickBreaker.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\ninterface Brick {\n  x: number;\n  y: number;\n  width: number;\n}\n\nconst MAX_DELTA = 16;\nconst MIN_DELTA = 10;\nconst MAX_PADDLE_LENGTH = 150;\nconst MIN_PADDLE_LENGTH = 85;\nconst PADDLE_HEIGHT = 15;\nconst BALL_RADIUS = 10;\n\ninterface ColorPalette {\n  light: string;\n  mediumLighter: string;\n  mediumDarker: string;\n  dark: string;\n}\n\nconst colorPallettes: ColorPalette[] = [\n  // blues\n  {\n    light: 'rgb(224,240,255)',\n    mediumLighter: 'rgb(176,208,255)',\n    mediumDarker: 'rgb(112,160,221)',\n    dark: 'rgb(0,92,153)',\n  },\n  // pinks\n  {\n    light: 'rgb(253, 216, 229)',\n    mediumLighter: 'rgb(250, 157, 188)',\n    mediumDarker: 'rgb(249, 98, 154)',\n    dark: 'rgb(254, 5, 105)',\n  },\n  // pastel pinks\n  {\n    light: 'rgb(254, 234, 234)',\n    mediumLighter: 'rgb(255, 216, 216)',\n    mediumDarker: 'rgb(255, 195, 195)',\n    dark: 'rgb(235, 125, 138)',\n  },\n  // purples\n  {\n    light: 'rgb(226,183,206)',\n    mediumLighter: 'rgb(219,124,165)',\n    mediumDarker: 'rgb(146,60,129)',\n    dark: 'rgb(186, 85, 255)',\n  },\n  // greens\n  {\n    light: 'rgb(206,255,206)',\n    mediumLighter: 'rgb(128,255,128)',\n    mediumDarker: 'rgb(0,246,0)',\n    dark: 'rgb(0,187,0)',\n  },\n  // reds\n  {\n    light: 'rgb(255, 188, 181)',\n    mediumLighter: 'rgb(254, 170, 170)',\n    mediumDarker: 'rgb(215, 59, 43)',\n    dark: 'rgb(187, 37, 23)',\n  },\n  // aqua\n  {\n    light: 'rgb(236, 254, 250)',\n    mediumLighter: 'rgb(204, 255, 245)',\n    mediumDarker: 'rgb(164, 240, 233)',\n    dark: 'rgb(72,189,144)',\n  },\n  // yellow/pink\n  {\n    light: 'rgb(255, 225, 185)',\n    mediumLighter: 'rgb(255, 204, 141)',\n    mediumDarker: 'rgb(240, 140, 115)',\n    dark: 'rgb(211, 96, 117)',\n  },\n  // ocean breeze\n  {\n    light: 'rgb(218, 255, 248)',\n    mediumLighter: 'rgb(177, 235, 236)',\n    mediumDarker: 'rgb(112, 214, 214)',\n    dark: 'rgb(34, 205, 181)',\n  },\n];\n\nexport class BrickBreaker extends HTMLElement {\n  #canvas: HTMLCanvasElement;\n  #ctx: CanvasRenderingContext2D;\n\n  #helperCanvas: HTMLCanvasElement;\n  #helperCanvasCtx: CanvasRenderingContext2D;\n  #scorePanel: HTMLElement;\n  #trackTimelineOffset = 0;\n  #visibleEntries = new Set<number>();\n  #brokenBricks = new Map<number, Brick>();\n  #keyDownHandlerBound = this.#keyDownHandler.bind(this);\n  #keyUpHandlerBound = this.#keyUpHandler.bind(this);\n  #keyPressHandlerBound = this.#keyPressHandler.bind(this);\n  #closeGameBound = this.#closeGame.bind(this);\n  #mouseMoveHandlerBound = this.#mouseMoveHandler.bind(this);\n  #boundingElement = WindowBounds.WindowBoundsService.WindowBoundsServiceImpl.instance().getDevToolsBoundingElement();\n  // Value by which we moved the game up relative to the viewport\n  #gameViewportOffset = 0;\n  #running = false;\n  #initialDPR = devicePixelRatio;\n  #ballX = 0;\n  #ballY = 0;\n  #ballDx = 0;\n  #ballDy = 0;\n  #paddleX = 0;\n  #rightPressed = false;\n  #leftPressed = false;\n  #brickHeight = 0;\n  #lives = 0;\n  #blockCount = 0;\n  #paddleLength = MAX_PADDLE_LENGTH;\n  #minScreenHeight = 150;\n  #maxScreenHeight = 1500;\n  #screenHeightDiff = this.#maxScreenHeight - this.#minScreenHeight;\n  // Value from 0.1 to 1 that multiplies speed depending on the screen height\n  #deltaMultiplier = 0;\n  #deltaVectorLength = 0;\n  #currentPalette: ColorPalette;\n  constructor(private timelineFlameChart: FlameChart) {\n    super();\n    this.#canvas = this.createChild('canvas', 'fill');\n    this.#ctx = this.#canvas.getContext('2d') as CanvasRenderingContext2D;\n    this.#helperCanvas = document.createElement('canvas');\n    this.#helperCanvasCtx = this.#helperCanvas.getContext('2d') as CanvasRenderingContext2D;\n    const randomPaletteIndex = Math.floor(Math.random() * colorPallettes.length);\n    this.#currentPalette = colorPallettes[randomPaletteIndex];\n    this.#scorePanel = this.createChild('div');\n    this.#scorePanel.classList.add('scorePanel');\n    this.#scorePanel.style.borderImage =\n        'linear-gradient(' + this.#currentPalette.mediumDarker + ',' + this.#currentPalette.dark + ') 1';\n    this.initButton();\n  }\n\n  initButton(): void {\n    const button = this.createChild('div');\n    button.classList.add('game-close-button');\n    button.innerHTML = '<b><span style=\\'font-size: 1.2em; color: white\\'>x</span></b>';\n    button.style.background = this.#currentPalette.dark;\n    button.style.boxShadow = this.#currentPalette.dark + ' 1px 1px, ' + this.#currentPalette.mediumDarker +\n        ' 3px 3px, ' + this.#currentPalette.mediumLighter + ' 5px 5px';\n    button.addEventListener('click', this.#closeGame.bind(this));\n    this.appendChild(button);\n  }\n\n  connectedCallback(): void {\n    this.#running = true;\n    this.#setUpNewGame();\n    this.#boundingElement.addEventListener('keydown', this.#keyDownHandlerBound);\n    document.addEventListener('keydown', this.#keyDownHandlerBound, false);\n    document.addEventListener('keyup', this.#keyUpHandlerBound, false);\n    document.addEventListener('keypress', this.#keyPressHandlerBound, false);\n    window.addEventListener('resize', this.#closeGameBound);\n    document.addEventListener('mousemove', this.#mouseMoveHandlerBound, false);\n    this.tabIndex = 1;\n    this.focus();\n  }\n\n  disconnectedCallback(): void {\n    this.#boundingElement.removeEventListener('keydown', this.#keyDownHandlerBound);\n    window.removeEventListener('resize', this.#closeGameBound);\n    document.removeEventListener('keydown', this.#keyDownHandlerBound, false);\n    document.removeEventListener('keyup', this.#keyUpHandlerBound, false);\n    window.removeEventListener('resize', this.#closeGameBound);\n    document.removeEventListener('keypress', this.#keyPressHandlerBound, false);\n    document.removeEventListener('mousemove', this.#mouseMoveHandlerBound, false);\n  }\n\n  #resetCanvas(): void {\n    const dPR = window.devicePixelRatio;\n    const height = Math.round(this.offsetHeight * dPR);\n    const width = Math.round(this.offsetWidth * dPR);\n    this.#canvas.height = height;\n    this.#canvas.width = width;\n    this.#canvas.style.height = (height / dPR) + 'px';\n    this.#canvas.style.width = (width / dPR) + 'px';\n  }\n\n  #closeGame(): void {\n    this.#running = false;\n    this.remove();\n  }\n\n  #setUpNewGame(): void {\n    this.#resetCanvas();\n    this.#deltaMultiplier = Math.max(0.1, (this.offsetHeight - this.#minScreenHeight) / this.#screenHeightDiff);\n    this.#deltaVectorLength = MIN_DELTA * this.#deltaMultiplier;\n    const trackData = this.timelineFlameChart.drawTrackOnCanvas('Main', this.#ctx, BALL_RADIUS);\n    if (trackData === null || trackData.visibleEntries.size === 0) {\n      console.error('Could not draw game');\n      this.#closeGame();\n      return;\n    }\n    this.#trackTimelineOffset = trackData.top;\n    this.#visibleEntries = trackData.visibleEntries;\n    this.#gameViewportOffset = this.#trackTimelineOffset +\n        this.timelineFlameChart.getCanvas().getBoundingClientRect().top - this.timelineFlameChart.getScrollOffset();\n\n    requestAnimationFrame(() => this.#animateFlameChartTopPositioning(trackData.top, trackData.height));\n  }\n\n  #animateFlameChartTopPositioning(currentOffset: number, flameChartHeight: number): void {\n    if (currentOffset === 0) {\n      this.#createGame();\n      return;\n    }\n    const dPR = window.devicePixelRatio;\n    const currentOffsetOnDPR = Math.round(currentOffset * dPR);\n    const newOffset = Math.max(currentOffset - 4, 0);\n    const newOffsetOnDPR = Math.round(newOffset * dPR);\n    const baseCanvas = this.#canvas;\n    this.#helperCanvas.height = baseCanvas.height;\n    this.#helperCanvas.width = baseCanvas.width;\n    this.#helperCanvas.style.height = baseCanvas.style.height;\n    this.#helperCanvas.style.width = baseCanvas.style.width;\n\n    this.#helperCanvasCtx.drawImage(\n        baseCanvas, 0, currentOffsetOnDPR, baseCanvas.width, flameChartHeight * dPR, 0, newOffsetOnDPR,\n        baseCanvas.width, flameChartHeight * dPR);\n    this.#resetCanvas();\n    this.#ctx.drawImage(this.#helperCanvas, 0, 0);\n    requestAnimationFrame(() => this.#animateFlameChartTopPositioning(newOffset, flameChartHeight));\n  }\n\n  #keyUpHandler(event: KeyboardEvent): void {\n    if (event.key === 'Right' || event.key === 'ArrowRight' || event.key === 'd') {\n      this.#rightPressed = false;\n      event.preventDefault();\n    } else if (event.key === 'Left' || event.key === 'ArrowLeft' || event.key === 'a') {\n      this.#leftPressed = false;\n      event.preventDefault();\n    } else {\n      event.stopImmediatePropagation();\n    }\n  }\n\n  #keyPressHandler(e: Event): void {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n  }\n\n  #keyDownHandler(event: KeyboardEvent): void {\n    if (event.key === 'Escape') {\n      this.#closeGame();\n      event.stopImmediatePropagation();\n    } else if (event.key === 'Right' || event.key === 'ArrowRight' || event.key === 'd') {\n      this.#rightPressed = true;\n      event.preventDefault();\n    } else if (event.key === 'Left' || event.key === 'ArrowLeft' || event.key === 'a') {\n      this.#leftPressed = true;\n      event.preventDefault();\n    } else {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  }\n\n  #mouseMoveHandler(e: MouseEvent): void {\n    this.#paddleX = Math.max(e.offsetX - this.#paddleLength / 2, 0);\n    this.#paddleX = Math.min(this.#paddleX, this.offsetWidth - this.#paddleLength);\n  }\n\n  #createGame(): void {\n    this.#ballX = this.offsetWidth / 2;\n    this.#ballY = this.offsetHeight - PADDLE_HEIGHT - BALL_RADIUS;\n    this.#ballDx = 0;\n    this.#ballDy = -Math.SQRT2 * this.#deltaVectorLength;\n    this.#paddleX = (this.#canvas.width - this.#paddleLength) / 2;\n    this.#rightPressed = false;\n    this.#leftPressed = false;\n    this.#brickHeight = this.timelineFlameChart.getBarHeight();\n    this.#blockCount = this.#visibleEntries.size;\n    this.#lives = Math.max(Math.round(this.#blockCount / 17), 2);\n    this.#draw();\n  }\n\n  #restartBall(): void {\n    this.#ballX = this.offsetWidth / 2;\n    this.#ballY = this.offsetHeight - PADDLE_HEIGHT - BALL_RADIUS;\n    this.#ballDx = 0;\n    this.#ballDy = -Math.SQRT2 * this.#deltaVectorLength;\n  }\n\n  #drawBall(): void {\n    if (!this.#ctx) {\n      return;\n    }\n    const gradient = this.#ctx.createRadialGradient(\n        this.#ballX + BALL_RADIUS / 4,  // Offset towards the left\n        this.#ballY - BALL_RADIUS / 4,  // Offset downwards\n        0,\n        this.#ballX + BALL_RADIUS / 4,\n        this.#ballY - BALL_RADIUS / 4,\n        BALL_RADIUS,\n    );\n\n    // stops for gradient\n    gradient.addColorStop(0.3, this.#currentPalette.mediumLighter);\n    gradient.addColorStop(0.6, this.#currentPalette.mediumDarker);\n    gradient.addColorStop(1, this.#currentPalette.dark);\n\n    this.#ctx.beginPath();\n    this.#ctx.arc(this.#ballX, this.#ballY, BALL_RADIUS, 0, Math.PI * 2);\n    this.#ctx.fillStyle = gradient;\n    this.#ctx.fill();\n    this.#ctx.closePath();\n  }\n\n  #drawPaddle(): void {\n    if (!this.#ctx) {\n      return;\n    }\n\n    const gradient = this.#ctx.createRadialGradient(\n        this.#paddleX + this.#paddleLength / 3,\n        this.offsetHeight - PADDLE_HEIGHT - PADDLE_HEIGHT / 4,\n        0,\n        this.#paddleX + this.#paddleLength / 3,\n        this.offsetHeight - PADDLE_HEIGHT - PADDLE_HEIGHT / 4,\n        this.#paddleLength / 2,\n    );\n\n    gradient.addColorStop(0.3, this.#currentPalette.dark);        // Paddle color\n    gradient.addColorStop(1, this.#currentPalette.mediumDarker);  // Lighter color\n\n    this.#ctx.beginPath();\n    this.#ctx.rect(this.#paddleX, this.offsetHeight - PADDLE_HEIGHT, this.#paddleLength, PADDLE_HEIGHT);\n    this.#ctx.fillStyle = gradient;\n    this.#ctx.fill();\n    this.#ctx.closePath();\n  }\n\n  #patchBrokenBricks(): void {\n    if (!this.#ctx) {\n      return;\n    }\n    for (const brick of this.#brokenBricks.values()) {\n      this.#ctx.beginPath();\n      // Extend the patch width an extra 0.5 px to ensure the\n      // entry is completely covered.\n      this.#ctx.rect(brick.x, brick.y, brick.width + 0.5, this.#brickHeight + 0.5);\n      this.#ctx.fillStyle =\n          ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-neutral-container', this);\n      this.#ctx.fill();\n      this.#ctx.closePath();\n    }\n  }\n\n  #draw(): void {\n    if (this.#initialDPR !== devicePixelRatio) {\n      this.#running = false;\n    }\n    if (this.#lives === 0) {\n      window.alert('GAME OVER');\n      this.#closeGame();\n      return;\n    }\n    if (this.#blockCount === 0) {\n      this.#party();\n      return;\n    }\n    this.#ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);\n    this.#ctx.drawImage(this.#helperCanvas, 0, 0);\n    this.#ctx.save();\n    this.#ctx.scale(devicePixelRatio, devicePixelRatio);\n    this.#helperCanvasCtx.save();\n    this.#helperCanvasCtx.scale(devicePixelRatio, devicePixelRatio);\n    this.#patchBrokenBricks();\n    this.#drawBall();\n    this.#drawPaddle();\n    this.#brickCollisionDetection();\n\n    const lives = `<div><b><span style='font-size: 1.3em; color:  ${this.#currentPalette.dark}'>&#x2764;&#xfe0f; ${\n        this.#lives}</span></b></div>`;\n    const blocks = `<div><b><span style='font-size: 1.3em; color: ${this.#currentPalette.dark}'> 🧱 ${\n        this.#blockCount}</span></b></div>`;\n    this.#scorePanel.innerHTML = lives + blocks;\n\n    this.#blockCount = this.#visibleEntries.size - this.#brokenBricks.size;\n    this.#deltaVectorLength =\n        (MIN_DELTA + (MAX_DELTA - MIN_DELTA) * this.#brokenBricks.size / this.#visibleEntries.size) *\n        this.#deltaMultiplier;\n\n    this.#paddleLength = MAX_PADDLE_LENGTH -\n        (MAX_PADDLE_LENGTH - MIN_PADDLE_LENGTH) * this.#brokenBricks.size / this.#visibleEntries.size;\n\n    if (this.#ballX + this.#ballDx > this.offsetWidth - BALL_RADIUS || this.#ballX + this.#ballDx < BALL_RADIUS) {\n      // Ball bounces on a side wall.\n      this.#ballDx = -this.#ballDx;\n    }\n    if (this.#ballY + this.#ballDy < BALL_RADIUS) {\n      // Ball bounces on the top.\n      this.#ballDy = -this.#ballDy;\n    } else if (this.#ballY + this.#ballDy > this.offsetHeight - BALL_RADIUS && this.#ballDy > 0) {\n      // Ball is at the bottom, either on the paddle or in the\n      // void.\n      if (this.#ballX > (this.#paddleX - BALL_RADIUS) &&\n          this.#ballX < this.#paddleX + this.#paddleLength + BALL_RADIUS) {\n        // Ball bounces on the paddle, calculate this.ballDx and this.ballDy so that\n        // the speed remains constant.\n        // speed^2 = dx^2 + dy^2 = MAX_DELTA^2 + MAX_DELTA^2\n        // -> speed = MAX_DELTA * sqrt(2)\n        // (speed is measured in pixels / frame)\n\n        // The bouncing angle is determined by the portion of the\n        // paddle's length on which it falls and by the restriction\n        // -MAX_DELTA < this.ballDx < MAX_DELTA\n\n        // Since we allow for some margin of error (BALL_RADIUS), we need to\n        // round the ball x to be within the paddle.\n        let roundedBallX = Math.min(this.#ballX, this.#paddleX + this.#paddleLength);\n        roundedBallX = Math.max(roundedBallX, this.#paddleX);\n        const paddleLenghtPortion = (roundedBallX - this.#paddleX) * this.#deltaVectorLength * 2 / this.#paddleLength;\n        this.#ballDx = -this.#deltaVectorLength + paddleLenghtPortion;\n        // Solve for this.ballDy given the above equation and bounce up.\n        this.#ballDy = -Math.sqrt(2 * Math.pow(this.#deltaVectorLength, 2) - Math.pow(this.#ballDx, 2));\n      } else {\n        // Ball fell into oblivion, restart.\n        this.#restartBall();\n        this.#paddleX = (this.offsetWidth - this.#paddleLength) / 2;\n        this.#lives--;\n      }\n    }\n    const keyDelta = Math.round(this.clientWidth / 60);\n    if (this.#rightPressed && this.#paddleX < this.offsetWidth - this.#paddleLength) {\n      this.#paddleX += keyDelta;\n    } else if (this.#leftPressed && this.#paddleX > 0) {\n      this.#paddleX -= keyDelta;\n    }\n\n    this.#ballX += Math.round(this.#ballDx);\n    this.#ballY += Math.round(this.#ballDy);\n    this.#ctx.restore();\n    this.#helperCanvasCtx.restore();\n    if (this.#running) {\n      requestAnimationFrame(this.#draw.bind(this));\n    }\n  }\n  #brickCollisionDetection(): void {\n    // coordinatesToEntryIndex expects coordinates relative to the timeline canvas.\n    const timelineCanvasOffset = this.timelineFlameChart.getCanvas().getBoundingClientRect();\n\n    // Check collision if there is an entry on the top, bottom, left and right of the ball\n    const ballYRelativeToGame = this.#ballY + this.#gameViewportOffset - timelineCanvasOffset.top;\n    const entryIndexTop =\n        this.timelineFlameChart.coordinatesToEntryIndex(this.#ballX, ballYRelativeToGame + BALL_RADIUS);\n    const entryIndexBottom =\n        this.timelineFlameChart.coordinatesToEntryIndex(this.#ballX, ballYRelativeToGame - BALL_RADIUS);\n    const entryIndexRight =\n        this.timelineFlameChart.coordinatesToEntryIndex(this.#ballX + BALL_RADIUS, ballYRelativeToGame);\n    const entryIndexLeft =\n        this.timelineFlameChart.coordinatesToEntryIndex(this.#ballX - BALL_RADIUS, ballYRelativeToGame);\n\n    // Points on the 45 degree corners\n    const diffBetweenCornerandCircle = BALL_RADIUS / Math.SQRT2;\n    const entryIndexRightTop = this.timelineFlameChart.coordinatesToEntryIndex(\n        this.#ballX + diffBetweenCornerandCircle, ballYRelativeToGame + diffBetweenCornerandCircle);\n    const entryIndexLeftTop = this.timelineFlameChart.coordinatesToEntryIndex(\n        this.#ballX - diffBetweenCornerandCircle, ballYRelativeToGame + diffBetweenCornerandCircle);\n    const entryIndexRightBottom = this.timelineFlameChart.coordinatesToEntryIndex(\n        this.#ballX + diffBetweenCornerandCircle, ballYRelativeToGame - diffBetweenCornerandCircle);\n    const entryIndexLeftBottom = this.timelineFlameChart.coordinatesToEntryIndex(\n        this.#ballX - diffBetweenCornerandCircle, ballYRelativeToGame - diffBetweenCornerandCircle);\n\n    const breakBrick = (entryIndex: number): void => {\n      const entryCoordinates = this.timelineFlameChart.entryIndexToCoordinates(entryIndex);\n      if (entryCoordinates) {\n        // Cap entries starting before the visible window in the game.\n        const entryBegin = Math.max(entryCoordinates.x - timelineCanvasOffset.left, 0);\n        // Extend the patch width and height an extra 0.5 px to ensure the\n        // entry is completely covered.\n        this.#brokenBricks.set(entryIndex, {\n          x: entryBegin - 0.5,\n          y: entryCoordinates.y - this.#gameViewportOffset - 0.5,\n          width: this.timelineFlameChart.entryWidth(entryIndex),\n        });\n      }\n    };\n\n    if (entryIndexTop > -1 && !this.#brokenBricks.has(entryIndexTop) && this.#visibleEntries.has(entryIndexTop)) {\n      this.#ballDy = -this.#ballDy;\n      breakBrick(entryIndexTop);\n      return;\n    }\n\n    if (entryIndexBottom > -1 && !this.#brokenBricks.has(entryIndexBottom) &&\n        this.#visibleEntries.has(entryIndexBottom)) {\n      this.#ballDy = -this.#ballDy;\n      breakBrick(entryIndexBottom);\n      return;\n    }\n\n    if (entryIndexRight > -1 && !this.#brokenBricks.has(entryIndexRight) && this.#visibleEntries.has(entryIndexRight)) {\n      this.#ballDx = -this.#ballDx;\n      breakBrick(entryIndexRight);\n      return;\n    }\n\n    if (entryIndexLeft > -1 && !this.#brokenBricks.has(entryIndexLeft) && this.#visibleEntries.has(entryIndexLeft)) {\n      this.#ballDx = -this.#ballDx;\n      breakBrick(entryIndexLeft);\n      return;\n    }\n\n    // if the brick hits on 45 degrees, reverse both directions\n    const diagonalIndexes = [entryIndexRightTop, entryIndexLeftTop, entryIndexRightBottom, entryIndexLeftBottom];\n    for (const index of diagonalIndexes) {\n      if (index > -1 && !this.#brokenBricks.has(index) && this.#visibleEntries.has(index)) {\n        this.#ballDx = -this.#ballDx;\n        this.#ballDy = -this.#ballDy;\n        breakBrick(index);\n        return;\n      }\n    }\n  }\n\n  #random(min: number, max: number): number {\n    return Math.floor(Math.random() * (max - min) + min);\n  }\n  #party(): void {\n    this.#resetCanvas();\n    let count = 0;\n    const columnCount = 15;\n    const rowCount = 5;\n    const xSpacing = this.offsetWidth / columnCount;\n    const ySpacing = this.offsetHeight * 0.7 / columnCount;\n    const timeoutIDs: number[] = [];\n    const randomOffset = (): number => -20 + Math.random() * 40;\n    const drawConfetti = (): void => {\n      for (let i = 0; i < columnCount * rowCount; i++) {\n        const confettiContainerElement = document.createElement('span');\n        confettiContainerElement.className = 'confetti-100';\n        confettiContainerElement.append(this.#createConfettiElement(\n            (i % columnCount) * xSpacing + randomOffset(), (i % rowCount) * ySpacing + randomOffset()));\n        timeoutIDs.push(window.setTimeout(() => this.append(confettiContainerElement), Math.random() * 100));\n        timeoutIDs.push(window.setTimeout(() => {\n          confettiContainerElement.remove();\n        }, 1000));\n      }\n      if (++count < 6) {\n        setTimeout(drawConfetti, Math.random() * 100 + 400);\n        return;\n      }\n      window.alert(`${i18nString(UIStrings.congrats)}\\n${i18nString(UIStrings.ps)}`);\n\n      timeoutIDs.forEach(id => clearTimeout(id));\n      this.#closeGame();\n    };\n    drawConfetti();\n  }\n\n  #createConfettiElement(x: number, y: number): HTMLElement {\n    const maxDistance = 400;\n    const maxRotation = 3;\n    const emojies = ['💯', '🎉', '🎊'];\n    const confettiElement = document.createElement('span');\n    confettiElement.textContent = emojies[this.#random(0, emojies.length)];\n    confettiElement.className = 'confetti-100-particle';\n    confettiElement.style.setProperty('--rotation', this.#random(-maxRotation * 360, maxRotation * 360) + 'deg');\n    confettiElement.style.setProperty('--to-X', this.#random(-maxDistance, maxDistance) + 'px');\n    confettiElement.style.setProperty('--to-Y', this.#random(-maxDistance, maxDistance) + 'px');\n    confettiElement.style.left = x + 'px';\n    confettiElement.style.top = y + 'px';\n\n    return confettiElement;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'brick-breaker': BrickBreaker;\n  }\n}\n\ncustomElements.define('brick-breaker', BrickBreaker);\n", "// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as RenderCoordinator from '../../../components/render_coordinator/render_coordinator.js';\nimport * as UI from '../../legacy.js';\n\nimport chartViewPortStyles from './chartViewport.css.js';\nimport {MinimalTimeWindowMs} from './FlameChart.js';\n\nexport interface ChartViewportDelegate {\n  windowChanged(startTime: number, endTime: number, animate: boolean): void;\n  updateRangeSelection(startTime: number, endTime: number): void;\n  setSize(width: number, height: number): void;\n  update(): void;\n}\n\nexport interface Config {\n  /**\n   * Configures if the Chart should show a vertical line at the position of the\n   * mouse cursor when the user holds the `Shift` key.\n   * The reason this is configurable is because within the Performance Panel\n   * we use our own overlays system for UI like this, so we do not need the\n   * ChartViewport to manage it.\n   */\n  enableCursorElement: boolean;\n}\n\nexport class ChartViewport extends UI.Widget.VBox {\n  private readonly delegate: ChartViewportDelegate;\n  viewportElement: HTMLElement;\n  private alwaysShowVerticalScrollInternal: boolean;\n  private rangeSelectionEnabled: boolean;\n  private vScrollElement: HTMLElement;\n  private vScrollContent: HTMLElement;\n  private readonly selectionOverlay: HTMLElement;\n  private cursorElement: HTMLElement;\n  private isDraggingInternal!: boolean;\n  private totalHeight!: number;\n  private offsetHeight!: number;\n  private scrollTop!: number;\n  private rangeSelectionStart: number|null;\n  private rangeSelectionEnd: number|null;\n  private dragStartPointX!: number;\n  private dragStartPointY!: number;\n  private dragStartScrollTop!: number;\n  private visibleLeftTime!: number;\n  private visibleRightTime!: number;\n  private offsetWidth!: number;\n  private targetLeftTime!: number;\n  private targetRightTime!: number;\n  private selectionOffsetShiftX!: number;\n  private selectionStartX!: number|null;\n  private lastMouseOffsetX?: number;\n  private minimumBoundary!: number;\n  private totalTime!: number;\n  private isUpdateScheduled?: boolean;\n  private cancelWindowTimesAnimation?: (() => void)|null;\n\n  #config: Config;\n\n  constructor(delegate: ChartViewportDelegate, config: Config) {\n    super();\n    this.#config = config;\n    this.registerRequiredCSS(chartViewPortStyles);\n\n    this.delegate = delegate;\n\n    this.viewportElement = this.contentElement.createChild('div', 'fill');\n    this.viewportElement.addEventListener('mousemove', this.updateCursorPosition.bind(this), false);\n    this.viewportElement.addEventListener('mouseout', this.onMouseOut.bind(this), false);\n    this.viewportElement.addEventListener('wheel', this.onMouseWheel.bind(this), false);\n    this.viewportElement.addEventListener('keydown', this.onChartKeyDown.bind(this), false);\n    this.viewportElement.addEventListener('keyup', this.onChartKeyUp.bind(this), false);\n\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startDragging.bind(this), this.dragging.bind(this), this.endDragging.bind(this),\n        '-webkit-grabbing', null);\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startRangeSelection.bind(this), this.rangeSelectionDragging.bind(this),\n        this.endRangeSelection.bind(this), 'text', null);\n\n    this.alwaysShowVerticalScrollInternal = false;\n    this.rangeSelectionEnabled = true;\n    this.vScrollElement = this.contentElement.createChild('div', 'chart-viewport-v-scroll');\n    this.vScrollContent = this.vScrollElement.createChild('div');\n    this.vScrollElement.addEventListener('scroll', this.onScroll.bind(this), false);\n\n    this.selectionOverlay = this.contentElement.createChild('div', 'chart-viewport-selection-overlay hidden');\n\n    this.cursorElement = this.contentElement.createChild('div', 'chart-cursor-element hidden');\n\n    this.reset();\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  alwaysShowVerticalScroll(): void {\n    this.alwaysShowVerticalScrollInternal = true;\n    this.vScrollElement.classList.add('always-show-scrollbar');\n  }\n\n  disableRangeSelection(): void {\n    this.rangeSelectionEnabled = false;\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  isDragging(): boolean {\n    return this.isDraggingInternal;\n  }\n\n  override elementsToRestoreScrollPositionsFor(): Element[] {\n    return [this.vScrollElement];\n  }\n\n  private updateScrollBar(): void {\n    const showScroll = this.alwaysShowVerticalScrollInternal || this.totalHeight > this.offsetHeight;\n    if (this.vScrollElement.classList.contains('hidden') !== showScroll) {\n      return;\n    }\n    this.vScrollElement.classList.toggle('hidden', !showScroll);\n    this.updateContentElementSize();\n  }\n\n  override onResize(): void {\n    this.updateScrollBar();\n    this.updateContentElementSize();\n    this.scheduleUpdate();\n  }\n\n  reset(): void {\n    this.vScrollElement.scrollTop = 0;\n    this.scrollTop = 0;\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n    this.isDraggingInternal = false;\n    this.dragStartPointX = 0;\n    this.dragStartPointY = 0;\n    this.dragStartScrollTop = 0;\n    this.visibleLeftTime = 0;\n    this.visibleRightTime = 0;\n    this.offsetWidth = 0;\n    this.offsetHeight = 0;\n    this.totalHeight = 0;\n    this.targetLeftTime = 0;\n    this.targetRightTime = 0;\n    this.isUpdateScheduled = false;\n    this.updateContentElementSize();\n  }\n\n  private updateContentElementSize(): void {\n    let offsetWidth: number = this.vScrollElement.offsetLeft;\n    if (!offsetWidth) {\n      offsetWidth = this.contentElement.offsetWidth;\n    }\n    this.offsetWidth = offsetWidth;\n    this.offsetHeight = this.contentElement.offsetHeight;\n    this.delegate.setSize(this.offsetWidth, this.offsetHeight);\n  }\n\n  setContentHeight(totalHeight: number): void {\n    this.totalHeight = totalHeight;\n    this.vScrollContent.style.height = totalHeight + 'px';\n    this.updateScrollBar();\n    this.updateContentElementSize();\n    if (this.scrollTop + this.offsetHeight <= totalHeight) {\n      return;\n    }\n    this.scrollTop = Math.max(0, totalHeight - this.offsetHeight);\n    this.vScrollElement.scrollTop = this.scrollTop;\n  }\n\n  /**\n   * @param centered - If true, scrolls offset to where it is centered on the chart,\n   * based on current the this.offsetHeight value.\n   */\n  setScrollOffset(offset: number, height?: number, centered?: boolean): void {\n    height = height || 0;\n    if (centered) {\n      // Half of the height for padding.\n      const halfPadding = Math.floor(this.offsetHeight / 2);\n\n      if (this.vScrollElement.scrollTop > offset) {\n        // Need to scroll up, include height.\n        this.vScrollElement.scrollTop = offset - (height + halfPadding);\n      }\n    } else if (this.vScrollElement.scrollTop > offset) {\n      this.vScrollElement.scrollTop = offset;\n    }\n\n    if (this.vScrollElement.scrollTop < offset - this.offsetHeight + height) {\n      this.vScrollElement.scrollTop = offset - this.offsetHeight + height;\n    }\n  }\n\n  scrollOffset(): number {\n    // Return the cached value, rather than the live value (which typically incurs a forced reflow)\n    // In practice, this is true whenever scrollOffset() is called:  `this.scrollTop === this.vScrollElement.scrollTop`\n    return this.scrollTop;\n  }\n\n  chartHeight(): number {\n    return this.offsetHeight;\n  }\n\n  setBoundaries(zeroTime: number, totalTime: number): void {\n    this.minimumBoundary = zeroTime;\n    this.totalTime = totalTime;\n  }\n\n  /**\n   * The mouse wheel can results in flamechart zoom, scroll and pan actions, depending on the scroll deltas and the selected navigation:\n   *\n   * Classic navigation:\n   * 1. Mouse Wheel --> Zoom\n   * 2. Mouse Wheel + Shift --> Scroll\n   * 3. Trackpad: Mouse Wheel AND horizontal scroll (deltaX > deltaY): --> Pan left/right\n   *\n   * Modern navigation:\n   * 1. Mouse Wheel -> Scroll\n   * 2. Mouse Wheel + Shift -> Pan left/right\n   * 3. Mouse Wheel + Ctrl/Cmd -> Zoom\n   * 4. Trackpad: Mouse Wheel AND horizontal scroll (deltaX > deltaY): --> Zoom\n   */\n  private onMouseWheel(wheelEvent: WheelEvent): void {\n    const navigation = Common.Settings.Settings.instance().moduleSetting('flamechart-selected-navigation').get();\n    // Delta for navigation left, right, up and down.\n    // Calculated from horizontal or vertical scroll delta, depending on which one exists.\n    const panDelta = (wheelEvent.deltaY || wheelEvent.deltaX) / 53 * this.offsetHeight / 8;\n    const zoomDelta = Math.pow(1.2, (wheelEvent.deltaY || wheelEvent.deltaX) * 1 / 53) - 1;\n\n    if (navigation === 'classic') {\n      if (wheelEvent.shiftKey) {  // Scroll\n        this.vScrollElement.scrollTop += panDelta;\n      } else if (\n          Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {  // Pan left/right on trackpad horizontal scroll\n        // Horizontal scroll on the trackpad feels smoother when only deltaX is taken into account\n        this.handleHorizontalPanGesture(wheelEvent.deltaX, /* animate */ true);\n      } else {  // Zoom\n        this.handleZoomGesture(zoomDelta);\n      }\n    } else if (navigation === 'modern') {\n      const isCtrlOrCmd = UI.KeyboardShortcut.KeyboardShortcut.eventHasCtrlEquivalentKey(wheelEvent);\n      if (wheelEvent.shiftKey) {  // Pan left/right\n        this.handleHorizontalPanGesture(panDelta, /* animate */ true);\n      } else if (\n          Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {  // Pan left/right on trackpad horizontal scroll\n        // Horizontal scroll on the trackpad feels smoother when only deltaX is taken into account\n        this.handleHorizontalPanGesture(wheelEvent.deltaX, /* animate */ true);\n      } else if (isCtrlOrCmd) {  // Zoom\n        this.handleZoomGesture(zoomDelta);\n      } else {  // Scroll\n        this.vScrollElement.scrollTop += panDelta;\n      }\n    }\n\n    // Block swipe gesture.\n    wheelEvent.consume(true);\n  }\n\n  private startDragging(event: MouseEvent): boolean {\n    if (event.shiftKey) {\n      return false;\n    }\n    this.isDraggingInternal = true;\n    this.dragStartPointX = event.pageX;\n    this.dragStartPointY = event.pageY;\n    this.dragStartScrollTop = this.vScrollElement.scrollTop;\n    this.viewportElement.style.cursor = '';\n    return true;\n  }\n\n  private dragging(event: MouseEvent): void {\n    const pixelShift = this.dragStartPointX - event.pageX;\n    this.dragStartPointX = event.pageX;\n    this.handleHorizontalPanGesture(pixelShift);\n    const pixelScroll = this.dragStartPointY - event.pageY;\n    this.vScrollElement.scrollTop = this.dragStartScrollTop + pixelScroll;\n  }\n\n  private endDragging(): void {\n    this.isDraggingInternal = false;\n  }\n\n  private startRangeSelection(event: MouseEvent): boolean {\n    if (!event.shiftKey || !this.rangeSelectionEnabled) {\n      return false;\n    }\n    this.isDraggingInternal = true;\n    this.selectionOffsetShiftX = event.offsetX - event.pageX;\n    this.selectionStartX = event.offsetX;\n    return true;\n  }\n\n  private endRangeSelection(): void {\n    this.isDraggingInternal = false;\n    this.selectionStartX = null;\n  }\n\n  hideRangeSelection(): void {\n    this.selectionOverlay.classList.add('hidden');\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  /**\n   * @param startTime - the start time of the selection in MilliSeconds\n   * @param endTime - the end time of the selection in MilliSeconds\n   * TODO(crbug.com/346312365): update the type definitions in ChartViewport.ts\n   */\n  setRangeSelection(startTime: number, endTime: number): void {\n    if (!this.rangeSelectionEnabled) {\n      return;\n    }\n    this.rangeSelectionStart = Math.min(startTime, endTime);\n    this.rangeSelectionEnd = Math.max(startTime, endTime);\n    this.delegate.updateRangeSelection(this.rangeSelectionStart, this.rangeSelectionEnd);\n  }\n\n  onClick(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    const time = this.pixelToTime(mouseEvent.offsetX);\n    if (this.rangeSelectionStart !== null && this.rangeSelectionEnd !== null && time >= this.rangeSelectionStart &&\n        time <= this.rangeSelectionEnd) {\n      return;\n    }\n    this.hideRangeSelection();\n  }\n\n  private rangeSelectionDragging(event: MouseEvent): void {\n    const x = Platform.NumberUtilities.clamp(event.pageX + this.selectionOffsetShiftX, 0, this.offsetWidth);\n    const start = this.pixelToTime(this.selectionStartX || 0);\n    const end = this.pixelToTime(x);\n    this.setRangeSelection(start, end);\n  }\n\n  private onScroll(): void {\n    this.scrollTop = this.vScrollElement.scrollTop;\n    this.scheduleUpdate();\n  }\n\n  private onMouseOut(): void {\n    this.lastMouseOffsetX = -1;\n    this.showCursor(false);\n  }\n\n  private updateCursorPosition(e: Event): void {\n    const mouseEvent = (e as MouseEvent);\n    this.lastMouseOffsetX = mouseEvent.offsetX;\n    const shouldShowCursor = this.#config.enableCursorElement && mouseEvent.shiftKey && !mouseEvent.metaKey;\n    this.showCursor(shouldShowCursor);\n    if (shouldShowCursor) {\n      this.cursorElement.style.left = mouseEvent.offsetX + 'px';\n    }\n  }\n\n  pixelToTime(x: number): number {\n    return this.pixelToTimeOffset(x) + this.visibleLeftTime;\n  }\n\n  pixelToTimeOffset(x: number): number {\n    return x * (this.visibleRightTime - this.visibleLeftTime) / this.offsetWidth;\n  }\n\n  timeToPosition(time: number): number {\n    return Math.floor(\n        (time - this.visibleLeftTime) / (this.visibleRightTime - this.visibleLeftTime) * this.offsetWidth);\n  }\n\n  timeToPixel(): number {\n    return this.offsetWidth / (this.visibleRightTime - this.visibleLeftTime);\n  }\n\n  private showCursor(visible: boolean): void {\n    this.cursorElement.classList.toggle('hidden', !visible || this.isDraggingInternal);\n  }\n\n  private onChartKeyDown(keyboardEvent: KeyboardEvent): void {\n    this.showCursor(keyboardEvent.shiftKey);\n    this.handleZoomPanScrollKeys(keyboardEvent);\n  }\n\n  private onChartKeyUp(keyboardEvent: KeyboardEvent): void {\n    this.showCursor(keyboardEvent.shiftKey);\n  }\n\n  private handleZoomPanScrollKeys(keyboardEvent: KeyboardEvent): void {\n    // Do not zoom, pan or scroll if the key combination has any modifiers other than shift key\n    if (UI.KeyboardShortcut.KeyboardShortcut.hasAtLeastOneModifier(keyboardEvent) && !keyboardEvent.shiftKey) {\n      return;\n    }\n    const zoomFactor = keyboardEvent.shiftKey ? 0.8 : 0.3;\n    const panOffset = 160;\n    const scrollOffset = 50;\n    switch (keyboardEvent.code) {\n      case 'KeyA':\n        this.handleHorizontalPanGesture(-panOffset, /* animate */ true);\n        break;\n      case 'KeyD':\n        this.handleHorizontalPanGesture(panOffset, /* animate */ true);\n        break;\n      case 'Equal':  // '+' key for zoom in\n      case 'KeyW':\n        this.handleZoomGesture(-zoomFactor);\n        break;\n      case 'Minus':  // '-' key for zoom out\n      case 'KeyS':\n        this.handleZoomGesture(zoomFactor);\n        break;\n      case 'ArrowUp':\n        if (keyboardEvent.shiftKey) {\n          this.vScrollElement.scrollTop -= scrollOffset;\n        }\n        break;\n      case 'ArrowDown':\n        if (keyboardEvent.shiftKey) {\n          this.vScrollElement.scrollTop += scrollOffset;\n        }\n        break;\n      case 'ArrowLeft':\n        if (keyboardEvent.shiftKey) {\n          this.handleHorizontalPanGesture(-panOffset, /* animate */ true);\n        }\n        break;\n      case 'ArrowRight':\n        if (keyboardEvent.shiftKey) {\n          this.handleHorizontalPanGesture(panOffset, /* animate */ true);\n        }\n        break;\n      default:\n        return;\n    }\n    keyboardEvent.consume(true);\n  }\n\n  private handleZoomGesture(zoom: number): void {\n    const bounds = {left: this.targetLeftTime, right: this.targetRightTime};\n    // If the user has not moved their mouse over the panel (unlikely but\n    // possible!), the offsetX will be undefined. In that case, let's just use\n    // the minimum time / pixel 0 as their mouse point.\n    const cursorTime = this.pixelToTime(this.lastMouseOffsetX || 0);\n    bounds.left += (bounds.left - cursorTime) * zoom;\n    bounds.right += (bounds.right - cursorTime) * zoom;\n    this.requestWindowTimes(bounds, /* animate */ true);\n  }\n\n  private handleHorizontalPanGesture(offset: number, animate?: boolean): void {\n    const bounds = {left: this.targetLeftTime, right: this.targetRightTime};\n    const timeOffset = Platform.NumberUtilities.clamp(\n        this.pixelToTimeOffset(offset), this.minimumBoundary - bounds.left,\n        this.totalTime + this.minimumBoundary - bounds.right);\n    bounds.left += timeOffset;\n    bounds.right += timeOffset;\n    this.requestWindowTimes(bounds, Boolean(animate));\n  }\n\n  private requestWindowTimes(\n      bounds: {\n        left: number,\n        right: number,\n      },\n      animate: boolean): void {\n    const maxBound = this.minimumBoundary + this.totalTime;\n    if (bounds.left < this.minimumBoundary) {\n      bounds.right = Math.min(bounds.right + this.minimumBoundary - bounds.left, maxBound);\n      bounds.left = this.minimumBoundary;\n    } else if (bounds.right > maxBound) {\n      bounds.left = Math.max(bounds.left - bounds.right + maxBound, this.minimumBoundary);\n      bounds.right = maxBound;\n    }\n    if (bounds.right - bounds.left < MinimalTimeWindowMs) {\n      return;\n    }\n    this.delegate.windowChanged(bounds.left, bounds.right, animate);\n  }\n\n  scheduleUpdate(): void {\n    if (this.cancelWindowTimesAnimation || this.isUpdateScheduled) {\n      return;\n    }\n    this.isUpdateScheduled = true;\n    void RenderCoordinator.write(() => {\n      this.isUpdateScheduled = false;\n      this.update();\n    });\n  }\n\n  update(): void {\n    this.delegate.update();\n  }\n\n  override willHide(): void {\n    // Stop animations when the view is hidden (or destroyed).\n    // In this case, we also jump the time immediately to the target time, so\n    // that if the view is restored, the time shown is correct.\n    if (this.cancelWindowTimesAnimation) {\n      this.cancelWindowTimesAnimation();\n      this.setWindowTimes(this.targetLeftTime, this.targetRightTime, false);\n    }\n  }\n\n  setWindowTimes(startTime: number, endTime: number, animate?: boolean): void {\n    if (startTime === this.targetLeftTime && endTime === this.targetRightTime) {\n      return;\n    }\n    if (!animate || this.visibleLeftTime === 0 || this.visibleRightTime === Infinity ||\n        (startTime === 0 && endTime === Infinity) || (startTime === Infinity && endTime === Infinity)) {\n      // Skip animation, move instantly.\n      this.targetLeftTime = startTime;\n      this.targetRightTime = endTime;\n      this.visibleLeftTime = startTime;\n      this.visibleRightTime = endTime;\n      this.scheduleUpdate();\n      return;\n    }\n    if (this.cancelWindowTimesAnimation) {\n      this.cancelWindowTimesAnimation();\n      this.visibleLeftTime = this.targetLeftTime;\n      this.visibleRightTime = this.targetRightTime;\n    }\n    this.targetLeftTime = startTime;\n    this.targetRightTime = endTime;\n    this.cancelWindowTimesAnimation = UI.UIUtils.animateFunction(\n        this.element.window(), animateWindowTimes.bind(this),\n        [{from: this.visibleLeftTime, to: startTime}, {from: this.visibleRightTime, to: endTime}], 100, () => {\n          this.cancelWindowTimesAnimation = null;\n        });\n\n    function animateWindowTimes(this: ChartViewport, startTime: number, endTime: number): void {\n      // We cancel the animation in the willHide method, but as an extra check\n      // bail here if we are hidden rather than queue an update.\n      if (!this.isShowing()) {\n        return;\n      }\n      this.visibleLeftTime = startTime;\n      this.visibleRightTime = endTime;\n      this.update();\n    }\n  }\n\n  windowLeftTime(): number {\n    return this.visibleLeftTime;\n  }\n\n  windowRightTime(): number {\n    return this.visibleRightTime;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.chart-viewport-v-scroll {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  overflow-x: hidden;\n  z-index: 200;\n  padding-left: 1px;\n}\n\n.chart-viewport-v-scroll.always-show-scrollbar {\n  overflow-y: scroll;\n}\n/* force non overlay scrollbars for Mac */\n\n:host-context(.platform-mac) .chart-viewport-v-scroll {\n  right: 2px;\n  top: 3px;\n  bottom: 3px;\n}\n\n:host-context(.platform-mac) ::-webkit-scrollbar {\n  width: 8px;\n}\n\n:host-context(.platform-mac) ::-webkit-scrollbar-thumb {\n  background-color: var(--color-scrollbar-mac);\n  border-radius: 50px;\n}\n\n:host-context(.platform-mac) .chart-viewport-v-scroll:hover::-webkit-scrollbar-thumb {\n  background-color: var(--color-scrollbar-mac-hover);\n}\n/* force non overlay scrollbars for Aura Overlay Scrollbar enabled */\n\n:host-context(.overlay-scrollbar-enabled) ::-webkit-scrollbar {\n  width: 10px;\n}\n\n:host-context(.overlay-scrollbar-enabled) ::-webkit-scrollbar-thumb {\n  background-color: var(--color-scrollbar-other);\n}\n\n:host-context(.overlay-scrollbar-enabled) .chart-viewport-v-scroll:hover::-webkit-scrollbar-thumb {\n  background-color: var(--color-scrollbar-other-hover);\n}\n\n.chart-viewport-selection-overlay {\n  position: absolute;\n  z-index: 100;\n  background-color: var(--sys-color-state-ripple-primary);\n  border-color: var(--sys-color-primary);\n  border-width: 0 1px;\n  border-style: solid;\n  pointer-events: none;\n  top: 0;\n  bottom: 0;\n  text-align: center;\n}\n\n.chart-viewport-selection-overlay .time-span {\n  white-space: nowrap;\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n/*# sourceURL=${import.meta.resolve('./chartViewport.css')} */`;", "/**\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\nimport * as Buttons from '../../../components/buttons/buttons.js';\nimport * as UI from '../../legacy.js';\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport {drawExpansionArrow, drawIcon, horizontalLine} from './CanvasHelper.js';\nimport {ChartViewport, type ChartViewportDelegate} from './ChartViewport.js';\nimport flameChartStyles from './flameChart.css.js';\nimport {DEFAULT_FONT_SIZE, getFontFamilyForCanvas} from './Font.js';\nimport {type Calculator, TimelineGrid} from './TimelineGrid.js';\n\n/**\n * Set as the `details` value on the fake context menu event we dispatch to\n * trigger a context menu on an event on a keyboard space key press.\n {@see onContextMenu} for more details and explanation.\n */\nconst KEYBOARD_FAKED_CONTEXT_MENU_DETAIL = -1;\n\n/**\n * The adjustments needed for the subtitle font (based off of the default font).\n */\nconst SUBTITLE_FONT_SIZE_AND_STYLE = 'italic 10px';\n\nconst UIStrings = {\n  /**\n   *@description Aria alert used to notify the user when an event has been selected because they tabbed into a group.\n   *@example {Paint} PH1\n   *@example {Main thread} PH2\n   *\n   */\n  eventSelectedFromGroup: 'Selected a {PH1} event within {PH2}. Press \"enter\" to focus this event.',\n  /**\n   *@description Aria accessible name in Flame Chart of the Performance panel\n   */\n  flameChart: 'Flame Chart',\n  /**\n   *@description Text for the screen reader to announce a hovered group\n   *@example {Network} PH1\n   */\n  sHovered: '{PH1} hovered',\n  /**\n   *@description Text for screen reader to announce a selected group.\n   *@example {Network} PH1\n   */\n  sSelected: '{PH1} selected',\n  /**\n   *@description Text for screen reader to announce an expanded group\n   *@example {Network} PH1\n   */\n  sExpanded: '{PH1} expanded',\n  /**\n   *@description Text for screen reader to announce a collapsed group\n   *@example {Network} PH1\n   */\n  sCollapsed: '{PH1} collapsed',\n  /**\n   *@description Text for an action that adds a label annotation to an entry in the Flame Chart\n   */\n  labelEntry: 'Label entry',\n  /**\n   *@description Text for an action that adds link annotation between entries in the Flame Chart\n   */\n  linkEntries: 'Link entries',\n  /**\n   *@description Shown in the context menu when right clicking on a track header to enable the user to enter the track configuration mode.\n   */\n  enterTrackConfigurationMode: 'Configure tracks',\n  /**\n   *@description Shown in the context menu when right clicking on a track header to allow the user to exit track configuration mode.\n   */\n  exitTrackConfigurationMode: 'Finish configuring tracks',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/FlameChart.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\n/**\n * The expansion arrow is drawn from the center, so the indent is in fact the center of the arrow.\n * See `drawExpansionArrow` function to understand how we draw the arrow.\n * |headerLeftPadding|Arrow|\n * |expansionArrowIndent|\n *\n * When we are in edit mode, we render 3 icons to the left of the track's title.\n * When we are in normal mode, there are no icons to the left of the track's title.\n **/\n\n// Placed to the left of the track header.\nconst HEADER_LEFT_PADDING = 6;\nexport const ARROW_SIDE = 8;\n\nconst EXPANSION_ARROW_INDENT = HEADER_LEFT_PADDING + ARROW_SIDE / 2;\nconst HEADER_LABEL_X_PADDING = 3;\nconst HEADER_LABEL_Y_PADDING = 2;\nconst PADDING_BETWEEN_TITLE_AND_SUBTITLE = 6;\n\n// The width of each of the edit mode icons.\nexport const EDIT_ICON_WIDTH = 16;\n// This gap might seem quite small - but the icons themselves have some\n// whitespace either side, so we don't need a huge gap.\nconst GAP_BETWEEN_EDIT_ICONS = 3;\n// The UP icon is first, and is rendered in from the left just as the track text.\nconst UP_ICON_LEFT = HEADER_LEFT_PADDING;\n// The DOWN icon is after the UP icon, hence we take the up icon's position,\n// add its width and then the gap between them.\nconst DOWN_ICON_LEFT = UP_ICON_LEFT + EDIT_ICON_WIDTH + GAP_BETWEEN_EDIT_ICONS;\n// The HIDE icon is after the DOWN icon, hence we take the up icon's position,\n// add its width and then the gap between them.\nconst HIDE_ICON_LEFT = DOWN_ICON_LEFT + EDIT_ICON_WIDTH + GAP_BETWEEN_EDIT_ICONS;\n\n// Represents the total width taken by the 3 icons (up, down, hide/show, and\n// the gap between them.)\n// We calculate this by taking the space to the left of the hide icon (which\n// encompasses UP/DOWN icons), adding on the width of the HIDE icon, and then a\n// bit of extra padding.\nconst EDIT_MODE_TOTAL_ICON_WIDTH = HIDE_ICON_LEFT + EDIT_ICON_WIDTH + GAP_BETWEEN_EDIT_ICONS;\n\n// These are copied from front_end/images/*.svg, because we need to draw them with canvas.\n// arrow-up.svg\nconst moveUpIconPath = 'M9.25 17V5.875L7.062 8.062L6 7L10 3L14 7L12.938 8.062L10.75 5.875V17H9.25Z';\n// arrow-down.svg\nconst moveDownIconPath = 'M9.25 3V14.125L7.062 11.938L6 13L10 17L14 13L12.938 11.938L10.75 14.125V3H9.25Z';\n// eye-crossed.svg\nconst hideIconPath =\n    'M13.2708 11.1459L11.9792 9.85419C12.0347 9.32641 11.875 8.87155 11.5 8.4896C11.125 8.10766 10.6736 7.94446 10.1458 8.00002L8.85417 6.70835C9.03472 6.63891 9.22222 6.58683 9.41667 6.5521C9.61111 6.51738 9.80556 6.50002 10 6.50002C10.9722 6.50002 11.7986 6.8403 12.4792 7.52085C13.1597 8.20141 13.5 9.0278 13.5 10C13.5 10.1945 13.4826 10.3889 13.4479 10.5834C13.4132 10.7778 13.3542 10.9653 13.2708 11.1459ZM16.0417 13.9167L14.9583 12.8334C15.4583 12.4445 15.9132 12.0174 16.3229 11.5521C16.7326 11.0868 17.0764 10.5695 17.3542 10C16.6736 8.59724 15.6701 7.49655 14.3438 6.69794C13.0174 5.89933 11.5694 5.50002 10 5.50002C9.63889 5.50002 9.28472 5.52085 8.9375 5.56252C8.59028 5.60419 8.25 5.67363 7.91667 5.77085L6.70833 4.56252C7.23611 4.35419 7.77431 4.20835 8.32292 4.12502C8.87153 4.04169 9.43056 4.00002 10 4.00002C11.9861 4.00002 13.8021 4.53821 15.4479 5.6146C17.0938 6.69099 18.2778 8.1528 19 10C18.6944 10.7917 18.2882 11.5104 17.7813 12.1563C17.2743 12.8021 16.6944 13.3889 16.0417 13.9167ZM16 18.125L13.2917 15.4167C12.7639 15.6111 12.2257 15.757 11.6771 15.8542C11.1285 15.9514 10.5694 16 10 16C8.01389 16 6.19792 15.4618 4.55208 14.3854C2.90625 13.309 1.72222 11.8472 1 10C1.30556 9.20835 1.70833 8.48613 2.20833 7.83335C2.70833 7.18058 3.29167 6.5903 3.95833 6.06252L1.875 3.97919L2.9375 2.91669L17.0625 17.0625L16 18.125ZM5.02083 7.14585C4.53472 7.53474 4.08333 7.96183 3.66667 8.4271C3.25 8.89238 2.90972 9.41669 2.64583 10C3.32639 11.4028 4.32986 12.5035 5.65625 13.3021C6.98264 14.1007 8.43056 14.5 10 14.5C10.3611 14.5 10.7153 14.4757 11.0625 14.4271C11.4097 14.3785 11.7569 14.3125 12.1042 14.2292L11.1667 13.2917C10.9722 13.3611 10.7778 13.4132 10.5833 13.4479C10.3889 13.4827 10.1944 13.5 10 13.5C9.02778 13.5 8.20139 13.1597 7.52083 12.4792C6.84028 11.7986 6.5 10.9722 6.5 10C6.5 9.80558 6.52431 9.61113 6.57292 9.41669C6.62153 9.22224 6.66667 9.0278 6.70833 8.83335L5.02083 7.14585Z';\n// eye.svg\nconst showIconPath =\n    'M10 13.5C10.972 13.5 11.7983 13.1597 12.479 12.479C13.1597 11.7983 13.5 10.972 13.5 10C13.5 9.028 13.1597 8.20167 12.479 7.521C11.7983 6.84033 10.972 6.5 10 6.5C9.028 6.5 8.20167 6.84033 7.521 7.521C6.84033 8.20167 6.5 9.028 6.5 10C6.5 10.972 6.84033 11.7983 7.521 12.479C8.20167 13.1597 9.028 13.5 10 13.5ZM10 12C9.44467 12 8.97233 11.8057 8.583 11.417C8.19433 11.0277 8 10.5553 8 10C8 9.44467 8.19433 8.97233 8.583 8.583C8.97233 8.19433 9.44467 8 10 8C10.5553 8 11.0277 8.19433 11.417 8.583C11.8057 8.97233 12 9.44467 12 10C12 10.5553 11.8057 11.0277 11.417 11.417C11.0277 11.8057 10.5553 12 10 12ZM10 16C8.014 16 6.20833 15.455 4.583 14.365C2.95833 13.2743 1.764 11.8193 1 10C1.764 8.18067 2.95833 6.72567 4.583 5.635C6.20833 4.545 8.014 4 10 4C11.986 4 13.7917 4.545 15.417 5.635C17.0417 6.72567 18.236 8.18067 19 10C18.236 11.8193 17.0417 13.2743 15.417 14.365C13.7917 15.455 11.986 16 10 16ZM10 14.5C11.5553 14.5 12.9927 14.0973 14.312 13.292C15.632 12.486 16.646 11.3887 17.354 10C16.646 8.61133 15.632 7.514 14.312 6.708C12.9927 5.90267 11.5553 5.5 10 5.5C8.44467 5.5 7.00733 5.90267 5.688 6.708C4.368 7.514 3.354 8.61133 2.646 10C3.354 11.3887 4.368 12.486 5.688 13.292C7.00733 14.0973 8.44467 14.5 10 14.5Z';\n\n// export for test.\nexport const enum HoverType {\n  TRACK_CONFIG_UP_BUTTON = 'TRACK_CONFIG_UP_BUTTON',\n  TRACK_CONFIG_DOWN_BUTTON = 'TRACK_CONFIG_DOWN_BUTTON',\n  TRACK_CONFIG_HIDE_BUTTON = 'TRACK_CONFIG_HIDE_BUTTON',\n  TRACK_CONFIG_SHOW_BUTTON = 'TRACK_CONFIG_SHOW_BUTTON',\n  INSIDE_TRACK_HEADER = 'INSIDE_TRACK_HEADER',\n  INSIDE_TRACK = 'INSIDE_TRACK',\n  OUTSIDE_TRACKS = 'OUTSIDE_TRACKS',\n  ERROR = 'ERROR',\n}\n\nexport interface FlameChartDelegate {\n  windowChanged(_startTime: number, _endTime: number, _animate: boolean): void;\n  updateRangeSelection(_startTime: number, _endTime: number): void;\n  updateSelectedGroup(_flameChart: FlameChart, _group: Group|null): void;\n  /**\n   * Returns the element that the FlameChart has been rendered into. Used to\n   * provide element references for attaching to Visual Element logs.\n   */\n  containingElement?: () => HTMLElement;\n}\n\ninterface PopoverState {\n  // Index of the last entry the popover was shown over.\n  entryIndex: number|null;\n  // Index of the last group the popover was shown over.\n  groupIndex: number;\n  hiddenEntriesPopover: boolean;\n}\ninterface GroupTreeNode {\n  index: number;\n  nestingLevel: number;\n  startLevel: number;\n  endLevel: number;\n  // The order in children is the visible order of them.\n  children: GroupTreeNode[];\n}\n\nexport interface OptionalFlameChartConfig {\n  /**\n   * The FlameChart will highlight the entry that is selected by default. In\n   * some cases (Performance Panel) we manage this ourselves with the Overlays\n   * system, so we disable the built in one.\n   */\n  selectedElementOutline?: boolean;\n  /**\n   * The element to use when populating and positioning the mouse tooltip.\n   */\n  tooltipElement?: HTMLElement;\n  /**\n   * Used to disable the cursor element in ChartViewport and instead use the new overlays system.\n   */\n  useOverlaysForCursorRuler?: boolean;\n}\n\nexport const enum FilterAction {\n  MERGE_FUNCTION = 'MERGE_FUNCTION',\n  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',\n  COLLAPSE_REPEATING_DESCENDANTS = 'COLLAPSE_REPEATING_DESCENDANTS',\n  RESET_CHILDREN = 'RESET_CHILDREN',\n  UNDO_ALL_ACTIONS = 'UNDO_ALL_ACTIONS',\n}\n\nexport interface UserFilterAction {\n  type: FilterAction;\n  entry: Trace.Types.Events.Event;\n}\n\n// Object used to indicate to the Context Menu if an action is possible on the selected entry.\nexport interface PossibleFilterActions {\n  [FilterAction.MERGE_FUNCTION]: boolean;\n  [FilterAction.COLLAPSE_FUNCTION]: boolean;\n  [FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: boolean;\n  [FilterAction.RESET_CHILDREN]: boolean;\n  [FilterAction.UNDO_ALL_ACTIONS]: boolean;\n}\n\nexport interface PositionOverride {\n  x: number;\n  width: number;\n  /** The z index of this entry. Use -1 if placing it underneath other entries. A z of 0 is assumed, otherwise, much like CSS's z-index */\n  z?: number;\n}\n\nexport type DrawOverride =\n    (context: CanvasRenderingContext2D, x: number, y: number, width: number, height: number,\n     timeToPosition: (time: number) => number, transformColor: (color: string) => string) => PositionOverride;\n\nexport class FlameChart extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(UI.Widget.VBox)\n    implements Calculator, ChartViewportDelegate {\n  private readonly flameChartDelegate: FlameChartDelegate;\n  private chartViewport: ChartViewport;\n  private dataProvider: FlameChartDataProvider;\n  private candyStripePattern: CanvasPattern|null;\n  private candyStripePatternGray: CanvasPattern|null;\n  private contextMenu?: UI.ContextMenu.ContextMenu;\n  private viewportElement: HTMLElement;\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private popoverElement: HTMLElement;\n  private readonly markerHighlighElement: HTMLElement;\n  readonly highlightElement: HTMLElement;\n  readonly revealDescendantsArrowHighlightElement: HTMLElement;\n  private readonly selectedElement: HTMLElement|null = null;\n  private rulerEnabled: boolean;\n  private barHeight: number;\n  // Additional space around an entry that is added for operations with entry.\n  // It allows for less pecision while selecting/hovering over an entry.\n  private hitMarginPx: number;\n  private textBaseline: number;\n  private textPadding: number;\n  private highlightedMarkerIndex: number;\n  /**\n   * The index of the entry that's hovered (typically), or focused because of searchResult or other reasons.focused via searchResults, or focused by other means.\n   * Updated as the cursor moves. Meanwhile `selectedEntryIndex` is the entry that's been clicked.\n   **/\n  private highlightedEntryIndex: number;\n  /**\n   * Represents the index of the entry that is selected. For an entry to be\n   * selected, it has to be clicked by the user (generally).\n   **/\n  private selectedEntryIndex: number;\n  private rawTimelineDataLength: number;\n  private readonly markerPositions: Map<number, PositionOverride>;\n  private readonly customDrawnPositions: Map<number, PositionOverride>;\n  private lastMouseOffsetX: number;\n  private selectedGroupIndex: number;\n  private keyboardFocusedGroup: number;\n  private offsetWidth!: number;\n  private offsetHeight!: number;\n  private dragStartX!: number;\n  private dragStartY!: number;\n  private lastMouseOffsetY!: number;\n  private minimumBoundaryInternal!: number;\n  private maxDragOffset!: number;\n  private timelineLevels?: number[][]|null;\n  private visibleLevelOffsets?: Uint32Array|null;\n  private visibleLevels?: boolean[]|null;\n  private visibleLevelHeights?: Uint32Array;\n  private groupOffsets?: Uint32Array|null;\n  private rawTimelineData?: FlameChartTimelineData|null;\n  private forceDecorationCache?: boolean[]|null;\n  private entryColorsCache?: string[]|null;\n  private colorDimmingCache = new Map<string, string>();\n  private totalTime?: number;\n  private lastPopoverState: PopoverState;\n\n  private dimIndices?: Uint8Array|null;\n  /** When true, all undimmed entries are outlined. When an array, only those indices are outlined (if not dimmed). */\n  private dimShouldOutlineUndimmedEntries: boolean|Uint8Array = false;\n\n  #tooltipPopoverYAdjustment = 0;\n\n  #font: string;\n  #subtitleFont: string;\n  #groupTreeRoot?: GroupTreeNode|null;\n  #searchResultEntryIndex: number|null = null;\n  #inTrackConfigEditMode = false;\n  #linkSelectionAnnotationIsInProgress = false;\n\n  // Stored because we cache this value to save extra lookups and layoffs.\n  #canvasBoundingClientRect: DOMRect|null = null;\n  #selectedElementOutlineEnabled = true;\n\n  #indexToDrawOverride = new Map<number, DrawOverride>();\n  #persistedGroupConfig: PersistedGroupConfig[]|null = null;\n  readonly #boundOnThemeChanged = this.#onThemeChanged.bind(this);\n\n  constructor(\n      dataProvider: FlameChartDataProvider, flameChartDelegate: FlameChartDelegate,\n      optionalConfig: OptionalFlameChartConfig = {}) {\n    super(true);\n    this.#font = `${DEFAULT_FONT_SIZE} ${getFontFamilyForCanvas()}`;\n    this.#subtitleFont = `${SUBTITLE_FONT_SIZE_AND_STYLE} ${getFontFamilyForCanvas()}`;\n    this.registerRequiredCSS(flameChartStyles);\n    this.registerRequiredCSS(UI.inspectorCommonStyles);\n\n    this.contentElement.classList.add('flame-chart-main-pane');\n    if (typeof optionalConfig.selectedElementOutline === 'boolean') {\n      this.#selectedElementOutlineEnabled = optionalConfig.selectedElementOutline;\n    }\n\n    this.flameChartDelegate = flameChartDelegate;\n\n    // The ChartViewport has its own built-in ruler for when the user holds\n    // shift and moves the mouse. We want to disable that if we are within the\n    // performance panel where we use overlays, but enable it otherwise.\n    let enableCursorElement = true;\n    if (typeof optionalConfig.useOverlaysForCursorRuler === 'boolean') {\n      enableCursorElement = !optionalConfig.useOverlaysForCursorRuler;\n    }\n    this.chartViewport = new ChartViewport(this, {\n      enableCursorElement,\n    });\n    this.chartViewport.show(this.contentElement);\n\n    this.dataProvider = dataProvider;\n\n    this.viewportElement = this.chartViewport.viewportElement;\n    this.canvas = this.viewportElement.createChild('canvas', 'fill');\n    this.context = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n    this.candyStripePattern = this.candyStripePatternGray = null;\n\n    this.canvas.tabIndex = 0;\n    UI.ARIAUtils.setLabel(this.canvas, i18nString(UIStrings.flameChart));\n    UI.ARIAUtils.markAsTree(this.canvas);\n    this.setDefaultFocusedElement(this.canvas);\n    this.canvas.classList.add('flame-chart-canvas');\n    this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this), false);\n    this.canvas.addEventListener('mouseout', this.onMouseOut.bind(this), false);\n    this.canvas.addEventListener('click', this.onClick.bind(this), false);\n    this.canvas.addEventListener('dblclick', this.#onDblClick.bind(this), false);\n    this.canvas.addEventListener('keydown', this.onKeyDown.bind(this), false);\n    this.canvas.addEventListener('contextmenu', this.onContextMenu.bind(this), false);\n\n    this.popoverElement =\n        optionalConfig.tooltipElement || this.viewportElement.createChild('div', 'flame-chart-entry-info');\n    this.markerHighlighElement = this.viewportElement.createChild('div', 'flame-chart-marker-highlight-element');\n    this.highlightElement = this.viewportElement.createChild('div', 'flame-chart-highlight-element');\n    this.revealDescendantsArrowHighlightElement =\n        this.viewportElement.createChild('div', 'reveal-descendants-arrow-highlight-element');\n\n    if (this.#selectedElementOutlineEnabled) {\n      this.selectedElement = this.viewportElement.createChild('div', 'flame-chart-selected-element');\n    }\n\n    this.canvas.addEventListener('focus', () => {\n      this.dispatchEventToListeners(Events.CANVAS_FOCUSED);\n    }, false);\n\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startDragging.bind(this), this.dragging.bind(this), this.endDragging.bind(this),\n        null);\n\n    this.rulerEnabled = true;\n    this.barHeight = 17;\n    this.hitMarginPx = 3;\n    this.textBaseline = 5;\n    this.textPadding = 5;\n    this.chartViewport.setWindowTimes(\n        dataProvider.minimumBoundary(), dataProvider.minimumBoundary() + dataProvider.totalTime());\n\n    this.highlightedMarkerIndex = -1;\n    this.highlightedEntryIndex = -1;\n    this.selectedEntryIndex = -1;\n    this.#searchResultEntryIndex = null;\n    this.rawTimelineDataLength = 0;\n    this.markerPositions = new Map();\n    this.customDrawnPositions = new Map();\n\n    this.lastMouseOffsetX = 0;\n    this.selectedGroupIndex = -1;\n    this.lastPopoverState = {\n      entryIndex: -1,\n      groupIndex: -1,\n      hiddenEntriesPopover: false,\n    };\n\n    // Keyboard focused group is used to navigate groups irrespective of whether they are selectable or not\n    this.keyboardFocusedGroup = -1;\n  }\n\n  #onThemeChanged(): void {\n    this.scheduleUpdate();\n  }\n\n  override wasShown(): void {\n    super.wasShown();\n    ThemeSupport.ThemeSupport.instance().addEventListener(\n        ThemeSupport.ThemeChangeEvent.eventName, this.#boundOnThemeChanged);\n  }\n\n  override willHide(): void {\n    ThemeSupport.ThemeSupport.instance().removeEventListener(\n        ThemeSupport.ThemeChangeEvent.eventName, this.#boundOnThemeChanged);\n    this.hideHighlight();\n    super.willHide();\n  }\n\n  canvasBoundingClientRect(): DOMRect|null {\n    // If we have a rect already, and it has width & height, use it by default.\n    // The reason we check the dimensions is because otherwise if this method was\n    // called before the FlameChart was fully rendered it might have been\n    // calculated with a width or height of 0, and that is clearly incorrect.\n    if (this.#canvasBoundingClientRect && this.#canvasBoundingClientRect.width > 0 &&\n        this.#canvasBoundingClientRect.height > 0) {\n      return this.#canvasBoundingClientRect;\n    }\n    this.#canvasBoundingClientRect = this.canvas.getBoundingClientRect();\n    return this.#canvasBoundingClientRect;\n  }\n\n  /**\n   * In some cases we need to manually adjust the positioning of the tooltip\n   * vertically to account for the fact that it might be rendered not relative\n   * to just this flame chart. This is true of the main flame chart in the\n   * Performance Panel where the element is rendered in a higher-stack container\n   * and we need to manually adjust its Y position to correctly put the tooltip\n   * in the right place.\n   */\n  setTooltipYPixelAdjustment(y: number): void {\n    if (y === this.#tooltipPopoverYAdjustment) {\n      return;\n    }\n\n    this.#tooltipPopoverYAdjustment = y;\n    // Reposition the popover if it has any children (otherwise it is not visible)\n    if (this.popoverElement.children.length) {\n      this.updatePopoverOffset();\n    }\n  }\n\n  getBarHeight(): number {\n    return this.barHeight;\n  }\n\n  setBarHeight(value: number): void {\n    this.barHeight = value;\n  }\n\n  setTextBaseline(value: number): void {\n    this.textBaseline = value;\n  }\n\n  setTextPadding(value: number): void {\n    this.textPadding = value;\n  }\n\n  enableRuler(enable: boolean): void {\n    this.rulerEnabled = enable;\n  }\n\n  alwaysShowVerticalScroll(): void {\n    this.chartViewport.alwaysShowVerticalScroll();\n  }\n\n  disableRangeSelection(): void {\n    this.chartViewport.disableRangeSelection();\n  }\n\n  #shouldDimEvent(entryIndex: number): boolean {\n    if (this.dimIndices) {\n      return this.dimIndices[entryIndex] !== 0;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true only if dimming is active, but not for this specific entry.\n   * Also checks `dimShouldOutlineUndimmedEntries`.\n   */\n  #shouldOutlineEvent(entryIndex: number): boolean {\n    if (!this.isDimming() || this.#shouldDimEvent(entryIndex)) {\n      return false;\n    }\n\n    if (ArrayBuffer.isView(this.dimShouldOutlineUndimmedEntries)) {\n      return this.dimShouldOutlineUndimmedEntries[entryIndex] !== 0;\n    }\n\n    return this.dimShouldOutlineUndimmedEntries;\n  }\n\n  /**\n   * Returns a contiguous boolean array for quick lookup during drawing.\n   */\n  #createTypedIndexArray(indices: number[], inclusive: boolean): Uint8Array {\n    const typedIndices = new Uint8Array(this.rawTimelineDataLength);\n\n    if (inclusive) {\n      for (const index of indices) {\n        typedIndices[index] = 1;\n      }\n    } else {\n      typedIndices.fill(1);\n      for (const index of indices) {\n        typedIndices[index] = 0;\n      }\n    }\n\n    return typedIndices;\n  }\n\n  enableDimming(entryIndices: number[], inclusive: boolean, outline: boolean|number[]): void {\n    this.dimIndices = this.#createTypedIndexArray(entryIndices, inclusive);\n    this.dimShouldOutlineUndimmedEntries =\n        Array.isArray(outline) ? this.#createTypedIndexArray(outline, true) : outline;\n\n    this.draw();\n  }\n\n  disableDimming(): void {\n    this.dimIndices = null;\n    this.dimShouldOutlineUndimmedEntries = false;\n\n    this.draw();\n  }\n\n  isDimming(): boolean {\n    return Boolean(this.dimIndices);\n  }\n\n  #transformColor(entryIndex: number, color: string): string {\n    if (this.#shouldDimEvent(entryIndex)) {\n      let dimmed = this.colorDimmingCache.get(color);\n      if (dimmed) {\n        return dimmed;\n      }\n\n      const parsedColor = Common.Color.parse(color);\n      dimmed = parsedColor ? parsedColor.asLegacyColor().grayscale().asString() : 'lightgrey';\n      this.colorDimmingCache.set(color, dimmed);\n      return dimmed;\n    }\n\n    return color;\n  }\n\n  getColorForEntry(entryIndex: number): string {\n    if (!this.entryColorsCache) {\n      return '';\n    }\n\n    return this.#transformColor(entryIndex, this.entryColorsCache[entryIndex]);\n  }\n\n  highlightEntry(entryIndex: number): void {\n    if (this.highlightedEntryIndex === entryIndex) {\n      return;\n    }\n    if (!this.dataProvider.entryColor(entryIndex)) {\n      return;\n    }\n    this.highlightedEntryIndex = entryIndex;\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.dispatchEventToListeners(Events.ENTRY_HOVERED, entryIndex);\n  }\n\n  hideHighlight(): void {\n    if (this.#searchResultEntryIndex === null) {\n      this.popoverElement.removeChildren();\n      this.lastPopoverState = {\n        entryIndex: -1,\n        groupIndex: -1,\n        hiddenEntriesPopover: false,\n      };\n    }\n    if (this.highlightedEntryIndex === -1) {\n      return;\n    }\n    this.highlightedEntryIndex = -1;\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.dispatchEventToListeners(Events.ENTRY_HOVERED, -1);\n  }\n\n  private createCandyStripePattern(color: string): CanvasPattern {\n    // Set the candy stripe pattern to 17px so it repeats well.\n    const size = 17;\n    const candyStripeCanvas = document.createElement('canvas');\n    candyStripeCanvas.width = size;\n    candyStripeCanvas.height = size;\n    const ctx = candyStripeCanvas.getContext('2d', {willReadFrequently: true}) as CanvasRenderingContext2D;\n\n    // Rotate the stripe by 45deg to the right.\n    ctx.translate(size * 0.5, size * 0.5);\n    ctx.rotate(Math.PI * 0.25);\n    ctx.translate(-size * 0.5, -size * 0.5);\n\n    ctx.fillStyle = color;\n    for (let x = -size; x < size * 2; x += 3) {\n      ctx.fillRect(x, -size, 1, size * 3);\n    }\n    // Because we're using a canvas, we know createPattern won't return null\n    // https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-createpattern-dev\n    return ctx.createPattern(candyStripeCanvas, 'repeat') as CanvasPattern;\n  }\n\n  private resetCanvas(): void {\n    const ratio = window.devicePixelRatio;\n    const width = Math.round(this.offsetWidth * ratio);\n    const height = Math.round(this.offsetHeight * ratio);\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.width = `${width / ratio}px`;\n    this.canvas.style.height = `${height / ratio}px`;\n  }\n\n  windowChanged(startTime: number, endTime: number, animate: boolean): void {\n    this.flameChartDelegate.windowChanged(startTime, endTime, animate);\n  }\n\n  updateRangeSelection(startTime: number, endTime: number): void {\n    this.flameChartDelegate.updateRangeSelection(startTime, endTime);\n  }\n\n  setSize(width: number, height: number): void {\n    this.offsetWidth = width;\n    this.offsetHeight = height;\n  }\n\n  private startDragging(event: MouseEvent): boolean {\n    this.hideHighlight();\n    this.maxDragOffset = 0;\n    this.dragStartX = event.pageX;\n    this.dragStartY = event.pageY;\n    return true;\n  }\n\n  private dragging(event: MouseEvent): void {\n    const dx = event.pageX - this.dragStartX;\n    const dy = event.pageY - this.dragStartY;\n    this.maxDragOffset = Math.max(this.maxDragOffset, Math.sqrt(dx * dx + dy * dy));\n  }\n\n  private endDragging(_event: MouseEvent): void {\n    this.updateHighlight();\n  }\n\n  timelineData(rebuild?: boolean): FlameChartTimelineData|null {\n    if (!this.dataProvider) {\n      return null;\n    }\n\n    const timelineData = this.dataProvider.timelineData(rebuild);\n    if (timelineData !== this.rawTimelineData ||\n        (timelineData && timelineData.entryStartTimes.length !== this.rawTimelineDataLength)) {\n      this.processTimelineData(timelineData);\n    }\n    return this.rawTimelineData || null;\n  }\n\n  revealEntryVertically(entryIndex: number): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const level = timelineData.entryLevels[entryIndex];\n    this.chartViewport.setScrollOffset(this.levelToOffset(level), this.levelHeight(level), true);\n  }\n\n  revealEntry(entryIndex: number): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const timeLeft = this.chartViewport.windowLeftTime();\n    const timeRight = this.chartViewport.windowRightTime();\n    const entryStartTime = timelineData.entryStartTimes[entryIndex];\n    let entryTotalTime = timelineData.entryTotalTimes[entryIndex];\n    // Marker entries have NaN durations; for the sake of the reveal logic\n    // let's pretend they have a 1ms duration so we can calculate a reasonable\n    // time window to reveal\n    if (Number.isNaN(entryTotalTime)) {\n      entryTotalTime = 1;\n    }\n    const entryEndTime = entryStartTime + entryTotalTime;\n    let minEntryTimeWindow = Math.min(entryTotalTime, timeRight - timeLeft);\n\n    const level = timelineData.entryLevels[entryIndex];\n    this.chartViewport.setScrollOffset(this.levelToOffset(level), this.levelHeight(level));\n\n    const minVisibleWidthPx = 30;\n    const futurePixelToTime = (timeRight - timeLeft) / this.offsetWidth;\n    minEntryTimeWindow = Math.max(minEntryTimeWindow, futurePixelToTime * minVisibleWidthPx);\n    if (timeLeft > entryEndTime) {\n      const delta = timeLeft - entryEndTime + minEntryTimeWindow;\n      this.windowChanged(timeLeft - delta, timeRight - delta, /* animate */ true);\n    } else if (timeRight < entryStartTime) {\n      const delta = entryStartTime - timeRight + minEntryTimeWindow;\n      this.windowChanged(timeLeft + delta, timeRight + delta, /* animate */ true);\n    }\n  }\n\n  setWindowTimes(startTime: number, endTime: number, animate?: boolean): void {\n    this.chartViewport.setWindowTimes(startTime, endTime, animate);\n    this.updateHighlight();\n  }\n\n  /**\n   * Handle the mouse move event. The handle priority will be:\n   *   1. Track configuration icons -> show tooltip for the icons\n   *   2. Inside a track header -> mouse style will be a \"pointer\", indicating track can be focused\n   *   3. Inside a track -> update the highlight of hovered event\n   */\n  private onMouseMove(mouseEvent: MouseEvent): void {\n    this.#searchResultEntryIndex = null;\n    this.lastMouseOffsetX = mouseEvent.offsetX;\n    this.lastMouseOffsetY = mouseEvent.offsetY;\n    if (!this.enabled()) {\n      return;\n    }\n    if (this.chartViewport.isDragging()) {\n      return;\n    }\n\n    const timeMilliSeconds = Trace.Types.Timing.Milli(this.chartViewport.pixelToTime(mouseEvent.offsetX));\n\n    this.dispatchEventToListeners(Events.MOUSE_MOVE, {\n      mouseEvent,\n      timeInMicroSeconds: Trace.Helpers.Timing.milliToMicro(timeMilliSeconds),\n    });\n\n    // Check if the mouse is hovering any group's header area\n    const {groupIndex, hoverType} = this.coordinatesToGroupIndexAndHoverType(mouseEvent.offsetX, mouseEvent.offsetY);\n    switch (hoverType) {\n      case HoverType.TRACK_CONFIG_UP_BUTTON:\n      case HoverType.TRACK_CONFIG_DOWN_BUTTON:\n      case HoverType.TRACK_CONFIG_HIDE_BUTTON:\n      case HoverType.TRACK_CONFIG_SHOW_BUTTON: {\n        this.hideHighlight();\n        this.viewportElement.style.cursor = 'pointer';\n        const iconTooltipElement = this.#prepareIconInfo(groupIndex, hoverType);\n        if (iconTooltipElement) {\n          this.popoverElement.appendChild(iconTooltipElement);\n          this.updatePopoverOffset();\n        }\n        return;\n      }\n      case HoverType.INSIDE_TRACK_HEADER:\n        this.updateHighlight();\n        this.viewportElement.style.cursor = 'pointer';\n        return;\n      case HoverType.INSIDE_TRACK:\n      case HoverType.OUTSIDE_TRACKS:\n        this.updateHighlight();\n        return;\n      case HoverType.ERROR:\n        return;\n      default:\n        Platform.assertNever(hoverType, `Invalid hovering type: ${hoverType}`);\n    }\n  }\n\n  #prepareIconInfo(groupIndex: number, iconType: HoverType): Element|null {\n    const group = this.rawTimelineData?.groups[groupIndex];\n    if (!group) {\n      return null;\n    }\n\n    // Only show first 20 characters to make the tooltip not too long.\n    const maxTitleChars = 20;\n    const displayName = Platform.StringUtilities.trimMiddle(group.name, maxTitleChars);\n\n    let iconTooltip = '';\n    switch (iconType) {\n      case HoverType.TRACK_CONFIG_UP_BUTTON:\n        iconTooltip = `Move ${displayName} track up`;\n        break;\n      case HoverType.TRACK_CONFIG_DOWN_BUTTON:\n        iconTooltip = `Move ${displayName} track down`;\n        break;\n      case HoverType.TRACK_CONFIG_HIDE_BUTTON:\n        if (this.groupIsLastVisibleTopLevel(groupIndex)) {\n          iconTooltip = 'Can not hide the last top level track';\n        } else {\n          iconTooltip = `Hide ${displayName} track`;\n        }\n        break;\n      case HoverType.TRACK_CONFIG_SHOW_BUTTON:\n        iconTooltip = `Show ${displayName} track`;\n        break;\n      default:\n        return null;\n    }\n    const element = document.createElement('div');\n    element.createChild('span', 'popoverinfo-title').textContent = iconTooltip;\n\n    return element;\n  }\n\n  private updateHighlight(): void {\n    const entryIndex = this.coordinatesToEntryIndex(this.lastMouseOffsetX, this.lastMouseOffsetY);\n    // Each time the entry highlight is updated, we need to check if the mouse is hovering over a\n    // button that indicates hidden child elements and if so, update the button highlight.\n    this.updateHiddenChildrenArrowHighlighPosition(entryIndex);\n\n    // No entry is hovered.\n    if (entryIndex === -1) {\n      this.hideHighlight();\n\n      const {groupIndex, hoverType} =\n          this.coordinatesToGroupIndexAndHoverType(this.lastMouseOffsetX, this.lastMouseOffsetY);\n      if (hoverType === HoverType.INSIDE_TRACK_HEADER) {\n        this.#updatePopoverForGroup(groupIndex);\n      }\n      if (groupIndex >= 0 && this.rawTimelineData?.groups?.[groupIndex].selectable) {\n        // This means the mouse is in a selectable group's area, and not hovering any entry.\n        this.viewportElement.style.cursor = 'pointer';\n      } else {\n        // This means the mouse is not hovering any selectable track, and not hovering any entry.\n        this.viewportElement.style.cursor = 'default';\n      }\n      return;\n    }\n\n    // Some entry is hovered.\n    if (this.chartViewport.isDragging()) {\n      return;\n    }\n    this.#updatePopoverForEntry(entryIndex);\n    this.viewportElement.style.cursor = this.dataProvider.canJumpToEntry(entryIndex) ? 'pointer' : 'default';\n    this.highlightEntry(entryIndex);\n  }\n\n  private onMouseOut(): void {\n    this.lastMouseOffsetX = -1;\n    this.lastMouseOffsetY = -1;\n    this.hideHighlight();\n  }\n\n  showPopoverForSearchResult(selectedSearchResult: number|null): void {\n    this.#searchResultEntryIndex = selectedSearchResult;\n    this.#updatePopoverForEntry(selectedSearchResult);\n  }\n\n  #updatePopoverForEntry(entryIndex: number|null): void {\n    // Just update position if cursor is hovering the same entry.\n    const isMouseOverRevealChildrenArrow =\n        entryIndex !== null && this.isMouseOverRevealChildrenArrow(this.lastMouseOffsetX, entryIndex);\n    if (entryIndex === this.lastPopoverState.entryIndex &&\n        isMouseOverRevealChildrenArrow === this.lastPopoverState.hiddenEntriesPopover) {\n      return this.updatePopoverOffset();\n    }\n    const data = this.timelineData();\n    if (!data) {\n      return;\n    }\n    const group = data.groups.at(this.selectedGroupIndex);\n    // If the mouse is hovering over the hidden descendants arrow, get an element that shows how many children are hidden, otherwise an element with the event name and length\n    const popoverElement = (isMouseOverRevealChildrenArrow && group) ?\n        this.dataProvider.preparePopoverForCollapsedArrow?.(entryIndex) :\n        entryIndex !== null && this.dataProvider.preparePopoverElement(entryIndex);\n    if (popoverElement) {\n      this.updatePopoverContents(popoverElement);\n    }\n    this.lastPopoverState = {\n      entryIndex,\n      groupIndex: -1,\n      hiddenEntriesPopover: isMouseOverRevealChildrenArrow,\n    };\n  }\n\n  updatePopoverContents(popoverElement: Element): void {\n    this.popoverElement.removeChildren();\n    this.popoverElement.appendChild(popoverElement);\n    // Must update the offset AFTER the new content has been added.\n    this.updatePopoverOffset();\n    this.lastPopoverState.entryIndex = -1;\n  }\n\n  updateMouseOffset(mouseX: number, mouseY: number): void {\n    this.lastMouseOffsetX = mouseX;\n    this.lastMouseOffsetY = mouseY;\n  }\n\n  #updatePopoverForGroup(groupIndex: number): void {\n    // Just update position if cursor is hovering the group name.\n    if (groupIndex === this.lastPopoverState.groupIndex) {\n      return this.updatePopoverOffset();\n    }\n    this.popoverElement.removeChildren();\n    const data = this.timelineData();\n    if (!data) {\n      return;\n    }\n    const group = data.groups.at(groupIndex);\n    if (group?.description) {\n      this.popoverElement.innerText = (group?.description);\n      this.updatePopoverOffset();\n    }\n    this.lastPopoverState = {\n      groupIndex,\n      entryIndex: -1,\n      hiddenEntriesPopover: false,\n    };\n  }\n\n  private updatePopoverOffset(): void {\n    let mouseX = this.lastMouseOffsetX;\n    let mouseY = this.lastMouseOffsetY;\n\n    // If the popover is being updated from a search, we calculate the coordinates manually\n    if (this.#searchResultEntryIndex !== null) {\n      const coordinate = this.entryIndexToCoordinates(this.selectedEntryIndex);\n      const {x: canvasViewportOffsetX, y: canvasViewportOffsetY} = this.canvas.getBoundingClientRect();\n      mouseX = coordinate?.x ? coordinate.x - canvasViewportOffsetX : mouseX;\n      mouseY = coordinate?.y ? coordinate.y - canvasViewportOffsetY : mouseY;\n    }\n    // The parent dimensions are the maximum the popover can use.\n    const parentWidth = this.popoverElement.parentElement ? this.popoverElement.parentElement.clientWidth : 0;\n    const parentHeight = this.popoverElement.parentElement ? this.popoverElement.parentElement.clientHeight : 0;\n    const infoWidth = this.popoverElement.clientWidth;\n    const infoHeight = this.popoverElement.clientHeight;\n\n    // How much offset to use (when placing popover relative to mouseX/mouseY)\n    const offsetX = 10;\n    // Incorporate any network flamechart height into dynamic positioning\n    const offsetY = 6 + this.#tooltipPopoverYAdjustment;\n    let x;\n    let y;\n\n    /**\n     * Fancy positioning algorithm. It optimizes for consistent positioning, not obstructing any of the popover, and not positioning atop the mouse cursor.\n     *\n     * Take the mouse cursor position (mouseX/mouseY) and split up the area into four quadrants\n     *     0: bottom-right. 1: top-right. 2: bottom-left. 3: top-left.\n     *\n     * We attempt this in two passes, first is for keeping the whole popover visible, the second is slightly relaxed.\n     *   If we hit the second pass, its because the tooltip size is close to the size of the available (parent*) space.\n     * In each pass, we loop through the quadrants\n     *   If the tooltip can fit (after some adjustments) within a quadrant, we `break` and that x,y is used.\n     */\n    for (let pass = 0; pass < 2; ++pass) {\n      for (let quadrant = 0; quadrant < 4; ++quadrant) {\n        // The bitwise AND operator is used to generate the 4 unique combinations of two booleans. (true+false, true+true, etc)\n        const dx = quadrant & 2 ? -offsetX - infoWidth : offsetX;\n        const dy = quadrant & 1 ? -offsetY - infoHeight : offsetY;\n        // mouseX+dx is ideal, but clamp against the available space (It will be adapted to fit)\n        x = Platform.NumberUtilities.clamp(mouseX + dx, 0, parentWidth - infoWidth);\n        y = Platform.NumberUtilities.clamp(mouseY + dy, 0, parentHeight - infoHeight);\n\n        const popoverFits = pass === 0 ?\n            // Will the whole popover be visible?\n            (x >= mouseX || mouseX >= x + infoWidth) && (y >= mouseY || mouseY >= y + infoHeight) :\n            // Will the popover fit well in 1 dimension? (Though we typically see it fit in both, here. Shrug.)\n            x >= mouseX || mouseX >= x + infoWidth || y >= mouseY || mouseY >= y + infoHeight;\n\n        if (popoverFits) {\n          break;\n        }\n      }\n    }\n    this.popoverElement.style.left = x + 'px';\n    this.popoverElement.style.top = y + 'px';\n  }\n\n  /**\n   * Handle double mouse click event in flame chart.\n   */\n  #onDblClick(mouseEvent: MouseEvent): void {\n    this.focus();\n    const {groupIndex} = this.coordinatesToGroupIndexAndHoverType(mouseEvent.offsetX, mouseEvent.offsetY);\n\n    /**\n     * When a hovered entry on any track is double clicked, create a label for it.\n     *\n     * Checking the existence of `highlightedEntryIndex` is enough to make sure that the double\n     * click happened on the entry since an entry is only highlighted if the mouse is hovering it.\n     */\n    if (this.highlightedEntryIndex !== -1) {\n      this.#selectGroup(groupIndex);\n\n      this.dispatchEventToListeners(\n          Events.ENTRY_LABEL_ANNOTATION_ADDED, {entryIndex: this.highlightedEntryIndex, withLinkCreationButton: true});\n\n      // Log the double click on the TimelineFlameChartView for VE logs.\n      const flameChartView = this.flameChartDelegate.containingElement?.();\n      if (flameChartView) {\n        VisualLogging.logClick(flameChartView, mouseEvent, {doubleClick: true});\n      }\n    }\n  }\n\n  /**\n   * Handle mouse click event in flame chart\n   *\n   * And the handle priority will be:\n   * 1. Track configuration icons -> Config a track\n   * 1.1 if it's edit mode ignore others.\n   * 2. Inside a track header -> Select and Expand/Collapse a track\n   * 3. Inside a track -> Select a track\n   * 3.1 shift + click -> Select the time range of clicked event\n   * 3.2 click -> update highlight (handle in other functions)\n   */\n  private onClick(mouseEvent: MouseEvent): void {\n    this.focus();\n    // onClick comes after dragStart and dragEnd events.\n    // So if there was drag (mouse move) in the middle of that events\n    // we skip the click. Otherwise we jump to the sources.\n    const clickThreshold = 5;\n    if (this.maxDragOffset > clickThreshold) {\n      return;\n    }\n\n    // If any button is clicked, we should handle the action only and ignore others.\n    const {groupIndex, hoverType} = this.coordinatesToGroupIndexAndHoverType(mouseEvent.offsetX, mouseEvent.offsetY);\n    // There could be a special case, when there is no group and all entries are appended directly, for example the\n    // Memory panel.\n    // In this case, the |groupIndex| will be -1, and |groups| should be empty.\n    // All the functions here can handle the -1 groupIndex properly, so we don't need to add extra check here.\n    switch (hoverType) {\n      case HoverType.TRACK_CONFIG_UP_BUTTON:\n        this.moveGroupUp(groupIndex);\n        return;\n      case HoverType.TRACK_CONFIG_DOWN_BUTTON:\n        this.moveGroupDown(groupIndex);\n        return;\n      case HoverType.TRACK_CONFIG_HIDE_BUTTON:\n        if (this.groupIsLastVisibleTopLevel(groupIndex)) {\n          // If this is the last visible top-level group, we will not allow you hiding the track.\n          return;\n        }\n        this.hideGroup(groupIndex);\n        return;\n      case HoverType.TRACK_CONFIG_SHOW_BUTTON:\n        this.showGroup(groupIndex);\n        return;\n      case HoverType.INSIDE_TRACK_HEADER:\n        this.#selectGroup(groupIndex);\n        this.toggleGroupExpand(groupIndex);\n        return;\n      case HoverType.INSIDE_TRACK:\n      case HoverType.OUTSIDE_TRACKS: {\n        this.#selectGroup(groupIndex);\n\n        const timelineData = this.timelineData();\n        if (mouseEvent.shiftKey && this.highlightedEntryIndex !== -1 && timelineData) {\n          const start = timelineData.entryStartTimes[this.highlightedEntryIndex];\n          const end = start + timelineData.entryTotalTimes[this.highlightedEntryIndex];\n          this.chartViewport.setRangeSelection(start, end);\n        } else {\n          this.chartViewport.onClick(mouseEvent);\n          this.dispatchEventToListeners(Events.ENTRY_INVOKED, this.highlightedEntryIndex);\n        }\n        return;\n      }\n    }\n  }\n\n  setLinkSelectionAnnotationIsInProgress(inProgress: boolean): void {\n    this.#linkSelectionAnnotationIsInProgress = inProgress;\n  }\n\n  #selectGroup(groupIndex: number): void {\n    if (groupIndex < 0 || this.selectedGroupIndex === groupIndex) {\n      return;\n    }\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    if (!groups) {\n      return;\n    }\n\n    this.keyboardFocusedGroup = groupIndex;\n\n    // Do not scroll the track if the user is currently selecting an entry for a connection annotation.\n    // Scrolling the view when the entry is being selected results in creating a link with different entry from the one that was clicked on.\n    if (!this.#linkSelectionAnnotationIsInProgress) {\n      this.scrollGroupIntoView(groupIndex);\n    }\n    const groupName = groups[groupIndex].name;\n    if (!groups[groupIndex].selectable) {\n      this.deselectAllGroups();\n      UI.ARIAUtils.LiveAnnouncer.alert(i18nString(UIStrings.sHovered, {PH1: groupName}));\n    } else {\n      this.selectedGroupIndex = groupIndex;\n      this.flameChartDelegate.updateSelectedGroup(this, groups[groupIndex]);\n      this.draw();\n      UI.ARIAUtils.LiveAnnouncer.alert(i18nString(UIStrings.sSelected, {PH1: groupName}));\n    }\n  }\n\n  private deselectAllGroups(): void {\n    this.selectedGroupIndex = -1;\n    this.flameChartDelegate.updateSelectedGroup(this, null);\n    this.draw();\n  }\n\n  private deselectAllEntries(): void {\n    this.selectedEntryIndex = -1;\n    this.rawTimelineData?.emptyInitiators();\n    this.draw();\n  }\n\n  private isGroupFocused(index: number): boolean {\n    return index === this.selectedGroupIndex || index === this.keyboardFocusedGroup;\n  }\n\n  private scrollGroupIntoView(index: number): void {\n    if (index < 0) {\n      return;\n    }\n\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    const groupOffsets = this.groupOffsets;\n    if (!groupOffsets || !groups) {\n      return;\n    }\n    const groupTop = groupOffsets[index];\n\n    let nextOffset = groupOffsets[index + 1];\n    if (index === groups.length - 1) {\n      nextOffset += groups[index].style.padding;\n    }\n\n    // For the top group, scroll all the way to the top of the chart\n    // to accommodate the bar with time markers\n    const scrollTop = index === 0 ? 0 : groupTop;\n\n    const scrollHeight = Math.min(nextOffset - scrollTop, this.chartViewport.chartHeight());\n    this.chartViewport.setScrollOffset(scrollTop, scrollHeight);\n  }\n\n  /**\n   * Toggle a group's expanded state.\n   * @param groupIndex - the index of this group in the timelineData.groups\n   * array. Note that this is the array index, and not the startLevel of the\n   * group.\n   */\n  toggleGroupExpand(groupIndex: number): void {\n    if (groupIndex < 0 || !this.isGroupCollapsible(groupIndex)) {\n      return;\n    }\n\n    if (!this.rawTimelineData?.groups) {\n      return;\n    }\n\n    this.expandGroup(groupIndex, !this.rawTimelineData.groups[groupIndex].expanded /* setExpanded */);\n  }\n\n  private expandGroup(\n      groupIndex: number, setExpanded: boolean|undefined = true, propagatedExpand: boolean|undefined = false): void {\n    if (groupIndex < 0 || !this.isGroupCollapsible(groupIndex)) {\n      return;\n    }\n\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    if (!groups) {\n      return;\n    }\n\n    const group = groups[groupIndex];\n    group.expanded = setExpanded;\n\n    this.updateLevelPositions();\n\n    this.updateHighlight();\n    if (!group.expanded) {\n      const timelineData = this.timelineData();\n      if (timelineData) {\n        const level = timelineData.entryLevels[this.selectedEntryIndex];\n        if (this.selectedEntryIndex >= 0 && level >= group.startLevel &&\n            (groupIndex >= groups.length - 1 || groups[groupIndex + 1].startLevel > level)) {\n          this.selectedEntryIndex = -1;\n          // Reset all flow arrows when we deselect the entry.\n          this.rawTimelineData.emptyInitiators();\n        }\n      }\n    }\n\n    this.updateHeight();\n    this.draw();\n    this.#notifyProviderOfConfigurationChange();\n\n    this.scrollGroupIntoView(groupIndex);\n    // We only want to read expanded/collapsed state on user inputted expand/collapse\n    if (!propagatedExpand) {\n      const groupName = groups[groupIndex].name;\n      const content = group.expanded ? i18nString(UIStrings.sExpanded, {PH1: groupName}) :\n                                       i18nString(UIStrings.sCollapsed, {PH1: groupName});\n      UI.ARIAUtils.LiveAnnouncer.alert(content);\n    }\n  }\n\n  moveGroupUp(groupIndex: number): void {\n    if (groupIndex < 0) {\n      return;\n    }\n\n    if (!this.rawTimelineData?.groups) {\n      return;\n    }\n\n    if (!this.#groupTreeRoot) {\n      return;\n    }\n\n    for (let i = 0; i < this.#groupTreeRoot.children.length; i++) {\n      const child = this.#groupTreeRoot.children[i];\n      if (child.index === groupIndex) {\n        // exchange with previous one, only second or later group can do so\n        if (i >= 1) {\n          this.#groupTreeRoot.children[i] = this.#groupTreeRoot.children[i - 1];\n          this.#groupTreeRoot.children[i - 1] = child;\n          break;\n        }\n      }\n    }\n\n    this.updateLevelPositions();\n\n    this.updateHighlight();\n    this.updateHeight();\n    this.draw();\n    this.#notifyProviderOfConfigurationChange();\n  }\n\n  #notifyProviderOfConfigurationChange(): void {\n    if (!this.#groupTreeRoot) {\n      return;\n    }\n    if (!this.dataProvider.handleTrackConfigurationChange) {\n      return;\n    }\n    const groups = this.rawTimelineData?.groups;\n    if (!groups) {\n      return;\n    }\n    const sortedGroupIndexes = this.#getVisualOrderOfGroupIndexes(this.#groupTreeRoot);\n    this.dataProvider.handleTrackConfigurationChange(groups, sortedGroupIndexes);\n  }\n\n  /**\n   * Walks the tree in DFS to generate the visual order of the groups.\n   */\n  #getVisualOrderOfGroupIndexes(root: GroupTreeNode): number[] {\n    const sortedGroupIndexes: number[] = [];\n    function traverse(node: GroupTreeNode): void {\n      if (node.index !== -1) {\n        // The first root is a fake parent node that we do not render, we don't\n        // want to include this in the sorted list.\n        sortedGroupIndexes.push(node.index);\n      }\n      for (const child of node.children) {\n        traverse(child);\n      }\n    }\n    traverse(root);\n    return sortedGroupIndexes;\n  }\n\n  moveGroupDown(groupIndex: number): void {\n    if (groupIndex < 0) {\n      return;\n    }\n\n    if (!this.rawTimelineData?.groups) {\n      return;\n    }\n\n    if (!this.#groupTreeRoot) {\n      return;\n    }\n\n    for (let i = 0; i < this.#groupTreeRoot.children.length; i++) {\n      const child = this.#groupTreeRoot.children[i];\n      if (child.index === groupIndex) {\n        // exchange with previous one, only second to last or before group can do so\n        if (i <= this.#groupTreeRoot.children.length - 2) {\n          this.#groupTreeRoot.children[i] = this.#groupTreeRoot.children[i + 1];\n          this.#groupTreeRoot.children[i + 1] = child;\n          break;\n        }\n      }\n    }\n\n    this.updateLevelPositions();\n\n    this.updateHighlight();\n    this.updateHeight();\n    this.draw();\n    this.#notifyProviderOfConfigurationChange();\n  }\n\n  hideGroup(groupIndex: number): void {\n    this.#toggleGroupHiddenState(groupIndex, /* hidden= */ true);\n  }\n\n  showGroup(groupIndex: number): void {\n    this.#toggleGroupHiddenState(groupIndex, /* hidden= */ false);\n  }\n\n  #toggleGroupHiddenState(groupIndex: number, hidden: boolean): void {\n    if (groupIndex < 0) {\n      return;\n    }\n\n    if (!this.rawTimelineData?.groups) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    if (!groups) {\n      return;\n    }\n\n    const group = groups[groupIndex];\n    group.hidden = hidden;\n\n    this.updateLevelPositions();\n    this.updateHighlight();\n    this.updateHeight();\n    this.draw();\n    this.#notifyProviderOfConfigurationChange();\n  }\n\n  modifyTree(treeAction: FilterAction, index: number): void {\n    const data = this.timelineData();\n    if (!data || !this.dataProvider.modifyTree) {\n      return;\n    }\n    this.dataProvider.modifyTree(treeAction, index);\n    this.update();\n  }\n\n  #buildEnterEditModeContextMenu(event: MouseEvent): void {\n    if (this.#inTrackConfigEditMode) {\n      return;\n    }\n\n    this.contextMenu = new UI.ContextMenu.ContextMenu(event);\n    const label = i18nString(UIStrings.enterTrackConfigurationMode);\n    this.contextMenu.defaultSection().appendItem(label, () => {\n      this.#enterEditMode();\n    }, {\n      jslogContext: 'track-configuration-enter',\n    });\n    void this.contextMenu.show();\n  }\n\n  #buildExitEditModeContextMenu(event: MouseEvent): void {\n    if (this.#inTrackConfigEditMode === false) {\n      return;\n    }\n    this.contextMenu = new UI.ContextMenu.ContextMenu(event);\n    const label = i18nString(UIStrings.exitTrackConfigurationMode);\n    this.contextMenu.defaultSection().appendItem(label, () => {\n      this.#exitEditMode();\n    }, {\n      jslogContext: 'track-configuration-exit',\n    });\n    void this.contextMenu.show();\n  }\n\n  #hasTrackConfigurationMode(): boolean {\n    // Track Configuration mode is off by default: a provider must define the\n    // function and have it return `true` to enable it.\n    return Boolean(this.dataProvider.hasTrackConfigurationMode?.());\n  }\n\n  onContextMenu(event: MouseEvent): void {\n    const {groupIndex, hoverType} = this.coordinatesToGroupIndexAndHoverType(event.offsetX, event.offsetY);\n\n    // If the user is in edit mode, allow a right click anywhere to exit the mode.\n    if (this.#inTrackConfigEditMode) {\n      this.#buildExitEditModeContextMenu(event);\n      return;\n    }\n\n    // If we are not in edit mode, and the user right clicks on the header,\n    // allow them to enter edit mode.\n    // Data providers can disable the ability to enter this mode, hence the\n    // extra check. For example, in the DevTools Performance Panel the network\n    // data provider & flame chart does not support this mode, but the main one\n    // does.\n    if (hoverType === HoverType.INSIDE_TRACK_HEADER && this.#hasTrackConfigurationMode()) {\n      this.#buildEnterEditModeContextMenu(event);\n    }\n\n    // The user can create context menus in two ways:\n    // 1. they right click and a contextMenu event is dispatched from the\n    //    browser. This event will be trusted.\n    // 2. they press \"space\" on the keyboard and we dispatch the event\n    //    ourselves from {@see triggerContextMenuFromKeyPress}.\n    // To enable us to differentiate, we set the detail property\n    // [https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail] to a\n    // specific number (-1) for our faked context menu event. We can do this\n    // because the detail property is never natively set to a negative number.\n    // The reason this is important is because the highlightedEntryIndex is\n    // only updated when the mouse moves, so if the user is navigating +\n    // triggering menus via the keyboard, it will not be updated, and we should\n    // use the selectedEntryIndex.\n    const isFakedFromKeyboardPress = event.detail === KEYBOARD_FAKED_CONTEXT_MENU_DETAIL;\n    const entryIndexToUse = isFakedFromKeyboardPress ? this.selectedEntryIndex : this.highlightedEntryIndex;\n\n    if (entryIndexToUse === -1) {\n      return;\n    }\n\n    if (!isFakedFromKeyboardPress) {\n      this.dispatchEventToListeners(Events.ENTRY_INVOKED, entryIndexToUse);\n      this.setSelectedEntry(entryIndexToUse);\n      // Update the selected group as well.\n      this.#selectGroup(groupIndex);\n    }\n\n    // Build the context menu for right clicking individual entries.\n    // The context menu only applies if the user is hovering over an individual\n    // entry, and we are not in edit mode (which we know we cannot be in given\n    // the conditional checks above)\n    // If the flame chart provider can build a customized context menu for the\n    // given entry, we will use that, otherwise just do nothing and fall back to\n    // default context menu.\n    // We need to use |selectedEntryIndex| instead of |highlightedEntryIndex|.\n    // The reason is when we call the |setSelectedEntry| and |#selectGroup|,\n    // the flame chart will be redrawn, so the |highlightedEntryIndex| will be\n    // reset to -1.\n    // In real life, because we might trigger the |mousemove| event again, the\n    // |highlightedEntryIndex| might be correct, but to make the code easier\n    // to maintain, let's use |selectedEntryIndex|.\n    this.contextMenu = this.dataProvider.customizedContextMenu?.(event, this.selectedEntryIndex, groupIndex) ??\n        new UI.ContextMenu.ContextMenu(event);\n\n    // Generate context menu entries for annotations.\n    const annotationSection = this.contextMenu.annotationSection();\n    annotationSection.appendItem(i18nString(UIStrings.labelEntry), () => {\n      this.dispatchEventToListeners(\n          Events.ENTRY_LABEL_ANNOTATION_ADDED, {entryIndex: this.selectedEntryIndex, withLinkCreationButton: false});\n    }, {\n      jslogContext: 'timeline.annotations.create-entry-label',\n    });\n\n    annotationSection.appendItem(i18nString(UIStrings.linkEntries), () => {\n      this.dispatchEventToListeners(Events.ENTRIES_LINK_ANNOTATION_CREATED, {entryFromIndex: this.selectedEntryIndex});\n    }, {\n      jslogContext: 'timeline.annotations.create-entries-link',\n    });\n\n    void this.contextMenu.show();\n  }\n\n  #handleFlameChartTransformEvent(event: KeyboardEvent): void {\n    // TODO(crbug.com/1469887): Indicate Shortcuts to the user when the designs are complete.\n    if (this.selectedEntryIndex === -1) {\n      return;\n    }\n    this.dataProvider.handleFlameChartTransformKeyboardEvent?.(event, this.selectedEntryIndex, this.selectedGroupIndex);\n  }\n\n  /**\n   * Triggers a context menu as if the user had clicked on the selected entry.\n   * To do this we calculate the (x, y) of the selected entry, and create a\n   * fake mouse event to pretend the user has clicked on that coordinate.\n   * We then dispatch the event as a \"contextmenu\" event, thus triggering the\n   * usual contextmenu code path.\n   */\n  #triggerContextMenuFromKeyPress(): void {\n    const startTime = this.timelineData()?.entryStartTimes[this.selectedEntryIndex];\n    const level = this.timelineData()?.entryLevels[this.selectedEntryIndex];\n    if (!startTime || !level) {\n      return;\n    }\n    const boundingRect = this.canvasBoundingClientRect();\n    if (!boundingRect) {\n      return;\n    }\n    // If we use the (x, y) of the entry, that is relative to the canvas, so we\n    // add on the left / top of the canvas' rect to place the contextmenu in\n    // the correct place within the entire DevTools window.\n    const x = this.chartViewport.timeToPosition(startTime) + boundingRect.left;\n    const y = this.levelToOffset(level) - this.getScrollOffset() + boundingRect.top;\n\n    // Set the `detail` key so in the context menu handler we can differentiate\n    // between a keyboard invoked context menu and a mouse invoked one.\n    const event = new MouseEvent('contextmenu', {clientX: x, clientY: y, detail: KEYBOARD_FAKED_CONTEXT_MENU_DETAIL});\n    this.canvas.dispatchEvent(event);\n  }\n\n  private onKeyDown(e: KeyboardEvent): void {\n    if (UI.KeyboardShortcut.KeyboardShortcut.hasAtLeastOneModifier(e) || !this.timelineData()) {\n      return;\n    }\n\n    if (e.key === ' ' && this.selectedEntryIndex > -1) {\n      // If the user has an event selected, and there is a selected entry, then we open the context menu at this event.\n      this.#triggerContextMenuFromKeyPress();\n    }\n\n    let eventHandled = this.handleSelectionNavigation(e);\n\n    // Handle keyboard navigation in groups\n    if (!eventHandled && this.rawTimelineData?.groups) {\n      eventHandled = this.handleKeyboardGroupNavigation(e);\n    }\n\n    if (!eventHandled) {\n      this.#handleFlameChartTransformEvent(e);\n    }\n  }\n\n  bindCanvasEvent(eventName: string, onEvent: (arg0: Event) => void): void {\n    this.canvas.addEventListener(eventName, onEvent);\n  }\n\n  drawTrackOnCanvas(trackName: string, context: CanvasRenderingContext2D, minWidth: number):\n      {top: number, height: number, visibleEntries: Set<number>}|null {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return null;\n    }\n    const canvasWidth = this.offsetWidth;\n    const canvasHeight = this.offsetHeight;\n    context.save();\n    const ratio = window.devicePixelRatio;\n    context.scale(ratio, ratio);\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n    context.fillRect(0, 0, canvasWidth, canvasHeight);\n    context.font = this.#font;\n\n    const groups = this.rawTimelineData?.groups || [];\n    const groupOffsets = this.groupOffsets;\n    if (!groups.length || !groupOffsets) {\n      return null;\n    }\n    const trackIndex = groups.findIndex(g => g.name.includes(trackName));\n    if (trackIndex < 0) {\n      return null;\n    }\n    this.scrollGroupIntoView(trackIndex);\n    const group = groups[trackIndex];\n    const startLevel = group.startLevel;\n    const endLevel = groups[trackIndex + 1].startLevel;\n    const groupTop = groupOffsets[trackIndex];\n    const nextOffset = groupOffsets[trackIndex + 1];\n\n    const {drawBatches, titleIndices} = this.getDrawBatches(context, timelineData);\n\n    const entryIndexIsInTrack = (index: number): boolean => {\n      const barWidth = Math.min(this.#eventBarWidth(timelineData, index), canvasWidth);\n      return timelineData.entryLevels[index] >= startLevel && timelineData.entryLevels[index] < endLevel &&\n          barWidth > minWidth;\n    };\n    let allFilteredIndexes: number[] = [];\n    for (const [{color, outline}, {indexes}] of drawBatches) {\n      const filteredIndexes = indexes.filter(entryIndexIsInTrack);\n      allFilteredIndexes = [...allFilteredIndexes, ...filteredIndexes];\n      this.#drawBatchEvents(context, timelineData, color, filteredIndexes, outline);\n    }\n    const filteredTitleIndices = titleIndices.filter(entryIndexIsInTrack);\n    this.drawEventTitles(context, timelineData, filteredTitleIndices, canvasWidth);\n    context.restore();\n    return {\n      top: groupOffsets[trackIndex],\n      height: nextOffset - groupTop,\n      visibleEntries: new Set(allFilteredIndexes),\n    };\n  }\n\n  private handleKeyboardGroupNavigation(event: Event): boolean {\n    const keyboardEvent = (event as KeyboardEvent);\n    let handled = false;\n    let entrySelected = false;\n\n    if (keyboardEvent.code === 'ArrowUp') {\n      handled = this.selectPreviousGroup();\n    } else if (keyboardEvent.code === 'ArrowDown') {\n      handled = this.selectNextGroup();\n    } else if (keyboardEvent.code === 'ArrowLeft') {\n      if (this.keyboardFocusedGroup >= 0) {\n        this.expandGroup(this.keyboardFocusedGroup, false /* setExpanded */);\n        handled = true;\n      }\n    } else if (keyboardEvent.code === 'ArrowRight') {\n      if (this.keyboardFocusedGroup >= 0) {\n        this.expandGroup(this.keyboardFocusedGroup, true /* setExpanded */);\n        this.selectFirstChild();\n        handled = true;\n      }\n    } else if (keyboardEvent.key === 'Enter') {\n      entrySelected = this.selectFirstEntryInCurrentGroup();\n      handled = entrySelected;\n    }\n\n    if (handled && !entrySelected) {\n      this.deselectAllEntries();\n    }\n\n    if (handled) {\n      keyboardEvent.consume(true);\n    }\n\n    return handled;\n  }\n\n  /**\n   * Used when the user presses \"enter\" when a group is selected, so that we\n   * move their selection into an event in the group.\n   */\n  private selectFirstEntryInCurrentGroup(): boolean {\n    if (!this.rawTimelineData) {\n      return false;\n    }\n\n    const allGroups = this.rawTimelineData.groups;\n\n    if (this.keyboardFocusedGroup < 0 || !allGroups) {\n      return false;\n    }\n\n    const group = allGroups[this.keyboardFocusedGroup];\n    const startLevelInGroup = group.startLevel;\n\n    // Return if no levels in this group\n    if (startLevelInGroup < 0) {\n      return false;\n    }\n\n    // Make sure this is the innermost nested group with this startLevel\n    // This is because a parent group also contains levels of all its child groups\n    // So check if the next group has the same level, if it does, user should\n    // go to that child group to select this entry\n    if (this.keyboardFocusedGroup < allGroups.length - 1 &&\n        allGroups[this.keyboardFocusedGroup + 1].startLevel === startLevelInGroup) {\n      return false;\n    }\n\n    if (!this.timelineLevels) {\n      return false;\n    }\n\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return false;\n    }\n    // Get the first entry within the group that is at least 1ms long.\n    // Otherwise the panel can select a tiny event which is really hard to see\n    // even at maximum zoom. We hedge our bets that the user probably doesn't\n    // care for such a tiny event, at least not by default. Better to take them\n    // to an event that is slightly more prominent in the UI.\n    const minDurationOfFirstEntry = Trace.Types.Timing.Milli(1);\n    let firstEntryIndex = this.timelineLevels[startLevelInGroup].find((i => {\n      const duration = timelineData.entryTotalTimes[i];\n      return !Number.isNaN(duration) && duration >= minDurationOfFirstEntry;\n    }));\n    if (typeof firstEntryIndex === 'undefined') {\n      // If we didn't find a 1ms+ event, fallback to the first, regardless of duration.\n      firstEntryIndex = this.timelineLevels[startLevelInGroup][0];\n    }\n\n    this.expandGroup(this.keyboardFocusedGroup, true /* setExpanded */);\n    const eventName = this.dataProvider.entryTitle(firstEntryIndex);\n    if (eventName) {\n      UI.ARIAUtils.LiveAnnouncer.alert(i18nString(UIStrings.eventSelectedFromGroup, {\n        PH1: eventName,\n        PH2: group.name,\n      }));\n    }\n    this.setSelectedEntry(firstEntryIndex);\n    return true;\n  }\n\n  private selectPreviousGroup(): boolean {\n    if (this.keyboardFocusedGroup <= 0) {\n      return false;\n    }\n\n    const groupIndexToSelect = this.getGroupIndexToSelect(-1 /* offset */);\n    this.#selectGroup(groupIndexToSelect);\n    return true;\n  }\n\n  private selectNextGroup(): boolean {\n    if (!this.rawTimelineData?.groups) {\n      return false;\n    }\n\n    if (this.keyboardFocusedGroup >= this.rawTimelineData.groups.length - 1) {\n      return false;\n    }\n\n    const groupIndexToSelect = this.getGroupIndexToSelect(1 /* offset */);\n    this.#selectGroup(groupIndexToSelect);\n    return true;\n  }\n\n  private getGroupIndexToSelect(offset: number): number {\n    if (!this.rawTimelineData?.groups) {\n      throw new Error('No raw timeline data');\n    }\n    const allGroups = this.rawTimelineData.groups;\n    let groupIndexToSelect = this.keyboardFocusedGroup;\n    let groupName, groupWithSubNestingLevel;\n\n    do {\n      groupIndexToSelect += offset;\n      groupName = this.rawTimelineData.groups[groupIndexToSelect].name;\n      groupWithSubNestingLevel = this.keyboardFocusedGroup !== -1 &&\n          allGroups[groupIndexToSelect].style.nestingLevel > allGroups[this.keyboardFocusedGroup].style.nestingLevel;\n    } while (groupIndexToSelect > 0 && groupIndexToSelect < allGroups.length - 1 &&\n             (!groupName || groupWithSubNestingLevel));\n\n    return groupIndexToSelect;\n  }\n\n  private selectFirstChild(): void {\n    if (!this.rawTimelineData?.groups) {\n      return;\n    }\n\n    const allGroups = this.rawTimelineData.groups;\n    if (this.keyboardFocusedGroup < 0 || this.keyboardFocusedGroup >= allGroups.length - 1) {\n      return;\n    }\n\n    const groupIndexToSelect = this.keyboardFocusedGroup + 1;\n    if (allGroups[groupIndexToSelect].style.nestingLevel > allGroups[this.keyboardFocusedGroup].style.nestingLevel) {\n      this.#selectGroup(groupIndexToSelect);\n    }\n  }\n\n  private handleSelectionNavigation(event: KeyboardEvent): boolean {\n    if (this.selectedEntryIndex === -1) {\n      return false;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return false;\n    }\n\n    function timeComparator(time: number, entryIndex: number): number {\n      if (!timelineData) {\n        throw new Error('No timeline data');\n      }\n      return time - timelineData.entryStartTimes[entryIndex];\n    }\n\n    function entriesIntersect(entry1: number, entry2: number): boolean {\n      if (!timelineData) {\n        throw new Error('No timeline data');\n      }\n\n      const start1 = timelineData.entryStartTimes[entry1];\n      const start2 = timelineData.entryStartTimes[entry2];\n      const end1 = start1 + timelineData.entryTotalTimes[entry1];\n      const end2 = start2 + timelineData.entryTotalTimes[entry2];\n      return start1 < end2 && start2 < end1;\n    }\n\n    const keyboardEvent = (event);\n    const keys = UI.KeyboardShortcut.Keys;\n    if (keyboardEvent.keyCode === keys.Left.code || keyboardEvent.keyCode === keys.Right.code) {\n      const level = timelineData.entryLevels[this.selectedEntryIndex];\n      const levelIndexes = this.timelineLevels ? this.timelineLevels[level] : [];\n      let indexOnLevel = Platform.ArrayUtilities.lowerBound(levelIndexes, this.selectedEntryIndex, (a, b) => a - b);\n      indexOnLevel += keyboardEvent.keyCode === keys.Left.code ? -1 : 1;\n      event.consume(true);\n      if (indexOnLevel >= 0 && indexOnLevel < levelIndexes.length) {\n        this.dispatchEventToListeners(Events.ENTRY_SELECTED, levelIndexes[indexOnLevel]);\n      }\n      return true;\n    }\n\n    if (keyboardEvent.keyCode === keys.Up.code || keyboardEvent.keyCode === keys.Down.code) {\n      let level = timelineData.entryLevels[this.selectedEntryIndex];\n      level += keyboardEvent.keyCode === keys.Up.code ? -1 : 1;\n      if (level < 0 || (this.timelineLevels && level >= this.timelineLevels.length)) {\n        this.deselectAllEntries();\n        keyboardEvent.consume(true);\n        return true;\n      }\n      const entryTime = timelineData.entryStartTimes[this.selectedEntryIndex] +\n          timelineData.entryTotalTimes[this.selectedEntryIndex] / 2;\n      const levelIndexes = this.timelineLevels ? this.timelineLevels[level] : [];\n      let indexOnLevel = Platform.ArrayUtilities.upperBound(levelIndexes, entryTime, timeComparator) - 1;\n      if (!entriesIntersect(this.selectedEntryIndex, levelIndexes[indexOnLevel])) {\n        ++indexOnLevel;\n        if (indexOnLevel >= levelIndexes.length ||\n            !entriesIntersect(this.selectedEntryIndex, levelIndexes[indexOnLevel])) {\n          if (keyboardEvent.code === 'ArrowDown') {\n            return false;\n          }\n\n          // Stay in the current group and give focus to the parent group instead of entries\n          this.deselectAllEntries();\n          keyboardEvent.consume(true);\n          return true;\n        }\n      }\n      keyboardEvent.consume(true);\n      this.dispatchEventToListeners(Events.ENTRY_SELECTED, levelIndexes[indexOnLevel]);\n      return true;\n    }\n    if (event.key === 'Enter') {\n      event.consume(true);\n      this.dispatchEventToListeners(Events.ENTRY_INVOKED, this.selectedEntryIndex);\n\n      // Treat hitting enter on an entry just like we would clicking & create the annotation\n      this.dispatchEventToListeners(Events.ENTRY_LABEL_ANNOTATION_ADDED, {\n        entryIndex: this.selectedEntryIndex,\n        withLinkCreationButton: true,\n      });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Given offset of the cursor, returns the index of the entry.\n   * This function is public for test purpose.\n   * @param x\n   * @param y\n   * @returns the index of the entry\n   */\n  coordinatesToEntryIndex(x: number, y: number): number {\n    if (x < 0 || y < 0) {\n      return -1;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return -1;\n    }\n    y += this.chartViewport.scrollOffset();\n    if (!this.visibleLevelOffsets || !this.visibleLevelHeights || !this.visibleLevels) {\n      throw new Error('No visible level offsets or heights');\n    }\n\n    // The real order of the levels might be changed.\n    // So we just check each level, and check if the y is between the start and the end of this level. If yes, this is\n    // the level we want to find.\n    let cursorLevel = -1;\n    for (let i = 0; i < this.dataProvider.maxStackDepth(); i++) {\n      if (y >= this.visibleLevelOffsets[i] &&\n          y < this.visibleLevelOffsets[i] + (this.visibleLevels[i] ? this.visibleLevelHeights[i] : 0)) {\n        cursorLevel = i;\n        break;\n      }\n    }\n\n    if (cursorLevel < 0 || !this.visibleLevels[cursorLevel]) {\n      return -1;\n    }\n    const offsetFromLevel = y - this.visibleLevelOffsets[cursorLevel];\n    if (offsetFromLevel > this.levelHeight(cursorLevel)) {\n      return -1;\n    }\n\n    // Check custom drawn entries first.\n    for (const [index, pos] of this.customDrawnPositions) {\n      if (timelineData.entryLevels[index] !== cursorLevel) {\n        continue;\n      }\n      if (pos.x <= x && x < pos.x + pos.width) {\n        return index;\n      }\n    }\n\n    // Check markers.\n    for (const [index, pos] of this.markerPositions) {\n      if (timelineData.entryLevels[index] !== cursorLevel) {\n        continue;\n      }\n      if (pos.x <= x && x < pos.x + pos.width) {\n        return index;\n      }\n    }\n\n    // Check regular entries.\n    const entryStartTimes = timelineData.entryStartTimes;\n    const entriesOnLevel: number[] = this.timelineLevels ? this.timelineLevels[cursorLevel] : [];\n    if (!entriesOnLevel?.length) {\n      return -1;\n    }\n\n    const cursorTime = this.chartViewport.pixelToTime(x);\n    const indexOnLevel = Math.max(\n        Platform.ArrayUtilities.upperBound(\n            entriesOnLevel, cursorTime, (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n            1,\n        0);\n\n    function checkEntryHit(this: FlameChart, entryIndex: number|undefined): boolean {\n      if (entryIndex === undefined) {\n        return false;\n      }\n\n      if (!timelineData) {\n        return false;\n      }\n\n      const startTime = entryStartTimes[entryIndex];\n      const duration = timelineData.entryTotalTimes[entryIndex];\n      const startX = this.chartViewport.timeToPosition(startTime);\n      const endX = this.chartViewport.timeToPosition(startTime + duration);\n      return startX - this.hitMarginPx < x && x < endX + this.hitMarginPx;\n    }\n\n    let entryIndex: number = entriesOnLevel[indexOnLevel];\n    if (checkEntryHit.call(this, entryIndex)) {\n      return entryIndex;\n    }\n    entryIndex = entriesOnLevel[indexOnLevel + 1];\n    if (checkEntryHit.call(this, entryIndex)) {\n      return entryIndex;\n    }\n    return -1;\n  }\n\n  /**\n   * Given an entry's index and an X coordinate of a mouse click, returns\n   * whether the mouse is hovering over the arrow button that reveals hidden children\n   */\n  isMouseOverRevealChildrenArrow(x: number, index: number): boolean {\n    // Check if given entry has an arrow\n    if (!this.entryHasDecoration(index, FlameChartDecorationType.HIDDEN_DESCENDANTS_ARROW)) {\n      return false;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return false;\n    }\n    const startTime = timelineData.entryStartTimes[index];\n    const duration = timelineData.entryTotalTimes[index];\n    const endX = this.chartViewport.timeToPosition(startTime + duration);\n    // The arrow icon is square, therefore the width is equal to the bar height\n    const barHeight = this.#eventBarHeight(timelineData, index);\n    const arrowWidth = barHeight;\n    if (endX - arrowWidth - this.hitMarginPx < x && x < endX + this.hitMarginPx) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Given an entry's index, returns its coordinates relative to the\n   * viewport.\n   * This function is public for test purpose.\n   */\n  entryIndexToCoordinates(entryIndex: number): {x: number, y: number}|null {\n    const timelineData = this.timelineData();\n    const {x: canvasViewportOffsetX, y: canvasViewportOffsetY} = this.canvas.getBoundingClientRect();\n    if (!timelineData || !this.visibleLevelOffsets) {\n      return null;\n    }\n\n    const x = this.chartViewport.timeToPosition(timelineData.entryStartTimes[entryIndex]) + canvasViewportOffsetX;\n    const y = this.visibleLevelOffsets[timelineData.entryLevels[entryIndex]] - this.chartViewport.scrollOffset() +\n        canvasViewportOffsetY;\n    return {x, y};\n  }\n\n  /**\n   * Given an entry's index, returns its title\n   */\n  entryTitle(entryIndex: number): string|null {\n    return this.dataProvider.entryTitle(entryIndex);\n  }\n\n  /**\n   * Returns the offset of the canvas relative to the viewport.\n   */\n  getCanvasOffset(): {x: number, y: number} {\n    return this.canvas.getBoundingClientRect();\n  }\n\n  getCanvas(): HTMLCanvasElement {\n    return this.canvas;\n  }\n\n  /**\n   * Returns the y scroll of the chart viewport.\n   */\n  getScrollOffset(): number {\n    return this.chartViewport.scrollOffset();\n  }\n\n  getContextMenu(): UI.ContextMenu.ContextMenu|undefined {\n    return this.contextMenu;\n  }\n\n  /**\n   * Given offset of the cursor, returns the index of the group and the hover type of current mouse position.\n   * Will return -1 for index and HoverType.OUTSIDE_TRACKS if no group is hovered/clicked.\n   * And the handle priority will be:\n   * 1. Track configuration icons\n   * 2. Inside a track header (track label and the expansion arrow)\n   * 3. Inside a track\n   * 4. Outside all tracks\n   *\n   * This function is public for test purpose.\n   * @param x\n   * @param y\n   * @returns the index of the group and the button user clicked. If there is no button the button type will be\n   * undefined.\n   */\n  coordinatesToGroupIndexAndHoverType(x: number, y: number): {groupIndex: number, hoverType: HoverType} {\n    if (!this.rawTimelineData?.groups || !this.groupOffsets) {\n      return {groupIndex: -1, hoverType: HoverType.ERROR};\n    }\n\n    if (x < 0 || y < 0) {\n      return {groupIndex: -1, hoverType: HoverType.ERROR};\n    }\n    y += this.chartViewport.scrollOffset();\n    const groups = this.rawTimelineData.groups || [];\n\n    // The real order of the groups is the preorder traversal, and it will match the order in the sortedGroup.\n    // So we first do a preorder traversal to get an array of GroupIndex. And then based on the visual index we got\n    // before, we can get the real group index.\n    if (this.#groupTreeRoot) {\n      const sortedGroupIndexes = this.#getVisualOrderOfGroupIndexes(this.#groupTreeRoot);\n\n      // This shouldn't happen, because the tree should have the fake root and all groups. Add a sanity check to avoid\n      // error.\n      if (sortedGroupIndexes.length !== groups.length) {\n        console.warn('The data from the group tree doesn\\'t match the data from DataProvider.');\n        return {groupIndex: -1, hoverType: HoverType.ERROR};\n      }\n\n      // Add an extra index, which is equal to the length of the |groups|, this\n      // will be used for the coordinates after the last group.\n      // If the coordinates after the last group, it will return in later check\n      // `groupIndex >= groups.length` anyway. But add one more element to make\n      // this array same length as the |groupOffsets|.\n      sortedGroupIndexes.push(groups.length);\n\n      for (let i = 0; i < sortedGroupIndexes.length; i++) {\n        const groupIndex = sortedGroupIndexes[i];\n        const nextIndex = sortedGroupIndexes[i + 1] ?? sortedGroupIndexes.length;\n\n        if (y >= this.groupOffsets[groupIndex] && y < this.groupOffsets[nextIndex]) {\n          // This section is used to calculate the position of current group's header\n          // If we are in edit mode, the track label is pushed right to make room for the icons.\n          const context = this.context;\n          context.save();\n          context.font = this.#font;\n          const headerRight = HEADER_LEFT_PADDING + (this.#inTrackConfigEditMode ? EDIT_MODE_TOTAL_ICON_WIDTH : 0) +\n              this.labelWidthForGroup(context, groups[groupIndex]);\n          context.restore();\n\n          const mouseInHeaderRow =\n              y >= this.groupOffsets[groupIndex] && y < this.groupOffsets[groupIndex] + groups[groupIndex].style.height;\n\n          if (this.#inTrackConfigEditMode) {\n            if (mouseInHeaderRow) {\n              if (UP_ICON_LEFT <= x && x < UP_ICON_LEFT + EDIT_ICON_WIDTH) {\n                return {groupIndex, hoverType: HoverType.TRACK_CONFIG_UP_BUTTON};\n              }\n              if (DOWN_ICON_LEFT <= x && x < DOWN_ICON_LEFT + EDIT_ICON_WIDTH) {\n                return {groupIndex, hoverType: HoverType.TRACK_CONFIG_DOWN_BUTTON};\n              }\n              if (HIDE_ICON_LEFT <= x && x < HIDE_ICON_LEFT + EDIT_ICON_WIDTH) {\n                return {\n                  groupIndex,\n                  hoverType: groups[groupIndex].hidden ? HoverType.TRACK_CONFIG_SHOW_BUTTON :\n                                                         HoverType.TRACK_CONFIG_HIDE_BUTTON,\n                };\n              }\n              if (mouseInHeaderRow && x <= headerRight) {\n                return {groupIndex, hoverType: HoverType.INSIDE_TRACK_HEADER};\n              }\n            }\n            // Ignore any other actions when user is customizing the tracks.\n            // For example, we won't toggle the expand status in the editing mode.\n          } else {\n            // User is not in edit mode so they can either be in the header, or in the track.\n            if (mouseInHeaderRow && x <= headerRight) {\n              return {groupIndex, hoverType: HoverType.INSIDE_TRACK_HEADER};\n            }\n            return {groupIndex, hoverType: HoverType.INSIDE_TRACK};\n          }\n        }\n      }\n    }\n\n    return {groupIndex: -1, hoverType: HoverType.OUTSIDE_TRACKS};\n  }\n\n  #enterEditMode(): void {\n    const div = document.createElement('div');\n    div.classList.add('flame-chart-edit-confirm');\n    const button = new Buttons.Button.Button();\n    button.data = {\n      variant: Buttons.Button.Variant.PRIMARY,\n      jslogContext: 'track-configuration-exit',\n    };\n    button.innerText = i18nString(UIStrings.exitTrackConfigurationMode);\n    div.appendChild(button);\n    button.addEventListener('click', () => {\n      this.#exitEditMode();\n    });\n\n    this.viewportElement.appendChild(div);\n    this.#inTrackConfigEditMode = true;\n    this.dispatchEventToListeners(Events.TRACKS_REORDER_STATE_CHANGED, true);\n    this.updateLevelPositions();\n    this.draw();\n  }\n\n  #removeEditModeButton(): void {\n    const confirmButton = this.viewportElement.querySelector('.flame-chart-edit-confirm');\n    if (confirmButton) {\n      this.viewportElement.removeChild(confirmButton);\n    }\n  }\n\n  #exitEditMode(): void {\n    this.#removeEditModeButton();\n    this.#inTrackConfigEditMode = false;\n    this.dispatchEventToListeners(Events.TRACKS_REORDER_STATE_CHANGED, false);\n    this.updateLevelPositions();\n    this.draw();\n  }\n\n  private markerIndexBeforeTime(time: number): number {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      throw new Error('No timeline data');\n    }\n\n    const markers = timelineData.markers;\n    if (!markers) {\n      throw new Error('No timeline markers');\n    }\n\n    return Platform.ArrayUtilities.lowerBound(\n        timelineData.markers, time, (markerTimestamp, marker) => markerTimestamp - marker.startTime());\n  }\n\n  /**\n   * Draw the whole flame chart.\n   * Make sure |setWindowTimes| is called with correct time range before this function.\n   */\n  private draw(): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    this.resetCanvas();\n\n    this.dispatchEventToListeners(Events.LATEST_DRAW_DIMENSIONS, {\n      chart: {\n        widthPixels: this.offsetWidth,\n        heightPixels: this.offsetHeight,\n        scrollOffsetPixels: this.chartViewport.scrollOffset(),\n        // If there are no groups because we have no timeline data, we treat\n        // that as all being collapsed.\n        allGroupsCollapsed: this.rawTimelineData?.groups.every(g => !g.expanded) ?? true,\n      },\n      traceWindow: Trace.Helpers.Timing.traceWindowFromMilliSeconds(this.minimumBoundary(), this.maximumBoundary()),\n    });\n    const canvasWidth = this.offsetWidth;\n    const canvasHeight = this.offsetHeight;\n    const context = this.context;\n\n    context.save();\n    const ratio = window.devicePixelRatio;\n    const top = this.chartViewport.scrollOffset();\n    context.scale(ratio, ratio);\n    // Clear the canvas area by drawing a white square first\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n    context.fillRect(0, 0, canvasWidth, canvasHeight);\n    context.translate(0, -top);\n    context.font = this.#font;\n\n    const {markerIndices, drawBatches, titleIndices} = this.getDrawBatches(context, timelineData);\n\n    const groups = this.rawTimelineData?.groups || [];\n    const trackIndex = groups.findIndex(g => g.name.includes('Main'));\n    const group = groups.at(trackIndex);\n    const startLevel = group?.startLevel;\n    const endLevel = groups.at(trackIndex + 1)?.startLevel;\n    const entryIndexIsInTrack = (index: number): boolean => {\n      if (trackIndex < 0 || startLevel === undefined || endLevel === undefined) {\n        return false;\n      }\n      const barWidth = Math.min(this.#eventBarWidth(timelineData, index), canvasWidth);\n      return timelineData.entryLevels[index] >= startLevel && timelineData.entryLevels[index] < endLevel &&\n          barWidth > 10;\n    };\n    let wideEntryExists = false;\n    for (const [{color, outline}, {indexes}] of drawBatches) {\n      if (!wideEntryExists) {\n        wideEntryExists = indexes.some(entryIndexIsInTrack);\n      }\n      this.#drawBatchEvents(context, timelineData, color, indexes, outline);\n    }\n    this.dispatchEventToListeners(Events.CHART_PLAYABLE_STATE_CHANGED, wideEntryExists);\n\n    if (!this.#inTrackConfigEditMode) {\n      // In configuration mode, we do not render the actual flame chart, so we\n      // can skip checking for any custom symbols on any tracks.\n      this.#drawCustomSymbols(context, timelineData);\n      // Markers get in the way of the UI for editing, so hide them in edit mode.\n      this.drawMarkers(context, timelineData, markerIndices);\n    }\n\n    this.drawEventTitles(context, timelineData, titleIndices, canvasWidth);\n\n    // If there is a `forceDecoration` function, it will be called in `drawEventTitles`, which will overwrite the\n    // default decorations, so we need to call this function after the `drawEventTitles`.\n    const allIndexes = Array.from(drawBatches.values()).map(x => x.indexes).flat();\n    this.#drawDecorations(context, timelineData, allIndexes);\n    context.restore();\n\n    this.drawGroupHeaders(canvasWidth, canvasHeight);\n    this.drawFlowEvents(context, timelineData);\n    this.drawMarkerLines();\n    const dividersData = TimelineGrid.calculateGridOffsets(this);\n    const navStartTimes = this.dataProvider.mainFrameNavigationStartEvents?.() || [];\n\n    let navStartTimeIndex = 0;\n    const drawAdjustedTime = (time: number): string => {\n      if (navStartTimes.length === 0) {\n        return this.formatValue(time, dividersData.precision);\n      }\n\n      // Track when the time crosses the boundary to the next nav start record,\n      // and when it does, move the nav start array index accordingly.\n      const hasNextNavStartTime = navStartTimes.length > navStartTimeIndex + 1;\n      if (hasNextNavStartTime) {\n        const nextNavStartTime = navStartTimes[navStartTimeIndex + 1];\n        const nextNavStartTimeStartTimestamp = Trace.Helpers.Timing.microToMilli(nextNavStartTime.ts);\n        if (time > nextNavStartTimeStartTimestamp) {\n          navStartTimeIndex++;\n        }\n      }\n\n      // Adjust the time by the nearest nav start marker's value.\n      const nearestMarker = navStartTimes[navStartTimeIndex];\n      if (nearestMarker) {\n        const nearestMarkerStartTime = Trace.Helpers.Timing.microToMilli(nearestMarker.ts);\n        time -= nearestMarkerStartTime - this.zeroTime();\n      }\n\n      return this.formatValue(time, dividersData.precision);\n    };\n\n    TimelineGrid.drawCanvasGrid(context, dividersData);\n    if (this.rulerEnabled) {\n      TimelineGrid.drawCanvasHeaders(context, dividersData, drawAdjustedTime, 3, RulerHeight);\n    }\n\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.updateElementPosition(this.selectedElement, this.selectedEntryIndex);\n\n    if (this.#searchResultEntryIndex !== null) {\n      this.showPopoverForSearchResult(this.#searchResultEntryIndex);\n    }\n    this.updateMarkerHighlight();\n  }\n\n  /**\n   * Draws generic flame chart events, that is, the plain rectangles that fill several parts\n   * in the timeline like the Main Thread flamechart and the timings track.\n   * Drawn on a color by color basis to minimize the amount of times context.style is switched.\n   */\n  #drawBatchEvents(\n      context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData, color: string, indexes: number[],\n      outline: boolean): void {\n    context.save();\n    context.beginPath();\n    for (let i = 0; i < indexes.length; ++i) {\n      const entryIndex = indexes[i];\n\n      // If there is a draw override, then this is not a generic event.\n      if (this.#indexToDrawOverride.has(entryIndex)) {\n        continue;\n      }\n\n      // Doesn't draw a rect, just adds the rect into the current path\n      this.#drawEventRect(context, timelineData, entryIndex);\n    }\n\n    // In some scenarios we want to draw outlines around events for added visual contrast.\n    if (outline) {\n      // This near-black works best in both light- and dark-mode. Color mix with the rect's bg so it's a good contrast, but still has the base flavor.\n      const nearBlack = ThemeSupport.ThemeSupport.instance().getComputedValue('--ref-palette-neutral10');\n      context.strokeStyle = `color-mix(in srgb, ${color}, ${nearBlack} 60%)`;\n      context.stroke();\n    }\n\n    context.fillStyle = color;\n    context.fill();\n    context.restore();\n  }\n\n  /**\n   * Draws decorations onto events. {@see FlameChartDecoration}.\n   */\n  #drawDecorations(context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData, indexes: number[]): void {\n    const {entryTotalTimes, entryStartTimes, entryLevels} = timelineData;\n    context.save();\n    for (let i = 0; i < indexes.length; ++i) {\n      const entryIndex = indexes[i];\n      const decorationsForEvent = timelineData.entryDecorations.at(entryIndex);\n      if (!decorationsForEvent || decorationsForEvent.length < 1) {\n        continue;\n      }\n      if (decorationsForEvent.length > 1) {\n        sortDecorationsForRenderingOrder(decorationsForEvent);\n      }\n      const entryStartTime = entryStartTimes[entryIndex];\n      const duration = entryTotalTimes[entryIndex];\n      const barX = this.timeToPositionClipped(entryStartTime);\n      const barLevel = entryLevels[entryIndex];\n      const barHeight = this.#eventBarHeight(timelineData, entryIndex);\n      const barY = this.levelToOffset(barLevel);\n      let barWidth = this.#eventBarWidth(timelineData, entryIndex);\n\n      for (const decoration of decorationsForEvent) {\n        switch (decoration.type) {\n          case FlameChartDecorationType.CANDY: {\n            const candyStripeStartTime = Trace.Helpers.Timing.microToMilli(decoration.startAtTime);\n            if (duration < candyStripeStartTime) {\n              // If the duration of the event is less than the start time to draw the candy stripes, then we have no stripes to draw.\n              continue;\n            }\n            if (!this.candyStripePattern || !this.candyStripePatternGray) {\n              const red = 'rgba(255, 0, 0, 0.8)';\n              this.candyStripePattern = this.createCandyStripePattern(red);\n              const parsedColor = Common.Color.parse(red);\n              const dimmed = parsedColor?.asLegacyColor().grayscale().asString() ?? 'lightgrey';\n              this.candyStripePatternGray = this.createCandyStripePattern(dimmed);\n            }\n\n            context.save();\n            context.beginPath();\n            // Draw a rectangle over the event, starting at the X value of the\n            // event's start time + the startDuration of the candy striping.\n            const barXStart = this.timeToPositionClipped(entryStartTime + candyStripeStartTime);\n            // We stripe until the very end of the entry.\n            const barXEnd = this.timeToPositionClipped(entryStartTime + duration);\n            this.#drawEventRect(context, timelineData, entryIndex, {\n              startX: barXStart,\n              width: barXEnd - barXStart,\n            });\n            context.fillStyle =\n                this.#shouldDimEvent(entryIndex) ? this.candyStripePatternGray : this.candyStripePattern;\n            context.fill();\n            context.restore();\n            break;\n          }\n          case FlameChartDecorationType.WARNING_TRIANGLE: {\n            let endTimePixels = barX + barWidth;\n            if (typeof decoration.customEndTime !== 'undefined') {\n              // The user can pass a customEndTime to tell us where the event's box ends and therefore where we should\n              // draw the triangle. So therefore we calculate the width by taking the end time off the start time.\n              const endTimeMilli = Trace.Helpers.Timing.microToMilli(decoration.customEndTime);\n              endTimePixels = this.timeToPositionClipped(endTimeMilli);\n              barWidth = endTimePixels - barX;\n            }\n            const triangleHeight = 8;\n            let triangleWidth = 8;\n            if (typeof decoration.customStartTime !== 'undefined') {\n              // The user can pass a customStartTime to tell us where the event's box start and therefore where we\n              // should draw the triangle. So therefore we calculate the width by taking the end time off the start\n              // time.\n              const startTimeMilli = Trace.Helpers.Timing.microToMilli(decoration.customStartTime);\n              const startTimePixels = this.timeToPositionClipped(startTimeMilli);\n              triangleWidth = Math.min(endTimePixels - startTimePixels, 8);\n            }\n            context.save();\n            context.beginPath();\n            context.rect(barX, barY, barWidth, barHeight);\n            context.clip();\n            context.beginPath();\n            context.fillStyle = this.#transformColor(entryIndex, 'red');\n            context.moveTo(barX + barWidth - triangleWidth, barY);\n            context.lineTo(barX + barWidth, barY);\n            context.lineTo(barX + barWidth, barY + triangleHeight);\n            context.fill();\n            context.restore();\n            break;\n          }\n          case FlameChartDecorationType.HIDDEN_DESCENDANTS_ARROW: {\n            context.save();\n            context.beginPath();\n            context.rect(barX, barY, barWidth, barHeight);\n            const arrowSize = barHeight;\n            // If the bar is wider than double the arrow button, draw the button. Otherwise, draw a corner triangle to indicate some entries are hidden\n            if (barWidth > arrowSize * 2) {\n              const triangleSize = 7;\n              const triangleHorizontalPadding = 5;\n              const triangleVerrticalPadding = 6;\n              context.clip();\n              context.beginPath();\n              context.fillStyle = '#474747';\n              const arrowAX = barX + barWidth - triangleSize - triangleHorizontalPadding;\n              const arrowAY = barY + triangleVerrticalPadding;\n              context.moveTo(arrowAX, arrowAY);\n              const arrowBX = barX + barWidth - triangleHorizontalPadding;\n              const arrowBY = barY + triangleVerrticalPadding;\n              context.lineTo(arrowBX, arrowBY);\n              const arrowCX = barX + barWidth - triangleHorizontalPadding - triangleSize / 2;\n              const arrowCY = barY + barHeight - triangleVerrticalPadding;\n              context.lineTo(arrowCX, arrowCY);\n            } else {\n              const triangleSize = 8;\n              context.clip();\n              context.beginPath();\n              context.fillStyle = '#474747';\n              context.moveTo(barX + barWidth - triangleSize, barY + barHeight);\n              context.lineTo(barX + barWidth, barY + barHeight);\n              context.lineTo(barX + barWidth, barY + triangleSize);\n            }\n            context.fill();\n            context.restore();\n            break;\n          }\n        }\n      }\n    }\n    context.restore();\n  }\n\n  /**\n   * Draws (but does not fill) a rectangle for a given event onto the provided\n   * context. Because sometimes we need to draw a portion of the rect, it\n   * optionally allows the start X and width of the rect to be overridden by\n   * custom pixel values. It currently does not allow the start Y and height to\n   * be changed because we have no need to do so, but this can be extended in\n   * the future if required.\n   **/\n  #drawEventRect(\n      context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData, entryIndex: number, overrides?: {\n        startX?: number,\n        width?: number,\n      }): void {\n    const {entryTotalTimes, entryStartTimes, entryLevels} = timelineData;\n    const duration = entryTotalTimes[entryIndex];\n    if (isNaN(duration)) {\n      return;\n    }\n    const entryStartTime = entryStartTimes[entryIndex];\n    const barX = overrides?.startX ?? this.timeToPositionClipped(entryStartTime);\n    const barLevel = entryLevels[entryIndex];\n    const barHeight = this.#eventBarHeight(timelineData, entryIndex);\n    const barY = this.levelToOffset(barLevel);\n    const barWidth = overrides?.width ?? this.#eventBarWidth(timelineData, entryIndex);\n    if (barWidth === 0) {\n      return;\n    }\n    // We purposefully leave a 1px gap off the height so there is a small gap\n    // visually between events vertically in the panel.\n    // Similarly, we leave 0.5 pixels off the width so that there is a small\n    // gap between events. Otherwise if a trace has a lot of events it looks\n    // like one solid block and is not very easy to distinguish when events\n    // start and end.\n    context.rect(barX, barY, barWidth - 0.5, barHeight - 1);\n  }\n\n  #eventBarHeight(timelineData: FlameChartTimelineData, entryIndex: number): number {\n    const {entryLevels} = timelineData;\n    const barLevel = entryLevels[entryIndex];\n    const barHeight = this.levelHeight(barLevel);\n    return barHeight;\n  }\n\n  entryWidth(entryIndex: number): number {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return 0;\n    }\n    return this.#eventBarWidth(timelineData, entryIndex);\n  }\n\n  #eventBarWidth(timelineData: FlameChartTimelineData, entryIndex: number): number {\n    const {entryTotalTimes, entryStartTimes} = timelineData;\n    const duration = entryTotalTimes[entryIndex];\n    const entryStartTime = entryStartTimes[entryIndex];\n    const barXStart = this.timeToPositionClipped(entryStartTime);\n    const barXEnd = this.timeToPositionClipped(entryStartTime + duration);\n    // Ensure that the width of the bar is at least one pixel.\n    const barWidth = Math.max(barXEnd - barXStart, 1);\n    return barWidth;\n  }\n\n  /**\n   * Preprocess the data to be drawn to speed the rendering time.\n   * Specifically:\n   *  - Groups events into draw batches - same color + same outline - to help drawing performance\n   *    by reducing how often `context.fillStyle` is changed.\n   *  - Discards non visible events.\n   *  - Gathers marker events (LCP, FCP, DCL, etc.).\n   *  - Gathers event titles that should be rendered.\n   */\n  private getDrawBatches(context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData): {\n    drawBatches: Map<{color: string, outline: boolean}, {indexes: number[]}>,\n    titleIndices: number[],\n    markerIndices: number[],\n  } {\n    // These are the event indexes of events that we are drawing onto the timeline that:\n    // 1) have text within them\n    // 2) are visually wide enough in pixels to make it worth rendering the text.\n    const titleIndices: number[] = [];\n\n    // These point to events that represent single points in the timeline, most\n    // often an event such as DCL/LCP.\n    const markerIndices: number[] = [];\n    const {entryTotalTimes, entryStartTimes} = timelineData;\n\n    const top = this.chartViewport.scrollOffset();\n\n    const textPadding = this.textPadding;\n    // How wide in pixels / long in duration an event needs to be to make it\n    // worthwhile rendering the text inside it.\n    const minTextWidth = 2 * textPadding + UI.UIUtils.measureTextWidth(context, '…');\n    const minTextWidthDuration = this.chartViewport.pixelToTimeOffset(minTextWidth);\n\n    // As we parse each event, we bucket them into batches based on the color and\n    // whether they should be outlined. The key of this map is an object, so the\n    // following helps for dedupings keys to use within a Map.\n    interface BatchKey {\n      color: string;\n      outline: boolean;\n    }\n    const keysByColorWithOutline = new Map<string, BatchKey>();\n    const keysByColorWithNoOutline = new Map<string, BatchKey>();\n    const getOrMakeKey = (color: string, outline: boolean): BatchKey => {\n      const map = outline ? keysByColorWithOutline : keysByColorWithNoOutline;\n      const key = map.get(color);\n      if (key) {\n        return key;\n      }\n\n      const newKey = {color, outline};\n      map.set(color, newKey);\n      return newKey;\n    };\n\n    const drawBatches = new Map<BatchKey, {indexes: number[]}>();\n    for (let level = 0; level < this.dataProvider.maxStackDepth(); ++level) {\n      // Since tracks can be reordered the |visibleLevelOffsets| is not necessarily sorted, so we need to check all levels.\n      // Note that to check if a level is off the top of the screen, we can't\n      // just check its offset, because then the level will disappear the\n      // moment it is 1px off the top of the screen. So instead we check that\n      // the entire height of the level is off the top of the screen before\n      // skipping it.\n      if (this.levelToOffset(level) + this.levelHeight(level) < top ||\n          this.levelToOffset(level) > top + this.offsetHeight) {\n        continue;\n      }\n      if (!this.visibleLevels?.[level]) {\n        continue;\n      }\n      if (!this.timelineLevels) {\n        break;\n      }\n\n      // Entries are ordered by start time within a level, so find the last visible entry.\n      const levelIndexes = this.timelineLevels[level];\n      const rightIndexOnLevel = Platform.ArrayUtilities.lowerBound(\n                                    levelIndexes, this.chartViewport.windowRightTime(),\n                                    (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n          1;\n      let lastDrawOffset = Infinity;\n      for (let entryIndexOnLevel = rightIndexOnLevel; entryIndexOnLevel >= 0; --entryIndexOnLevel) {\n        const entryIndex = levelIndexes[entryIndexOnLevel];\n        const duration = entryTotalTimes[entryIndex];\n        // Markers are single events in time (e.g. LCP): they do not have a duration.\n        if (isNaN(duration)) {\n          markerIndices.push(entryIndex);\n          continue;\n        }\n\n        if (duration >= minTextWidthDuration || this.forceDecorationCache?.[entryIndex]) {\n          // If the event is big enough visually to have its text rendered,\n          // or if it's in the array of event indexes that we forcibly render (as defined by the data provider)\n          // then we store its index. Later on, we'll loop through all\n          // `titleIndices` to render the text for each event.\n          titleIndices.push(entryIndex);\n        }\n\n        const entryStartTime = entryStartTimes[entryIndex];\n        const entryOffsetRight = entryStartTime + duration;\n        const levelForcedDrawable = Boolean(this.dataProvider.forceDrawableLevel?.(level));\n        if (entryOffsetRight <= this.chartViewport.windowLeftTime() && !levelForcedDrawable) {\n          // If the event is entirely to the left of the visible window, and the level is not forced to be drawn, we can stop processing this level.\n          break;\n        }\n\n        const barX = this.timeToPositionClipped(entryStartTime);\n        // Check if the entry entirely fits into an already drawn pixel, we can just skip drawing it.\n        if (barX >= lastDrawOffset) {\n          continue;\n        }\n        lastDrawOffset = barX;\n\n        if (this.entryColorsCache) {\n          const color = this.getColorForEntry(entryIndex);\n          const outline = this.#shouldOutlineEvent(entryIndex);\n          const key = getOrMakeKey(color, outline);\n          let batch = drawBatches.get(key);\n          if (!batch) {\n            batch = {indexes: []};\n            drawBatches.set(key, batch);\n          }\n          batch.indexes.push(entryIndex);\n        }\n      }\n    }\n\n    return {drawBatches, titleIndices, markerIndices};\n  }\n\n  /**\n   * The function to draw the group headers. It will draw the title by default.\n   * And when a group is hovered, it will add a edit button.\n   * And will draw the move up/down, hide and save button if user enter the editing mode.\n   * @param width\n   * @param height\n   * @param hoveredGroupIndex This is used to show the edit icon for hovered group. If it is undefined or -1, it means\n   * there is no group being hovered.\n   */\n  private drawGroupHeaders(width: number, height: number): void {\n    const context = this.context;\n    const top = this.chartViewport.scrollOffset();\n    const ratio = window.devicePixelRatio;\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups || [];\n    if (!groups.length) {\n      return;\n    }\n\n    const groupOffsets = this.groupOffsets;\n    if (groupOffsets === null || groupOffsets === undefined) {\n      return;\n    }\n    const lastGroupOffset = groupOffsets[groupOffsets.length - 1];\n\n    context.save();\n    context.scale(ratio, ratio);\n    context.translate(0, -top);\n    context.font = this.#font;\n\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-cdt-base-container');\n    // Fill the gap between groups.\n    this.forEachGroupInViewport((offset, _, group) => {\n      const paddingHeight = group.style.padding;\n      if (paddingHeight < 5) {\n        return;\n      }\n      context.fillRect(0, offset - paddingHeight + 2, width, paddingHeight - 4);\n    });\n    // Fill the gap between last group and the bottom of canvas view.\n    if (groups.length && lastGroupOffset < top + height) {\n      context.fillRect(0, lastGroupOffset + 2, width, top + height - lastGroupOffset);\n    }\n\n    // The separating line between top level groups.\n    context.strokeStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-neutral-container');\n    context.beginPath();\n    // Draw a separator line at the beginning of each top-level group (except the first one).\n    this.forEachGroupInViewport((offset, _, group, isFirst) => {\n      if (isFirst || group.style.padding < 4) {\n        return;\n      }\n      horizontalLine(context, width, offset - 2.5);\n    });\n    // Draw a separator line at the end of all groups.\n    horizontalLine(context, width, lastGroupOffset + 1.5);\n    context.stroke();\n\n    this.forEachGroupInViewport((offset, index, group) => {\n      if (group.style.useFirstLineForOverview) {\n        return;\n      }\n      if (!this.isGroupCollapsible(index) || group.expanded) {\n        if (!group.style.shareHeaderLine && this.isGroupFocused(index)) {\n          context.fillStyle = group.style.backgroundColor;\n          context.fillRect(0, offset, width, group.style.height);\n        }\n        return;\n      }\n      let nextGroup = index + 1;\n      while (nextGroup < groups.length && groups[nextGroup].style.nestingLevel > group.style.nestingLevel) {\n        nextGroup++;\n      }\n      const endLevel = nextGroup < groups.length ? groups[nextGroup].startLevel : this.dataProvider.maxStackDepth();\n      this.drawCollapsedOverviewForGroup(group, offset, endLevel);\n    });\n\n    context.save();\n    // If there is only one track, we won't allow the track reordering or hiding.\n    const trackConfigurationAllowed = groups.length > 1;\n\n    // When it is normal mode, there are no icons to the left of a track.\n    // When it is in edit mode, there are three icons to customize the groups.\n    const iconsWidth = this.#inTrackConfigEditMode ? EDIT_MODE_TOTAL_ICON_WIDTH : 0;\n    this.forEachGroupInViewport((offset, groupIndex, group) => {\n      context.font = this.#font;\n      if (this.isGroupCollapsible(groupIndex) && !group.expanded || group.style.shareHeaderLine) {\n        // In edit mode, we draw an extra rectangle for the save icon.\n        const labelBackgroundWidth = this.labelWidthForGroup(context, group);\n        const parsedColor = Common.Color.parse(group.style.backgroundColor);\n        if (parsedColor) {\n          context.fillStyle = (parsedColor.setAlpha(0.8).asString());\n        }\n        context.fillRect(\n            iconsWidth + HEADER_LEFT_PADDING, offset + HEADER_LABEL_Y_PADDING, labelBackgroundWidth,\n            group.style.height - 2 * HEADER_LABEL_Y_PADDING);\n      }\n      context.fillStyle = (this.#inTrackConfigEditMode && group.hidden) ?\n          ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-token-subtle', this.contentElement) :\n          group.style.color;\n\n      // The arrow is drawn from the center, so the indent is in fact the center of the arrow. See `drawExpansionArrow`\n      // function to understand how we draw the arrow.\n      // So the header looks like this:\n      // |ICON_WIDTH|expansionArrowIndent * (nesting level + 1)|\n      // |headerLeftPadding|EDIT  ICON|                     |Arrow|LabelXPadding|Title|LabelXPadding|\n      //                                                                        ^ titleStart\n      const titleStart = iconsWidth + EXPANSION_ARROW_INDENT * (group.style.nestingLevel + 1) + ARROW_SIDE / 2 +\n          HEADER_LABEL_X_PADDING;\n      const y = offset + group.style.height - this.textBaseline;\n      context.fillText(group.name, titleStart, y);\n      if (group.subtitle) {\n        const titleMetrics = context.measureText(group.name);\n        context.font = this.#subtitleFont;\n        context.fillText(group.subtitle, titleStart + titleMetrics.width + PADDING_BETWEEN_TITLE_AND_SUBTITLE, y - 1);\n        context.font = this.#font;\n      }\n      if (this.#inTrackConfigEditMode && group.hidden) {\n        // Draw a strikethrough line for the hidden tracks.\n        context.fillRect(\n            titleStart, offset + group.style.height / 2, UI.UIUtils.measureTextWidth(context, group.name), 1);\n      }\n\n      // The icon and track title will look like this\n      // Normal mode:\n      // Track title\n      // Edit mode:\n      // [ Up ][Down][Hide]Track title\n      if (trackConfigurationAllowed) {\n        if (this.#inTrackConfigEditMode) {\n          const iconColor = group.hidden ? '--sys-color-token-subtle' : '--sys-color-on-surface';\n          // We only allow to reorder the top level groups.\n          if (group.style.nestingLevel === 0) {\n            drawIcon(context, UP_ICON_LEFT, offset, EDIT_ICON_WIDTH, moveUpIconPath, iconColor);\n            drawIcon(context, DOWN_ICON_LEFT, offset, EDIT_ICON_WIDTH, moveDownIconPath, iconColor);\n          }\n          // If this is the last visible top-level group, we will disable the hide action.\n          drawIcon(\n              context, HIDE_ICON_LEFT, offset, EDIT_ICON_WIDTH, group.hidden ? showIconPath : hideIconPath,\n              this.groupIsLastVisibleTopLevel(groupIndex) ? '--sys-color-state-disabled' : iconColor);\n        }\n      }\n    });\n    context.restore();\n\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-token-subtle');\n    this.forEachGroupInViewport((offset, index, group) => {\n      if (this.isGroupCollapsible(index)) {\n        drawExpansionArrow(\n            context, iconsWidth + EXPANSION_ARROW_INDENT * (group.style.nestingLevel + 1),\n            offset + group.style.height - this.textBaseline - ARROW_SIDE / 2,\n            this.#inTrackConfigEditMode ? false : Boolean(group.expanded));\n      }\n    });\n\n    context.strokeStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-neutral-outline');\n    context.beginPath();\n    context.stroke();\n\n    this.forEachGroupInViewport((offset, index, group, _isFirst, groupHeight) => {\n      if (this.isGroupFocused(index)) {\n        const lineWidth = 2;\n        const bracketLength = 10;\n        context.fillStyle =\n            ThemeSupport.ThemeSupport.instance().getComputedValue('--selected-group-border', this.contentElement);\n        // The selected group indicator will be blue and in this kind of shape. And we will draw it with three\n        // rectangles.\n        // +-+---+\n        // |-|---+\n        // | |\n        // | |\n        // |-|---+\n        // +-+---+\n\n        // The vertical stroke\n        context.fillRect(0, offset - lineWidth, lineWidth, groupHeight - group.style.padding + 2 * lineWidth);\n        // The top horizontal stroke\n        context.fillRect(0, offset - lineWidth, bracketLength, lineWidth);\n        // The top horizontal stroke\n        context.fillRect(0, offset + groupHeight - group.style.padding, bracketLength, lineWidth);\n      }\n    });\n\n    context.restore();\n  }\n\n  /**\n   * Draws page load events in the Timings track (LCP, FCP, DCL, etc.)\n   */\n  private drawMarkers(context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData, markerIndices: number[]):\n      void {\n    const {entryStartTimes, entryLevels} = timelineData;\n    this.markerPositions.clear();\n    context.textBaseline = 'alphabetic';\n    context.save();\n    context.beginPath();\n    let lastMarkerLevel = -1;\n    let lastMarkerX = -Infinity;\n    // Markers are sorted top to bottom, right to left.\n    for (let m = markerIndices.length - 1; m >= 0; --m) {\n      const entryIndex = markerIndices[m];\n      const title = this.entryTitle(entryIndex);\n      if (!title) {\n        continue;\n      }\n      const entryStartTime = entryStartTimes[entryIndex];\n      const level = entryLevels[entryIndex];\n      if (lastMarkerLevel !== level) {\n        lastMarkerX = -Infinity;\n      }\n      const x = Math.max(this.chartViewport.timeToPosition(entryStartTime), lastMarkerX);\n      const y = this.levelToOffset(level);\n      const h = this.levelHeight(level);\n      const padding = 4;\n      const width = Math.ceil(UI.UIUtils.measureTextWidth(context, title)) + 2 * padding;\n      lastMarkerX = x + width + 1;\n      lastMarkerLevel = level;\n      this.markerPositions.set(entryIndex, {x, width});\n      context.fillStyle = this.getColorForEntry(entryIndex);\n      context.fillRect(x, y, width, h - 1);\n      context.fillStyle = 'white';\n      context.fillText(title, x + padding, y + h - this.textBaseline);\n    }\n    context.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n    context.stroke();\n    context.restore();\n  }\n\n  #drawCustomSymbols(context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData): void {\n    const {entryStartTimes, entryTotalTimes, entryLevels} = timelineData;\n    this.customDrawnPositions.clear();\n    context.save();\n\n    // TODO: Don't draw if it's not in the viewport.\n    const posArray = [];\n    for (const [entryIndex, drawOverride] of this.#indexToDrawOverride.entries()) {\n      const entryStartTime = entryStartTimes[entryIndex];\n      const entryTotalTime = entryTotalTimes[entryIndex];\n      const level = entryLevels[entryIndex];\n\n      // Skip if the group for this event has been hidden.\n      const group = this.dataProvider.groupForEvent?.(entryIndex);\n      if (group?.hidden) {\n        continue;\n      }\n\n      const unclippedXStart = this.chartViewport.timeToPosition(entryStartTime);\n      const unclippedXEnd = this.chartViewport.timeToPosition(entryStartTime + entryTotalTime);\n\n      const x = unclippedXStart;\n      const y = this.levelToOffset(level);\n      const height = this.levelHeight(level);\n      const width = unclippedXEnd - unclippedXStart;\n      const pos = drawOverride(\n          context, x, y, width, height, time => this.chartViewport.timeToPosition(time),\n          color => this.#transformColor(entryIndex, color));\n      posArray.push({entryIndex, pos});\n    }\n    // Place in z order so coordinatesToEntryIndex finds the highest z-index match first.\n    posArray.sort((a, b) => (b.pos.z ?? 0) - (a.pos.z ?? 0));\n    for (const {entryIndex, pos} of posArray) {\n      this.customDrawnPositions.set(entryIndex, pos);\n    }\n    context.restore();\n  }\n\n  /**\n   * Draws the titles of trace events in the timeline. Also calls `decorateEntry` on the data\n   * provider, which can do any custom drawing on the corresponding entry's area (e.g. draw screenshots\n   * in the Performance Panel timeline).\n   *\n   * Takes in the width of the entire canvas so that we know if an event does\n   * not fit into the viewport entirely, the max width we can draw is that\n   * width, not the width of the event itself.\n   */\n  private drawEventTitles(\n      context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData, titleIndices: number[],\n      canvasWidth: number): void {\n    const timeToPixel = this.chartViewport.timeToPixel();\n    const textPadding = this.textPadding;\n    context.save();\n    context.beginPath();\n    const {entryStartTimes, entryLevels} = timelineData;\n    for (let i = 0; i < titleIndices.length; ++i) {\n      const entryIndex = titleIndices[i];\n      const entryStartTime = entryStartTimes[entryIndex];\n      const barX = this.timeToPositionClipped(entryStartTime);\n      // Ensure that the title does not go off screen, if the width of the\n      // event is wider than the width of the canvas, use the canvas width as\n      // our maximum width.\n      const barWidth = Math.min(this.#eventBarWidth(timelineData, entryIndex), canvasWidth);\n      const barLevel = entryLevels[entryIndex];\n      const barY = this.levelToOffset(barLevel);\n      let text = this.dataProvider.entryTitle(entryIndex);\n      const barHeight = this.#eventBarHeight(timelineData, entryIndex);\n      if (text?.length) {\n        context.font = this.#font;\n        const hasArrowDecoration =\n            this.entryHasDecoration(entryIndex, FlameChartDecorationType.HIDDEN_DESCENDANTS_ARROW);\n        // Set the max width to be the width of the bar plus some padding. If the bar has an arrow decoration and the bar is wide enough for the larger\n        // version of the decoration that is a square button, also subtract the width of the decoration.\n        // Because the decoration is square, it's width is equal to this.barHeight\n        const maxBarWidth = (hasArrowDecoration && barWidth > barHeight * 2) ? barWidth - textPadding - this.barHeight :\n                                                                               barWidth - 2 * textPadding;\n        text = UI.UIUtils.trimTextMiddle(\n            context,\n            text,\n            maxBarWidth,\n        );\n      }\n      const unclippedBarX = this.chartViewport.timeToPosition(entryStartTime);\n      if (this.dataProvider.decorateEntry(\n              entryIndex, context, text, barX, barY, barWidth, barHeight, unclippedBarX, timeToPixel,\n              color => this.#transformColor(entryIndex, color))) {\n        continue;\n      }\n      if (!text?.length) {\n        continue;\n      }\n      context.fillStyle = this.#transformColor(entryIndex, this.dataProvider.textColor(entryIndex));\n      context.fillText(text, barX + textPadding, barY + barHeight - this.textBaseline);\n    }\n\n    context.restore();\n  }\n\n  /**\n   * @callback GroupCallback\n   * @param groupTop pixels between group top and the top of the flame chart.\n   * @param groupIndex\n   * @param group\n   * @param isFirstGroup if the group is the first one of this nesting level.\n   * @param height pixels of height of this group\n   */\n  /**\n   * Process the pixels of start and end, and other data of each group, which are used in drawing the group.\n   * @param {GroupCallback} callback\n   */\n  private forEachGroup(\n      callback: (groupTop: number, groupIndex: number, group: Group, isFirstGroup: boolean, height: number) => void):\n      void {\n    if (!this.rawTimelineData) {\n      return;\n    }\n    const groups = this.rawTimelineData.groups || [];\n    if (!groups.length) {\n      return;\n    }\n    const groupOffsets = this.groupOffsets;\n    if (!groupOffsets) {\n      return;\n    }\n\n    const groupStack: Array<{\n      nestingLevel: number,\n      visible: boolean,\n    }> = [{nestingLevel: -1, visible: true}];\n    for (let i = 0; i < groups.length; ++i) {\n      const groupTop = groupOffsets[i];\n      const group = groups[i];\n      let firstGroup = true;\n      let last: {\n        nestingLevel: number,\n        visible: boolean,\n      } = groupStack[groupStack.length - 1];\n      while (last && last.nestingLevel >= group.style.nestingLevel) {\n        groupStack.pop();\n        firstGroup = false;\n        last = groupStack[groupStack.length - 1];\n      }\n      last = groupStack[groupStack.length - 1];\n      const parentGroupVisible = last ? last.visible : false;\n      const thisGroupVisible = !group.hidden && parentGroupVisible && (!this.isGroupCollapsible(i) || group.expanded);\n      groupStack.push({nestingLevel: group.style.nestingLevel, visible: Boolean(thisGroupVisible)});\n\n      if (!this.#groupTreeRoot) {\n        return;\n      }\n      const sortedGroupIndexes: number[] = [];\n\n      function traverse(root: GroupTreeNode): void {\n        sortedGroupIndexes.push(root.index);\n        for (const child of root.children) {\n          traverse(child);\n        }\n      }\n      traverse(this.#groupTreeRoot);\n      // Skip the one whose index is -1, because we added to represent the top\n      // level to be the parent of all groups.\n      sortedGroupIndexes.shift();\n\n      // This shouldn't happen, because the tree should have the fake root and all groups. Add a sanity check to avoid\n      // error.\n      if (sortedGroupIndexes.length !== groups.length) {\n        console.warn('The data from the group tree doesn\\'t match the data from DataProvider.');\n        return;\n      }\n\n      // Add an extra index, which is equal to the length of the |groups|, this\n      // will be used for the coordinates after the last group.\n      // If the coordinates after the last group, it will return in later check\n      // `groupIndex >= groups.length` anyway. But add one more element to make\n      // this array same length as the |groupOffsets|.\n      sortedGroupIndexes.push(groups.length);\n\n      const currentIndex = sortedGroupIndexes.indexOf(i);\n      const nextOffset = groupOffsets[sortedGroupIndexes[currentIndex + 1]];\n      // In edit mode all the groups are visible.\n      if (!this.#inTrackConfigEditMode && (!parentGroupVisible || group.hidden)) {\n        continue;\n      }\n      callback(groupTop, i, group, firstGroup, nextOffset - groupTop);\n    }\n  }\n\n  private forEachGroupInViewport(\n      callback: (offset: number, index: number, group: Group, isFirst: boolean, groupHeight: number) => void): void {\n    const top = this.chartViewport.scrollOffset();\n    this.forEachGroup((groupTop, index, group, firstGroup, height) => {\n      if (groupTop - group.style.padding > top + this.offsetHeight) {\n        return;\n      }\n      if (groupTop + height < top) {\n        return;\n      }\n      callback(groupTop, index, group, firstGroup, height);\n    });\n  }\n\n  /**\n   * Returns the width of the title label of the group, which include the left padding, arrow and the group header text.\n   * This function is public for test reason.\n   * |ICON_WIDTH|expansionArrowIndent * (nestingLevel + 1)|\n   * |headerLeftPadding|EDIT  ICON|                    |Arrow|LabelXPadding|Title|LabelXPadding|\n   *                              |<--                      labelWidth                      -->|\n   * @param context canvas context\n   * @param group\n   * @returns the width of the label of the group.\n   */\n  labelWidthForGroup(context: CanvasRenderingContext2D, group: Group): number {\n    return EXPANSION_ARROW_INDENT * (group.style.nestingLevel + 1) + ARROW_SIDE / 2 + HEADER_LABEL_X_PADDING +\n        UI.UIUtils.measureTextWidth(context, group.name) + HEADER_LABEL_X_PADDING - HEADER_LEFT_PADDING;\n  }\n\n  private drawCollapsedOverviewForGroup(group: Group, y: number, endLevel: number): void {\n    const range = new Common.SegmentedRange.SegmentedRange<string>(mergeCallback);\n    const timeWindowLeft = this.chartViewport.windowLeftTime();\n    const timeWindowRight = this.chartViewport.windowRightTime();\n    const context = this.context;\n    const groupBarHeight = group.style.height;\n    if (!this.rawTimelineData) {\n      return;\n    }\n    const entryStartTimes = this.rawTimelineData.entryStartTimes;\n    const entryTotalTimes = this.rawTimelineData.entryTotalTimes;\n    const timeToPixel = this.chartViewport.timeToPixel();\n\n    for (let level = group.startLevel; level < endLevel; ++level) {\n      const levelIndexes: number[] = this.timelineLevels ? this.timelineLevels[level] : [];\n      const rightIndexOnLevel =\n          Platform.ArrayUtilities.lowerBound(\n              levelIndexes, timeWindowRight, (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n          1;\n      let lastDrawOffset = Infinity;\n\n      for (let entryIndexOnLevel = rightIndexOnLevel; entryIndexOnLevel >= 0; --entryIndexOnLevel) {\n        const entryIndex = levelIndexes[entryIndexOnLevel];\n        const entryStartTime = entryStartTimes[entryIndex];\n        const barX = this.timeToPositionClipped(entryStartTime);\n        const entryEndTime = entryStartTime + entryTotalTimes[entryIndex];\n        if (isNaN(entryEndTime) || barX >= lastDrawOffset) {\n          continue;\n        }\n        if (entryEndTime <= timeWindowLeft) {\n          break;\n        }\n        lastDrawOffset = barX;\n        const color = this.getColorForEntry(entryIndex);\n        const endBarX = this.timeToPositionClipped(entryEndTime);\n        if (group.style.useDecoratorsForOverview && this.dataProvider.forceDecoration(entryIndex)) {\n          const unclippedBarX = this.chartViewport.timeToPosition(entryStartTime);\n          const barWidth = this.#eventBarWidth(this.rawTimelineData, entryIndex);\n\n          context.beginPath();\n          context.fillStyle = color;\n          context.fillRect(barX, y, barWidth, groupBarHeight - 1);\n          this.dataProvider.decorateEntry(\n              entryIndex, context, '', barX, y, barWidth, groupBarHeight, unclippedBarX, timeToPixel,\n              color => this.#transformColor(entryIndex, color));\n          continue;\n        }\n        range.append(new Common.SegmentedRange.Segment(barX, endBarX, color));\n      }\n    }\n\n    const segments = range.segments().slice().sort((a, b) => a.data.localeCompare(b.data));\n    let lastColor;\n    context.beginPath();\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i];\n      if (lastColor !== segments[i].data) {\n        context.fill();\n        context.beginPath();\n        lastColor = segments[i].data;\n        context.fillStyle = lastColor;\n      }\n      context.rect(segment.begin, y, segment.end - segment.begin, groupBarHeight);\n    }\n    context.fill();\n\n    function mergeCallback<T>(a: Common.SegmentedRange.Segment<T>, b: Common.SegmentedRange.Segment<T>):\n        Common.SegmentedRange.Segment<T>|null {\n      return a.data === b.data && a.end + 0.4 > b.end ? a : null;\n    }\n  }\n\n  private drawFlowEvents(context: CanvasRenderingContext2D, timelineData: FlameChartTimelineData): void {\n    const td = this.timelineData();\n    if (!td) {\n      return;\n    }\n\n    const {entryTotalTimes, entryStartTimes, entryLevels} = timelineData;\n    const ratio = window.devicePixelRatio;\n    const top = this.chartViewport.scrollOffset();\n    const arrowLineWidth = 6;\n    const arrowWidth = 3;\n\n    context.save();\n    context.scale(ratio, ratio);\n    context.translate(0, -top);\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-on-surface-subtle');\n    context.fillStyle = arrowColor;\n    context.strokeStyle = arrowColor;\n\n    for (let i = 0; i < td.initiatorsData.length; ++i) {\n      const initiatorsData = td.initiatorsData[i];\n\n      // Draw an arrow in an 'elbow connector' shape if the initiator ends before the initiated event starts, like this\n      // ---\n      //   |\n      //   --->\n      // Otherwise directly draw from the initiator start to initiated start, like this:\n      // |\n      // |\n      // ---->\n      const initiatorStartTime = entryStartTimes[initiatorsData.initiatorIndex];\n      const initiatorEndTime =\n          entryStartTimes[initiatorsData.initiatorIndex] + entryTotalTimes[initiatorsData.initiatorIndex];\n      const initiatedStartTime = entryStartTimes[initiatorsData.eventIndex];\n\n      const initiatorEndsBeforeInitiatedStart = initiatorEndTime < initiatedStartTime;\n      const initiatorArrowStartTime = initiatorEndsBeforeInitiatedStart ?\n          initiatorEndTime :\n          // The blue indicator's width is 2, so add a little bit offset to start the arrow.\n          Math.max(initiatorStartTime, this.chartViewport.pixelToTime(5));\n      const initiatorArrowEndTime = initiatedStartTime;\n\n      // Do not draw the initiator if it is out of the viewport\n      if (initiatorArrowEndTime < this.chartViewport.windowLeftTime()) {\n        continue;\n      }\n      let startX = this.chartViewport.timeToPosition(initiatorArrowStartTime);\n      let endX = this.chartViewport.timeToPosition(initiatorArrowEndTime);\n\n      // Draw a circle around 'collapsed entries' arrow to indicate that the initiated entry is hidden\n      if (initiatorsData.isInitiatorHidden) {\n        const {circleEndX} = this.drawCircleAroundCollapseArrow(initiatorsData.initiatorIndex, context, timelineData);\n        // If the circle exists around the initiator, start the initiator arrow from the circle end\n        if (circleEndX) {\n          startX = circleEndX;\n        }\n      }\n      if (initiatorsData.isEntryHidden) {\n        const {circleStartX} = this.drawCircleAroundCollapseArrow(initiatorsData.eventIndex, context, timelineData);\n        // If the circle exists around the initiated event, draw the initiator arrow until the circle beginning\n        if (circleStartX) {\n          endX = circleStartX;\n        }\n      }\n\n      const startLevel = entryLevels[initiatorsData.initiatorIndex];\n      const endLevel = entryLevels[initiatorsData.eventIndex];\n      const startY = this.levelToOffset(startLevel) + this.levelHeight(startLevel) / 2;\n      const endY = this.levelToOffset(endLevel) + this.levelHeight(endLevel) / 2;\n      const lineLength = endX - startX;\n\n      context.lineWidth = 1;\n      context.shadowColor = 'rgba(0, 0, 0, 0.3)';\n      context.shadowOffsetX = 2;\n      context.shadowOffsetY = 2;\n      context.shadowBlur = 3;\n      if (lineLength > arrowWidth) {\n        // Add an arrow to the line if the line is long enough.\n        context.beginPath();\n        context.moveTo(endX, endY);\n        context.lineTo(endX - arrowLineWidth, endY - 3);\n        context.lineTo(endX - arrowLineWidth, endY + 3);\n        context.fill();\n      }\n\n      if (initiatorEndsBeforeInitiatedStart) {\n        // ---\n        //   |\n        //   --->\n        context.beginPath();\n        context.moveTo(startX, startY);\n        context.lineTo(startX + lineLength / 2, startY);\n        context.lineTo(startX + lineLength / 2, endY);\n        context.lineTo(endX, endY);\n        context.stroke();\n      } else {\n        // |\n        // |\n        // ---->\n        context.beginPath();\n        context.moveTo(startX, startY);\n        context.lineTo(startX, endY);\n        context.lineTo(endX, endY);\n        context.stroke();\n      }\n    }\n    context.restore();\n  }\n\n  private drawCircleAroundCollapseArrow(\n      entryIndex: number, context: CanvasRenderingContext2D,\n      timelineData: FlameChartTimelineData): {circleStartX?: number, circleEndX?: number} {\n    const decorationsForEvent = timelineData.entryDecorations.at(entryIndex);\n    // The circle is only drawn when the initiator arrow is going to/from some hidden entry. Make sure that the entry also has a decoration for hidden children.\n    if (!decorationsForEvent?.find(\n            decoration => decoration.type === FlameChartDecorationType.HIDDEN_DESCENDANTS_ARROW)) {\n      // This should not happen, break if it does.\n      return {};\n    }\n\n    const {entryStartTimes, entryLevels} = timelineData;\n    // The large version of 'hidden entries' is displayed\n    // only when the bar width is over double the height.\n    // We do not want to draw the circle if the arrow is not visible.\n    const barWidth = this.#eventBarWidth(timelineData, entryIndex);\n    if (barWidth < this.barHeight * 2) {\n      return {};\n    }\n\n    const entryStartTime = entryStartTimes[entryIndex];\n    const barX = this.timeToPositionClipped(entryStartTime);\n    const barLevel = entryLevels[entryIndex];\n    const barHeight = this.#eventBarHeight(timelineData, entryIndex);\n    const barY = this.levelToOffset(barLevel);\n\n    context.save();\n    context.beginPath();\n    context.rect(barX, barY, barWidth, barHeight);\n    context.clip();\n    context.lineWidth = 1;\n    context.beginPath();\n    context.fillStyle = '#474747';\n    const triangleCenterX = barX + barWidth - this.barHeight / 2;\n    const triangleCenterY = barY + this.barHeight / 2;\n    const circleRadius = 6;\n    context.beginPath();\n    context.arc(triangleCenterX, triangleCenterY, circleRadius, 0, 2 * Math.PI);\n    context.stroke();\n    context.restore();\n\n    return {circleStartX: triangleCenterX - circleRadius, circleEndX: triangleCenterX + circleRadius};\n  }\n\n  /**\n   * Draws the vertical dashed lines in the timeline marking where the \"Marker\" events\n   * happened in time.\n   */\n  private drawMarkerLines(): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const markers = timelineData.markers;\n    const left = this.markerIndexBeforeTime(this.minimumBoundary());\n    const rightBoundary = this.maximumBoundary();\n    const timeToPixel = this.chartViewport.timeToPixel();\n\n    const context = this.context;\n    context.save();\n    const ratio = window.devicePixelRatio;\n    context.scale(ratio, ratio);\n    context.translate(0, 3);\n    const height = RulerHeight - 1;\n    for (let i = left; i < markers.length; i++) {\n      const timestamp = markers[i].startTime();\n      if (timestamp > rightBoundary) {\n        break;\n      }\n      markers[i].draw(context, this.chartViewport.timeToPosition(timestamp), height, timeToPixel);\n    }\n    context.restore();\n  }\n\n  private updateMarkerHighlight(): void {\n    const element = this.markerHighlighElement;\n    if (element.parentElement) {\n      element.remove();\n    }\n    const markerIndex = this.highlightedMarkerIndex;\n    if (markerIndex === -1) {\n      return;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const marker = timelineData.markers[markerIndex];\n    const barX = this.timeToPositionClipped(marker.startTime());\n    UI.Tooltip.Tooltip.install(element, marker.title() || '');\n    const style = element.style;\n    style.left = barX + 'px';\n    style.backgroundColor = marker.color();\n    this.viewportElement.appendChild(element);\n  }\n\n  private processTimelineData(timelineData: FlameChartTimelineData|null): void {\n    if (!timelineData) {\n      this.timelineLevels = null;\n      this.visibleLevelOffsets = null;\n      this.visibleLevels = null;\n      this.groupOffsets = null;\n      this.rawTimelineData = null;\n      this.forceDecorationCache = null;\n      this.entryColorsCache = null;\n      this.dimIndices = null;\n      this.colorDimmingCache.clear();\n      this.rawTimelineDataLength = 0;\n      this.#groupTreeRoot = null;\n      this.selectedGroupIndex = -1;\n      this.keyboardFocusedGroup = -1;\n      this.flameChartDelegate.updateSelectedGroup(this, null);\n      return;\n    }\n\n    this.rawTimelineData = timelineData;\n    this.rawTimelineDataLength = timelineData.entryStartTimes.length;\n    this.forceDecorationCache = new Array(this.rawTimelineDataLength);\n    this.entryColorsCache = new Array(this.rawTimelineDataLength);\n    this.#indexToDrawOverride.clear();\n    for (let i = 0; i < this.rawTimelineDataLength; ++i) {\n      this.forceDecorationCache[i] = this.dataProvider.forceDecoration(i) ?? false;\n      this.entryColorsCache[i] = this.dataProvider.entryColor(i);\n      const drawOverride = this.dataProvider.getDrawOverride?.(i);\n      if (drawOverride) {\n        this.#indexToDrawOverride.set(i, drawOverride);\n      }\n    }\n\n    const entryCounters = new Uint32Array(this.dataProvider.maxStackDepth() + 1);\n    for (let i = 0; i < timelineData.entryLevels.length; ++i) {\n      ++entryCounters[timelineData.entryLevels[i]];\n    }\n    const levelIndexes = new Array(entryCounters.length);\n    for (let i = 0; i < levelIndexes.length; ++i) {\n      levelIndexes[i] = new Uint32Array(entryCounters[i]);\n      entryCounters[i] = 0;\n    }\n\n    for (let i = 0; i < timelineData.entryLevels.length; ++i) {\n      const level = timelineData.entryLevels[i];\n      levelIndexes[level][entryCounters[level]++] = i;\n    }\n    this.timelineLevels = levelIndexes;\n    const groups = this.rawTimelineData.groups || [];\n    for (let i = 0; i < groups.length; ++i) {\n      const expanded = groups[i].expanded ?? this.#persistedGroupConfig?.[i]?.expanded ?? false;\n      const hidden = groups[i].hidden ?? this.#persistedGroupConfig?.[i]?.hidden ?? false;\n      groups[i].expanded = expanded;\n      groups[i].hidden = hidden;\n    }\n\n    if (!this.#groupTreeRoot) {\n      this.#groupTreeRoot = this.buildGroupTree(groups);\n    } else {\n      // When the |groupTreeRoot| is already existing, and a \"new\" timeline data comes, this means the new timeline data\n      // is just a modification of original, so we should update the tree instead of rebuild it.\n      // For example,\n      // [\n      //   { name: 'Test Group 0', startLevel: 0, ...},\n      //   { name: 'Test Group 1', startLevel: 1, ...},\n      //   { name: 'Test Group 2', startLevel: 2, ...},\n      // ], and [\n      //   { name: 'Test Group 0', startLevel: 0, ...},\n      //   { name: 'Test Group 1', startLevel: 2, ...},\n      //   { name: 'Test Group 2', startLevel: 4, ...},\n      // ],\n      // are the same.\n      // But they and [\n      //   { name: 'Test Group 0', startLevel: 0, ...},\n      //   { name: 'Test Group 2', startLevel: 1, ...},\n      //   { name: 'Test Group 1', startLevel: 2, ...},\n      // ] are different.\n      // But if the |groups| is changed (this means the group order inside the |groups| is changed), it means the\n      // timeline data is a real new one, then please call |reset()| before rendering.\n      this.updateGroupTree(groups, this.#groupTreeRoot);\n    }\n\n    // If we have persisted track config, apply it. This method can get called when there is no timeline data, so we check for that.\n    // It shouldn't happen, but if the length of the persisted config does not match, we bail, rather than apply some invalid state.\n    if (this.#persistedGroupConfig && groups.length > 0 && this.#groupTreeRoot &&\n        this.#persistedGroupConfig.length === groups.length) {\n      this.#reOrderGroupsBasedOnPersistedConfig(this.#persistedGroupConfig, this.#groupTreeRoot);\n    }\n\n    this.updateLevelPositions();\n    this.updateHeight();\n\n    // If this is a new trace, we will call the reset()(See TimelineFlameChartView > setModel()), which will set the\n    // |selectedGroupIndex| to -1.\n    // So when |selectedGroupIndex| is not -1, it means it is the same trace file, but might have some modification\n    // (like reorder the track, merge an entry, etc).\n    if (this.selectedGroupIndex === -1) {\n      this.selectedGroupIndex = timelineData.selectedGroup ? groups.indexOf(timelineData.selectedGroup) : -1;\n    }\n\n    this.keyboardFocusedGroup = this.selectedGroupIndex;\n    this.flameChartDelegate.updateSelectedGroup(this, timelineData.selectedGroup);\n  }\n\n  /**\n   * If we find persisted configuration, we need to update the tree so the\n   * children in the tree are ordered in the way they were ordered the last time\n   * the user viewed this trace.\n   */\n  #reOrderGroupsBasedOnPersistedConfig(persistedConfig: PersistedGroupConfig[], root: GroupTreeNode): void {\n    function traverseAndOrderChildren(node: GroupTreeNode): void {\n      if (node.children.length) {\n        // Sort the children based on their visual index, meaning that the tree\n        // structure is updated to reflect what the stored configuration shows.\n        node.children.sort((a, b) => {\n          const aIndex = persistedConfig[a.index].visualIndex;\n          const bIndex = persistedConfig[b.index].visualIndex;\n          return aIndex - bIndex;\n        });\n      }\n      node.children.forEach(traverseAndOrderChildren);\n    }\n\n    traverseAndOrderChildren(root);\n  }\n\n  /**\n   * Builds a tree node for a group. For each group the start level is inclusive and the end level is exclusive.\n   * @param group\n   * @param index index of the group in the |FlameChartTimelineData.groups[]|\n   * @param endLevel The end level of this group, which is also the start level of the next group or the end of all\n   * groups\n   * @returns the tree node for the group\n   */\n  #buildGroupTreeNode(group: Group, index: number, endLevel: number): GroupTreeNode {\n    return {\n      index,\n      nestingLevel: group.style.nestingLevel,\n      startLevel: group.startLevel,\n      endLevel,\n      children: [],\n    };\n  }\n\n  /**\n   * Builds a tree for the given group array, the tree will be built based on the nesting level.\n   * We will add one fake root to represent the top level parent, and the for each tree node, its children means the\n   * group nested in. The order of the children matters because it represent the order of groups.\n   * So for example if there are Group 0-7, Group 0, 3, 4 have nestingLevel 0, Group 1, 2, 5, 6, 7 have nestingLevel 1.\n   * Then we will get a tree like this.\n   *              -1(fake root to represent the top level parent)\n   *             / | \\\n   *            /  |  \\\n   *           0   3   4\n   *          / \\    / | \\\n   *         1   2  5  6  7\n   * This function is public for test purpose.\n   * @param groups the array of all groups, it should be the one from FlameChartTimelineData\n   * @returns the root of the Group tree. The root is the fake one we added, which represent the parent for all groups\n   */\n  buildGroupTree(groups: Group[]): GroupTreeNode {\n    // Add an extra top level. This will be used as a parent for all groups, and\n    // will be used to contain the levels that not belong to any group.\n    const treeRoot: GroupTreeNode = {\n      index: -1,\n      nestingLevel: -1,\n      startLevel: 0,\n      // If there is no |groups| (for example the JS Profiler), it means all the\n      // levels belong to the top level, so just use the max level as the end.\n      endLevel: groups.length ? groups[0].startLevel : this.dataProvider.maxStackDepth(),\n      children: [],\n    };\n    const groupStack: GroupTreeNode[] = [treeRoot];\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      const currentGroupNestingLevel = group.style.nestingLevel;\n      let parentGroup: GroupTreeNode = groupStack[groupStack.length - 1];\n      while (parentGroup && parentGroup.nestingLevel >= currentGroupNestingLevel) {\n        groupStack.pop();\n        parentGroup = groupStack[groupStack.length - 1];\n      }\n\n      const nextGroup = groups[i + 1];\n      // If this group is the last one, it means all the remaining levels belong\n      // to this level, so just use the max level as the end.\n      const endLevel = nextGroup?.startLevel ?? this.dataProvider.maxStackDepth();\n      const currentGroupNode = this.#buildGroupTreeNode(group, i, endLevel);\n      parentGroup.children.push(currentGroupNode);\n      groupStack.push(currentGroupNode);\n    }\n    return treeRoot;\n  }\n\n  /**\n   * Updates the tree for the given group array.\n   * For a new timeline data, if the groups remains the same (the same here mean the group order inside the |groups|,\n   * the start level, style and other attribute can be changed), but other parts are different.\n   * For example the |entryLevels[]| or |maxStackDepth| is changed, then we should update the group tree instead of\n   * re-build it.\n   * So we can keep the order that user manually set.\n   * To do this, we go through the tree, and update the start and end level of each group.\n   * This function is public for test purpose.\n   * @param groups the array of all groups, it should be the one from FlameChartTimelineData\n   * @returns the root of the Group tree. The root is the fake one we added, which represent the parent for all groups\n   */\n  updateGroupTree(groups: Group[], root: GroupTreeNode): void {\n    const maxStackDepth = this.dataProvider.maxStackDepth();\n\n    function traverse(treeNode: GroupTreeNode): void {\n      const index = treeNode.index;\n      if (index < 0) {\n        // For the extra top level. This will be used as a parent for all\n        // groups, so it will start from level 0.\n        treeNode.startLevel = 0;\n        // If there is no |groups| (for example the JS Profiler), it means all the\n        // levels belong to the top level, so just use the max level as the end.\n        treeNode.endLevel = groups.length ? groups[0].startLevel : maxStackDepth;\n      } else {\n        // This shouldn't happen. If this happen, it means the |groups| from data provider is changed. Add a sanity\n        // check to avoid error.\n        if (!groups[index]) {\n          console.warn(\n              'The |groups| is changed. ' +\n              'Please make sure the flamechart is reset after data change in the data provider');\n          return;\n        }\n        treeNode.startLevel = groups[index].startLevel;\n        const nextGroup = groups[index + 1];\n        // If this group is the last one, it means all the remaining levels belong\n        // to this level, so just use the max level as the end.\n        treeNode.endLevel = nextGroup?.startLevel ?? maxStackDepth;\n      }\n      for (const child of treeNode.children) {\n        traverse(child);\n      }\n    }\n    traverse(root);\n  }\n\n  /**\n   * Given a tree, do a preorder traversal, and process the group and the levels in this group.\n   * So for a tree like this:\n   *              -1\n   *             / | \\\n   *            /  |  \\\n   *           0   3   4\n   *          / \\    / | \\\n   *         1   2  5  6  7\n   * The traverse order will be: -1, 0, 1, 2, 3, 4, 5, 6, 7.\n   * @param groupNode TreeNode for current group\n   * @param currentOffset\n   * @param parentGroupIsVisible used to determine if current group's header and its levels are visible\n   * @returns the offset (in pixels) after processing current group\n   */\n  #traverseGroupTreeAndUpdateLevelPositionsForTheGroup(\n      groupNode: GroupTreeNode, currentOffset: number, parentGroupIsVisible: boolean): number {\n    if (!this.visibleLevels || !this.visibleLevelOffsets || !this.visibleLevelHeights || !this.groupOffsets) {\n      return currentOffset;\n    }\n\n    const groups = this.rawTimelineData?.groups;\n    if (!groups) {\n      return currentOffset;\n    }\n\n    // This shouldn't happen. If this happen, it means the group tree is outdated. Add a sanity check to avoid error.\n    if (groupNode.index >= groups.length) {\n      console.warn(\n          'The data from the group tree is outdated. ' +\n          'Please make sure the flamechart is reset after data change in the data provider');\n      return currentOffset;\n    }\n\n    if (groupNode.index >= 0) {\n      this.groupOffsets[groupNode.index] = currentOffset;\n      // If |shareHeaderLine| is false, we add the height of one more level to\n      // the current offset, which will be used for the start level of current\n      // group.\n      // For edit mode, we will show all the groups whose name are not empty.\n      if ((this.#inTrackConfigEditMode && groups[groupNode.index].name) ||\n          (!groups[groupNode.index].hidden && parentGroupIsVisible && !groups[groupNode.index].style.shareHeaderLine)) {\n        currentOffset += groups[groupNode.index].style.height;\n      }\n    }\n\n    // If this is the top level, it is always shown.\n    // Otherwise, if the parent group is visible and current group is not hidden, and this group is expanded, then this\n    // group is visible.\n    let thisGroupIsVisible = false;\n    if (groupNode.index < 0) {\n      thisGroupIsVisible = true;\n    } else {\n      const thisGroupIsExpanded = !(this.isGroupCollapsible(groupNode.index) && !groups[groupNode.index].expanded);\n      thisGroupIsVisible = !groups[groupNode.index].hidden && thisGroupIsExpanded;\n    }\n    const thisGroupLevelsAreVisible = thisGroupIsVisible && parentGroupIsVisible;\n\n    for (let level = groupNode.startLevel; level < groupNode.endLevel; level++) {\n      // This shouldn't happen. If this happen, it means the group tree is outdated. Add a sanity check to avoid error.\n      if (level >= this.dataProvider.maxStackDepth()) {\n        console.warn(\n            'The data from the group tree is outdated. ' +\n            'Please make sure the flamechart is reset after data change in the data provider');\n        return currentOffset;\n      }\n\n      // Handle offset and visibility of each level inside this group.\n      const isFirstOnLevel = level === groupNode.startLevel;\n      // If this is the top level group, all the levels in this group are always shown.\n      // Otherwise it depends on the visibility of parent group and this group.\n      let thisLevelIsVisible;\n      if (groupNode.index < 0) {\n        thisLevelIsVisible = true;\n      } else {\n        const isFirstLevelAndForOverview = isFirstOnLevel && groups[groupNode.index].style.useFirstLineForOverview;\n        thisLevelIsVisible = !groups[groupNode.index].hidden &&\n            (parentGroupIsVisible && (thisGroupLevelsAreVisible || isFirstLevelAndForOverview));\n      }\n\n      let height;\n      if (groups[groupNode.index]) {\n        // |shareHeaderLine| is false means the first level of this group is on the next level of the header.\n        const isFirstLevelAndNotShareHeaderLine = isFirstOnLevel && !groups[groupNode.index].style.shareHeaderLine;\n        // A group is collapsed means only ite header is visible.\n        const thisGroupIsCollapsed = this.isGroupCollapsible(groupNode.index) && !groups[groupNode.index].expanded;\n\n        if (isFirstLevelAndNotShareHeaderLine || thisGroupIsCollapsed) {\n          // This means this level is only the header, so we use the height of the header for this level.\n          height = groups[groupNode.index].style.height;\n        } else {\n          height = groups[groupNode.index].style.itemsHeight ?? this.barHeight;\n        }\n      } else {\n        height = this.barHeight;\n      }\n\n      // If it's in edit mode, all the levels are hidden.\n      this.visibleLevels[level] = this.#inTrackConfigEditMode ? false : Boolean(thisLevelIsVisible);\n      this.visibleLevelOffsets[level] = currentOffset;\n      this.visibleLevelHeights[level] = this.#inTrackConfigEditMode ? 0 : height;\n\n      // If this level not belong to any group, it is always shown, otherwise we need to check if it is visible.\n      if (groupNode.index < 0 ||\n          (!groups[groupNode.index].hidden) &&\n              (thisLevelIsVisible ||\n               (parentGroupIsVisible && groups[groupNode.index].style.shareHeaderLine && isFirstOnLevel))) {\n        currentOffset += this.visibleLevelHeights[level];\n      }\n    }\n\n    if (groupNode.children.length === 0) {\n      return currentOffset;\n    }\n\n    for (const child of groupNode.children) {\n      // If the child is not the first child, we will add a padding top.\n      // For edit mode, we will show all the groups whose name are not empty.\n      if ((this.#inTrackConfigEditMode && groups[child.index].name) ||\n          (thisGroupLevelsAreVisible && !groups[child.index]?.hidden && child !== groupNode.children[0])) {\n        currentOffset += (groups[child.index].style.padding ?? 0);\n      }\n      currentOffset =\n          this.#traverseGroupTreeAndUpdateLevelPositionsForTheGroup(child, currentOffset, thisGroupLevelsAreVisible);\n    }\n    return currentOffset;\n  }\n\n  private updateLevelPositions(): void {\n    if (!this.#groupTreeRoot) {\n      console.warn('Please make sure the new timeline data is processed before update the level positions.');\n      return;\n    }\n    const levelCount = this.dataProvider.maxStackDepth();\n    const groups = this.rawTimelineData?.groups || [];\n    // Add an extra number in visibleLevelOffsets to store the end of last level\n    this.visibleLevelOffsets = new Uint32Array(levelCount + 1);\n    this.visibleLevelHeights = new Uint32Array(levelCount);\n    this.visibleLevels = new Array(levelCount);\n    // Add an extra number in groupOffsets to store the end of last group\n    this.groupOffsets = new Uint32Array(groups.length + 1);\n    let currentOffset = this.rulerEnabled ? RulerHeight + 2 : 2;\n    // The root is always visible, so just simply set the |parentGroupIsVisible| to visible.\n    currentOffset = this.#traverseGroupTreeAndUpdateLevelPositionsForTheGroup(\n        this.#groupTreeRoot, currentOffset, /* parentGroupIsVisible= */ true);\n\n    // Set the final offset to the last element of |groupOffsets| and\n    // |visibleLevelOffsets|. This number represent the end of last group and\n    // level.\n    this.groupOffsets[groups.length] = currentOffset;\n    this.visibleLevelOffsets[levelCount] = currentOffset;\n  }\n\n  private isGroupCollapsible(index: number): boolean|undefined {\n    if (!this.rawTimelineData || index < 0) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups || [];\n    const style = groups[index].style;\n    if (!style.shareHeaderLine || !style.collapsible) {\n      return Boolean(style.collapsible);\n    }\n    const isLastGroup = index + 1 >= groups.length;\n    if (!isLastGroup && groups[index + 1].style.nestingLevel > style.nestingLevel) {\n      return true;\n    }\n    const nextGroupLevel = isLastGroup ? this.dataProvider.maxStackDepth() : groups[index + 1].startLevel;\n    if (nextGroupLevel !== groups[index].startLevel + 1) {\n      return true;\n    }\n    // For groups that only have one line and share header line, pretend these are not collapsible\n    // unless the itemsHeight does not match the headerHeight\n    return style.height !== style.itemsHeight;\n  }\n\n  groupIsLastVisibleTopLevel(groupIndex: number): boolean {\n    if (groupIndex < 0 || !this.rawTimelineData) {\n      return true;\n    }\n    const group = this.rawTimelineData.groups[groupIndex];\n    const visibleTopLevelGroupNumber =\n        this.#groupTreeRoot?.children.filter(track => !this.rawTimelineData?.groups[track.index].hidden).length;\n    return visibleTopLevelGroupNumber === 1 && group.style.nestingLevel === 0 && !group.hidden;\n  }\n\n  setSelectedEntry(entryIndex: number): void {\n    // Check if the button that resets children of the entry is clicked. We need to check it even if the entry\n    // clicked is not selected to avoid needing to double click\n    if (this.isMouseOverRevealChildrenArrow(this.lastMouseOffsetX, entryIndex)) {\n      this.modifyTree(FilterAction.RESET_CHILDREN, entryIndex);\n    }\n    if (this.selectedEntryIndex === entryIndex) {\n      return;\n    }\n    if (entryIndex !== -1) {\n      this.chartViewport.hideRangeSelection();\n    }\n    this.selectedEntryIndex = entryIndex;\n    this.revealEntry(entryIndex);\n    this.updateElementPosition(this.selectedElement, this.selectedEntryIndex);\n    this.update();\n  }\n\n  private entryHasDecoration(entryIndex: number, decorationType: FlameChartDecorationType): boolean {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return false;\n    }\n\n    const decorationsForEvent = timelineData.entryDecorations.at(entryIndex);\n    if (decorationsForEvent && decorationsForEvent.length >= 1) {\n      return decorationsForEvent.some(decoration => decoration.type === decorationType);\n    }\n\n    return false;\n  }\n\n  getCustomDrawnPositionForEntryIndex(entryIndex: number): PositionOverride|null {\n    const customPos = this.customDrawnPositions.get(entryIndex);\n    if (customPos) {\n      return customPos;\n    }\n\n    return this.markerPositions.get(entryIndex) ?? null;\n  }\n\n  /**\n   * Update position of an Element. By default, the element is treated as a full entry and it's dimensions are set to the full entry width/length/height.\n   * If isDecoration parameter is set to true, the element will be positioned on the right side of the entry and have a square shape where width == height of the entry.\n   */\n  private updateElementPosition(element: Element|null, entryIndex: number, isDecoration?: boolean): void {\n    if (!element) {\n      return;\n    }\n    const elementMinWidthPx = 2;\n    element.classList.add('hidden');\n    if (entryIndex === -1) {\n      return;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n\n    const startTime = timelineData.entryStartTimes[entryIndex];\n    const duration = timelineData.entryTotalTimes[entryIndex];\n    let barX = 0;\n    let barWidth = 0;\n    let visible = true;\n\n    const customPos = this.customDrawnPositions.get(entryIndex);\n\n    if (customPos) {\n      barX = customPos.x;\n      barWidth = customPos.width;\n    } else if (Number.isNaN(duration)) {\n      const position = this.markerPositions.get(entryIndex);\n      if (position) {\n        barX = position.x;\n        barWidth = position.width;\n      } else {\n        visible = false;\n      }\n    } else {\n      barX = this.chartViewport.timeToPosition(startTime);\n      barWidth = duration * this.chartViewport.timeToPixel();\n    }\n    if (barX + barWidth <= 0 || barX >= this.offsetWidth) {\n      return;\n    }\n    const barCenter = barX + barWidth / 2;\n    barWidth = Math.max(barWidth, elementMinWidthPx);\n    barX = barCenter - barWidth / 2;\n    const entryLevel = timelineData.entryLevels[entryIndex];\n    const barY = this.levelToOffset(entryLevel) - this.chartViewport.scrollOffset();\n    const barHeight = this.levelHeight(entryLevel);\n    const style = (element as HTMLElement).style;\n\n    // TODO(paulirish): make these changes within a RenderCoordinator.write callback.\n    // Currently these (plus the scrollOffset() right above) trigger layout thrashing.\n    if (isDecoration) {\n      style.top = barY + 'px';\n      style.width = barHeight + 'px';\n      style.height = barHeight + 'px';\n      style.left = barX + barWidth - barHeight + 'px';\n    } else {\n      style.top = barY + 'px';\n      style.width = barWidth + 'px';\n      style.height = barHeight - 1 + 'px';\n      style.left = barX + 'px';\n    }\n    element.classList.toggle('hidden', !visible);\n    this.viewportElement.appendChild(element);\n  }\n\n  // Updates the highlight of an Arrow button that is shown on an entry if it has hidden child entries\n  private updateHiddenChildrenArrowHighlighPosition(entryIndex: number): void {\n    this.revealDescendantsArrowHighlightElement.classList.add('hidden');\n    /**\n     * No need to update the hidden descendants arrow highlight if\n     * 1. No entry is highlighted\n     * 2. Mouse is not hovering over the arrow button\n     */\n    if (entryIndex === -1 || !this.isMouseOverRevealChildrenArrow(this.lastMouseOffsetX, entryIndex)) {\n      return;\n    }\n    this.updateElementPosition(this.revealDescendantsArrowHighlightElement, entryIndex, true);\n  }\n\n  private timeToPositionClipped(time: number): number {\n    return Platform.NumberUtilities.clamp(this.chartViewport.timeToPosition(time), 0, this.offsetWidth);\n  }\n\n  /**\n   * Returns the amount of pixels a group is vertically offset in the flame chart.\n   * Now this function is only used for tests.\n   */\n  groupIndexToOffsetForTest(groupIndex: number): number {\n    if (!this.groupOffsets) {\n      throw new Error('No visible group offsets');\n    }\n    return this.groupOffsets[groupIndex];\n  }\n\n  /**\n   * Set the edit mode.\n   * Now this function is only used for tests.\n   */\n  setEditModeForTest(editMode: boolean): void {\n    this.#inTrackConfigEditMode = editMode;\n  }\n\n  /**\n   * Returns the visibility of a level in the.\n   * flame chart.\n   */\n  levelIsVisible(level: number): boolean {\n    if (!this.visibleLevels) {\n      throw new Error('No level visiblibities');\n    }\n    return this.visibleLevels[level];\n  }\n\n  /**\n   * Returns the amount of pixels a level is vertically offset in the.\n   * flame chart.\n   */\n  levelToOffset(level: number): number {\n    if (!this.visibleLevelOffsets) {\n      throw new Error('No visible level offsets');\n    }\n    return this.visibleLevelOffsets[level];\n  }\n\n  levelHeight(level: number): number {\n    if (!this.visibleLevelHeights) {\n      throw new Error('No visible level heights');\n    }\n    return this.visibleLevelHeights[level];\n  }\n\n  private updateBoundaries(): void {\n    this.totalTime = this.dataProvider.totalTime();\n    this.minimumBoundaryInternal = this.dataProvider.minimumBoundary();\n    this.chartViewport.setBoundaries(this.minimumBoundaryInternal, this.totalTime);\n  }\n\n  private updateHeight(): void {\n    const height = this.levelToOffset(this.dataProvider.maxStackDepth()) + 2;\n    this.chartViewport.setContentHeight(height);\n  }\n\n  override onResize(): void {\n    // Clear the rect cache because we have been resized.\n    this.#canvasBoundingClientRect = null;\n    this.scheduleUpdate();\n  }\n\n  setPersistedConfig(config: PersistedGroupConfig[]): void {\n    this.#persistedGroupConfig = config;\n  }\n\n  update(): void {\n    if (!this.timelineData()) {\n      return;\n    }\n    this.updateHeight();\n    this.updateBoundaries();\n    this.draw();\n    if (!this.chartViewport.isDragging()) {\n      this.updateHighlight();\n    }\n  }\n\n  // Reset the whole flame chart.\n  // It will reset the viewport, which will reset the scrollTop and scrollLeft. So should be careful when call this\n  // function. But when the data is \"real\" changed, especially when groups[] is changed, make sure call this before\n  // re-rendering.\n  // This will also clear all the selected entry, group, etc.\n  // Remember to call |setWindowTimes| before draw the flame chart again.\n  reset(): void {\n    if (this.#inTrackConfigEditMode) {\n      this.#removeEditModeButton();\n      this.#inTrackConfigEditMode = false;\n    }\n\n    this.chartViewport.reset();\n    this.rawTimelineData = null;\n    this.rawTimelineDataLength = 0;\n    this.#groupTreeRoot = null;\n    this.dimIndices = null;\n    this.colorDimmingCache.clear();\n    this.highlightedMarkerIndex = -1;\n    this.highlightedEntryIndex = -1;\n    this.selectedEntryIndex = -1;\n    this.selectedGroupIndex = -1;\n    this.#persistedGroupConfig = null;\n  }\n\n  scheduleUpdate(): void {\n    this.chartViewport.scheduleUpdate();\n  }\n\n  private enabled(): boolean {\n    return this.rawTimelineDataLength !== 0;\n  }\n\n  computePosition(time: number): number {\n    return this.chartViewport.timeToPosition(time);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return this.dataProvider.formatValue(value - this.zeroTime(), precision);\n  }\n\n  maximumBoundary(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.chartViewport.windowRightTime());\n  }\n\n  minimumBoundary(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.chartViewport.windowLeftTime());\n  }\n\n  zeroTime(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.dataProvider.minimumBoundary());\n  }\n\n  boundarySpan(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.maximumBoundary() - this.minimumBoundary());\n  }\n  getDimIndices(): Uint8Array<ArrayBufferLike>|null {\n    return this.dimIndices || null;\n  }\n}\n\nexport const RulerHeight = 15;\nexport const MinimalTimeWindowMs = 0.5;\n\n/**\n * initiatorIndex is the index of the initiator entry and\n * eventIndex is the entry initiated by it.\n * However, if isEntryHidden or isInitiatorHidden are set to true,\n * it means that the actual initiator or initiated entry is hidden\n * by some context menu action and the indexes in initiatorIndex\n * or/and eventIndex are for the entries that are the closest\n * modified by an actions ancestors to them.\n */\nexport interface FlameChartInitiatorData {\n  initiatorIndex: number;\n  eventIndex: number;\n  isEntryHidden?: boolean;\n  isInitiatorHidden?: boolean;\n}\n\nexport const enum FlameChartDecorationType {\n  CANDY = 'CANDY',\n  WARNING_TRIANGLE = 'WARNING_TRIANGLE',\n  HIDDEN_DESCENDANTS_ARROW = 'HIDDEN_DESCENDANTS_ARROW',\n}\n\n/**\n * Represents a decoration that can be added to event. Each event can have as\n * many decorations as required.\n *\n * It is anticipated in the future that we will add to this as we want to\n * annotate events in more ways.\n *\n * This work is being tracked in crbug.com/1434297.\n **/\nexport type FlameChartDecoration = {\n  type: FlameChartDecorationType.CANDY,\n  /** Relative to entry's ts. We often only want to highlight problem parts of events, so this time sets the minimum\n   * time at which the candystriping will start. If you want to candystripe the entire event, set this to 0. */\n  startAtTime: Trace.Types.Timing.Micro,\n}|{\n  type: FlameChartDecorationType.WARNING_TRIANGLE,\n  customStartTime?: Trace.Types.Timing.Micro,\n  customEndTime?: Trace.Types.Timing.Micro,\n}|{\n  type: FlameChartDecorationType.HIDDEN_DESCENDANTS_ARROW,\n};\n\n// We have to ensure we draw the decorations in a particular order; warning\n// triangles always go on top of any candy stripes.\nconst decorationDrawOrder: Record<FlameChartDecorationType, number> = {\n  CANDY: 1,\n  WARNING_TRIANGLE: 2,\n  HIDDEN_DESCENDANTS_ARROW: 3,\n};\n\nexport function sortDecorationsForRenderingOrder(decorations: FlameChartDecoration[]): void {\n  decorations.sort((decoration1, decoration2) => {\n    return decorationDrawOrder[decoration1.type] - decorationDrawOrder[decoration2.type];\n  });\n}\n\nexport class FlameChartTimelineData {\n  entryLevels: number[]|Uint16Array;\n  entryTotalTimes: number[]|Float32Array;\n  entryStartTimes: number[]|Float64Array;\n  /**\n   * An array of entry decorations, where each item in the array is an array of\n   * decorations for the event at that index.\n   **/\n  entryDecorations: FlameChartDecoration[][];\n  groups: Group[];\n  markers: FlameChartMarker[];\n\n  // These four arrays are used to draw the initiator arrows, and if there are\n  // multiple arrows, they should be a chain.\n  initiatorsData: FlameChartInitiatorData[];\n\n  selectedGroup: Group|null;\n  private constructor(\n      entryLevels: number[]|Uint16Array, entryTotalTimes: number[]|Float32Array, entryStartTimes: number[]|Float64Array,\n      groups: Group[]|null, entryDecorations: FlameChartDecoration[][] = [],\n      initiatorsData: FlameChartInitiatorData[] = []) {\n    this.entryLevels = entryLevels;\n    this.entryTotalTimes = entryTotalTimes;\n    this.entryStartTimes = entryStartTimes;\n    this.entryDecorations = entryDecorations;\n    this.groups = groups || [];\n    this.markers = [];\n    this.initiatorsData = initiatorsData || [];\n    this.selectedGroup = null;\n  }\n\n  // TODO(crbug.com/1501055) Thinking about refactor this class, so we can avoid create a new object when modifying the\n  // flame chart.\n  static create(data: {\n    entryLevels: FlameChartTimelineData['entryLevels'],\n    entryTotalTimes: FlameChartTimelineData['entryTotalTimes'],\n    entryStartTimes: FlameChartTimelineData['entryStartTimes'],\n    groups: FlameChartTimelineData['groups']|null,\n    entryDecorations?: FlameChartDecoration[][],\n    initiatorsData?: FlameChartTimelineData['initiatorsData'],\n  }): FlameChartTimelineData {\n    return new FlameChartTimelineData(\n        data.entryLevels, data.entryTotalTimes, data.entryStartTimes, data.groups, data.entryDecorations || [],\n        data.initiatorsData || []);\n  }\n\n  // TODO(crbug.com/1501055) Thinking about refactor this class, so we can avoid create a new object when modifying the\n  // flame chart.\n  static createEmpty(): FlameChartTimelineData {\n    return new FlameChartTimelineData(\n        [],  // entry levels: what level on the timeline is an event on,\n        [],  // entry total times: the total duration of an event,\n        [],  // entry start times: the start time of a given event,\n        [],  // groups: a list of flame chart groups, which roughly correlate to each individual track\n    );\n  }\n\n  emptyInitiators(): void {\n    this.initiatorsData = [];\n  }\n}\n\nexport interface DataProviderSearchResult {\n  index: number;\n  startTimeMilli: Trace.Types.Timing.Milli;\n  provider: 'main'|'network'|'other';\n}\n\nexport interface DataProviderSearchResult {\n  index: number;\n  startTimeMilli: Trace.Types.Timing.Milli;\n  provider: 'main'|'network'|'other';\n}\n\nexport interface FlameChartDataProvider {\n  setPersistedGroupConfigSetting?(setting: Common.Settings.Setting<PersistedConfigPerTrace>): void;\n\n  minimumBoundary(): number;\n\n  totalTime(): number;\n\n  formatValue(value: number, precision?: number): string;\n\n  maxStackDepth(): number;\n\n  /**\n   * Construct the data for the FlameChart. Note that this method is called\n   * multiple times. It is expected that the implementor cache the data\n   * aggressively and only rebuild if the flag is passed.\n   */\n  timelineData(rebuild?: boolean): FlameChartTimelineData|null;\n\n  preparePopoverElement(entryIndex: number): Element|null;\n\n  preparePopoverForCollapsedArrow?(entryIndex: number): Element|null;\n\n  canJumpToEntry(entryIndex: number): boolean;\n\n  entryTitle(entryIndex: number): string|null;\n\n  entryFont(entryIndex: number): string|null;\n\n  entryColor(entryIndex: number): string;\n\n  decorateEntry(\n      entryIndex: number, context: CanvasRenderingContext2D, text: string|null, barX: number, barY: number,\n      barWidth: number, barHeight: number, unclippedBarX: number, timeToPixelRatio: number,\n      transformColor?: (color: string) => string): boolean;\n\n  forceDecoration(entryIndex: number): boolean;\n\n  forceDrawableLevel?(level: number): boolean;\n\n  textColor(entryIndex: number): string;\n\n  mainFrameNavigationStartEvents?(): readonly Trace.Types.Events.NavigationStart[];\n\n  hasTrackConfigurationMode(): boolean;\n\n  // The following functions are optional and are used in Performance panel.\n  eventByIndex?(entryIndex: number): Trace.Types.Events.Event|null;\n\n  indexForEvent?(event: Trace.Types.Events.Event|Trace.Types.Events.LegacyTimelineFrame): number|null;\n\n  buildFlowForInitiator?(index: number): unknown;\n\n  customizedContextMenu?\n      (event: MouseEvent, eventIndex: number, groupIndex: number): UI.ContextMenu.ContextMenu|undefined;\n\n  search?(visibleWindow: Trace.Types.Timing.TraceWindowMicro, filter?: Trace.Extras.TraceFilter.TraceFilter):\n      DataProviderSearchResult[];\n\n  // The following three functions are used for the flame chart entry customization.\n  modifyTree?(action: FilterAction, entryIndex: number): void;\n\n  findPossibleContextMenuActions?(node: number): PossibleFilterActions|void;\n\n  handleFlameChartTransformKeyboardEvent?(event: KeyboardEvent, entryIndex: number, groupIndex: number): void;\n\n  groupForEvent?(entryIndex: number): Group|null;\n\n  getDrawOverride?(entryIndex: number): DrawOverride|undefined;\n\n  /**\n   * Used when the user re-orders / hides / shows tracks to notify the data\n   * provider. The data provider can choose to store this data in order to have\n   * the user's view persisted in memory and/or to disk when the trace is saved.\n   */\n  handleTrackConfigurationChange?(groups: readonly Group[], indexesInVisualOrder: number[]): void;\n}\n\nexport interface FlameChartMarker {\n  startTime(): number;\n  color(): string;\n  title(): string|null;\n  draw(context: CanvasRenderingContext2D, x: number, height: number, pixelsPerMillisecond: number): void;\n}\n\nexport const enum Events {\n  /**\n   * Emitted when the <canvas> element of the FlameChart is focused by the user.\n   **/\n  CANVAS_FOCUSED = 'CanvasFocused',\n  /**\n   * Emitted when an event is selected by either mouse click, or hitting\n   * <enter> on the keyboard - e.g. the same actions that would invoke a\n   * <button> element.\n   *\n   * Will be emitted with a number which is the index of the entry that has\n   * been selected, or -1 if no entry is selected (e.g the user has clicked\n   * away from any events)\n   */\n  ENTRY_INVOKED = 'EntryInvoked',\n  // Emitted when entry label annotation is added through a shortcut or a context menu.\n  ENTRY_LABEL_ANNOTATION_ADDED = 'EntryLabelAnnotationAdded',\n  // Emitted when entries link annotation is added through a shortcut or a context menu.\n  ENTRIES_LINK_ANNOTATION_CREATED = 'EntriesLinkAnnotationCreated',\n  /**\n   * Emitted when the user enters or exits 'reorder tracks' view.\n   * If the event value is 'true', the 'reorder tracks' state was entered,\n   * if it's false, the reorder state was exited.\n   */\n  TRACKS_REORDER_STATE_CHANGED = 'TracksReorderStateChange',\n  /**\n   * Emitted when an event is selected via keyboard navigation using the arrow\n   * keys.\n   *\n   * Will be emitted with a number which is the index of the entry that has\n   * been selected, or -1 if no entry is selected.\n   */\n  ENTRY_SELECTED = 'EntrySelected',\n  /**\n   * Emitted when an event is hovered over with the mouse.\n   *\n   * Will be emitted with a number which is the index of the entry that has\n   * been hovered on, or -1 if no entry is selected (the user has moved their\n   * mouse off the event)\n   */\n  ENTRY_HOVERED = 'EntryHovered',\n  CHART_PLAYABLE_STATE_CHANGED = 'ChartPlayableStateChange',\n\n  LATEST_DRAW_DIMENSIONS = 'LatestDrawDimensions',\n\n  MOUSE_MOVE = 'MouseMove',\n}\n\nexport interface EventTypes {\n  [Events.ENTRY_LABEL_ANNOTATION_ADDED]: {\n    entryIndex: number,\n    withLinkCreationButton: boolean,\n  };\n  [Events.ENTRIES_LINK_ANNOTATION_CREATED]: {\n    entryFromIndex: number,\n  };\n  [Events.TRACKS_REORDER_STATE_CHANGED]: boolean;\n  [Events.CANVAS_FOCUSED]: number|void;\n  [Events.ENTRY_INVOKED]: number;\n  [Events.ENTRY_SELECTED]: number;\n  [Events.ENTRY_HOVERED]: number;\n  [Events.CHART_PLAYABLE_STATE_CHANGED]: boolean;\n  [Events.LATEST_DRAW_DIMENSIONS]: {\n    chart: {\n      widthPixels: number,\n      heightPixels: number,\n      scrollOffsetPixels: number,\n      allGroupsCollapsed: boolean,\n    },\n    traceWindow: Trace.Types.Timing.TraceWindowMicro,\n  };\n  [Events.MOUSE_MOVE]: {\n    mouseEvent: MouseEvent,\n    timeInMicroSeconds: Trace.Types.Timing.Micro,\n  };\n}\n\nexport interface Group {\n  name: Common.UIString.LocalizedString;\n  subtitle?: Common.UIString.LocalizedString;\n  startLevel: number;\n  expanded?: boolean;\n  hidden?: boolean;\n  selectable?: boolean;\n  style: GroupStyle;\n  /** Should be turned on if the track supports user editable stacks. */\n  showStackContextMenu?: boolean;\n  jslogContext?: string;\n  description?: string;\n}\n\nexport interface GroupStyle {\n  height: number;\n  padding: number;\n  /* Can it be collapsed? True by default! */\n  collapsible: boolean;\n  /** The color of the group title text. */\n  color: string;\n  /** The background color of the group title when the track is collapsed,\n   * and this is usually around same length as the title text. */\n  backgroundColor: string;\n  nestingLevel: number;\n  itemsHeight?: number;\n  /** Allow entries to be placed on the same horizontal level as the text heading. True by default for Timeline */\n  // TODO(paulirish): Attempt to remove with this behavior always true\n  shareHeaderLine?: boolean;\n  useFirstLineForOverview?: boolean;\n  useDecoratorsForOverview?: boolean;\n}\n\nexport interface PersistedGroupConfig {\n  hidden: boolean;\n  expanded: boolean;\n  originalIndex: number;\n  visualIndex: number;\n}\n\n/**\n * Used to persist into memory the configuration, so that if the user imports a\n * new trace and then navigates back to the old one, the configuration is\n * restored.\n * The key here is the `traceBounds.min` time from the trace. Given this is\n * monotonic, the chances of it clashing within traces the user records are very\n * low. It could happen, but we accept that this is best effort.\n * Note: the value type includes `undefined` to make sure that anyone can't do\n * value[traceMin] and not check that it exists. If the user has not manually\n * edited the track config, it will not be stored.\n */\nexport type PersistedConfigPerTrace = Record<Trace.Types.Timing.Micro, PersistedGroupConfig[]|undefined>;\n", "// Copyright (c) 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport {ARROW_SIDE} from './FlameChart.js';\n\nexport function horizontalLine(context: CanvasRenderingContext2D, width: number, y: number): void {\n  context.moveTo(0, y);\n  context.lineTo(width, y);\n}\n\nexport function drawExpansionArrow(context: CanvasRenderingContext2D, x: number, y: number, expanded: boolean): void {\n  // We will draw a equilateral triangle, so first calculate the height of the triangle.\n  const arrowHeight = ARROW_SIDE * Math.sqrt(3) / 2;\n  const arrowCenterOffset = Math.round(arrowHeight / 2);\n  context.save();\n  context.beginPath();\n  context.translate(x, y);\n  context.rotate(expanded ? Math.PI / 2 : 0);\n  // The final triangle will be this shape: (the rotation will be handled by `context.rotate`)\n  // |\\\n  // | \\\n  // | /\n  // |/\n\n  // Move to the top vertex\n  context.moveTo(-arrowCenterOffset, -ARROW_SIDE / 2);\n  // Line to the bottom vertex\n  context.lineTo(-arrowCenterOffset, ARROW_SIDE / 2);\n  // Line to the right vertex\n  context.lineTo(arrowHeight - arrowCenterOffset, 0);\n  context.fill();\n  context.restore();\n}\n\nexport function drawIcon(\n    context: CanvasRenderingContext2D, x: number, y: number, width: number, pathData: string,\n    iconColor = '--sys-color-on-surface'): void {\n  const p = new Path2D(pathData);\n\n  context.save();\n  context.translate(x, y);\n  // This color is same as the background of the whole flame chart.\n  context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-cdt-base-container');\n  context.fillRect(0, 0, width, width);\n\n  context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue(iconColor);\n  // The pathData from front_end/images folder is for a 20 pixel icon.\n  // So we add a scale to draw the icon in a correct size.\n  const scale = width / 20;\n  context.scale(scale, scale);\n  context.fill(p);\n  context.restore();\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.flame-chart-main-pane {\n  overflow: hidden;\n\n  --selected-group-border: hsl(216deg 68% 54%);\n}\n\n:host-context(.theme-with-dark-background) .flame-chart-main-pane {\n  --selected-group-border: hsl(216deg 68% 46%);\n}\n\n.flame-chart-marker-highlight-element {\n  position: absolute;\n  top: 1px;\n  height: 18px;\n  width: 6px;\n  margin: 0 -3px;\n  content: \"\";\n  display: block;\n}\n\n.flame-chart-canvas:focus-visible {\n  border-top: 1px solid var(--sys-color-state-focus-ring);\n  border-bottom: 1px solid var(--sys-color-state-focus-ring);\n}\n\n.flame-chart-highlight-element {\n  position: absolute;\n  pointer-events: none;\n  background-color: var(--sys-color-state-hover-on-subtle);\n}\n\n.reveal-descendants-arrow-highlight-element {\n  position: absolute;\n  pointer-events: none;\n  background-color: var(--sys-color-state-hover-on-subtle);\n}\n\n.flame-chart-selected-element {\n  position: absolute;\n  pointer-events: none;\n  outline: 2px solid var(--sys-color-primary);\n  background-color: var(--sys-color-state-ripple-primary);\n}\n\n.chart-cursor-element {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  z-index: 100;\n  width: 2px;\n  background-color: var(--ref-palette-pink50);\n  pointer-events: none;\n}\n\n.flame-chart-entry-info:not(:empty) {\n  z-index: 2000;\n  position: absolute;\n  contain: content;\n  background-color: var(--sys-color-cdt-base-container);\n  pointer-events: none;\n  padding: 4px 8px;\n  white-space: nowrap;\n  max-width: 80%;\n  box-shadow: var(--drop-shadow);\n}\n\n.flame-chart-entry-info table tr td:empty {\n  padding: 0;\n}\n\n.flame-chart-entry-info table tr td:not(:empty) {\n  padding: 0 5px;\n  white-space: nowrap;\n}\n\n.flame-chart-entry-info table tr td:first-child {\n  font-weight: bold;\n}\n\n.flame-chart-entry-info table tr td span {\n  margin-right: 5px;\n}\n\n.flame-chart-edit-confirm {\n  position: fixed;\n  bottom: 10px;\n  right: 10px;\n}\n\n/*# sourceURL=${import.meta.resolve('./flameChart.css')} */`;", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Host from '../../../../core/host/host.js';\n\nlet fontFamily: string|null = null;\n\n/**\n * Because we run our UI in a couple of contexts (actual app & test\n * environments) and on multiple platforms, the font is not consistent, so this\n * function is used to determine which font to use when rendering the canvas.\n * The most reliable way to do this is to see what font is on the body element,\n * but because this triggers layout we ensure we only do it once before caching\n * the result. If nothing is set on the body for whatever reason, we fall back\n * to what we usually use on the platform.\n *\n * We need this behaviour because in interaction tests we force the font to be a\n * specific font that we know is available on local dev machines and on the bots\n * to ensure that the screenshot tests are consistent.\n **/\nexport function getFontFamilyForCanvas(): string {\n  if (fontFamily) {\n    return fontFamily;\n  }\n\n  const bodyStyles = getComputedStyle(document.body);\n  if (bodyStyles.fontFamily) {\n    fontFamily = bodyStyles.fontFamily;\n  } else {\n    fontFamily = Host.Platform.fontFamily();\n  }\n\n  return fontFamily;\n}\n\nexport const DEFAULT_FONT_SIZE = '11px';\n", "// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\n/*\n * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2008, 2009 Anthony Ricaud <rik@webkit.org>\n * Copyright (C) 2009 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport {DEFAULT_FONT_SIZE, getFontFamilyForCanvas} from './Font.js';\nimport timelineGridStyles from './timelineGrid.css.js';\n\nconst labelMap = new Map<HTMLDivElement|HTMLElement, HTMLDivElement>();\n\nexport class TimelineGrid {\n  element: HTMLDivElement;\n  private readonly dividersElementInternal: HTMLElement;\n  private readonly gridHeaderElement: HTMLDivElement;\n  private eventDividersElement: HTMLElement;\n  private dividersLabelBarElementInternal: HTMLElement;\n\n  constructor() {\n    this.element = document.createElement('div');\n    Platform.DOMUtilities.appendStyle(this.element, timelineGridStyles);\n\n    this.dividersElementInternal = this.element.createChild('div', 'resources-dividers');\n\n    this.gridHeaderElement = document.createElement('div');\n    this.gridHeaderElement.classList.add('timeline-grid-header');\n    this.eventDividersElement = this.gridHeaderElement.createChild('div', 'resources-event-dividers');\n    this.dividersLabelBarElementInternal = this.gridHeaderElement.createChild('div', 'resources-dividers-label-bar');\n    this.element.appendChild(this.gridHeaderElement);\n  }\n\n  static calculateGridOffsets(calculator: Calculator, freeZoneAtLeft?: number): DividersData {\n    const minGridSlicePx = 64;  // minimal distance between grid lines.\n\n    const clientWidth = calculator.computePosition(calculator.maximumBoundary());\n    let dividersCount: number|0 = clientWidth / minGridSlicePx;\n    let gridSliceTime: number = calculator.boundarySpan() / dividersCount;\n    const pixelsPerTime = clientWidth / calculator.boundarySpan();\n\n    // Align gridSliceTime to a nearest round value.\n    // We allow spans that fit into the formula: span = (1|2|5)x10^n,\n    // e.g.: ...  .1  .2  .5  1  2  5  10  20  50  ...\n    // After a span has been chosen make grid lines at multiples of the span.\n\n    const logGridSliceTime = Math.ceil(Math.log(gridSliceTime) / Math.LN10);\n    gridSliceTime = Math.pow(10, logGridSliceTime);\n    if (gridSliceTime * pixelsPerTime >= 5 * minGridSlicePx) {\n      gridSliceTime = gridSliceTime / 5;\n    }\n    if (gridSliceTime * pixelsPerTime >= 2 * minGridSlicePx) {\n      gridSliceTime = gridSliceTime / 2;\n    }\n\n    const firstDividerTime =\n        Math.ceil((calculator.minimumBoundary() - calculator.zeroTime()) / gridSliceTime) * gridSliceTime +\n        calculator.zeroTime();\n    let lastDividerTime = calculator.maximumBoundary();\n    // Add some extra space past the right boundary as the rightmost divider label text\n    // may be partially shown rather than just pop up when a new rightmost divider gets into the view.\n    lastDividerTime += minGridSlicePx / pixelsPerTime;\n    dividersCount = Math.ceil((lastDividerTime - firstDividerTime) / gridSliceTime);\n\n    if (!gridSliceTime) {\n      dividersCount = 0;\n    }\n\n    const offsets = [];\n    for (let i = 0; i < dividersCount; ++i) {\n      // The grid slice time could be small like 0.2. If we multiply this we\n      // open ourselves to floating point rounding errors. To avoid these, we\n      // multiply the number by 100, and i, and then divide it by 100 again.\n      const time = firstDividerTime + (gridSliceTime * 100 * i) / 100;\n\n      const positionFromTime = calculator.computePosition(time);\n\n      if (positionFromTime < (freeZoneAtLeft || 0)) {\n        continue;\n      }\n      offsets.push({position: Math.floor(positionFromTime), time});\n    }\n\n    return {offsets, precision: Math.max(0, -Math.floor(Math.log(gridSliceTime * 1.01) / Math.LN10))};\n  }\n\n  static drawCanvasGrid(context: CanvasRenderingContext2D, dividersData: DividersData): void {\n    context.save();\n    context.scale(window.devicePixelRatio, window.devicePixelRatio);\n    const height = Math.floor(context.canvas.height / window.devicePixelRatio);\n    context.strokeStyle = getComputedStyle(document.body).getPropertyValue('--app-color-strokestyle');\n    context.lineWidth = 1;\n\n    context.translate(0.5, 0.5);\n    context.beginPath();\n    for (const offsetInfo of dividersData.offsets) {\n      context.moveTo(offsetInfo.position, 0);\n      context.lineTo(offsetInfo.position, height);\n    }\n    context.stroke();\n    context.restore();\n  }\n\n  static drawCanvasHeaders(\n      context: CanvasRenderingContext2D, dividersData: DividersData, formatTimeFunction: (arg0: number) => string,\n      paddingTop: number, headerHeight: number, freeZoneAtLeft?: number): void {\n    context.save();\n    context.scale(window.devicePixelRatio, window.devicePixelRatio);\n    const width = Math.ceil(context.canvas.width / window.devicePixelRatio);\n\n    context.beginPath();\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background-opacity-80');\n    context.fillRect(0, 0, width, headerHeight);\n\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-on-surface');\n    context.textBaseline = 'hanging';\n    context.font = `${DEFAULT_FONT_SIZE} ${getFontFamilyForCanvas()}`;\n\n    const paddingRight = 4;\n    for (const offsetInfo of dividersData.offsets) {\n      const text = formatTimeFunction(offsetInfo.time);\n      const textWidth = context.measureText(text).width;\n      const textPosition = offsetInfo.position - textWidth - paddingRight;\n      if (!freeZoneAtLeft || freeZoneAtLeft < textPosition) {\n        context.fillText(text, textPosition, paddingTop);\n      }\n    }\n    context.restore();\n  }\n\n  get dividersElement(): HTMLElement {\n    return this.dividersElementInternal;\n  }\n\n  get dividersLabelBarElement(): HTMLElement {\n    return this.dividersLabelBarElementInternal;\n  }\n\n  updateDividers(calculator: Calculator, freeZoneAtLeft?: number): boolean {\n    const dividersData = TimelineGrid.calculateGridOffsets(calculator, freeZoneAtLeft);\n    const dividerOffsets = dividersData.offsets;\n    const precision = dividersData.precision;\n\n    const dividersElementClientWidth = this.dividersElementInternal.clientWidth;\n\n    // Reuse divider elements and labels.\n    let divider = (this.dividersElementInternal.firstChild as HTMLElement | null);\n    let dividerLabelBar = (this.dividersLabelBarElementInternal.firstChild as HTMLElement | null);\n\n    for (let i = 0; i < dividerOffsets.length; ++i) {\n      if (!divider) {\n        divider = document.createElement('div');\n        divider.className = 'resources-divider';\n        this.dividersElementInternal.appendChild(divider);\n\n        dividerLabelBar = document.createElement('div');\n        dividerLabelBar.className = 'resources-divider';\n        const label = document.createElement('div');\n        label.className = 'resources-divider-label';\n        labelMap.set(dividerLabelBar, label);\n        dividerLabelBar.appendChild(label);\n        this.dividersLabelBarElementInternal.appendChild(dividerLabelBar);\n      }\n\n      const time = dividerOffsets[i].time;\n      const position = dividerOffsets[i].position;\n      if (dividerLabelBar) {\n        const label = labelMap.get(dividerLabelBar);\n        if (label) {\n          label.textContent = calculator.formatValue(time, precision);\n        }\n      }\n\n      const percentLeft = 100 * position / dividersElementClientWidth;\n      divider.style.left = percentLeft + '%';\n      if (dividerLabelBar) {\n        dividerLabelBar.style.left = percentLeft + '%';\n      }\n      divider = (divider.nextSibling as HTMLElement | null);\n      if (dividerLabelBar) {\n        dividerLabelBar = (dividerLabelBar.nextSibling as HTMLElement | null);\n      }\n    }\n\n    // Remove extras.\n    while (divider) {\n      const nextDivider = divider.nextSibling;\n      this.dividersElementInternal.removeChild(divider);\n      if (nextDivider) {\n        divider = (nextDivider as HTMLElement);\n      } else {\n        break;\n      }\n    }\n    while (dividerLabelBar) {\n      const nextDivider = dividerLabelBar.nextSibling;\n      this.dividersLabelBarElementInternal.removeChild(dividerLabelBar);\n      if (nextDivider) {\n        dividerLabelBar = (nextDivider as HTMLElement);\n      } else {\n        break;\n      }\n    }\n    return true;\n  }\n\n  addEventDividers(dividers: Element[]): void {\n    this.gridHeaderElement.removeChild(this.eventDividersElement);\n    for (const divider of dividers) {\n      this.eventDividersElement.appendChild(divider);\n    }\n    this.gridHeaderElement.appendChild(this.eventDividersElement);\n  }\n\n  removeEventDividers(): void {\n    this.eventDividersElement.removeChildren();\n  }\n\n  hideEventDividers(): void {\n    this.eventDividersElement.classList.add('hidden');\n  }\n\n  showEventDividers(): void {\n    this.eventDividersElement.classList.remove('hidden');\n  }\n\n  setScrollTop(scrollTop: number): void {\n    this.dividersLabelBarElementInternal.style.top = scrollTop + 'px';\n    this.eventDividersElement.style.top = scrollTop + 'px';\n  }\n}\n\n// The TimelineGrid is used in the Performance panel and Memory panel -> Allocating sampling, so the value can be either\n// milliseconds or bytes\nexport interface Calculator {\n  computePosition(value: number): number;\n  formatValue(value: number, precision?: number): string;\n  minimumBoundary(): number;\n  zeroTime(): number;\n  maximumBoundary(): number;\n  boundarySpan(): number;\n}\n\nexport interface DividersData {\n  offsets: Array<{\n    position: number,\n    time: number,\n  }>;\n  precision: number;\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.resources-dividers {\n  position: absolute;\n  inset: 0;\n  z-index: -100;\n}\n\n.resources-event-dividers {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 100%;\n  top: 0;\n  z-index: 300;\n  pointer-events: none;\n}\n\n.resources-dividers-label-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  background-clip: padding-box;\n  height: 20px;\n  z-index: 200;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n.resources-divider {\n  position: absolute;\n  width: 1px;\n  top: 0;\n  bottom: 0;\n  background-color: var(--sys-color-divider);\n}\n\n.resources-event-divider {\n  position: absolute;\n  width: 1px;\n  top: 0;\n  bottom: 0;\n  z-index: 300;\n}\n\n.resources-divider-label {\n  position: absolute;\n  top: 4px;\n  right: 3px;\n  font-size: 80%;\n  white-space: nowrap;\n  pointer-events: none;\n}\n\n.timeline-grid-header {\n  height: 20px;\n  pointer-events: none;\n}\n\n/*# sourceURL=${import.meta.resolve('./timelineGrid.css')} */`;", "// Copyright 2015 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Host from '../../../../core/host/host.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as VisualLogging from '../../../visual_logging/visual_logging.js';\nimport * as UI from '../../legacy.js';\n\nimport filmStripViewStyles from './filmStripView.css.js';\n\nconst UIStrings = {\n  /**\n   *@description Element title in Film Strip View of the Performance panel\n   */\n  doubleclickToZoomImageClickTo: 'Doubleclick to zoom image. Click to view preceding requests.',\n  /**\n   *@description Aria label for captured screenshots in network panel.\n   *@example {3ms} PH1\n   */\n  screenshotForSSelectToView: 'Screenshot for {PH1} - select to view preceding requests.',\n  /**\n   *@description Text for one or a group of screenshots\n   */\n  screenshot: 'Screenshot',\n  /**\n   *@description Prev button title in Film Strip View of the Performance panel\n   */\n  previousFrame: 'Previous frame',\n  /**\n   *@description Next button title in Film Strip View of the Performance panel\n   */\n  nextFrame: 'Next frame',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/FilmStripView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class FilmStripView extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.HBox>(UI.Widget.HBox) {\n  private statusLabel: HTMLElement;\n  private zeroTime: Trace.Types.Timing.Milli = Trace.Types.Timing.Milli(0);\n  #filmStrip: Trace.Extras.FilmStrip.Data|null = null;\n\n  constructor() {\n    super(true);\n    this.registerRequiredCSS(filmStripViewStyles);\n    this.contentElement.classList.add('film-strip-view');\n    this.statusLabel = this.contentElement.createChild('div', 'gray-info-message');\n    this.reset();\n  }\n\n  static setImageData(imageElement: HTMLImageElement, dataUri: string|null): void {\n    if (dataUri) {\n      imageElement.src = dataUri;\n    }\n  }\n\n  setModel(filmStrip: Trace.Extras.FilmStrip.Data): void {\n    this.#filmStrip = filmStrip;\n    this.zeroTime = Trace.Helpers.Timing.microToMilli(filmStrip.zeroTime);\n\n    if (!this.#filmStrip.frames.length) {\n      this.reset();\n      return;\n    }\n    this.update();\n  }\n\n  createFrameElement(frame: Trace.Extras.FilmStrip.Frame): HTMLButtonElement {\n    const time = Trace.Helpers.Timing.microToMilli(frame.screenshotEvent.ts);\n    const frameTime = i18n.TimeUtilities.millisToString(time - this.zeroTime);\n    const element = document.createElement('button');\n    element.classList.add('frame');\n    UI.Tooltip.Tooltip.install(element, i18nString(UIStrings.doubleclickToZoomImageClickTo));\n    element.createChild('div', 'time').textContent = frameTime;\n    element.tabIndex = 0;\n    element.setAttribute('jslog', `${VisualLogging.preview('film-strip').track({click: true, dblclick: true})}`);\n    element.setAttribute('aria-label', i18nString(UIStrings.screenshotForSSelectToView, {PH1: frameTime}));\n    UI.ARIAUtils.markAsButton(element);\n    const imageElement = element.createChild('div', 'thumbnail').createChild('img');\n    imageElement.alt = i18nString(UIStrings.screenshot);\n    element.addEventListener('mousedown', this.onMouseEvent.bind(this, Events.FRAME_SELECTED, time), false);\n    element.addEventListener('mouseenter', this.onMouseEvent.bind(this, Events.FRAME_ENTER, time), false);\n    element.addEventListener('mouseout', this.onMouseEvent.bind(this, Events.FRAME_EXIT, time), false);\n    element.addEventListener('dblclick', this.onDoubleClick.bind(this, frame), false);\n    element.addEventListener('focusin', this.onMouseEvent.bind(this, Events.FRAME_ENTER, time), false);\n    element.addEventListener('focusout', this.onMouseEvent.bind(this, Events.FRAME_EXIT, time), false);\n\n    const imgData = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(frame.screenshotEvent);\n    FilmStripView.setImageData(imageElement, imgData);\n    return element;\n  }\n\n  update(): void {\n    const frames = this.#filmStrip?.frames;\n    if (!frames || frames.length < 1) {\n      return;\n    }\n\n    const frameElements = frames.map(frame => this.createFrameElement(frame));\n    this.contentElement.removeChildren();\n    for (const element of frameElements) {\n      this.contentElement.appendChild(element);\n    }\n  }\n\n  private onMouseEvent(eventName: string|symbol, timestamp: number): void {\n    // TODO(crbug.com/1228674): Use type-safe event dispatch and remove <any>.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.dispatchEventToListeners<any>(eventName, timestamp);\n  }\n\n  private onDoubleClick(filmStripFrame: Trace.Extras.FilmStrip.Frame): void {\n    if (!this.#filmStrip) {\n      return;\n    }\n    Dialog.fromFilmStrip(this.#filmStrip, filmStripFrame.index);\n  }\n\n  reset(): void {\n    this.zeroTime = Trace.Types.Timing.Milli(0);\n    this.contentElement.removeChildren();\n    this.contentElement.appendChild(this.statusLabel);\n  }\n\n  setStatusText(text: string): void {\n    this.statusLabel.textContent = text;\n  }\n}\n\nexport const enum Events {\n  FRAME_SELECTED = 'FrameSelected',\n  FRAME_ENTER = 'FrameEnter',\n  FRAME_EXIT = 'FrameExit',\n}\n\nexport interface EventTypes {\n  [Events.FRAME_SELECTED]: number;\n  [Events.FRAME_ENTER]: number;\n  [Events.FRAME_EXIT]: number;\n}\n\ninterface DialogParsedTrace {\n  source: 'Trace';\n  index: number;\n  zeroTime: Trace.Types.Timing.Milli;\n  frames: readonly Trace.Extras.FilmStrip.Frame[];\n}\n\nexport class Dialog {\n  private fragment: UI.Fragment.Fragment;\n  private readonly widget: UI.XWidget.XWidget;\n  private index: number;\n  private dialog: UI.Dialog.Dialog|null = null;\n\n  #data: DialogParsedTrace;\n\n  static fromFilmStrip(filmStrip: Trace.Extras.FilmStrip.Data, selectedFrameIndex: number): Dialog {\n    const data: DialogParsedTrace = {\n      source: 'Trace',\n      frames: filmStrip.frames,\n      index: selectedFrameIndex,\n      zeroTime: Trace.Helpers.Timing.microToMilli(filmStrip.zeroTime),\n    };\n    return new Dialog(data);\n  }\n\n  private constructor(data: DialogParsedTrace) {\n    this.#data = data;\n    this.index = data.index;\n    const prevButton = UI.UIUtils.createTextButton('\\u25C0', this.onPrevFrame.bind(this));\n    UI.Tooltip.Tooltip.install(prevButton, i18nString(UIStrings.previousFrame));\n    const nextButton = UI.UIUtils.createTextButton('\\u25B6', this.onNextFrame.bind(this));\n    UI.Tooltip.Tooltip.install(nextButton, i18nString(UIStrings.nextFrame));\n    this.fragment = UI.Fragment.Fragment.build`\n      <x-widget flex=none margin='var(--sys-size-7) var(--sys-size-8) var(--sys-size-8) var(--sys-size-8)'>\n        <x-hbox overflow=auto border='var(--sys-size-1) solid var(--sys-color-divider)'>\n          <img $='image' data-film-strip-dialog-img style=\"max-height: 80vh; max-width: 80vw;\"></img>\n        </x-hbox>\n        <x-hbox x-center justify-content=center margin-top='var(--sys-size-6)'>\n          ${prevButton}\n          <x-hbox $='time' margin='var(--sys-size-5)'></x-hbox>\n          ${nextButton}\n        </x-hbox>\n      </x-widget>\n    `;\n    this.widget = (this.fragment.element() as UI.XWidget.XWidget);\n    (this.widget as HTMLElement).tabIndex = 0;\n    this.widget.addEventListener('keydown', this.keyDown.bind(this), false);\n    this.dialog = null;\n\n    void this.render();\n  }\n\n  hide(): void {\n    if (this.dialog) {\n      this.dialog.hide();\n    }\n  }\n\n  #framesCount(): number {\n    return this.#data.frames.length;\n  }\n\n  #zeroTime(): Trace.Types.Timing.Milli {\n    return this.#data.zeroTime;\n  }\n\n  private resize(): void {\n    if (!this.dialog) {\n      this.dialog = new UI.Dialog.Dialog();\n      this.dialog.contentElement.appendChild(this.widget);\n      this.dialog.setDefaultFocusedElement(this.widget);\n      this.dialog.show();\n    }\n    this.dialog.setSizeBehavior(UI.GlassPane.SizeBehavior.MEASURE_CONTENT);\n  }\n\n  private keyDown(event: Event): void {\n    const keyboardEvent = (event as KeyboardEvent);\n    switch (keyboardEvent.key) {\n      case 'ArrowLeft':\n        if (Host.Platform.isMac() && keyboardEvent.metaKey) {\n          this.onFirstFrame();\n        } else {\n          this.onPrevFrame();\n        }\n        break;\n\n      case 'ArrowRight':\n        if (Host.Platform.isMac() && keyboardEvent.metaKey) {\n          this.onLastFrame();\n        } else {\n          this.onNextFrame();\n        }\n        break;\n\n      case 'Home':\n        this.onFirstFrame();\n        break;\n\n      case 'End':\n        this.onLastFrame();\n        break;\n    }\n  }\n\n  private onPrevFrame(): void {\n    if (this.index > 0) {\n      --this.index;\n    }\n    void this.render();\n  }\n\n  private onNextFrame(): void {\n    if (this.index < this.#framesCount() - 1) {\n      ++this.index;\n    }\n    void this.render();\n  }\n\n  private onFirstFrame(): void {\n    this.index = 0;\n    void this.render();\n  }\n\n  private onLastFrame(): void {\n    this.index = this.#framesCount() - 1;\n    void this.render();\n  }\n\n  private render(): void {\n    const frame = this.#data.frames[this.index];\n    const timestamp = Trace.Helpers.Timing.microToMilli(frame.screenshotEvent.ts);\n    this.fragment.$('time').textContent = i18n.TimeUtilities.millisToString(timestamp - this.#zeroTime());\n    const image = (this.fragment.$('image') as HTMLImageElement);\n    image.setAttribute('data-frame-index', this.index.toString());\n    const imgData = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(frame.screenshotEvent);\n    FilmStripView.setImageData(image, imgData);\n    this.resize();\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.film-strip-view {\n  overflow: auto hidden;\n  align-content: flex-start;\n  min-height: 81px;\n}\n\n.film-strip-view .frame .time {\n  font-size: 10px;\n  margin-top: 2px;\n}\n\n.film-strip-view .gray-info-message {\n  margin: auto;\n}\n\n.film-strip-view .frame {\n  background: none;\n  border: none;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding: 4px;\n  flex: none;\n  cursor: pointer;\n}\n\n.film-strip-view .frame .thumbnail {\n  min-width: 24px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  pointer-events: none;\n  margin: 4px 0 2px;\n  border: 2px solid transparent;\n}\n\n.film-strip-view .frame:hover .thumbnail,\n.film-strip-view .frame:focus .thumbnail {\n  border-color: var(--sys-color-primary);\n}\n\n.film-strip-view .frame .thumbnail img {\n  height: auto;\n  width: auto;\n  max-width: 80px;\n  max-height: 50px;\n  pointer-events: none;\n  box-shadow: 0 0 3px var(--box-shadow-outline-color);\n  flex: 0 0 auto;\n}\n\n.film-strip-view .frame:hover .thumbnail img,\n.film-strip-view .frame:focus .thumbnail img {\n  box-shadow: none;\n}\n\n/*# sourceURL=${import.meta.resolve('./filmStripView.css')} */`;", "// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../../core/sdk/sdk.js';\nimport type * as UI from '../../legacy.js';\n\nexport class GCActionDelegate implements UI.ActionRegistration.ActionDelegate {\n  handleAction(_context: UI.Context.Context, _actionId: string): boolean {\n    for (const heapProfilerModel of SDK.TargetManager.TargetManager.instance().models(\n             SDK.HeapProfilerModel.HeapProfilerModel)) {\n      void heapProfilerModel.collectGarbage();\n    }\n    return true;\n  }\n}\n", "// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../../core/platform/platform.js';\nimport * as SDK from '../../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../../generated/protocol.js';\nimport * as Bindings from '../../../../models/bindings/bindings.js';\nimport type * as CPUProfile from '../../../../models/cpu_profile/cpu_profile.js';\nimport * as Workspace from '../../../../models/workspace/workspace.js';\nimport * as SourceFrame from '../source_frame/source_frame.js';\n\nlet performanceInstance: Performance;\n\nexport class Performance {\n  private readonly helper: Helper;\n\n  private constructor() {\n    this.helper = new Helper(SourceFrame.SourceFrame.DecoratorType.PERFORMANCE);\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): Performance {\n    const {forceNew} = opts;\n    if (!performanceInstance || forceNew) {\n      performanceInstance = new Performance();\n    }\n\n    return performanceInstance;\n  }\n\n  reset(): void {\n    this.helper.reset();\n  }\n\n  private appendLegacyCPUProfile(\n      profile: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, target: SDK.Target.Target|null): void {\n    const nodesToGo: CPUProfile.CPUProfileDataModel.CPUProfileNode[] = [profile.profileHead];\n    const sampleDuration = (profile.profileEndTime - profile.profileStartTime) / profile.totalHitCount;\n    while (nodesToGo.length) {\n      const nodes: CPUProfile.CPUProfileDataModel.CPUProfileNode[] =\n          // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (nodesToGo.pop() as any).children;  // Cast to any because runtime checks assert the props.\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        nodesToGo.push(node);\n        if (!node.url || !node.positionTicks) {\n          continue;\n        }\n        for (let j = 0; j < node.positionTicks.length; ++j) {\n          const lineInfo = node.positionTicks[j];\n          const line = lineInfo.line;\n          const time = lineInfo.ticks * sampleDuration;\n          this.helper.addLineData(target, node.url, line, time);\n        }\n      }\n    }\n  }\n\n  appendCPUProfile(profile: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, target: SDK.Target.Target|null): void {\n    if (!profile.lines) {\n      this.appendLegacyCPUProfile(profile, target);\n      this.helper.scheduleUpdate();\n      return;\n    }\n    if (!profile.samples) {\n      return;\n    }\n\n    for (let i = 1; i < profile.samples.length; ++i) {\n      const line = profile.lines[i];\n      if (!line) {\n        continue;\n      }\n      const node = profile.nodeByIndex(i);\n      if (!node) {\n        continue;\n      }\n      const scriptIdOrUrl = Number(node.scriptId) || node.url;\n      if (!scriptIdOrUrl) {\n        continue;\n      }\n      const time = profile.timestamps[i] - profile.timestamps[i - 1];\n      this.helper.addLineData(target, scriptIdOrUrl, line, time);\n    }\n    this.helper.scheduleUpdate();\n  }\n}\n\nlet memoryInstance: Memory;\n\nexport class Memory {\n  private readonly helper: Helper;\n  private constructor() {\n    this.helper = new Helper(SourceFrame.SourceFrame.DecoratorType.MEMORY);\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): Memory {\n    const {forceNew} = opts;\n    if (!memoryInstance || forceNew) {\n      memoryInstance = new Memory();\n    }\n\n    return memoryInstance;\n  }\n\n  reset(): void {\n    this.helper.reset();\n  }\n\n  appendHeapProfile(profile: Protocol.HeapProfiler.SamplingHeapProfile, target: SDK.Target.Target|null): void {\n    const helper = this.helper;\n    processNode(profile.head);\n    helper.scheduleUpdate();\n\n    function processNode(node: Protocol.HeapProfiler.SamplingHeapProfileNode): void {\n      node.children.forEach(processNode);\n      if (!node.selfSize) {\n        return;\n      }\n      const script = Number(node.callFrame.scriptId) || node.callFrame.url as Platform.DevToolsPath.UrlString;\n      if (!script) {\n        return;\n      }\n      const line = node.callFrame.lineNumber + 1;\n      helper.addLineData(target, script, line, node.selfSize);\n    }\n  }\n}\n\nexport class Helper {\n  private readonly type: string;\n  private readonly locationPool = new Bindings.LiveLocation.LiveLocationPool();\n  private updateTimer: number|null = null;\n  private lineData =\n      new Map<SDK.Target.Target|null, Map<Platform.DevToolsPath.UrlString|number, Map<number, number>>>();\n\n  constructor(type: string) {\n    this.type = type;\n    this.reset();\n  }\n\n  reset(): void {\n    // The second map uses string keys for script URLs and numbers for scriptId.\n    this.lineData = new Map();\n    this.scheduleUpdate();\n  }\n\n  addLineData(\n      target: SDK.Target.Target|null, scriptIdOrUrl: Platform.DevToolsPath.UrlString|number, line: number,\n      data: number): void {\n    let targetData = this.lineData.get(target);\n    if (!targetData) {\n      targetData = new Map();\n      this.lineData.set(target, targetData);\n    }\n    let scriptData = targetData.get(scriptIdOrUrl);\n    if (!scriptData) {\n      scriptData = new Map();\n      targetData.set(scriptIdOrUrl, scriptData);\n    }\n    scriptData.set(line, (scriptData.get(line) || 0) + data);\n  }\n\n  scheduleUpdate(): void {\n    if (this.updateTimer) {\n      return;\n    }\n    this.updateTimer = window.setTimeout(() => {\n      this.updateTimer = null;\n      void this.doUpdate();\n    }, 0);\n  }\n\n  private async doUpdate(): Promise<void> {\n    this.locationPool.disposeAll();\n    // Map from sources to line->value profile maps.\n    const decorationsBySource = new Map<Workspace.UISourceCode.UISourceCode, Map<number, number>>();\n    const pending: Array<Promise<void>> = [];\n\n    for (const [target, scriptToLineMap] of this.lineData) {\n      const debuggerModel = target ? target.model(SDK.DebuggerModel.DebuggerModel) : null;\n      for (const [scriptIdOrUrl, lineToDataMap] of scriptToLineMap) {\n        // debuggerModel is null when the profile is loaded from file.\n        // Try to get UISourceCode by the URL in this case.\n        const workspace = Workspace.Workspace.WorkspaceImpl.instance();\n        if (debuggerModel) {\n          const workspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n          for (const lineToData of lineToDataMap) {\n            const line = lineToData[0] - 1;\n            const data = lineToData[1];\n            const rawLocation = typeof scriptIdOrUrl === 'string' ?\n                debuggerModel.createRawLocationByURL(scriptIdOrUrl, line, 0) :\n                debuggerModel.createRawLocationByScriptId(String(scriptIdOrUrl) as Protocol.Runtime.ScriptId, line, 0);\n            if (rawLocation) {\n              pending.push(workspaceBinding.rawLocationToUILocation(rawLocation).then(uiLocation => {\n                if (uiLocation) {\n                  let lineMap = decorationsBySource.get(uiLocation.uiSourceCode);\n                  if (!lineMap) {\n                    lineMap = new Map<number, number>();\n                    decorationsBySource.set(uiLocation.uiSourceCode, lineMap);\n                  }\n                  lineMap.set(uiLocation.lineNumber + 1, data);\n                }\n              }));\n            }\n          }\n        } else if (typeof scriptIdOrUrl === 'string') {\n          const uiSourceCode = workspace.uiSourceCodeForURL(scriptIdOrUrl);\n          if (uiSourceCode) {\n            decorationsBySource.set(uiSourceCode, lineToDataMap);\n          }\n        }\n      }\n      await Promise.all(pending);\n      for (const [uiSourceCode, lineMap] of decorationsBySource) {\n        uiSourceCode.setDecorationData(this.type, lineMap);\n      }\n    }\n    for (const uiSourceCode of Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodes()) {\n      if (!decorationsBySource.has(uiSourceCode)) {\n        uiSourceCode.setDecorationData(this.type, undefined);\n      }\n    }\n  }\n}\n", "// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Host from '../../../../core/host/host.js';\nimport * as SDK from '../../../../core/sdk/sdk.js';\n\nimport {Memory} from './LineLevelProfile.js';\n\nlet liveHeapProfileInstance: LiveHeapProfile;\nexport class LiveHeapProfile implements Common.Runnable.Runnable,\n                                        SDK.TargetManager.SDKModelObserver<SDK.HeapProfilerModel.HeapProfilerModel> {\n  private running: boolean;\n  private sessionId: number;\n  private loadEventCallback: (arg0?: () => void|null) => void;\n  private readonly setting: Common.Settings.Setting<boolean>;\n\n  private constructor() {\n    this.running = false;\n    this.sessionId = 0;\n    this.loadEventCallback = () => {};\n    this.setting = Common.Settings.Settings.instance().moduleSetting('memory-live-heap-profile');\n    this.setting.addChangeListener(event => event.data ? this.startProfiling() : this.stopProfiling());\n    if (this.setting.get()) {\n      void this.startProfiling();\n    }\n  }\n\n  static instance(opts: {forceNew: boolean|null} = {forceNew: null}): LiveHeapProfile {\n    const {forceNew} = opts;\n    if (!liveHeapProfileInstance || forceNew) {\n      liveHeapProfileInstance = new LiveHeapProfile();\n    }\n\n    return liveHeapProfileInstance;\n  }\n\n  async run(): Promise<void> {\n    return;\n  }\n\n  modelAdded(model: SDK.HeapProfilerModel.HeapProfilerModel): void {\n    void model.startSampling(1e4);\n  }\n\n  modelRemoved(_model: SDK.HeapProfilerModel.HeapProfilerModel): void {\n    // Cannot do much when the model has already been removed.\n  }\n\n  private async startProfiling(): Promise<void> {\n    if (this.running) {\n      return;\n    }\n    this.running = true;\n    const sessionId = this.sessionId;\n    SDK.TargetManager.TargetManager.instance().observeModels(SDK.HeapProfilerModel.HeapProfilerModel, this);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.Load, this.loadEventFired, this);\n\n    do {\n      const models = SDK.TargetManager.TargetManager.instance().models(SDK.HeapProfilerModel.HeapProfilerModel);\n      const profiles = await Promise.all(models.map(model => model.getSamplingProfile()));\n      if (sessionId !== this.sessionId) {\n        break;\n      }\n      Memory.instance().reset();\n      for (let i = 0; i < profiles.length; ++i) {\n        const profile = profiles[i];\n        if (!profile) {\n          continue;\n        }\n\n        Memory.instance().appendHeapProfile(profile, models[i].target());\n      }\n      await Promise.race([\n        new Promise(r => window.setTimeout(r, Host.InspectorFrontendHost.isUnderTest() ? 10 : 5000)),\n        new Promise(r => {\n          this.loadEventCallback = r;\n        }),\n      ]);\n    } while (sessionId === this.sessionId);\n\n    SDK.TargetManager.TargetManager.instance().unobserveModels(SDK.HeapProfilerModel.HeapProfilerModel, this);\n    SDK.TargetManager.TargetManager.instance().removeModelListener(\n        SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.Load, this.loadEventFired, this);\n    for (const model of SDK.TargetManager.TargetManager.instance().models(SDK.HeapProfilerModel.HeapProfilerModel)) {\n      void model.stopSampling();\n    }\n    Memory.instance().reset();\n  }\n\n  private stopProfiling(): void {\n    if (!this.running) {\n      return;\n    }\n    this.running = false;\n    this.sessionId++;\n  }\n\n  private loadEventFired(): void {\n    this.loadEventCallback();\n  }\n}\n", "// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Protocol from '../../../../generated/protocol.js';\n\nconst UIStrings = {\n  /**\n   *@description Text in Network Priorities of the Performance panel\n   */\n  lowest: 'Lowest',\n  /**\n   *@description Text in Network Priorities of the Performance panel\n   */\n  low: 'Low',\n  /**\n   *@description Text in Network Priorities of the Performance panel\n   */\n  medium: 'Medium',\n  /**\n   *@description Text in Network Priorities of the Performance panel\n   */\n  high: 'High',\n  /**\n   *@description Text in Network Priorities of the Performance panel\n   */\n  highest: 'Highest',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/NetworkPriorities.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport function uiLabelForNetworkPriority(priority: Protocol.Network.ResourcePriority): string {\n  return priorityUILabelMap().get(priority) || '';\n}\n\nconst uiLabelToPriorityMapInstance = new Map<string, Protocol.Network.ResourcePriority>();\n\nexport function uiLabelToNetworkPriority(priorityLabel: string): Protocol.Network.ResourcePriority {\n  if (uiLabelToPriorityMapInstance.size === 0) {\n    priorityUILabelMap().forEach((value, key) => uiLabelToPriorityMapInstance.set(value, key));\n  }\n  const priority = uiLabelToPriorityMapInstance.get(priorityLabel);\n  if (priority) {\n    return priority;\n  }\n  throw new Error('Priority not found');\n}\n\nconst priorityUILabelMapInstance = new Map<Protocol.Network.ResourcePriority, string>();\n\nexport function priorityUILabelMap(): Map<Protocol.Network.ResourcePriority, string> {\n  if (priorityUILabelMapInstance.size === 0) {\n    priorityUILabelMapInstance.set(Protocol.Network.ResourcePriority.VeryLow, i18nString(UIStrings.lowest));\n    priorityUILabelMapInstance.set(Protocol.Network.ResourcePriority.Low, i18nString(UIStrings.low));\n    priorityUILabelMapInstance.set(Protocol.Network.ResourcePriority.Medium, i18nString(UIStrings.medium));\n    priorityUILabelMapInstance.set(Protocol.Network.ResourcePriority.High, i18nString(UIStrings.high));\n    priorityUILabelMapInstance.set(Protocol.Network.ResourcePriority.VeryHigh, i18nString(UIStrings.highest));\n  }\n  return priorityUILabelMapInstance;\n}\n\nconst networkPriorityWeights = new Map<Protocol.Network.ResourcePriority, number>();\n\nexport function networkPriorityWeight(priority: Protocol.Network.ResourcePriority): number {\n  if (networkPriorityWeights.size === 0) {\n    networkPriorityWeights.set(Protocol.Network.ResourcePriority.VeryLow, 1);\n    networkPriorityWeights.set(Protocol.Network.ResourcePriority.Low, 2);\n    networkPriorityWeights.set(Protocol.Network.ResourcePriority.Medium, 3);\n    networkPriorityWeights.set(Protocol.Network.ResourcePriority.High, 4);\n    networkPriorityWeights.set(Protocol.Network.ResourcePriority.VeryHigh, 5);\n  }\n  return networkPriorityWeights.get(priority) || 0;\n}\n", "/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as IconButton from '../../../components/icon_button/icon_button.js';\nimport * as VisualLogging from '../../../visual_logging/visual_logging.js';\nimport * as UI from '../../legacy.js';\n\nimport overviewGridStyles from './overviewGrid.css.js';\nimport {type Calculator, TimelineGrid} from './TimelineGrid.js';\n\nconst UIStrings = {\n  /**\n   *@description Label for the window for Overview grids\n   */\n  overviewGridWindow: 'Overview grid window',\n  /**\n   *@description Label for left window resizer for Overview grids\n   */\n  leftResizer: 'Left Resizer',\n  /**\n   *@description Label for right window resizer for Overview grids\n   */\n  rightResizer: 'Right Resizer',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/OverviewGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class OverviewGrid {\n  element: HTMLDivElement;\n  private readonly grid: TimelineGrid;\n  // The |window| will manage the html element of resizers, the left/right blue-colour curtain, and handle the resizing,\n  // zooming, and breadcrumb creation.\n  private readonly window: Window;\n  constructor(prefix: string, calculator?: Calculator) {\n    this.element = document.createElement('div');\n    this.element.id = prefix + '-overview-container';\n\n    this.grid = new TimelineGrid();\n    this.grid.element.id = prefix + '-overview-grid';\n    this.grid.setScrollTop(0);\n\n    this.element.appendChild(this.grid.element);\n\n    this.window = new Window(this.element, this.grid.dividersLabelBarElement, calculator);\n  }\n\n  enableCreateBreadcrumbsButton(): HTMLElement {\n    return this.window.enableCreateBreadcrumbsButton();\n  }\n\n  set showingScreenshots(isShowing: boolean) {\n    this.window.showingScreenshots = isShowing;\n  }\n\n  clientWidth(): number {\n    return this.element.clientWidth;\n  }\n\n  updateDividers(calculator: Calculator): void {\n    this.grid.updateDividers(calculator);\n  }\n\n  addEventDividers(dividers: Element[]): void {\n    this.grid.addEventDividers(dividers);\n  }\n\n  removeEventDividers(): void {\n    this.grid.removeEventDividers();\n  }\n\n  reset(): void {\n    this.window.reset();\n  }\n\n  // The ratio of the left slider position compare to the whole overview grid.\n  // It should be a number between 0 and 1.\n  windowLeftRatio(): number {\n    return this.window.windowLeftRatio || 0;\n  }\n\n  // The ratio of the right slider position compare to the whole overview grid.\n  // It should be a number between 0 and 1.\n  windowRightRatio(): number {\n    return this.window.windowRightRatio || 0;\n  }\n\n  /**\n   * This function will return the raw value of the slider window.\n   * Since the OverviewGrid is used in Performance panel or Memory panel, the raw value can be in milliseconds or bytes.\n   *\n   * @returns the pair of start/end value of the slider window in milliseconds or bytes\n   */\n  calculateWindowValue(): {rawStartValue: number, rawEndValue: number} {\n    return this.window.calculateWindowValue();\n  }\n\n  setWindowRatio(leftRatio: number, rightRatio: number): void {\n    this.window.setWindowRatio(leftRatio, rightRatio);\n  }\n\n  addEventListener<T extends keyof EventTypes>(\n      eventType: T, listener: Common.EventTarget.EventListener<EventTypes, T>,\n      thisObject?: Object): Common.EventTarget.EventDescriptor {\n    return this.window.addEventListener(eventType, listener, thisObject);\n  }\n\n  setClickHandler(clickHandler: ((arg0: Event) => boolean)|null): void {\n    this.window.setClickHandler(clickHandler);\n  }\n\n  zoom(zoomFactor: number, referencePoint: number): void {\n    this.window.zoom(zoomFactor, referencePoint);\n  }\n\n  setResizeEnabled(enabled: boolean): void {\n    this.window.setResizeEnabled(enabled);\n  }\n}\n\nconst MinSelectableSize = 14;\nconst WindowScrollSpeedFactor = .3;\nconst ResizerOffset = 5;\nconst OffsetFromWindowEnds = 10;\n\nexport class Window extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  private parentElement: Element;\n  private calculator: Calculator|undefined;\n  private leftResizeElement: HTMLElement;\n  private rightResizeElement: HTMLElement;\n  private leftCurtainElement: HTMLElement;\n  private rightCurtainElement: HTMLElement;\n  private breadcrumbButtonContainerElement: HTMLElement;\n  private createBreadcrumbButton: HTMLElement;\n  private curtainsRange?: HTMLElement;\n  private breadcrumbZoomIcon?: IconButton.Icon.Icon;\n\n  private overviewWindowSelector!: WindowSelector|undefined;\n  private offsetLeft!: number;\n  private dragStartPointPixel!: number;\n  private dragStartLeftRatio!: number;\n  private dragStartRightRatio!: number;\n\n  // The ratio of the left/right resizer position compare to the whole overview grid.\n  // They should be a number between 0 and 1.\n  windowLeftRatio = 0;\n  windowRightRatio = 1;\n\n  private resizeEnabled?: boolean;\n  private clickHandler?: ((arg0: Event) => boolean)|null;\n  private resizerParentOffsetLeft?: number;\n  #breadcrumbsEnabled = false;\n  #mouseOverGridOverview = false;\n  constructor(parentElement: HTMLElement, dividersLabelBarElement?: Element, calculator?: Calculator) {\n    super();\n    this.parentElement = parentElement;\n    this.parentElement.classList.add('parent-element');\n    UI.ARIAUtils.markAsGroup(this.parentElement);\n    this.calculator = calculator;\n\n    UI.ARIAUtils.setLabel(this.parentElement, i18nString(UIStrings.overviewGridWindow));\n\n    UI.UIUtils.installDragHandle(\n        this.parentElement, this.startWindowSelectorDragging.bind(this), this.windowSelectorDragging.bind(this),\n        this.endWindowSelectorDragging.bind(this), 'text', null);\n    if (dividersLabelBarElement) {\n      UI.UIUtils.installDragHandle(\n          dividersLabelBarElement, this.startWindowDragging.bind(this), this.windowDragging.bind(this), null,\n          '-webkit-grabbing', '-webkit-grab');\n    }\n\n    this.parentElement.addEventListener('wheel', this.onMouseWheel.bind(this), true);\n    this.parentElement.addEventListener('dblclick', this.resizeWindowMaximum.bind(this), true);\n    Platform.DOMUtilities.appendStyle(this.parentElement, overviewGridStyles);\n\n    this.leftResizeElement = parentElement.createChild('div', 'overview-grid-window-resizer');\n    UI.UIUtils.installDragHandle(\n        this.leftResizeElement, this.resizerElementStartDragging.bind(this), this.leftResizeElementDragging.bind(this),\n        null, 'ew-resize');\n    this.rightResizeElement = parentElement.createChild('div', 'overview-grid-window-resizer');\n    UI.UIUtils.installDragHandle(\n        this.rightResizeElement, this.resizerElementStartDragging.bind(this),\n        this.rightResizeElementDragging.bind(this), null, 'ew-resize');\n\n    UI.ARIAUtils.setLabel(this.leftResizeElement, i18nString(UIStrings.leftResizer));\n    UI.ARIAUtils.markAsSlider(this.leftResizeElement);\n    const leftKeyDown = (event: Event): void => this.handleKeyboardResizing(event, false);\n    this.leftResizeElement.addEventListener('keydown', leftKeyDown);\n    this.leftResizeElement.addEventListener('click', this.onResizerClicked);\n\n    UI.ARIAUtils.setLabel(this.rightResizeElement, i18nString(UIStrings.rightResizer));\n    UI.ARIAUtils.markAsSlider(this.rightResizeElement);\n\n    const rightKeyDown = (event: Event): void => this.handleKeyboardResizing(event, true);\n    this.rightResizeElement.addEventListener('keydown', rightKeyDown);\n    this.rightResizeElement.addEventListener('focus', this.onRightResizeElementFocused.bind(this));\n    this.rightResizeElement.addEventListener('click', this.onResizerClicked);\n\n    this.leftCurtainElement = parentElement.createChild('div', 'window-curtain-left');\n    this.rightCurtainElement = parentElement.createChild('div', 'window-curtain-right');\n\n    this.breadcrumbButtonContainerElement = parentElement.createChild('div', 'create-breadcrumb-button-container');\n    this.createBreadcrumbButton = this.breadcrumbButtonContainerElement.createChild('div', 'create-breadcrumb-button');\n    this.createBreadcrumbButton.setAttribute(\n        'jslog', `${VisualLogging.action('timeline.create-breadcrumb').track({click: true})}`);\n    this.reset();\n  }\n\n  enableCreateBreadcrumbsButton(): HTMLElement {\n    this.curtainsRange = this.createBreadcrumbButton.createChild('div');\n    this.breadcrumbZoomIcon = IconButton.Icon.create('zoom-in');\n    this.createBreadcrumbButton.appendChild(this.breadcrumbZoomIcon);\n    this.createBreadcrumbButton.addEventListener('click', () => {\n      this.#createBreadcrumb();\n    });\n\n    this.#breadcrumbsEnabled = true;\n\n    this.#changeBreadcrumbButtonVisibilityOnInteraction(this.parentElement);\n    this.#changeBreadcrumbButtonVisibilityOnInteraction(this.rightResizeElement);\n    this.#changeBreadcrumbButtonVisibilityOnInteraction(this.leftResizeElement);\n\n    return this.breadcrumbButtonContainerElement;\n  }\n\n  set showingScreenshots(isShowing: boolean) {\n    this.breadcrumbButtonContainerElement.classList.toggle('with-screenshots', isShowing);\n  }\n\n  #changeBreadcrumbButtonVisibilityOnInteraction(element: Element): void {\n    if (!this.#breadcrumbsEnabled) {\n      return;\n    }\n    element.addEventListener('mouseover', () => {\n      if (this.windowLeftRatio <= 0 && this.windowRightRatio >= 1) {\n        this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', false);\n        this.#mouseOverGridOverview = false;\n      } else {\n        this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', true);\n        this.#mouseOverGridOverview = true;\n      }\n    });\n\n    element.addEventListener('mouseout', () => {\n      this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', false);\n      this.#mouseOverGridOverview = false;\n    });\n  }\n\n  private onResizerClicked(event: Event): void {\n    if (event.target) {\n      (event.target as HTMLElement).focus();\n    }\n  }\n\n  private onRightResizeElementFocused(): void {\n    // To prevent browser focus from scrolling the element into view and shifting the contents of the strip\n    this.parentElement.scrollLeft = 0;\n  }\n\n  reset(): void {\n    this.windowLeftRatio = 0;\n    this.windowRightRatio = 1;\n    this.setResizeEnabled(true);\n    this.updateCurtains();\n  }\n\n  setResizeEnabled(resizeEnabled: boolean): void {\n    this.resizeEnabled = resizeEnabled;\n    this.rightResizeElement.tabIndex = resizeEnabled ? 0 : -1;\n    this.leftResizeElement.tabIndex = resizeEnabled ? 0 : -1;\n  }\n\n  setClickHandler(clickHandler: ((arg0: Event) => boolean)|null): void {\n    this.clickHandler = clickHandler;\n  }\n\n  private resizerElementStartDragging(event: Event): boolean {\n    const mouseEvent = (event as MouseEvent);\n    const target = (event.target as HTMLElement);\n    if (!this.resizeEnabled) {\n      return false;\n    }\n    this.resizerParentOffsetLeft = mouseEvent.pageX - mouseEvent.offsetX - target.offsetLeft;\n    event.stopPropagation();\n    return true;\n  }\n\n  private leftResizeElementDragging(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    this.resizeWindowLeft(mouseEvent.pageX - (this.resizerParentOffsetLeft || 0));\n    event.preventDefault();\n  }\n\n  private rightResizeElementDragging(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    this.resizeWindowRight(mouseEvent.pageX - (this.resizerParentOffsetLeft || 0));\n    event.preventDefault();\n  }\n\n  private handleKeyboardResizing(event: Event, moveRightResizer?: boolean): void {\n    const keyboardEvent = (event as KeyboardEvent);\n    const target = (event.target as HTMLElement);\n    let increment = false;\n    if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowRight') {\n      if (keyboardEvent.key === 'ArrowRight') {\n        increment = true;\n      }\n      const newPos = this.getNewResizerPosition(target.offsetLeft, increment, keyboardEvent.ctrlKey);\n      if (moveRightResizer) {\n        this.resizeWindowRight(newPos);\n      } else {\n        this.resizeWindowLeft(newPos);\n      }\n      event.consume(true);\n    }\n  }\n\n  private getNewResizerPosition(offset: number, increment?: boolean, ctrlPressed?: boolean): number {\n    let newPos;\n    // We shift by 10px if the ctrlKey is pressed and 2 otherwise.  1px shifts result in noOp due to rounding in updateCurtains\n    let pixelsToShift: number|(2 | 10) = ctrlPressed ? 10 : 2;\n    pixelsToShift = increment ? pixelsToShift : -Math.abs(pixelsToShift);\n    const offsetLeft = offset + ResizerOffset;\n    newPos = offsetLeft + pixelsToShift;\n    if (increment && newPos < OffsetFromWindowEnds) {\n      // When incrementing, snap to the window offset value (10px) if the new position is between 0px and 10px\n      newPos = OffsetFromWindowEnds;\n    } else if (!increment && newPos > this.parentElement.clientWidth - OffsetFromWindowEnds) {\n      // When decrementing, snap to the window offset value (10px) from the rightmost side if the new position is within 10px from the end.\n      newPos = this.parentElement.clientWidth - OffsetFromWindowEnds;\n    }\n\n    return newPos;\n  }\n\n  private startWindowSelectorDragging(event: Event): boolean {\n    if (!this.resizeEnabled) {\n      return false;\n    }\n    const mouseEvent = (event as MouseEvent);\n    this.offsetLeft = this.parentElement.getBoundingClientRect().left;\n    const position = mouseEvent.x - this.offsetLeft;\n    this.overviewWindowSelector = new WindowSelector(this.parentElement, position);\n    return true;\n  }\n\n  private windowSelectorDragging(event: Event): void {\n    this.#mouseOverGridOverview = true;\n    if (!this.overviewWindowSelector) {\n      return;\n    }\n    const mouseEvent = (event as MouseEvent);\n    this.overviewWindowSelector.updatePosition(mouseEvent.x - this.offsetLeft);\n    event.preventDefault();\n  }\n\n  private endWindowSelectorDragging(event: Event): void {\n    if (!this.overviewWindowSelector) {\n      return;\n    }\n    const mouseEvent = (event as MouseEvent);\n    const window = this.overviewWindowSelector.close(mouseEvent.x - this.offsetLeft);\n\n    // prevent selecting a window on clicking the minimap if breadcrumbs are enabled\n    if (this.#breadcrumbsEnabled && window.start === window.end) {\n      return;\n    }\n\n    delete this.overviewWindowSelector;\n    const clickThreshold = 3;\n    if (window.end - window.start < clickThreshold) {\n      if (this.clickHandler?.call(null, event)) {\n        return;\n      }\n      const middle = window.end;\n      window.start = Math.max(0, middle - MinSelectableSize / 2);\n      window.end = Math.min(this.parentElement.clientWidth, middle + MinSelectableSize / 2);\n    } else if (window.end - window.start < MinSelectableSize) {\n      if (this.parentElement.clientWidth - window.end > MinSelectableSize) {\n        window.end = window.start + MinSelectableSize;\n      } else {\n        window.start = window.end - MinSelectableSize;\n      }\n    }\n    this.setWindowPosition(window.start, window.end);\n  }\n\n  private startWindowDragging(event: Event): boolean {\n    const mouseEvent = (event as MouseEvent);\n    this.dragStartPointPixel = mouseEvent.pageX;\n    this.dragStartLeftRatio = this.windowLeftRatio;\n    this.dragStartRightRatio = this.windowRightRatio;\n    event.stopPropagation();\n    return true;\n  }\n\n  private windowDragging(event: Event): void {\n    this.#mouseOverGridOverview = true;\n    if (this.#breadcrumbsEnabled) {\n      this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', true);\n    }\n    const mouseEvent = (event as MouseEvent);\n    mouseEvent.preventDefault();\n    let delta: number = (mouseEvent.pageX - this.dragStartPointPixel) / this.parentElement.clientWidth;\n    if (this.dragStartLeftRatio + delta < 0) {\n      delta = -this.dragStartLeftRatio;\n    }\n\n    if (this.dragStartRightRatio + delta > 1) {\n      delta = 1 - this.dragStartRightRatio;\n    }\n\n    this.setWindowRatio(this.dragStartLeftRatio + delta, this.dragStartRightRatio + delta);\n  }\n\n  private resizeWindowLeft(start: number): void {\n    this.#mouseOverGridOverview = true;\n    // Glue to edge.\n    if (start < OffsetFromWindowEnds) {\n      start = 0;\n    } else if (start > this.rightResizeElement.offsetLeft - 4) {\n      start = this.rightResizeElement.offsetLeft - 4;\n    }\n    this.setWindowPosition(start, null);\n  }\n\n  private resizeWindowRight(end: number): void {\n    this.#mouseOverGridOverview = true;\n    // Glue to edge.\n    if (end > this.parentElement.clientWidth - OffsetFromWindowEnds) {\n      end = this.parentElement.clientWidth;\n    } else if (end < this.leftResizeElement.offsetLeft + MinSelectableSize) {\n      end = this.leftResizeElement.offsetLeft + MinSelectableSize;\n    }\n    this.setWindowPosition(null, end);\n  }\n\n  private resizeWindowMaximum(): void {\n    this.setWindowPosition(0, this.parentElement.clientWidth);\n  }\n\n  /**\n   * This function will return the raw value of the give slider.\n   * Since the OverviewGrid is used in Performance panel or Memory panel, the raw value can be in milliseconds or bytes.\n   * @param leftSlider if this slider is the left one\n   * @returns the value in milliseconds or bytes\n   */\n  private getRawSliderValue(leftSlider?: boolean): number {\n    if (!this.calculator) {\n      throw new Error('No calculator to calculate boundaries');\n    }\n\n    const minimumValue = this.calculator.minimumBoundary();\n    const valueSpan = this.calculator.maximumBoundary() - minimumValue;\n    if (leftSlider) {\n      return minimumValue + valueSpan * this.windowLeftRatio;\n    }\n    return minimumValue + valueSpan * this.windowRightRatio;\n  }\n\n  private updateResizeElementAriaValue(leftPercentValue: number, rightPercentValue: number): void {\n    const roundedLeftValue = leftPercentValue.toFixed(2);\n    const roundedRightValue = rightPercentValue.toFixed(2);\n    UI.ARIAUtils.setAriaValueNow(this.leftResizeElement, roundedLeftValue);\n    UI.ARIAUtils.setAriaValueNow(this.rightResizeElement, roundedRightValue);\n\n    // Left and right sliders cannot be within 0.5% of each other (Range of AriaValueMin/Max/Now is from 0-100).\n    const leftResizeCeiling = Number(roundedRightValue) - 0.5;\n    const rightResizeFloor = Number(roundedLeftValue) + 0.5;\n    UI.ARIAUtils.setAriaValueMinMax(this.leftResizeElement, '0', leftResizeCeiling.toString());\n    UI.ARIAUtils.setAriaValueMinMax(this.rightResizeElement, rightResizeFloor.toString(), '100');\n  }\n\n  private updateResizeElementPositionLabels(): void {\n    if (!this.calculator) {\n      return;\n    }\n    const startValue = this.calculator.formatValue(this.getRawSliderValue(/* leftSlider */ true));\n    const endValue = this.calculator.formatValue(this.getRawSliderValue(/* leftSlider */ false));\n    UI.ARIAUtils.setAriaValueText(this.leftResizeElement, String(startValue));\n    UI.ARIAUtils.setAriaValueText(this.rightResizeElement, String(endValue));\n  }\n\n  private updateResizeElementPercentageLabels(leftValue: string, rightValue: string): void {\n    UI.ARIAUtils.setAriaValueText(this.leftResizeElement, leftValue);\n    UI.ARIAUtils.setAriaValueText(this.rightResizeElement, rightValue);\n  }\n\n  /**\n   * This function will return the raw value of the slider window.\n   * Since the OverviewGrid is used in Performance panel or Memory panel, the raw value can be in milliseconds or bytes.\n   *\n   * @returns the pair of start/end value of the slider window in milliseconds or bytes\n   */\n  calculateWindowValue(): {\n    rawStartValue: number,\n    rawEndValue: number,\n  } {\n    return {\n      rawStartValue: this.getRawSliderValue(/* leftSlider */ true),\n      rawEndValue: this.getRawSliderValue(/* leftSlider */ false),\n    };\n  }\n\n  setWindowRatio(windowLeftRatio: number, windowRightRatio: number): void {\n    this.windowLeftRatio = windowLeftRatio;\n    this.windowRightRatio = windowRightRatio;\n    this.updateCurtains();\n    if (this.calculator) {\n      this.dispatchEventToListeners(Events.WINDOW_CHANGED_WITH_POSITION, this.calculateWindowValue());\n    }\n    this.dispatchEventToListeners(Events.WINDOW_CHANGED);\n    this.#changeBreadcrumbButtonVisibility(windowLeftRatio, windowRightRatio);\n  }\n\n  // \"Create breadcrumb\" button is only visible when the window is set to\n  // something other than the full range and mouse is hovering over the MiniMap\n  #changeBreadcrumbButtonVisibility(windowLeftRatio: number, windowRightRatio: number): void {\n    if (!this.#breadcrumbsEnabled) {\n      return;\n    }\n    if ((windowRightRatio >= 1 && windowLeftRatio <= 0) || !this.#mouseOverGridOverview) {\n      this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', false);\n    } else {\n      this.breadcrumbButtonContainerElement.classList.toggle('is-breadcrumb-button-visible', true);\n    }\n  }\n\n  #createBreadcrumb(): void {\n    this.dispatchEventToListeners(Events.BREADCRUMB_ADDED, this.calculateWindowValue());\n  }\n\n  private updateCurtains(): void {\n    const windowLeftRatio = this.windowLeftRatio;\n    const windowRightRatio = this.windowRightRatio;\n    let leftRatio = windowLeftRatio;\n    let rightRatio = windowRightRatio;\n    const widthRatio = rightRatio - leftRatio;\n\n    // OverviewGrids that are instantiated before the parentElement is shown will have a parent element client width of 0 which throws off the 'factor' calculation\n    if (this.parentElement.clientWidth !== 0) {\n      // We allow actual time window to be arbitrarily small but don't want the UI window to be too small.\n      const widthInPixels = widthRatio * this.parentElement.clientWidth;\n      const minWidthInPixels = MinSelectableSize / 2;\n      if (widthInPixels < minWidthInPixels) {\n        const factor = minWidthInPixels / widthInPixels;\n        leftRatio = ((windowRightRatio + windowLeftRatio) - widthRatio * factor) / 2;\n        rightRatio = ((windowRightRatio + windowLeftRatio) + widthRatio * factor) / 2;\n      }\n    }\n    const leftResizerPercLeftOffset = (100 * leftRatio);\n    const rightResizerPercLeftOffset = (100 * rightRatio);\n    const rightResizerPercRightOffset = (100 - (100 * rightRatio));\n\n    const leftResizerPercLeftOffsetString = leftResizerPercLeftOffset + '%';\n    const rightResizerPercLeftOffsetString = rightResizerPercLeftOffset + '%';\n\n    this.leftResizeElement.style.left = leftResizerPercLeftOffsetString;\n    this.rightResizeElement.style.left = rightResizerPercLeftOffsetString;\n\n    this.leftCurtainElement.style.width = leftResizerPercLeftOffsetString;\n    this.rightCurtainElement.style.width = rightResizerPercRightOffset + '%';\n\n    this.breadcrumbButtonContainerElement.style.marginLeft =\n        (leftResizerPercLeftOffset > 0) ? leftResizerPercLeftOffset + '%' : '0%';\n    this.breadcrumbButtonContainerElement.style.marginRight =\n        (rightResizerPercRightOffset > 0) ? rightResizerPercRightOffset + '%' : '0%';\n\n    if (this.curtainsRange) {\n      this.curtainsRange.textContent = this.getWindowRange().toFixed(0) + ' ms';\n    }\n\n    this.updateResizeElementAriaValue(leftResizerPercLeftOffset, rightResizerPercLeftOffset);\n    if (this.calculator) {\n      this.updateResizeElementPositionLabels();\n    } else {\n      this.updateResizeElementPercentageLabels(leftResizerPercLeftOffsetString, rightResizerPercLeftOffsetString);\n    }\n\n    this.toggleBreadcrumbZoomButtonDisplay();\n  }\n\n  private toggleBreadcrumbZoomButtonDisplay(): void {\n    if (this.breadcrumbZoomIcon) {\n      // disable button that creates breadcrumbs and hide the zoom icon\n      // when the selected window is smaller than 4.5 ms\n      // 4.5 is rounded to 5 in the UI\n      if (this.getWindowRange() < 4.5) {\n        this.breadcrumbZoomIcon.style.display = 'none';\n        this.breadcrumbButtonContainerElement.style.pointerEvents = 'none';\n      } else {\n        this.breadcrumbZoomIcon.style.display = 'flex';\n        this.breadcrumbButtonContainerElement.style.pointerEvents = 'auto';\n      }\n    }\n  }\n\n  private getWindowRange(): number {\n    if (!this.calculator) {\n      throw new Error('No calculator to calculate window range');\n    }\n\n    const leftRatio = this.windowLeftRatio > 0 ? this.windowLeftRatio : 0;\n    const rightRatio = this.windowRightRatio < 1 ? this.windowRightRatio : 1;\n    return (this.calculator.boundarySpan() * (rightRatio - leftRatio));\n  }\n\n  private setWindowPosition(startPixel: number|null, endPixel: number|null): void {\n    const clientWidth = this.parentElement.clientWidth;\n    const windowLeft = typeof startPixel === 'number' ? startPixel / clientWidth : this.windowLeftRatio;\n    const windowRight = typeof endPixel === 'number' ? endPixel / clientWidth : this.windowRightRatio;\n    this.setWindowRatio(windowLeft || 0, windowRight || 0);\n  }\n\n  private onMouseWheel(event: Event): void {\n    const wheelEvent = (event as WheelEvent);\n    if (!this.resizeEnabled) {\n      return;\n    }\n    if (wheelEvent.deltaY) {\n      const zoomFactor = 1.1;\n      const wheelZoomSpeed = 1 / 53;\n\n      const reference = wheelEvent.offsetX / this.parentElement.clientWidth;\n      this.zoom(Math.pow(zoomFactor, wheelEvent.deltaY * wheelZoomSpeed), reference);\n    }\n    if (wheelEvent.deltaX) {\n      let offset = Math.round(wheelEvent.deltaX * WindowScrollSpeedFactor);\n      const windowLeftPixel = this.leftResizeElement.offsetLeft + ResizerOffset;\n      const windowRightPixel = this.rightResizeElement.offsetLeft + ResizerOffset;\n\n      if (windowLeftPixel - offset < 0) {\n        offset = windowLeftPixel;\n      }\n\n      if (windowRightPixel - offset > this.parentElement.clientWidth) {\n        offset = windowRightPixel - this.parentElement.clientWidth;\n      }\n\n      this.setWindowPosition(windowLeftPixel - offset, windowRightPixel - offset);\n\n      wheelEvent.preventDefault();\n    }\n  }\n\n  zoom(factor: number, reference: number): void {\n    let leftRatio: number = this.windowLeftRatio || 0;\n    let rightRatio: number = this.windowRightRatio || 0;\n    const windowSizeRatio = rightRatio - leftRatio;\n    let newWindowSizeRatio: 1|number = factor * windowSizeRatio;\n    if (newWindowSizeRatio > 1) {\n      newWindowSizeRatio = 1;\n      factor = newWindowSizeRatio / windowSizeRatio;\n    }\n    leftRatio = reference + (leftRatio - reference) * factor;\n    leftRatio = Platform.NumberUtilities.clamp(leftRatio, 0, 1 - newWindowSizeRatio);\n\n    rightRatio = reference + (rightRatio - reference) * factor;\n    rightRatio = Platform.NumberUtilities.clamp(rightRatio, newWindowSizeRatio, 1);\n    this.setWindowRatio(leftRatio, rightRatio);\n  }\n}\n\nexport const enum Events {\n  WINDOW_CHANGED = 'WindowChanged',\n  WINDOW_CHANGED_WITH_POSITION = 'WindowChangedWithPosition',\n  BREADCRUMB_ADDED = 'BreadcrumbAdded',\n}\n\nexport interface WindowChangedWithPositionEvent {\n  rawStartValue: number;\n  rawEndValue: number;\n}\n\nexport interface EventTypes {\n  [Events.WINDOW_CHANGED]: void;\n  [Events.BREADCRUMB_ADDED]: WindowChangedWithPositionEvent;\n  [Events.WINDOW_CHANGED_WITH_POSITION]: WindowChangedWithPositionEvent;\n}\n\nexport class WindowSelector {\n  private startPosition: number;\n  private width: number;\n  private windowSelector: HTMLDivElement;\n\n  constructor(parent: Element, position: number) {\n    this.startPosition = position;\n    this.width = (parent as HTMLElement).offsetWidth;\n    this.windowSelector = document.createElement('div');\n    this.windowSelector.className = 'overview-grid-window-selector';\n    this.windowSelector.style.left = this.startPosition + 'px';\n    this.windowSelector.style.right = this.width - this.startPosition + 'px';\n    parent.appendChild(this.windowSelector);\n  }\n\n  close(position: number): {\n    start: number,\n    end: number,\n  } {\n    position = Math.max(0, Math.min(position, this.width));\n    this.windowSelector.remove();\n    return this.startPosition < position ? {start: this.startPosition, end: position} :\n                                           {start: position, end: this.startPosition};\n  }\n\n  updatePosition(position: number): void {\n    position = Math.max(0, Math.min(position, this.width));\n    if (position < this.startPosition) {\n      this.windowSelector.style.left = position + 'px';\n      this.windowSelector.style.right = this.width - this.startPosition + 'px';\n    } else {\n      this.windowSelector.style.left = this.startPosition + 'px';\n      this.windowSelector.style.right = this.width - position + 'px';\n    }\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.overview-grid-window-selector {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  background-color: var(--sys-color-state-ripple-primary);\n  z-index: 250;\n  pointer-events: none;\n}\n\n.overview-grid-window-resizer {\n  position: absolute;\n  top: 0;\n  height: 19px;\n  width: 10px;\n  margin-left: -5px; /* half width (incl the border) */\n  background-color: var(--sys-color-tonal-container);\n  border: 1px solid var(--sys-color-tonal-outline);\n  z-index: 500;\n  border-radius: 3px;\n}\n\n/* Grip lines within the handle */\n.overview-grid-window-resizer::before,\n.overview-grid-window-resizer::after {\n  content: \"\";\n  width: 1px;\n  background: var(--sys-color-primary);\n  height: 7px;\n  position: absolute;\n  left: 2px;\n  top: 5px;\n  border-radius: 1px;\n}\n\n.overview-grid-window-resizer::after {\n  left: 5px;\n}\n\n.overview-grid-window-resizer:focus-visible {\n  background-color: var(--sys-color-state-focus-highlight);\n}\n\n.overview-grid-cursor-area {\n  position: absolute;\n  inset: 20px 0 0;\n  z-index: 500;\n  cursor: text;\n}\n\n.overview-grid-cursor-position {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 2px;\n  background-color: var(--sys-color-primary);\n  z-index: 500;\n  pointer-events: none;\n  visibility: hidden;\n  overflow: hidden;\n}\n\n.window-curtain-left,\n.window-curtain-right {\n  background-color: var(--sys-color-state-ripple-primary);\n  position: absolute;\n  top: 0;\n  height: 100%;\n  z-index: 300;\n  pointer-events: none;\n  border: 2px none var(--sys-color-tonal-outline);\n}\n\n.window-curtain-left {\n  left: 0;\n  border-right-style: solid;\n}\n\n.window-curtain-right {\n  right: 0;\n  border-left-style: solid;\n}\n\n.create-breadcrumb-button-container {\n  visibility: hidden;\n  opacity: 0%;\n  transition: opacity 100ms 250ms;\n  display: flex;\n  position: absolute;\n  top: 15px;\n  justify-content: center;\n  z-index: 600;\n  left: 0;\n  right: 0;\n}\n\n.is-breadcrumb-button-visible {\n  visibility: visible;\n  opacity: 100%;\n}\n\n.create-breadcrumb-button-container.with-screenshots {\n  /* We have more room when screenshots are enabled,\n   * so push the button down slightly */\n  top: 20px;\n}\n\n.create-breadcrumb-button {\n  display: flex;\n  flex-shrink: 0;\n  align-items: center;\n  background: var(--sys-color-cdt-base-container);\n  box-shadow: var(--drop-shadow-depth-3);\n  border-radius: 50px;\n  padding: 1px 6px;\n  gap: 2px;\n}\n\n.create-breadcrumb-button:active {\n  /* On minimap cursor changes to text to selected an area,\n  * so keep it as default on the breadcrumb button */\n  cursor: default;\n}\n\n.create-breadcrumb-button:hover {\n  background: var(--sys-color-neutral-container);\n}\n\n@media (forced-colors: active) {\n  .overview-grid-cursor-position {\n    forced-color-adjust: none;\n    background-color: Highlight;\n  }\n\n  .window-curtain-left,\n  .window-curtain-right {\n    background-color: transparent;\n    border-color: ButtonText;\n  }\n\n  .overview-grid-window-resizer {\n    background-color: ButtonText;\n  }\n\n  .overview-grid-window-resizer:hover,\n  .overview-grid-window-resizer:active,\n  .overview-grid-window-resizer:focus-visible {\n    forced-color-adjust: none;\n    background-color: Highlight;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./overviewGrid.css')} */`;", "// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport {html, render, svg} from '../../../lit/lit.js';\nimport * as VisualLogging from '../../../visual_logging/visual_logging.js';\n\nimport pieChartStyles from './pieChart.css.js';\n\nconst UIStrings = {\n  /**\n   *@description Text for sum\n   */\n  total: 'Total',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/PieChart.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface Slice {\n  value: number;\n  color: string;\n  title: string;\n}\n\nexport interface PieChartData {\n  chartName: string;\n  size: number;\n  formatter: (value: number) => string;\n  showLegend: boolean;\n  total: number;\n  slices: Slice[];\n}\n// If the slices are not available when constructing the pie chart, set .data\n// immediately, with total=0 and slices=[], so that the chart is rendered with\n// the correct initial size. This avoids a layout shift when the slices are\n// later populated.\nexport class PieChart extends HTMLElement {\n  private readonly shadow = this.attachShadow({mode: 'open'});\n  private chartName = '';\n  private size = 0;\n  private formatter = (val: number): string => String(val);\n  private showLegend = false;\n  private total = 0;\n  private slices: readonly Slice[] = [];\n\n  private totalSelected = true;\n  private sliceSelected = -1;\n\n  private readonly innerR = 0.618;\n  private lastAngle = -Math.PI / 2;\n\n  set data(data: PieChartData) {\n    this.chartName = data.chartName;\n    this.size = data.size;\n    this.formatter = data.formatter;\n    this.showLegend = data.showLegend;\n    this.total = data.total;\n    this.slices = data.slices;\n\n    this.render();\n  }\n\n  private render(): void {\n    this.lastAngle = -Math.PI / 2;\n    // clang-format off\n    const output = html`\n      <style>${pieChartStyles}</style>\n      <div class=\"root\" role=\"group\" @keydown=${this.onKeyDown} aria-label=${this.chartName}\n          jslog=${VisualLogging.pieChart().track({keydown: 'ArrowUp|ArrowDown'})}>\n        <div class=\"chart-root\" style=\"width: ${this.size}px; height: ${this.size}px;\">\n          ${svg`\n          <svg>\n          <g transform=\"scale(${this.size / 2}) translate(1, 1) scale(0.99, 0.99)\">\n            <circle r=\"1\" stroke=\"hsl(0, 0%, 80%)\" fill=\"transparent\" stroke-width=${1 / this.size}></circle>\n            <circle r=${this.innerR} stroke=\"hsl(0, 0%, 80%)\" fill=\"transparent\" stroke-width=${1 / this.size}></circle>\n            ${this.slices.map((slice, index) => {\n              const selected = this.sliceSelected === index;\n              const tabIndex = selected && !this.showLegend ? '0' : '-1';\n              return svg`<path class=\"slice ${selected ? 'selected' : ''}\"\n                  jslog=${VisualLogging.pieChartSlice().track({click: true})}\n                  @click=${this.onSliceClicked(index)} tabIndex=${tabIndex}\n                  fill=${slice.color} d=${this.getPathStringForSlice(slice)}\n                  aria-label=${slice.title} id=${selected ? 'selectedSlice' : ''}></path>`;\n            })}\n            <!-- This is so that the selected slice is re-drawn on top, to avoid re-ordering slices\n            just to render them properly. -->\n            <use href=\"#selectedSlice\" />\n            </g>\n          </svg>\n          `}\n          <div class=\"pie-chart-foreground\">\n            <div class=\"pie-chart-total ${this.totalSelected ? 'selected' : ''}\" @click=${this.selectTotal}\n                jslog=${VisualLogging.pieChartTotal('select-total').track({click: true})}\n                tabIndex=${this.totalSelected && !this.showLegend ? '1' : '-1'}>\n              ${this.total ? this.formatter(this.total) : ''}\n            </div>\n          </div>\n        </div>\n        ${this.showLegend ? html`\n        <div class=\"pie-chart-legend\" jslog=${VisualLogging.section('legend')}>\n          ${this.slices.map((slice, index) => {\n            const selected = this.sliceSelected === index;\n            return html`\n              <div class=\"pie-chart-legend-row ${selected ? 'selected' : ''}\"\n                  jslog=${VisualLogging.pieChartSlice().track({click: true})}\n                  @click=${this.onSliceClicked(index)} tabIndex=${selected ? '0' : '-1'}>\n                <div class=\"pie-chart-size\">${this.formatter(slice.value)}</div>\n                <div class=\"pie-chart-swatch\" style=\"background-color: ${slice.color};\"></div>\n                <div class=\"pie-chart-name\">${slice.title}</div>\n              </div>`;\n          })}\n          <div class=\"pie-chart-legend-row ${this.totalSelected ? 'selected' : ''}\"\n              jslog=${VisualLogging.pieChartTotal('select-total').track({click: true})}\n              @click=${this.selectTotal} tabIndex=${this.totalSelected ? '0' : '-1'}>\n            <div class=\"pie-chart-size\">${this.formatter(this.total)}</div>\n            <div class=\"pie-chart-swatch\"></div>\n            <div class=\"pie-chart-name\">${i18nString(UIStrings.total)}</div>\n          </div>\n        </div>\n        ` : ''}\n      </div>\n    `;\n    // clang-format on\n    render(output, this.shadow, {host: this});\n  }\n\n  private onSliceClicked(index: number): () => void {\n    return (): void => {\n      this.selectSlice(index);\n    };\n  }\n\n  private selectSlice(index: number): void {\n    this.totalSelected = false;\n    this.sliceSelected = index;\n    this.render();\n  }\n\n  private selectTotal(): void {\n    this.totalSelected = true;\n    this.sliceSelected = -1;\n    this.render();\n  }\n\n  private selectAndFocusTotal(): void {\n    this.selectTotal();\n    // In order for the :focus-visible styles to work, we need to focus the\n    // newly selected item. This is so that the outline is only shown for focus\n    // caused by keyboard events and not all focus e.g. showing a focus ring\n    // when we click on something is not necessary. The same goes for focusing\n    // slices below.\n    const totalLegendRow = this.shadow.querySelector<HTMLDivElement>('.pie-chart-legend > :last-child');\n    if (!totalLegendRow) {\n      return;\n    }\n    totalLegendRow.focus();\n  }\n\n  private selectAndFocusSlice(index: number): void {\n    this.selectSlice(index);\n    const sliceLegendRow = this.shadow.querySelector<HTMLDivElement>(`.pie-chart-legend > :nth-child(${index + 1})`);\n    if (!sliceLegendRow) {\n      return;\n    }\n    sliceLegendRow.focus();\n  }\n\n  private focusNextElement(): void {\n    if (this.totalSelected) {\n      this.selectAndFocusSlice(0);\n    } else if (this.sliceSelected === this.slices.length - 1) {\n      this.selectAndFocusTotal();\n    } else {\n      this.selectAndFocusSlice(this.sliceSelected + 1);\n    }\n  }\n\n  private focusPreviousElement(): void {\n    if (this.totalSelected) {\n      this.selectAndFocusSlice(this.slices.length - 1);\n    } else if (this.sliceSelected === 0) {\n      this.selectAndFocusTotal();\n    } else {\n      this.selectAndFocusSlice(this.sliceSelected - 1);\n    }\n  }\n\n  private onKeyDown(event: KeyboardEvent): void {\n    let handled = false;\n    if (event.key === 'ArrowDown') {\n      this.focusNextElement();\n      handled = true;\n    } else if (event.key === 'ArrowUp') {\n      this.focusPreviousElement();\n      handled = true;\n    }\n\n    if (handled) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n    }\n  }\n\n  private getPathStringForSlice(slice: Slice): string|undefined {\n    const value = slice.value;\n    let sliceAngle = value / this.total * 2 * Math.PI;\n    if (!isFinite(sliceAngle)) {\n      return;\n    }\n    sliceAngle = Math.min(sliceAngle, 2 * Math.PI * 0.9999);\n    const x1 = Math.cos(this.lastAngle);\n    const y1 = Math.sin(this.lastAngle);\n    this.lastAngle += sliceAngle;\n    const x2 = Math.cos(this.lastAngle);\n    const y2 = Math.sin(this.lastAngle);\n    const r2 = this.innerR;\n    const x3 = x2 * r2;\n    const y3 = y2 * r2;\n    const x4 = x1 * r2;\n    const y4 = y1 * r2;\n    const largeArc = sliceAngle > Math.PI ? 1 : 0;\n\n    const pathString =\n        `M${x1},${y1} A1,1,0,${largeArc},1,${x2},${y2} L${x3},${y3} A${r2},${r2},0,${largeArc},0,${x4},${y4} Z`;\n    return pathString;\n  }\n}\n\ncustomElements.define('devtools-perf-piechart', PieChart);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-perf-piechart': PieChart;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.root {\n  align-items: flex-start; /* keep chart at top so it doesnt change position as the legend changes height */\n  display: flex;\n  min-width: fit-content;\n  white-space: nowrap;\n}\n\n.chart-root {\n  position: relative;\n  overflow: hidden;\n}\n\n.pie-chart-foreground {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 10;\n  top: 0;\n  display: flex;\n  pointer-events: none;\n}\n\n.pie-chart-total {\n  margin: auto;\n  padding: 2px 5px;\n  pointer-events: auto;\n}\n\n:focus {\n  outline-width: 0;\n}\n\n.pie-chart-total.selected {\n  font-weight: bold;\n}\n\n.chart-root .slice.selected {\n  stroke: var(--sys-color-primary);\n  stroke-opacity: 100%;\n  stroke-width: 0.04;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n\n.pie-chart-legend {\n  margin-left: 30px;\n}\n\n.pie-chart-legend-row {\n  margin: 5px 2px 5px auto;\n  padding-right: 25px;\n}\n\n.pie-chart-legend-row.selected {\n  font-weight: bold;\n}\n\n.pie-chart-legend-row:focus-visible {\n  box-shadow: 0 0 0 2px var(--sys-color-state-focus-ring) !important; /* stylelint-disable-line declaration-no-important */\n}\n\n.pie-chart-swatch {\n  display: inline-block;\n  width: 11px;\n  height: 11px;\n  margin: 0 6px;\n  top: 1px;\n  position: relative;\n  border: 1px solid var(--sys-color-neutral-outline);\n}\n\n.pie-chart-name {\n  display: inline-block;\n}\n\n.pie-chart-size {\n  display: inline-block;\n  text-align: right;\n  width: 70px;\n}\n\n@media (forced-colors: active) {\n  .pie-chart-swatch {\n    forced-color-adjust: none;\n    border-color: ButtonText;\n  }\n\n  .pie-chart-total {\n    forced-color-adjust: none;\n    background-color: canvas;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./pieChart.css')} */`;", "// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\n\nimport type {Calculator} from './TimelineGrid.js';\n\nexport class TimelineOverviewCalculator implements Calculator {\n  #minimumBoundary: Trace.Types.Timing.Milli = Trace.Types.Timing.Milli(0);\n  #maximumBoundary: Trace.Types.Timing.Milli = Trace.Types.Timing.Milli(100);\n\n  #displayWidth = 0;\n  private navStartTimes?: readonly Trace.Types.Events.NavigationStart[];\n\n  /**\n   * Given a timestamp, returns its x position in the minimap.\n   *\n   * @param time\n   * @returns position in pixel\n   */\n  computePosition(time: Trace.Types.Timing.Milli): number {\n    return (time - this.#minimumBoundary) / this.boundarySpan() * this.#displayWidth;\n  }\n\n  positionToTime(position: number): Trace.Types.Timing.Milli {\n    if (this.#displayWidth === 0) {\n      return Trace.Types.Timing.Milli(0);\n    }\n    return Trace.Types.Timing.Milli(position / this.#displayWidth * this.boundarySpan() + this.#minimumBoundary);\n  }\n\n  setBounds(minimumBoundary: Trace.Types.Timing.Milli, maximumBoundary: Trace.Types.Timing.Milli): void {\n    this.#minimumBoundary = minimumBoundary;\n    this.#maximumBoundary = maximumBoundary;\n  }\n\n  setNavStartTimes(navStartTimes: readonly Trace.Types.Events.NavigationStart[]): void {\n    this.navStartTimes = navStartTimes;\n  }\n\n  setDisplayWidth(clientWidth: number): void {\n    this.#displayWidth = clientWidth;\n  }\n\n  reset(): void {\n    this.setBounds(\n        Trace.Types.Timing.Milli(0),\n        Trace.Types.Timing.Milli(100),\n    );\n  }\n\n  formatValue(time: Trace.Types.Timing.Milli, precision?: number): string {\n    // If there are nav start times the value needs to be remapped.\n    if (this.navStartTimes) {\n      // Find the latest possible nav start time which is considered earlier\n      // than the value passed through.\n      for (let i = this.navStartTimes.length - 1; i >= 0; i--) {\n        const startTimeMilliseconds = Trace.Helpers.Timing.microToMilli(\n            this.navStartTimes[i].ts,\n        );\n\n        if (time > startTimeMilliseconds) {\n          time = Trace.Types.Timing.Milli(time - (startTimeMilliseconds - this.zeroTime()));\n          break;\n        }\n      }\n    }\n\n    return i18n.TimeUtilities.preciseMillisToString(time - this.zeroTime(), precision);\n  }\n\n  maximumBoundary(): Trace.Types.Timing.Milli {\n    return this.#maximumBoundary;\n  }\n\n  minimumBoundary(): Trace.Types.Timing.Milli {\n    return this.#minimumBoundary;\n  }\n\n  zeroTime(): Trace.Types.Timing.Milli {\n    return this.#minimumBoundary;\n  }\n\n  /**\n   * This function returns the time different between min time and max time of current minimap.\n   *\n   * @returns the time range in milliseconds\n   */\n  boundarySpan(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.#maximumBoundary - this.#minimumBoundary);\n  }\n}\n", "/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as TraceBounds from '../../../../services/trace_bounds/trace_bounds.js';\nimport * as VisualLoggging from '../../../visual_logging/visual_logging.js';\nimport * as UI from '../../legacy.js';\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport {Events as OverviewGridEvents, OverviewGrid, type WindowChangedWithPositionEvent} from './OverviewGrid.js';\nimport {TimelineOverviewCalculator} from './TimelineOverviewCalculator.js';\nimport timelineOverviewInfoStyles from './timelineOverviewInfo.css.js';\n\nexport class TimelineOverviewPane extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(\n    UI.Widget.VBox) {\n  readonly overviewCalculator: TimelineOverviewCalculator;\n  private readonly overviewGrid: OverviewGrid;\n  private readonly cursorArea: HTMLElement;\n  private cursorElement: HTMLElement;\n  private overviewControls: TimelineOverview[] = [];\n  private markers = new Map<number, HTMLDivElement>();\n  private readonly overviewInfo: OverviewInfo;\n  private readonly updateThrottler = new Common.Throttler.Throttler(100);\n  private cursorEnabled = false;\n  private cursorPosition = 0;\n  private lastWidth = 0;\n  private windowStartTime = Trace.Types.Timing.Milli(0);\n  private windowEndTime = Trace.Types.Timing.Milli(Infinity);\n  private muteOnWindowChanged = false;\n  #dimHighlightSVG: Element;\n  readonly #boundOnThemeChanged = this.#onThemeChanged.bind(this);\n\n  constructor(prefix: string) {\n    super();\n    this.element.id = prefix + '-overview-pane';\n\n    this.overviewCalculator = new TimelineOverviewCalculator();\n    this.overviewGrid = new OverviewGrid(prefix, this.overviewCalculator);\n    this.overviewGrid.element.setAttribute(\n        'jslog', `${VisualLoggging.timeline(`${prefix}-overview`).track({click: true, drag: true, hover: true})}`);\n    this.element.appendChild(this.overviewGrid.element);\n    this.cursorArea = this.overviewGrid.element.createChild('div', 'overview-grid-cursor-area');\n    this.cursorElement = this.overviewGrid.element.createChild('div', 'overview-grid-cursor-position');\n    this.cursorArea.addEventListener('mousemove', this.onMouseMove.bind(this), true);\n    this.cursorArea.addEventListener('mouseleave', this.hideCursor.bind(this), true);\n\n    this.overviewGrid.setResizeEnabled(false);\n    this.overviewGrid.addEventListener(OverviewGridEvents.WINDOW_CHANGED_WITH_POSITION, this.onWindowChanged, this);\n    this.overviewGrid.addEventListener(OverviewGridEvents.BREADCRUMB_ADDED, this.onBreadcrumbAdded, this);\n    this.overviewGrid.setClickHandler(this.onClick.bind(this));\n\n    this.overviewInfo = new OverviewInfo(this.cursorElement);\n\n    this.#dimHighlightSVG = UI.UIUtils.createSVGChild(this.element, 'svg', 'timeline-minimap-dim-highlight-svg hidden');\n    this.#initializeDimHighlightSVG();\n  }\n\n  enableCreateBreadcrumbsButton(): void {\n    const breadcrumbsElement = this.overviewGrid.enableCreateBreadcrumbsButton();\n    breadcrumbsElement.addEventListener('mousemove', this.onMouseMove.bind(this), true);\n    breadcrumbsElement.addEventListener('mouseleave', this.hideCursor.bind(this), true);\n  }\n\n  private onMouseMove(event: Event): void {\n    if (!this.cursorEnabled) {\n      return;\n    }\n    const mouseEvent = (event as MouseEvent);\n    const target = (event.target as HTMLElement);\n    const offsetLeftRelativeToCursorArea =\n        target.getBoundingClientRect().left - this.cursorArea.getBoundingClientRect().left;\n    this.cursorPosition = mouseEvent.offsetX + offsetLeftRelativeToCursorArea;\n    this.cursorElement.style.left = this.cursorPosition + 'px';\n    this.cursorElement.style.visibility = 'visible';\n\n    // Dispatch an event to notify the flame chart to show a timestamp marker for the current timestamp if it's visible\n    // in the flame chart.\n    const timeInMilliSeconds = this.overviewCalculator.positionToTime(this.cursorPosition);\n    const timeWindow = this.overviewGrid.calculateWindowValue();\n    if (Trace.Types.Timing.Milli(timeWindow.rawStartValue) <= timeInMilliSeconds &&\n        timeInMilliSeconds <= Trace.Types.Timing.Milli(timeWindow.rawEndValue)) {\n      const timeInMicroSeconds = Trace.Helpers.Timing.milliToMicro(timeInMilliSeconds);\n      this.dispatchEventToListeners(Events.OVERVIEW_PANE_MOUSE_MOVE, {timeInMicroSeconds});\n    } else {\n      this.dispatchEventToListeners(Events.OVERVIEW_PANE_MOUSE_LEAVE);\n    }\n\n    void this.overviewInfo.setContent(this.buildOverviewInfo());\n  }\n\n  private async buildOverviewInfo(): Promise<DocumentFragment> {\n    const document = this.element.ownerDocument;\n    const x = this.cursorPosition;\n    const elements = await Promise.all(this.overviewControls.map(control => control.overviewInfoPromise(x)));\n    const fragment = document.createDocumentFragment();\n    const nonNullElements = (elements.filter(element => element !== null));\n    fragment.append(...nonNullElements);\n    return fragment;\n  }\n\n  private hideCursor(): void {\n    this.cursorElement.style.visibility = 'hidden';\n    this.dispatchEventToListeners(Events.OVERVIEW_PANE_MOUSE_LEAVE);\n    this.overviewInfo.hide();\n  }\n\n  #onThemeChanged(): void {\n    this.scheduleUpdate();\n  }\n\n  override wasShown(): void {\n    super.wasShown();\n    const start = TraceBounds.TraceBounds.BoundsManager.instance().state()?.milli.minimapTraceBounds.min;\n    const end = TraceBounds.TraceBounds.BoundsManager.instance().state()?.milli.minimapTraceBounds.max;\n    this.update(start, end);\n    ThemeSupport.ThemeSupport.instance().addEventListener(\n        ThemeSupport.ThemeChangeEvent.eventName, this.#boundOnThemeChanged);\n  }\n\n  override willHide(): void {\n    ThemeSupport.ThemeSupport.instance().removeEventListener(\n        ThemeSupport.ThemeChangeEvent.eventName, this.#boundOnThemeChanged);\n    this.overviewInfo.hide();\n    super.willHide();\n  }\n\n  override onResize(): void {\n    const width = this.element.offsetWidth;\n    if (width === this.lastWidth) {\n      return;\n    }\n    this.lastWidth = width;\n    this.scheduleUpdate();\n  }\n\n  setOverviewControls(overviewControls: TimelineOverview[]): void {\n    for (let i = 0; i < this.overviewControls.length; ++i) {\n      this.overviewControls[i].dispose();\n    }\n\n    for (let i = 0; i < overviewControls.length; ++i) {\n      overviewControls[i].setCalculator(this.overviewCalculator);\n      overviewControls[i].show(this.overviewGrid.element);\n    }\n    this.overviewControls = overviewControls;\n    this.update();\n  }\n\n  set showingScreenshots(isShowing: boolean) {\n    this.overviewGrid.showingScreenshots = isShowing;\n  }\n\n  setBounds(minimumBoundary: Trace.Types.Timing.Milli, maximumBoundary: Trace.Types.Timing.Milli): void {\n    if (minimumBoundary === this.overviewCalculator.minimumBoundary() &&\n        maximumBoundary === this.overviewCalculator.maximumBoundary()) {\n      return;\n    }\n    this.overviewCalculator.setBounds(minimumBoundary, maximumBoundary);\n    this.overviewGrid.setResizeEnabled(true);\n    this.cursorEnabled = true;\n    this.scheduleUpdate(minimumBoundary, maximumBoundary);\n  }\n\n  setNavStartTimes(navStartTimes: readonly Trace.Types.Events.NavigationStart[]): void {\n    this.overviewCalculator.setNavStartTimes(navStartTimes);\n  }\n\n  scheduleUpdate(start?: Trace.Types.Timing.Milli, end?: Trace.Types.Timing.Milli): void {\n    void this.updateThrottler.schedule(async () => {\n      this.update(start, end);\n    });\n  }\n\n  update(start?: Trace.Types.Timing.Milli, end?: Trace.Types.Timing.Milli): void {\n    if (!this.isShowing()) {\n      return;\n    }\n    this.overviewCalculator.setDisplayWidth(this.overviewGrid.clientWidth());\n    for (let i = 0; i < this.overviewControls.length; ++i) {\n      this.overviewControls[i].update(start, end);\n    }\n    this.overviewGrid.updateDividers(this.overviewCalculator);\n    this.updateMarkers();\n    this.updateWindow();\n  }\n\n  setMarkers(markers: Map<number, HTMLDivElement>): void {\n    this.markers = markers;\n  }\n\n  /**\n   * Dim the time marker outside the highlight time bounds.\n   *\n   * @param highlightBounds the time bounds to highlight, if it is empty, it means to highlight everything.\n   */\n  #dimMarkers(highlightBounds?: Trace.Types.Timing.TraceWindowMicro): void {\n    for (const time of this.markers.keys()) {\n      const marker = this.markers.get(time);\n      if (!marker) {\n        continue;\n      }\n      const timeInMicroSeconds = Trace.Helpers.Timing.milliToMicro(Trace.Types.Timing.Milli(time));\n      const dim = highlightBounds && !Trace.Helpers.Timing.timestampIsInBounds(highlightBounds, timeInMicroSeconds);\n\n      // `filter: grayscale(1)`  will make the element fully completely grayscale.\n      marker.style.filter = `grayscale(${dim ? 1 : 0})`;\n    }\n  }\n\n  private updateMarkers(): void {\n    const filteredMarkers = new Map<number, Element>();\n    for (const time of this.markers.keys()) {\n      const marker = this.markers.get(time) as HTMLElement;\n      const position = Math.round(this.overviewCalculator.computePosition(Trace.Types.Timing.Milli(time)));\n      // Limit the number of markers to one per pixel.\n      if (filteredMarkers.has(position)) {\n        continue;\n      }\n      filteredMarkers.set(position, marker);\n      marker.style.left = position + 'px';\n    }\n    this.overviewGrid.removeEventDividers();\n    this.overviewGrid.addEventDividers([...filteredMarkers.values()]);\n  }\n\n  reset(): void {\n    this.windowStartTime = Trace.Types.Timing.Milli(0);\n    this.windowEndTime = Trace.Types.Timing.Milli(Infinity);\n    this.overviewCalculator.reset();\n    this.overviewGrid.reset();\n    this.overviewGrid.setResizeEnabled(false);\n    this.cursorEnabled = false;\n    this.hideCursor();\n    this.markers = new Map();\n    for (const control of this.overviewControls) {\n      control.reset();\n    }\n    this.overviewInfo.hide();\n    this.scheduleUpdate();\n  }\n\n  private onClick(event: Event): boolean {\n    return this.overviewControls.some(control => control.onClick(event));\n  }\n\n  private onBreadcrumbAdded(): void {\n    this.dispatchEventToListeners(Events.OVERVIEW_PANE_BREADCRUMB_ADDED, {\n      startTime: Trace.Types.Timing.Milli(this.windowStartTime),\n      endTime: Trace.Types.Timing.Milli(this.windowEndTime),\n    });\n  }\n\n  private onWindowChanged(event: Common.EventTarget.EventTargetEvent<WindowChangedWithPositionEvent>): void {\n    if (this.muteOnWindowChanged) {\n      return;\n    }\n    // Always use first control as a time converter.\n    if (!this.overviewControls.length) {\n      return;\n    }\n\n    this.windowStartTime = Trace.Types.Timing.Milli(\n        event.data.rawStartValue === this.overviewCalculator.minimumBoundary() ? 0 : event.data.rawStartValue);\n    this.windowEndTime = Trace.Types.Timing.Milli(\n        event.data.rawEndValue === this.overviewCalculator.maximumBoundary() ? Infinity : event.data.rawEndValue);\n\n    const windowTimes = {\n      startTime: Trace.Types.Timing.Milli(this.windowStartTime),\n      endTime: Trace.Types.Timing.Milli(this.windowEndTime),\n    };\n\n    this.dispatchEventToListeners(Events.OVERVIEW_PANE_WINDOW_CHANGED, windowTimes);\n  }\n\n  setWindowTimes(startTime: Trace.Types.Timing.Milli, endTime: Trace.Types.Timing.Milli): void {\n    if (startTime === this.windowStartTime && endTime === this.windowEndTime) {\n      return;\n    }\n    this.windowStartTime = startTime;\n    this.windowEndTime = endTime;\n    this.updateWindow();\n    this.dispatchEventToListeners(Events.OVERVIEW_PANE_WINDOW_CHANGED, {\n      startTime: Trace.Types.Timing.Milli(startTime),\n      endTime: Trace.Types.Timing.Milli(endTime),\n    });\n  }\n\n  private updateWindow(): void {\n    if (!this.overviewControls.length) {\n      return;\n    }\n    const absoluteMin = this.overviewCalculator.minimumBoundary();\n    const timeSpan = this.overviewCalculator.maximumBoundary() - absoluteMin;\n    const haveRecords = absoluteMin > 0;\n    const left = haveRecords && this.windowStartTime ? Math.min((this.windowStartTime - absoluteMin) / timeSpan, 1) : 0;\n    const right = haveRecords && this.windowEndTime < Infinity ? (this.windowEndTime - absoluteMin) / timeSpan : 1;\n    this.muteOnWindowChanged = true;\n    this.overviewGrid.setWindowRatio(left, right);\n    this.muteOnWindowChanged = false;\n  }\n\n  /**\n   * This function will create three rectangles and a polygon, which will be use to highlight the time range.\n   */\n  #initializeDimHighlightSVG(): void {\n    // Set up the desaturation mask\n    const defs = UI.UIUtils.createSVGChild(this.#dimHighlightSVG, 'defs');\n    const mask = UI.UIUtils.createSVGChild(defs, 'mask') as SVGMaskElement;\n    mask.id = 'dim-highlight-cutouts';\n    /* Within the mask...\n        - black fill = punch, fully transparently, through to the next thing. these are the cutouts to the color.\n        - white fill = be 100% desaturated\n        - grey fill  = show at the Lightness level of grayscale/desaturation\n    */\n\n    // This a rectangle covers the entire SVG and has a light gray fill. This sets the base desaturation level for the\n    // masked area.\n    // The colour here should be fixed because the colour's brightness changes the desaturation level.\n    const showAllRect = UI.UIUtils.createSVGChild(mask, 'rect');\n    showAllRect.setAttribute('width', '100%');\n    showAllRect.setAttribute('height', '100%');\n    showAllRect.setAttribute('fill', 'hsl(0deg 0% 95%)');\n\n    // This rectangle also covers the entire SVG and has a fill with the current background. It is linked to the\n    // `mask` element.\n    // The `mixBlendMode` is set to 'saturation', so this rectangle will completely desaturate the area it covers\n    // within the mask.\n    const desaturateRect = UI.UIUtils.createSVGChild(this.#dimHighlightSVG, 'rect', 'background') as SVGRectElement;\n    desaturateRect.setAttribute('width', '100%');\n    desaturateRect.setAttribute('height', '100%');\n    desaturateRect.setAttribute('fill', ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background'));\n    desaturateRect.setAttribute('mask', `url(#${mask.id})`);\n    desaturateRect.style.mixBlendMode = 'saturation';\n\n    // This rectangle is positioned at the top of the not-to-desaturate time range, with full height and a black fill.\n    // It will be used to \"punch\" through the desaturation, revealing the original colours beneath.\n    // The *black* fill on the \"punch-out\" rectangle is crucial because black is fully transparent in a mask.\n    const punchRect = UI.UIUtils.createSVGChild(mask, 'rect', 'punch');\n    punchRect.setAttribute('y', '0');\n    punchRect.setAttribute('height', '100%');\n    punchRect.setAttribute('fill', 'black');\n\n    // This polygon is for the bracket beyond the not desaturated area.\n    const bracketColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-state-on-header-hover');\n    const bracket = UI.UIUtils.createSVGChild(this.#dimHighlightSVG, 'polygon') as SVGRectElement;\n    bracket.setAttribute('fill', bracketColor);\n\n    ThemeSupport.ThemeSupport.instance().addEventListener(ThemeSupport.ThemeChangeEvent.eventName, () => {\n      const desaturateRect = this.#dimHighlightSVG.querySelector('rect.background');\n      desaturateRect?.setAttribute('fill', ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background'));\n\n      const bracket = this.#dimHighlightSVG.querySelector('polygon');\n      bracket?.setAttribute(\n          'fill', ThemeSupport.ThemeSupport.instance().getComputedValue('--sys-color-state-on-header-hover'));\n    });\n  }\n\n  #addBracket(left: number, right: number): void {\n    const TRIANGLE_SIZE = 5;  // px size of triangles\n    const bracket = this.#dimHighlightSVG.querySelector('polygon');\n    bracket?.setAttribute(\n        'points',\n        `${left},0 ${left},${TRIANGLE_SIZE} ${left + TRIANGLE_SIZE - 1},1 ${right - TRIANGLE_SIZE - 1},1 ${right},${\n            TRIANGLE_SIZE} ${right},0`);\n    bracket?.classList.remove('hidden');\n  }\n\n  #hideBracket(): void {\n    const bracket = this.#dimHighlightSVG.querySelector('polygon');\n    bracket?.classList.add('hidden');\n  }\n\n  highlightBounds(bounds: Trace.Types.Timing.TraceWindowMicro, withBracket: boolean): void {\n    const left = this.overviewCalculator.computePosition(Trace.Helpers.Timing.microToMilli(bounds.min));\n    const right = this.overviewCalculator.computePosition(Trace.Helpers.Timing.microToMilli(bounds.max));\n    this.#dimMarkers(bounds);\n    // Update the punch out rectangle to the not-to-desaturate time range.\n    const punchRect = this.#dimHighlightSVG.querySelector('rect.punch');\n    punchRect?.setAttribute('x', left.toString());\n    punchRect?.setAttribute('width', (right - left).toString());\n\n    if (withBracket) {\n      this.#addBracket(left, right);\n    } else {\n      this.#hideBracket();\n    }\n\n    this.#dimHighlightSVG.classList.remove('hidden');\n  }\n\n  clearBoundsHighlight(): void {\n    this.#dimMarkers();\n    this.#dimHighlightSVG.classList.add('hidden');\n  }\n}\n\nexport const enum Events {\n  OVERVIEW_PANE_WINDOW_CHANGED = 'OverviewPaneWindowChanged',\n  OVERVIEW_PANE_BREADCRUMB_ADDED = 'OverviewPaneBreadcrumbAdded',\n  OVERVIEW_PANE_MOUSE_MOVE = 'OverviewPaneMouseMove',\n  OVERVIEW_PANE_MOUSE_LEAVE = 'OverviewPaneMouseLeave',\n}\n\nexport interface OverviewPaneWindowChangedEvent {\n  startTime: Trace.Types.Timing.Milli;\n  endTime: Trace.Types.Timing.Milli;\n}\n\nexport interface OverviewPaneBreadcrumbAddedEvent {\n  startTime: Trace.Types.Timing.Milli;\n  endTime: Trace.Types.Timing.Milli;\n}\n\nexport interface OverviewPaneMouseMoveEvent {\n  timeInMicroSeconds: Trace.Types.Timing.Micro;\n}\n\nexport interface EventTypes {\n  [Events.OVERVIEW_PANE_WINDOW_CHANGED]: OverviewPaneWindowChangedEvent;\n  [Events.OVERVIEW_PANE_BREADCRUMB_ADDED]: OverviewPaneBreadcrumbAddedEvent;\n  [Events.OVERVIEW_PANE_MOUSE_MOVE]: OverviewPaneMouseMoveEvent;\n  [Events.OVERVIEW_PANE_MOUSE_LEAVE]: void;\n}\n\nexport interface TimelineOverview {\n  show(parentElement: Element, insertBefore?: Element|null): void;\n  // if start and end are specified, data will be filtered and only data within those bound will be displayed\n  update(start?: Trace.Types.Timing.Milli, end?: Trace.Types.Timing.Milli): void;\n  dispose(): void;\n  reset(): void;\n  overviewInfoPromise(x: number): Promise<Element|null>;\n  onClick(event: Event): boolean;\n  setCalculator(calculator: TimelineOverviewCalculator): void;\n}\n\nexport class TimelineOverviewBase extends UI.Widget.VBox implements TimelineOverview {\n  private calculatorInternal: TimelineOverviewCalculator|null;\n  private canvas: HTMLCanvasElement;\n  private contextInternal: CanvasRenderingContext2D|null;\n\n  constructor() {\n    super();\n    this.calculatorInternal = null;\n    this.canvas = this.element.createChild('canvas', 'fill');\n    this.contextInternal = this.canvas.getContext('2d');\n  }\n\n  width(): number {\n    return this.canvas.width;\n  }\n\n  height(): number {\n    return this.canvas.height;\n  }\n\n  context(): CanvasRenderingContext2D {\n    if (!this.contextInternal) {\n      throw new Error('Unable to retrieve canvas context');\n    }\n    return this.contextInternal;\n  }\n\n  calculator(): TimelineOverviewCalculator|null {\n    return this.calculatorInternal;\n  }\n\n  update(): void {\n    throw new Error('Not implemented');\n  }\n\n  dispose(): void {\n    this.detach();\n  }\n\n  reset(): void {\n  }\n\n  async overviewInfoPromise(_x: number): Promise<Element|null> {\n    return null;\n  }\n\n  setCalculator(calculator: TimelineOverviewCalculator): void {\n    this.calculatorInternal = calculator;\n  }\n\n  onClick(_event: Event): boolean {\n    return false;\n  }\n\n  resetCanvas(): void {\n    if (this.element.clientWidth) {\n      this.setCanvasSize(this.element.clientWidth, this.element.clientHeight);\n    }\n  }\n\n  setCanvasSize(width: number, height: number): void {\n    this.canvas.width = width * window.devicePixelRatio;\n    this.canvas.height = height * window.devicePixelRatio;\n  }\n}\n\nexport class OverviewInfo {\n  private readonly anchorElement: Element;\n  private glassPane: UI.GlassPane.GlassPane;\n  private visible: boolean;\n  private readonly element: Element;\n\n  constructor(anchor: Element) {\n    this.anchorElement = anchor;\n    this.glassPane = new UI.GlassPane.GlassPane();\n    this.glassPane.setPointerEventsBehavior(UI.GlassPane.PointerEventsBehavior.PIERCE_CONTENTS);\n    this.glassPane.setMarginBehavior(UI.GlassPane.MarginBehavior.DEFAULT_MARGIN);\n    this.glassPane.setSizeBehavior(UI.GlassPane.SizeBehavior.MEASURE_CONTENT);\n    this.visible = false;\n    this.element =\n        UI.UIUtils.createShadowRootWithCoreStyles(this.glassPane.contentElement, {cssFile: timelineOverviewInfoStyles})\n            .createChild('div', 'overview-info');\n  }\n\n  async setContent(contentPromise: Promise<DocumentFragment>): Promise<void> {\n    this.visible = true;\n    const content = await contentPromise;\n    if (!this.visible) {\n      return;\n    }\n    this.element.removeChildren();\n    this.element.appendChild(content);\n    this.glassPane.setContentAnchorBox(this.anchorElement.boxInWindow());\n    if (!this.glassPane.isShowing()) {\n      this.glassPane.show((this.anchorElement.ownerDocument));\n    }\n  }\n\n  hide(): void {\n    this.visible = false;\n    this.glassPane.hide();\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2017 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.overview-info:not(:empty) {\n  display: flex;\n  background: var(--sys-color-cdt-base-container);\n  box-shadow: var(--sys-elevation-level2);\n  padding: var(--sys-size-4);\n  border-radius: var(--sys-shape-corner-small);\n}\n\n.overview-info .frame .time {\n  display: none;\n}\n\n.overview-info .frame .thumbnail img {\n  max-width: 50vw;\n  max-height: 50vh;\n}\n\n/*# sourceURL=${import.meta.resolve('./timelineOverviewInfo.css')} */`;"],
  "mappings": "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",
  "names": ["Common", "Platform", "UI", "i18n", "Platform", "ThemeSupport", "ThemeSupport", "Platform", "ThemeSupport", "UIStrings", "str_", "i18nString", "entryIndex", "color", "startTime", "endTime", "Dialog", "Common", "Host", "i18n", "Trace", "VisualLogging", "UI", "UIStrings", "str_", "i18nString", "Dialog", "SDK", "Common", "Host", "SDK", "i18n", "UIStrings", "str_", "i18nString", "Common", "i18n", "Platform", "VisualLogging", "UI", "UIStrings", "str_", "i18nString", "window", "i18n", "VisualLogging", "UIStrings", "str_", "i18nString", "i18n", "Trace", "Common", "Trace", "UI", "ThemeSupport", "document", "desaturateRect", "bracket"]
}
