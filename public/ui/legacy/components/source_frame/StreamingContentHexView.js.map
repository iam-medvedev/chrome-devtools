{"version":3,"file":"StreamingContentHexView.js","sourceRoot":"","sources":["../../../../../../../../front_end/ui/legacy/components/source_frame/StreamingContentHexView.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TextUtils from '../../../../models/text_utils/text_utils.js';\nimport * as LinearMemoryInspectorComponents from '../../../../panels/linear_memory_inspector/components/components.js';\nimport * as UI from '../../legacy.js';\n\nconst MEMORY_TRANSFER_MIN_CHUNK_SIZE = 1000;\n\n/**\n * This is a slightly reduced version of `panels/LinearMemoryInspectorPane.LinearMemoryInspectorView.\n *\n * It's not hooked up to the LinearMemoryInspectorController and it operates on a fixed memory array thats\n * known upfront.\n */\nclass LinearMemoryInspectorView extends UI.Widget.VBox {\n  #memory = new Uint8Array([0]);\n  #address = 0;\n  #inspector = new LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector();\n\n  constructor() {\n    super(false);\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent.eventName,\n        this.#memoryRequested.bind(this));\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.AddressChangedEvent.eventName, event => {\n          this.#address = event.data;\n        });\n    this.contentElement.appendChild(this.#inspector);\n  }\n\n  override wasShown(): void {\n    this.refreshData();\n  }\n\n  setMemory(memory: Uint8Array<ArrayBuffer>): void {\n    this.#memory = memory;\n    this.refreshData();\n  }\n\n  refreshData(): void {\n    // TODO(szuend): The following lines are copied from `LinearMemoryInspectorController`. We can't reuse them\n    // as depending on a module in `panels/` from a component is a layering violation.\n\n    // Provide a chunk of memory that covers the address to show and some before and after\n    // as 1. the address shown is not necessarily at the beginning of a page and\n    // 2. to allow for fewer memory requests.\n    const memoryChunkStart = Math.max(0, this.#address - MEMORY_TRANSFER_MIN_CHUNK_SIZE / 2);\n    const memoryChunkEnd = memoryChunkStart + MEMORY_TRANSFER_MIN_CHUNK_SIZE;\n    const memory = this.#memory.slice(memoryChunkStart, memoryChunkEnd);\n    this.#inspector.data = {\n      memory,\n      address: this.#address,\n      memoryOffset: memoryChunkStart,\n      outerMemoryLength: this.#memory.length,\n      hideValueInspector: true,\n    };\n  }\n\n  #memoryRequested(event: LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent): void {\n    // TODO(szuend): The following lines are copied from `LinearMemoryInspectorController`. We can't reuse them\n    // as depending on a module in `panels/` from a component is a layering violation.\n\n    const {start, end, address} = event.data;\n    if (address < start || address >= end) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    // Check that the requested start is within bounds.\n    // If the requested end is larger than the actual\n    // memory, it will be automatically capped when\n    // requesting the range.\n    if (start < 0 || start > end || start >= this.#memory.length) {\n      throw new Error('Requested range is out of bounds.');\n    }\n\n    const chunkEnd = Math.max(end, start + MEMORY_TRANSFER_MIN_CHUNK_SIZE);\n    const memory = this.#memory.slice(start, chunkEnd);\n\n    this.#inspector.data = {\n      memory,\n      address,\n      memoryOffset: start,\n      outerMemoryLength: this.#memory.length,\n      hideValueInspector: true,\n    };\n  }\n}\n\n/**\n * Adapter for the linear memory inspector that can show a {@link StreamingContentData}.\n */\nexport class StreamingContentHexView extends LinearMemoryInspectorView {\n  readonly #streamingContentData: TextUtils.StreamingContentData.StreamingContentData;\n\n  constructor(streamingContentData: TextUtils.StreamingContentData.StreamingContentData) {\n    super();\n    this.#streamingContentData = streamingContentData;\n  }\n\n  override wasShown(): void {\n    this.#updateMemoryFromContentData();\n    this.#streamingContentData.addEventListener(\n        TextUtils.StreamingContentData.Events.CHUNK_ADDED, this.#updateMemoryFromContentData, this);\n\n    // No need to call super.wasShown() as we call super.refreshData() ourselves.\n  }\n\n  override willHide(): void {\n    super.willHide();\n    this.#streamingContentData.removeEventListener(\n        TextUtils.StreamingContentData.Events.CHUNK_ADDED, this.#updateMemoryFromContentData, this);\n  }\n\n  #updateMemoryFromContentData(): void {\n    const binaryString = window.atob(this.#streamingContentData.content().base64);\n    const memory = Uint8Array.from(binaryString, m => m.codePointAt(0) as number);\n    this.setMemory(memory);\n  }\n}\n"]}