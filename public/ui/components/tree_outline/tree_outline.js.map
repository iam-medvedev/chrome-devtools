{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/tree_outline/TreeOutline.ts", "treeOutline.css.js", "../../../../../../../front_end/ui/components/tree_outline/TreeOutlineUtils.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-lit-render-outside-of-view */\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Lit from '../../lit/lit.js';\nimport * as VisualLogging from '../../visual_logging/visual_logging.js';\nimport * as CodeHighlighter from '../code_highlighter/code_highlighter.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as RenderCoordinator from '../render_coordinator/render_coordinator.js';\n\nimport treeOutlineStyles from './treeOutline.css.js';\nimport {\n  findNextNodeForTreeOutlineKeyboardNavigation,\n  getNodeChildren,\n  getPathToTreeNode,\n  isExpandableNode,\n  trackDOMNodeToTreeNode,\n  type TreeNode,\n  type TreeNodeId,\n  type TreeNodeWithChildren,\n} from './TreeOutlineUtils.js';\n\nconst {html, Directives: {ifDefined}} = Lit;\n\nexport interface TreeOutlineData<TreeNodeDataType> {\n  defaultRenderer: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => Lit.TemplateResult;\n  /**\n   * Note: it is important that all the TreeNode objects are unique. They are\n   * used internally to the TreeOutline as keys to track state (such as if a\n   * node is expanded or not), and providing the same object multiple times will\n   * cause issues in the TreeOutline.\n   */\n  tree: ReadonlyArray<TreeNode<TreeNodeDataType>>;\n  filter?: (node: TreeNodeDataType) => FilterOption;\n  compact?: boolean;\n}\n\nexport function defaultRenderer(node: TreeNode<string>): Lit.TemplateResult {\n  return html`${node.treeNodeData}`;\n}\n\nexport class ItemSelectedEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemselected';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemSelectedEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOverEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseover';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOverEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOutEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseout';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOutEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\n/**\n *\n * The tree can be filtered by providing a custom filter function.\n * The filter is applied on every node when constructing the tree\n * and proceeds as follows:\n * - If the filter return SHOW for a node, the node is included in the tree.\n * - If the filter returns FLATTEN, the node is ignored but its subtree is included.\n */\nexport const enum FilterOption {\n  SHOW = 'SHOW',\n  FLATTEN = 'FLATTEN',\n}\n\nexport class TreeOutline<TreeNodeDataType> extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #treeData: ReadonlyArray<TreeNode<TreeNodeDataType>> = [];\n  #nodeExpandedMap = new Map<string, boolean>();\n  #domNodeToTreeNodeMap = new WeakMap<HTMLLIElement, TreeNode<TreeNodeDataType>>();\n  #hasRenderedAtLeastOnce = false;\n  /**\n   * If we have expanded to a certain node, we want to focus it once we've\n   * rendered. But we render lazily and wrapped in Lit.until, so we can't\n   * know for sure when that node will be rendered. This variable tracks the\n   * node that we want focused but may not yet have been rendered.\n   */\n  #nodeIdPendingFocus: TreeNodeId|null = null;\n  #selectedTreeNode: TreeNode<TreeNodeDataType>|null = null;\n  #defaultRenderer = (node: TreeNode<TreeNodeDataType>, _state: {isExpanded: boolean}): Lit.TemplateResult => {\n    if (typeof node.treeNodeData !== 'string') {\n      console.warn(`The default TreeOutline renderer simply stringifies its given value. You passed in ${\n          JSON.stringify(\n              node.treeNodeData, null,\n              2)}. Consider providing a different defaultRenderer that can handle nodes of this type.`);\n    }\n    return html`${String(node.treeNodeData)}`;\n  };\n  #nodeFilter?: ((node: TreeNodeDataType) => FilterOption);\n  #compact = false;\n\n  /**\n   * scheduledRender = render() has been called and scheduled a render.\n   */\n  #scheduledRender = false;\n  /**\n   * enqueuedRender = render() was called mid-way through an existing render.\n   */\n  #enqueuedRender = false;\n\n  static get observedAttributes(): string[] {\n    return ['nowrap', 'toplevelbordercolor'];\n  }\n\n  attributeChangedCallback(name: 'nowrap'|'toplevelbordercolor', oldValue: string|null, newValue: string|null): void {\n    if (oldValue === newValue) {\n      return;\n    }\n\n    switch (name) {\n      case 'nowrap': {\n        this.#setNodeKeyNoWrapCSSVariable(newValue);\n        break;\n      }\n      case 'toplevelbordercolor': {\n        this.#setTopLevelNodeBorderColorCSSVariable(newValue);\n        break;\n      }\n    }\n  }\n\n  connectedCallback(): void {\n    this.#setTopLevelNodeBorderColorCSSVariable(this.getAttribute('toplevelbordercolor'));\n    this.#setNodeKeyNoWrapCSSVariable(this.getAttribute('nowrap'));\n  }\n\n  get data(): TreeOutlineData<TreeNodeDataType> {\n    return {\n      tree: this.#treeData as Array<TreeNode<TreeNodeDataType>>,\n      defaultRenderer: this.#defaultRenderer,\n    };\n  }\n\n  set data(data: TreeOutlineData<TreeNodeDataType>) {\n    this.#defaultRenderer = data.defaultRenderer;\n    this.#treeData = data.tree;\n    this.#nodeFilter = data.filter;\n    this.#compact = data.compact || false;\n\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#selectedTreeNode = this.#treeData[0];\n    }\n    void this.#render();\n  }\n\n  /**\n   * Recursively expands the tree from the root nodes, to a max depth. The max\n   * depth is 0 indexed - so a maxDepth of 2 (default) will expand 3 levels: 0,\n   * 1 and 2.\n   */\n  async expandRecursively(maxDepth = 2): Promise<void> {\n    await Promise.all(this.#treeData.map(rootNode => this.#expandAndRecurse(rootNode, 0, maxDepth)));\n    await this.#render();\n  }\n\n  /**\n   * Collapses all nodes in the tree.\n   */\n  async collapseAllNodes(): Promise<void> {\n    this.#nodeExpandedMap.clear();\n    await this.#render();\n  }\n\n  /**\n   * Takes a TreeNode, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNode(targetTreeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    return await this.expandToAndSelectTreeNodeId(targetTreeNode.id);\n  }\n\n  /**\n   * Takes a TreeNode ID, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNodeId(targetTreeNodeId: TreeNodeId): Promise<void> {\n    const pathToTreeNode = await getPathToTreeNode(this.#treeData, targetTreeNodeId);\n\n    if (pathToTreeNode === null) {\n      throw new Error(`Could not find node with id ${targetTreeNodeId} in the tree.`);\n    }\n    pathToTreeNode.forEach((node, index) => {\n      // We don't expand the very last node, which was the target node.\n      if (index < pathToTreeNode.length - 1) {\n        this.#setNodeExpandedState(node, true);\n      }\n    });\n\n    // Mark the node as pending focus so when it is rendered into the DOM we can focus it\n    this.#nodeIdPendingFocus = targetTreeNodeId;\n    await this.#render();\n  }\n\n  /**\n   * Takes a list of TreeNode IDs and expands the corresponding nodes.\n   */\n  expandNodeIds(nodeIds: TreeNodeId[]): Promise<void> {\n    nodeIds.forEach(id => this.#nodeExpandedMap.set(id, true));\n    return this.#render();\n  }\n\n  /**\n   * Takes a TreeNode ID and focuses the corresponding node.\n   */\n  focusNodeId(nodeId: TreeNodeId): Promise<void> {\n    this.#nodeIdPendingFocus = nodeId;\n    return this.#render();\n  }\n\n  async collapseChildrenOfNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    await this.#recursivelyCollapseTreeNodeChildren(treeNode);\n    await this.#render();\n  }\n\n  #setNodeKeyNoWrapCSSVariable(attributeValue: string|null): void {\n    this.style.setProperty('--override-key-whitespace-wrapping', attributeValue !== null ? 'nowrap' : 'initial');\n  }\n\n  #setTopLevelNodeBorderColorCSSVariable(attributeValue: string|null): void {\n    this.style.setProperty('--override-top-node-border', attributeValue ? `1px solid ${attributeValue}` : '');\n  }\n\n  async #recursivelyCollapseTreeNodeChildren(treeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    if (!isExpandableNode(treeNode) || !this.#nodeIsExpanded(treeNode)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(treeNode);\n    const childRecursions = Promise.all(children.map(child => this.#recursivelyCollapseTreeNodeChildren(child)));\n    await childRecursions;\n    this.#setNodeExpandedState(treeNode, false);\n  }\n\n  async #flattenSubtree(node: TreeNodeWithChildren<TreeNodeDataType>, filter: (node: TreeNodeDataType) => FilterOption):\n      Promise<Array<TreeNode<TreeNodeDataType>>> {\n    const children = await getNodeChildren(node);\n    const filteredChildren = [];\n    for (const child of children) {\n      const filtering = filter(child.treeNodeData);\n      // We always include the selected node in the tree, regardless of its filtering status.\n      const toBeSelected = this.#isSelectedNode(child) || child.id === this.#nodeIdPendingFocus;\n      // If a node is already expanded we should not flatten it away.\n      const expanded = this.#nodeExpandedMap.get(child.id);\n      if (filtering === FilterOption.SHOW || toBeSelected || expanded) {\n        filteredChildren.push(child);\n      } else if (filtering === FilterOption.FLATTEN && isExpandableNode(child)) {\n        const grandChildren = await this.#flattenSubtree(child, filter);\n        filteredChildren.push(...grandChildren);\n      }\n    }\n    return filteredChildren;\n  }\n\n  async #fetchNodeChildren(node: TreeNodeWithChildren<TreeNodeDataType>): Promise<Array<TreeNode<TreeNodeDataType>>> {\n    const children = await getNodeChildren(node);\n    const filter = this.#nodeFilter;\n    if (!filter) {\n      return children;\n    }\n    const filteredDescendants = await this.#flattenSubtree(node, filter);\n    return filteredDescendants.length ? filteredDescendants : children;\n  }\n\n  #setNodeExpandedState(node: TreeNode<TreeNodeDataType>, newExpandedState: boolean): void {\n    this.#nodeExpandedMap.set(node.id, newExpandedState);\n  }\n\n  #nodeIsExpanded(node: TreeNode<TreeNodeDataType>): boolean {\n    return this.#nodeExpandedMap.get(node.id) || false;\n  }\n\n  async #expandAndRecurse(node: TreeNode<TreeNodeDataType>, currentDepth: number, maxDepth: number): Promise<void> {\n    if (!isExpandableNode(node)) {\n      return;\n    }\n    this.#setNodeExpandedState(node, true);\n    if (currentDepth === maxDepth || !isExpandableNode(node)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(node);\n    await Promise.all(children.map(child => this.#expandAndRecurse(child, currentDepth + 1, maxDepth)));\n  }\n\n  #onArrowClick(node: TreeNode<TreeNodeDataType>): ((e: Event) => void) {\n    return (event: Event): void => {\n      event.stopPropagation();\n      if (isExpandableNode(node)) {\n        this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n        void this.#render();\n      }\n    };\n  }\n\n  #onNodeClick(event: Event): void {\n    // Avoid it bubbling up to parent tree elements, else clicking a node deep in the tree will toggle it + all its ancestor's visibility.\n    event.stopPropagation();\n    const nodeClickExpandsOrContracts = this.getAttribute('clickabletitle') !== null;\n    const domNode = event.currentTarget as HTMLLIElement;\n    const node = this.#domNodeToTreeNodeMap.get(domNode);\n    if (nodeClickExpandsOrContracts && node && isExpandableNode(node)) {\n      this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n    }\n    void this.#focusTreeNode(domNode);\n  }\n\n  async #focusTreeNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    this.#selectedTreeNode = treeNode;\n    await this.#render();\n    this.dispatchEvent(new ItemSelectedEvent(treeNode));\n    void RenderCoordinator.write('DOMNode focus', () => {\n      domNode.focus();\n    });\n  }\n\n  #processHomeAndEndKeysNavigation(key: 'Home'|'End'): void {\n    if (key === 'Home') {\n      const firstRootNode = this.#shadow.querySelector<HTMLLIElement>('ul[role=\"tree\"] > li[role=\"treeitem\"]');\n      if (firstRootNode) {\n        void this.#focusTreeNode(firstRootNode);\n      }\n    } else if (key === 'End') {\n      /**\n       * The End key takes the user to the last visible node in the tree - you\n       * can think of this as the one that's rendered closest to the bottom of\n       * the page.\n       *\n       * We could walk our tree and compute this - but it will also be the last\n       * li[role=\"treeitem\"] in the DOM because we only render visible nodes.\n       * Therefore we can select all the nodes and pick the last one.\n       */\n      const allTreeItems = this.#shadow.querySelectorAll<HTMLLIElement>('li[role=\"treeitem\"]');\n      const lastTreeItem = allTreeItems[allTreeItems.length - 1];\n      if (lastTreeItem) {\n        void this.#focusTreeNode(lastTreeItem);\n      }\n    }\n  }\n\n  async #processArrowKeyNavigation(key: Platform.KeyboardUtilities.ArrowKey, currentDOMNode: HTMLLIElement):\n      Promise<void> {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n\n    const domNode = findNextNodeForTreeOutlineKeyboardNavigation({\n      currentDOMNode,\n      currentTreeNode,\n      direction: key,\n      setNodeExpandedState: (node, expanded) => this.#setNodeExpandedState(node, expanded),\n    });\n    await this.#focusTreeNode(domNode);\n  }\n\n  #processEnterOrSpaceNavigation(currentDOMNode: HTMLLIElement): void {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n    if (isExpandableNode(currentTreeNode)) {\n      const currentExpandedState = this.#nodeIsExpanded(currentTreeNode);\n      this.#setNodeExpandedState(currentTreeNode, !currentExpandedState);\n      void this.#render();\n    }\n  }\n\n  async #onTreeKeyDown(event: KeyboardEvent): Promise<void> {\n    if (!(event.target instanceof HTMLLIElement)) {\n      throw new Error('event.target was not an <li> element');\n    }\n\n    if (event.key === 'Home' || event.key === 'End') {\n      event.preventDefault();\n      this.#processHomeAndEndKeysNavigation(event.key);\n    } else if (Platform.KeyboardUtilities.keyIsArrowKey(event.key)) {\n      event.preventDefault();\n      await this.#processArrowKeyNavigation(event.key, event.target);\n    } else if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      this.#processEnterOrSpaceNavigation(event.target);\n    }\n  }\n\n  #focusPendingNode(domNode: HTMLLIElement): void {\n    this.#nodeIdPendingFocus = null;\n    void this.#focusTreeNode(domNode);\n  }\n\n  #isSelectedNode(node: TreeNode<TreeNodeDataType>): boolean {\n    if (this.#selectedTreeNode) {\n      return node.id === this.#selectedTreeNode.id;\n    }\n    return false;\n  }\n\n  #renderNode(node: TreeNode<TreeNodeDataType>, {depth, setSize, positionInSet}: {\n    depth: number,\n    setSize: number,\n    positionInSet: number,\n  }): Lit.TemplateResult {\n    let childrenToRender;\n    const nodeIsExpanded = this.#nodeIsExpanded(node);\n    if (!isExpandableNode(node) || !nodeIsExpanded) {\n      childrenToRender = Lit.nothing;\n    } else {\n      const childNodes = this.#fetchNodeChildren(node).then(children => {\n        return children.map((childNode, index) => {\n          return this.#renderNode(childNode, {depth: depth + 1, setSize: children.length, positionInSet: index});\n        });\n      });\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      childrenToRender = html`<ul role=\"group\">${Lit.Directives.until(childNodes)}</ul>`;\n      // clang-format on\n    }\n\n    const nodeIsFocusable = this.#isSelectedNode(node);\n    const tabIndex = nodeIsFocusable ? 0 : -1;\n    const listItemClasses = Lit.Directives.classMap({\n      expanded: isExpandableNode(node) && nodeIsExpanded,\n      parent: isExpandableNode(node),\n      selected: this.#isSelectedNode(node),\n      'is-top-level': depth === 0,\n      compact: this.#compact,\n    });\n    const ariaExpandedAttribute = !isExpandableNode(node) ? undefined : nodeIsExpanded ? 'true' : 'false';\n\n    let renderedNodeKey: Lit.TemplateResult;\n    if (node.renderer) {\n      renderedNodeKey = node.renderer(node, {isExpanded: nodeIsExpanded});\n    } else {\n      renderedNodeKey = this.#defaultRenderer(node, {isExpanded: nodeIsExpanded});\n    }\n\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    return html`\n      <li role=\"treeitem\"\n        tabindex=${tabIndex}\n        aria-setsize=${setSize}\n        aria-expanded=${ifDefined(ariaExpandedAttribute)}\n        aria-level=${depth + 1}\n        aria-posinset=${positionInSet + 1}\n        class=${listItemClasses}\n        jslog=${VisualLogging.treeItem(node.jslogContext).track({click: true, keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space|Home|End'})}\n        @click=${this.#onNodeClick}\n        track-dom-node-to-tree-node=${trackDOMNodeToTreeNode(this.#domNodeToTreeNodeMap, node)}\n        on-render=${ComponentHelpers.Directives.nodeRenderedCallback(domNode => {\n         /**\n          * Because TreeNodes are lazily rendered, you can call\n          * `outline.expandToAndSelect(NodeX)`, but `NodeX` will be rendered at some\n          * later point, once it's been fully resolved, within a Lit.until\n          * directive. That means we don't have a direct hook into when it's\n          * rendered, which we need because we want to focus the element, so we use this directive to receive a callback when the node is rendered.\n          */\n          if (!(domNode instanceof HTMLLIElement)) {\n            return;\n          }\n\n          if (this.#nodeIdPendingFocus && node.id === this.#nodeIdPendingFocus) {\n            this.#focusPendingNode(domNode);\n          }\n        })}\n      >\n        <span class=\"arrow-and-key-wrapper\"\n          @mouseover=${() => {\n            this.dispatchEvent(new ItemMouseOverEvent(node));\n          }}\n          @mouseout=${() => {\n            this.dispatchEvent(new ItemMouseOutEvent(node));\n          }}\n        >\n          <span class=\"arrow-icon\" @click=${this.#onArrowClick(node)} jslog=${VisualLogging.expand().track({click: true})}>\n          </span>\n          <span class=\"tree-node-key\" data-node-key=${node.treeNodeData}>${renderedNodeKey}</span>\n        </span>\n        ${childrenToRender}\n      </li>\n    `;\n    // clang-format on\n  }\n\n  async #render(): Promise<void> {\n    if (this.#scheduledRender) {\n      // If we are already rendering, don't render again immediately, but\n      // enqueue it to be run after we're done on our current render.\n      this.#enqueuedRender = true;\n      return;\n    }\n\n    this.#scheduledRender = true;\n\n    await RenderCoordinator.write('TreeOutline render', () => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      Lit.render(html`\n      <style>${treeOutlineStyles}</style>\n      <style>${CodeHighlighter.codeHighlighterStyles}</style>\n      <div class=\"wrapping-container\">\n        <ul role=\"tree\" @keydown=${this.#onTreeKeyDown}>\n          ${this.#treeData.map((topLevelNode, index) => {\n            return this.#renderNode(topLevelNode, {\n              depth: 0,\n              setSize: this.#treeData.length,\n              positionInSet: index,\n            });\n          })}\n        </ul>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n    this.#hasRenderedAtLeastOnce = true;\n    this.#scheduledRender = false;\n\n    // If render() was called when we were already mid-render, let's re-render\n    // to ensure we're not rendering any stale UI.\n    if (this.#enqueuedRender) {\n      this.#enqueuedRender = false;\n      return await this.#render();\n    }\n  }\n}\n\ncustomElements.define('devtools-tree-outline', TreeOutline);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-tree-outline': TreeOutline<unknown>;\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  --list-group-padding: 16px;\n}\n\nli {\n  border: 2px solid transparent;\n  list-style: none;\n  text-overflow: ellipsis;\n  min-height: 12px;\n}\n\n.compact {\n  border: 0;\n}\n\n.tree-item:hover {\n  background-color: var(--sys-color-state-hover-on-subtle);\n}\n\n.tree-node-key {\n  white-space: var(--override-key-whitespace-wrapping);\n  /* Override the default |min-width: auto| to avoid overflows of flex items */\n  min-width: 0;\n  flex-grow: 1;\n}\n\n.arrow-icon {\n  display: block;\n  user-select: none;\n  mask-image: var(--image-file-arrow-collapse);\n  background-color: var(--icon-default);\n  margin-top: -2px;\n  margin-right: 3px;\n  content: \"\";\n  text-shadow: none;\n  height: 14px;\n  width: 14px;\n  overflow: hidden;\n  flex: none;\n}\n\nul {\n  margin: 0;\n  padding: 0;\n}\n\nul[role=\"group\"] {\n  padding-left: var(--list-group-padding);\n}\n\nli:not(.parent) > .arrow-and-key-wrapper > .arrow-icon {\n  mask-size: 0;\n}\n\nli.parent.expanded > .arrow-and-key-wrapper > .arrow-icon {\n  mask-image: var(--image-file-arrow-drop-down);\n}\n\nli.is-top-level {\n  border-top: var(--override-top-node-border);\n}\n\nli.is-top-level:last-child {\n  border-bottom: var(--override-top-node-border);\n}\n\n:host([animated]) li:not(.is-top-level) {\n  animation-name: slideIn;\n  animation-duration: 150ms;\n  animation-timing-function: cubic-bezier(0, 0, 0.3, 1);\n  animation-fill-mode: forwards;\n}\n\n@keyframes slideIn {\n  from {\n    transform: translateY(-5px);\n    opacity: 0%;\n  }\n\n  to {\n    transform: none;\n    opacity: 100%;\n  }\n}\n\n.arrow-and-key-wrapper {\n  display: flex;\n  align-content: center;\n  align-items: center;\n\n  & ::selection {\n    background-color: var(--sys-color-state-focus-select);\n    color: currentcolor;\n  }\n}\n\n[role=\"treeitem\"]:focus {\n  outline: 0;\n}\n\nul[role=\"tree\"]:focus-within [role=\"treeitem\"].selected > .arrow-and-key-wrapper {\n  background-color: var(--sys-color-tonal-container);\n}\n\n.text-ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.inline-icon {\n  vertical-align: sub;\n}\n\n@media (forced-colors: active) {\n  .arrow-icon {\n    background-color: ButtonText;\n  }\n\n  ul[role=\"tree\"]:focus-within [role=\"treeitem\"].selected {\n    outline: solid 1px ButtonText;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./treeOutline.css')} */`;", "// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Lit from '../../lit/lit.js';\n\nexport type TreeNodeId = string;\n\ninterface BaseTreeNode<TreeNodeDataType> {\n  treeNodeData: TreeNodeDataType;\n  renderer?: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => Lit.TemplateResult;\n  id: TreeNodeId;\n  jslogContext?: string;\n}\n\nexport interface TreeNodeWithChildren<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children: () => Promise<Array<TreeNode<TreeNodeDataType>>>;\n}\n\ninterface LeafNode<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children?: never;\n}\n\nexport type TreeNode<TreeNodeDataType> = TreeNodeWithChildren<TreeNodeDataType>|LeafNode<TreeNodeDataType>;\n\nexport function isExpandableNode<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>):\n    node is TreeNodeWithChildren<TreeNodeDataType> {\n  return 'children' in node;\n}\n\n/**\n * This is a custom lit directive that lets us track the DOM nodes that Lit\n * creates and maps them to the tree node that was given to us. This means we\n * can navigate between real DOM node and structural tree node easily in code.\n */\n\nclass TrackDOMNodeToTreeNode extends Lit.Directive.Directive {\n  constructor(partInfo: Lit.Directive.PartInfo) {\n    super(partInfo);\n\n    if (partInfo.type !== Lit.Directive.PartType.ATTRIBUTE) {\n      throw new Error('TrackDOMNodeToTreeNode directive must be used as an attribute.');\n    }\n  }\n\n  override update(part: Lit.Directive.ElementPart, [weakMap, treeNode]: Lit.Directive.DirectiveParameters<this>): void {\n    const elem = part.element;\n    if (!(elem instanceof HTMLLIElement)) {\n      throw new Error('trackTreeNodeToDOMNode must be used on <li> elements.');\n    }\n    weakMap.set(elem, treeNode);\n  }\n\n  /*\n   * Because this directive doesn't render anything, there's no implementation\n   * here for the render method. But we need it to state the params the\n   * directive takes so the update() method's types are correct. Unfortunately\n   * we have to pass any as the generic type because we can't define this class\n   * using a generic - the generic gets lost when wrapped in the directive call\n   * below.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  render(_weakmap: WeakMap<HTMLLIElement, TreeNode<any>>, _treeNode: TreeNode<any>): void {\n  }\n}\n\nexport const trackDOMNodeToTreeNode = Lit.Directive.directive(TrackDOMNodeToTreeNode);\n\n/**\n * Finds the next sibling of the node's parent, recursing up the tree if\n * required.\n * Given:\n * A\n *   * B\n *     * C\n * D\n * If called on B, this will return D. If called on C, this will also return D.\n */\nconst findNextParentSibling = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  // We go up two parents here because the structure is:\n  // <li treeitem> => <ul group> => <li treeitem>\n  // So if we are on the last treeitem (furthest to the right), we need to find its parent tree item, which is two parents up.\n  const currentDOMNodeParentListItem = currentDOMNode.parentElement?.parentElement;\n\n  if (currentDOMNodeParentListItem && currentDOMNodeParentListItem instanceof HTMLLIElement) {\n    const parentNodeSibling = currentDOMNodeParentListItem.nextElementSibling;\n    // If this parent doesn't have a sibling, recurse up the tree to look for\n    // the nearest parent that does have a sibling.\n    if (parentNodeSibling && parentNodeSibling instanceof HTMLLIElement) {\n      return parentNodeSibling;\n    }\n    return findNextParentSibling(currentDOMNodeParentListItem);\n  }\n  return null;\n};\n\nconst getFirstChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const firstChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:first-child');\n  if (!firstChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n  return firstChild;\n};\n\nconst domNodeIsExpandable = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNode.getAttribute('aria-expanded') !== null;\n};\n\nconst domNodeIsLeafNode = (domNode: HTMLLIElement): boolean => {\n  return !domNodeIsExpandable(domNode);\n};\n\nconst domNodeIsExpanded = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNodeIsExpandable(domNode) && domNode.getAttribute('aria-expanded') === 'true';\n};\n\nconst getDeepLastChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const lastChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:last-child');\n  if (!lastChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n\n  if (domNodeIsExpanded(lastChild)) {\n    return getDeepLastChildOfExpandedTreeNode(lastChild);\n  }\n  return lastChild;\n};\n\nconst getNextSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.nextElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getPreviousSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.previousElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getParentListItemForDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  let parentNode = currentDOMNode.parentElement;\n  if (!parentNode) {\n    return null;\n  }\n  while (parentNode && parentNode.getAttribute('role') !== 'treeitem' &&\n         (parentNode instanceof HTMLLIElement) === false) {\n    parentNode = parentNode.parentElement;\n  }\n  return parentNode as HTMLLIElement;\n};\n\n/**\n * We cache a tree node's children; they are lazily evaluated and if two code\n * paths get the children, we need to make sure they get the same objects.\n *\n * We're OK to use <unknown> here as the weakmap doesn't care and a TreeOutline that\n * adds nodes of type X to the map will always then get children of that type\n * back as that's enforced by the TreeOutline types elsewhere. We can't make\n * this WeakMap easily generic as it's a top level variable.\n */\nconst treeNodeChildrenWeakMap = new WeakMap<TreeNode<unknown>, Array<TreeNode<unknown>>>();\nexport const getNodeChildren =\n    async<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>): Promise<Array<TreeNode<TreeNodeDataType>>> => {\n  if (!node.children) {\n    throw new Error('Asked for children of node that does not have any children.');\n  }\n\n  const cachedChildren = treeNodeChildrenWeakMap.get(node as TreeNode<unknown>);\n  if (cachedChildren) {\n    return cachedChildren as unknown as Array<TreeNode<TreeNodeDataType>>;\n  }\n\n  const children = await node.children();\n  treeNodeChildrenWeakMap.set(node as TreeNode<unknown>, children as Array<TreeNode<unknown>>);\n  return children;\n};\n\n/**\n * Searches the tree and returns a path to the given node.\n * e.g. if the tree is:\n * A\n * - B\n *   - C\n * - D\n *   - E\n *   - F\n *\n * And you look for F, you'll get back [A, D, F]\n */\nexport const getPathToTreeNode =\n    async<TreeNodeDataType>(tree: ReadonlyArray<TreeNode<TreeNodeDataType>>, nodeIdToFind: TreeNodeId):\n        Promise<Array<TreeNode<TreeNodeDataType>>|null> => {\n          for (const rootNode of tree) {\n            const foundPathOrNull = await getPathToTreeNodeRecursively(rootNode, nodeIdToFind, [rootNode]);\n            if (foundPathOrNull !== null) {\n              return foundPathOrNull;\n            }\n          }\n          return null;\n        };\n\nconst getPathToTreeNodeRecursively = async<TreeNodeDataType>(\n    currentNode: TreeNode<TreeNodeDataType>, nodeIdToFind: TreeNodeId,\n    pathToNode: Array<TreeNode<TreeNodeDataType>>): Promise<Array<TreeNode<TreeNodeDataType>>|null> => {\n  if (currentNode.id === nodeIdToFind) {\n    return pathToNode;\n  }\n\n  if (currentNode.children) {\n    const children = await getNodeChildren(currentNode);\n    for (const child of children) {\n      const foundPathOrNull = await getPathToTreeNodeRecursively(child, nodeIdToFind, [...pathToNode, child]);\n      if (foundPathOrNull !== null) {\n        return foundPathOrNull;\n      }\n    }\n  }\n  return null;\n};\n\ninterface KeyboardNavigationOptions<TreeNodeDataType> {\n  currentDOMNode: HTMLLIElement;\n  currentTreeNode: TreeNode<TreeNodeDataType>;\n  direction: Platform.KeyboardUtilities.ArrowKey;\n  setNodeExpandedState: (treeNode: TreeNode<TreeNodeDataType>, expanded: boolean) => void;\n}\n\nexport const findNextNodeForTreeOutlineKeyboardNavigation =\n    <TreeNodeDataType>(options: KeyboardNavigationOptions<TreeNodeDataType>): HTMLLIElement => {\n      const {\n        currentDOMNode,\n        currentTreeNode,\n        direction,\n        setNodeExpandedState,\n      } = options;\n      if (!currentTreeNode) {\n        return currentDOMNode;\n      }\n\n      if (direction === Platform.KeyboardUtilities.ArrowKey.DOWN) {\n        // If the node has expanded children, down takes you into that list.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // If the node has a sibling, we go to that.\n        const currentNodeSibling = getNextSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodeSibling) {\n          return currentNodeSibling;\n        }\n\n        // If the Node's parent has a sibling then we go to that.\n        const parentSibling = findNextParentSibling(currentDOMNode);\n        if (parentSibling) {\n          return parentSibling;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.RIGHT) {\n        if (domNodeIsLeafNode(currentDOMNode)) {\n          // If the node cannot be expanded, we have nothing to do and we leave everything as is.\n          return currentDOMNode;\n        }\n\n        // If the current node is expanded, move and focus into the first child\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // Else, we expand the Node (but leave focus where it is)\n        setNodeExpandedState(currentTreeNode, true);\n        return currentDOMNode;\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.UP) {\n        // First see if there is a previous sibling\n        const currentNodePreviousSibling = getPreviousSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodePreviousSibling) {\n          // We now find the nested node within our previous sibling; if it has\n          // children that are expanded, we want to find the last child and\n          // highlight that, else we'll highlight our sibling directly.\n          if (domNodeIsExpanded(currentNodePreviousSibling)) {\n            return getDeepLastChildOfExpandedTreeNode(currentNodePreviousSibling);\n          }\n          // Otherwise, if we have a previous sibling with no children, focus it.\n          return currentNodePreviousSibling;\n        }\n\n        // Otherwise, let's go to the direct parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.LEFT) {\n        // If the node is expanded, we close it.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          setNodeExpandedState(currentTreeNode, false);\n          return currentDOMNode;\n        }\n\n        // Otherwise, let's go to the parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      }\n\n      // If we got here, there's no other option than to stay put.\n      return currentDOMNode;\n    };\n"],
  "mappings": "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",
  "names": ["Platform", "Lit", "Lit"]
}
